[{"new_code_raw":"private static EmbeddedElasticsearchNode create(Settings settings) { \/\/ ensure PainlessPlugin is installed or otherwise scripted fields would not work Node node = new LocalNode(settings, Arrays.asList(Netty4Plugin.class, PainlessPlugin.class)); return new EmbeddedElasticsearchNode(node); }","old_code_raw":"  public static EmbeddedElasticsearchNode create() {\n    File data = Files.createTempDir();\n    data.deleteOnExit();\n    File home = Files.createTempDir();\n    home.deleteOnExit();\n\n    Settings settings = Settings.builder()\n        .put(\"node.name\", \"fake-elastic\")\n        .put(\"path.home\", home.getAbsolutePath())\n        .put(\"path.data\", data.getAbsolutePath())\n        .put(\"http.type\", \"netty4\")\n        .put(\"network.host\", \"localhost\")\n        .build();\n\n    return create(settings);\n  }\n","new_comment_raw":"Creates an instance with existing settings","old_comment_raw":"Creates elastic node as single member of a cluster.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":48},{"new_code_raw":"private byte[] marshalAggregatorValues(long superstep) { if (superstep == INPUT_SUPERSTEP) { return new byte[0]; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); DataOutputStream output = new DataOutputStream(outputStream); for (Entry<String, AggregatorWrapper<Writable>> entry : getAggregatorMap().entrySet()) { if (entry.getValue().isChanged()) { try { output.writeUTF(entry.getKey()); entry.getValue().getCurrentAggregatedValue().write(output); } catch (IOException e) { throw new IllegalStateException(\"Failed to marshall aggregator \" + \"with IOException \" + entry.getKey(), e); } } } if (LOG.isInfoEnabled()) { LOG.info( \"marshalAggregatorValues: Finished assembling aggregator values\"); } return outputStream.toByteArray(); }","old_code_raw":"  private JSONArray marshalAggregatorValues(long superstep) {\n    JSONArray aggregatorArray = new JSONArray();\n    if ((superstep == INPUT_SUPERSTEP) || (aggregatorInUse.size() == 0)) {\n      return aggregatorArray;\n    }\n\n    for (String name : aggregatorInUse) {\n      try {\n        Aggregator<Writable> aggregator = getAggregatorMap().get(name);\n        ByteArrayOutputStream outputStream =\n            new ByteArrayOutputStream();\n        DataOutput output = new DataOutputStream(outputStream);\n        aggregator.getAggregatedValue().write(output);\n\n        JSONObject aggregatorObj = new JSONObject();\n        aggregatorObj.put(AGGREGATOR_NAME_KEY, name);\n        aggregatorObj.put(AGGREGATOR_CLASS_NAME_KEY,\n            aggregator.getClass().getName());\n        aggregatorObj.put(\n            AGGREGATOR_VALUE_KEY,\n            Base64.encodeBytes(outputStream.toByteArray()));\n        aggregatorArray.put(aggregatorObj);\n        if (LOG.isInfoEnabled()) {\n          LOG.info(\"marshalAggregatorValues: \" +\n              \"Found aggregatorObj \" +\n              aggregatorObj + \", value (\" +\n              aggregator.getAggregatedValue() + \")\");\n        }\n      } catch (JSONException e) {\n        throw new IllegalStateException(\"Failed to marshall aggregator \" +\n            \"with JSONException \" + name, e);\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Failed to marshall aggregator \" +\n            \"with IOException \" + name, e);\n      }\n    }\n\n    if (LOG.isInfoEnabled()) {\n      LOG.info(\"marshalAggregatorValues: Finished assembling \" +\n          \"aggregator values in JSONArray - \" + aggregatorArray);\n    }\n    aggregatorInUse.clear();\n    return aggregatorArray;\n  }\n","new_comment_raw":"Marshal the aggregator values of the worker to a byte array that will later be aggregated by master.","old_comment_raw":"Marshal the aggregator values of to a JSONArray that will later be aggregated by master.","label":1,"pre_label":0,"AST_level":13,"line_counts":28,"new_code_token_num":153},{"new_code_raw":"public File getSinkFile() { return queue.file(); }","old_code_raw":"\tpublic File getSinkFile() {\n\t\treturn sinkFile;\n\t}\n","new_comment_raw":"Returns the queue directory","old_comment_raw":"Returns","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"public SubProjectData getProjectInfo(AbstractProject context) { SubProjectData subProjectData = new SubProjectData(); iterateBuilds(context, projects, subProjectData); \/\/ We don't want to show a project twice subProjectData.getTriggered().removeAll(subProjectData.getDynamic()); subProjectData.getTriggered().removeAll(subProjectData.getFixed()); return subProjectData; }","old_code_raw":"    public List<Set<?>> getProjectInfo(AbstractProject context) {\n\n        Comparator customComparator = new Comparator<AbstractProject>() {\n            public int compare(AbstractProject abstractProject1, AbstractProject abstractProject2) {\n                return abstractProject1.getFullName().compareTo(abstractProject2.getFullName());\n            }\n        };\n\n        Set<AbstractProject> dynamicProject = new TreeSet<AbstractProject>(customComparator);\n        Set<AbstractProject> staticProject = new TreeSet<AbstractProject>(customComparator);\n        Set<AbstractProject> triggeredProject = new TreeSet<AbstractProject>(customComparator);\n        Set<String> unresolvedProject = new TreeSet<String>();\n\n        iterateBuilds(context, projects, dynamicProject, staticProject, triggeredProject, unresolvedProject);\n\n        \/\/ We don't want to show a project twice\n        triggeredProject.removeAll(dynamicProject);\n        triggeredProject.removeAll(staticProject);\n\n        return Arrays.asList(staticProject, dynamicProject, triggeredProject, unresolvedProject);\n    }\n","new_comment_raw":"Provides a SubProjectData object containing four set, each containing projects to be displayed on the project view under 'Subprojects' section. ","old_comment_raw":"Provides a list containing four set, each containing projects to be displayed on the project view for projects using the parameterized trigger plugin under 'Subprojects'.","label":1,"pre_label":0,"AST_level":6,"line_counts":14,"new_code_token_num":64},{"new_code_raw":"public String toOneOfName(List<String> names, ComposedSchema composedSchema) { Map<String, Object> exts = composedSchema.getExtensions(); if (exts != null && exts.containsKey(\"x-oneOf-name\")) { return (String) exts.get(\"x-oneOf-name\"); } return \"oneOf<\" + String.join(\",\", names) + \">\"; }","old_code_raw":"    public String toOneOfName(List<String> names, ComposedSchema composedSchema) {\n        return \"oneOf<\" + String.join(\",\", names) + \">\";\n    }\n","new_comment_raw":"Return the name of the oneOf schema","old_comment_raw":"Return the name of the oneOf schema","label":0,"pre_label":1,"AST_level":8,"line_counts":8,"new_code_token_num":78},{"new_code_raw":"public static Iterable<ProviderMetadata> boundedByIso3166Code(String iso3166Code, TypeToken<? extends Wrapper> contextWrappableAs) { return filter(all(), Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates .contextWrappableAs(contextWrappableAs))); }","old_code_raw":"   public static Iterable<ProviderMetadata<?, ?, ?, ?>> boundedByIso3166Code(String iso3166Code, ApiType type) {\n      return filter(all(),\n            Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates.type(type)));\n   }\n","new_comment_raw":"Returns the providers that are bound to the same location as the given ISO 3166 code and of the given contextWrappableAs.","old_comment_raw":"Returns the providers that are bound to the same location as the given ISO 3166 code and of the given type.","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"public boolean isMirrored() { if (!fMirroringEnabled) return false; Object property = getProperty(MIRRORED); return property instanceof Boolean && (Boolean) property; }","old_code_raw":"\tpublic boolean isMirrored() {\n\t\tObject property = getProperty(MIRRORED);\n\t\treturn property instanceof Boolean && (Boolean) property;\n\t}\n","new_comment_raw":"Returns true if the compare viewer is mirrored, i.e.","old_comment_raw":"Only the views are mirrored.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":33},{"new_code_raw":"public Lob build() { return new Lob(this); }","old_code_raw":"        public Ravioli build() {\n            return new Ravioli(this);\n        }\n","new_comment_raw":"Build a Lob client","old_comment_raw":"Build a Ravioli client","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"public static Viewable create(final boolean authEnabled, final String templateName, final SecurityContext sc) { return new ViewableWithPermissions(authEnabled, templateName, sc, true, null); }","old_code_raw":"  public static Viewable create(final String templateName, final SecurityContext sc, final Object model) {\n    return new ViewableWithPermissions(templateName, sc, true, model);\n  }\n","new_comment_raw":"Create the web page using the given template and  SecurityContext after authentication is done.","old_comment_raw":"Create a web page using the given template, SecurityContext and model data.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"private BufferedImage loadImage(int itemId, int quantity, boolean stackable) { SpritePixels sprite = client.get().createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, stackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM); return sprite.toBufferedImage(); }","old_code_raw":"\tprivate AsyncBufferedImage loadImage(int itemId, int quantity, boolean stackable)\n\t{\n\t\tAsyncBufferedImage img = new AsyncBufferedImage(36, 32, BufferedImage.TYPE_INT_ARGB);\n\t\tclientThread.invokeLater(() ->\n\t\t{\n\t\t\tif (client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal())\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tSpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR,\n\t\t\t\tstackable ? 1 : 0, false, CLIENT_DEFAULT_ZOOM);\n\t\t\tif (sprite == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsprite.toBufferedImage(img);\n\t\t\timg.changed();\n\t\t\treturn true;\n\t\t});\n\t\treturn img;\n\t}\n","new_comment_raw":"Loads item sprite from game, makes transparent, and generates image","old_comment_raw":"Loads item sprite from game, makes transparent, and generates image","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":49},{"new_code_raw":"public Element writeSchema(Class javaType, Types types) throws Exception { \/\/ Let the caller generate WSDL if this is not a SimpleType if (!SimpleType.class.isAssignableFrom(javaType)) return null; \/\/ ComplexType representation of SimpleType bean class Element complexType = types.createElement(\"complexType\"); types.writeSchemaElement(xmlType, complexType); complexType.setAttribute(\"name\", xmlType.getLocalPart()); \/\/ Produce simpleContent extending base type. Element simpleContent = types.createElement(\"simpleContent\"); complexType.appendChild(simpleContent); Element extension = types.createElement(\"extension\"); simpleContent.appendChild(extension); \/\/ Get the base type from the \"value\" element of the bean String base = \"string\"; for (int i=0; i<propertyDescriptor.length; i++) { String propName = propertyDescriptor[i].getName(); if (!propName.equals(\"value\")) { if (typeDesc != null) { FieldDesc field = typeDesc.getFieldByName(propName); if (field != null) { if (field.isElement()) { \/\/ throw? } QName qname = field.getXmlName(); if (qname == null) { \/\/ Use the default... qname = new QName(\"\", propName); } \/\/ write attribute element Class fieldType = propertyDescriptor[i].getType(); \/\/ Attribute must be a simple type, enum or SimpleType if (!types.isAcceptableAsAttribute(fieldType)) { throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType00\", propName, fieldType.getName())); } \/\/ write attribute element \/\/ TODO the attribute name needs to be preserved from the XML Element elem = types.createAttributeElement(propName, fieldType, field.getXmlType(), false, extension.getOwnerDocument()); extension.appendChild(elem); } } continue; } BeanPropertyDescriptor bpd = propertyDescriptor[i]; Class type = bpd.getType(); \/\/ Attribute must extend a simple type, enum or SimpleType if (!types.isAcceptableAsAttribute(type)) { throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType01\", type.getName())); } base = types.writeType(type); extension.setAttribute(\"base\", base); } \/\/ done return complexType; }","old_code_raw":"    public boolean writeSchema(Types types) throws Exception {\n        \/\/ Let the caller generate WSDL if this is not a SimpleType\n        if (!SimpleType.class.isAssignableFrom(javaType))\n            return false;\n\n        \/\/ ComplexType representation of SimpleType bean class\n        Element complexType = types.createElement(\"complexType\");\n        types.writeSchemaElement(xmlType, complexType);\n        complexType.setAttribute(\"name\", xmlType.getLocalPart());\n\n        \/\/ Produce simpleContent extending base type.\n        Element simpleContent = types.createElement(\"simpleContent\");\n        complexType.appendChild(simpleContent);\n        Element extension = types.createElement(\"extension\");\n        simpleContent.appendChild(extension);\n\n        \/\/ Get the base type from the \"value\" element of the bean\n        String base = \"string\";\n        for (int i=0; i<propertyDescriptor.length; i++) {\n            String propName = propertyDescriptor[i].getName();\n            if (!propName.equals(\"value\")) {\n                if (typeDesc != null) {\n                    FieldDesc field = typeDesc.getFieldByName(propName);\n                    if (field != null) {\n                        if (field.isElement()) {\n                            \/\/ throw?\n                        }\n                        QName qname = field.getXmlName();\n                        if (qname == null) {\n                            \/\/ Use the default...\n                            propName = propName;\n                            qname = new QName(\"\", propName);\n                        }\n\n                        \/\/  write attribute element\n                        Class fieldType = propertyDescriptor[i].getType();\n\n                        \/\/ Attribute must be a simple type, enum or SimpleType\n                        if (!types.isAcceptableAsAttribute(fieldType)) {\n                            throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType00\",\n                                    propName,\n                                    fieldType.getName()));\n                        }\n\n                        \/\/ write attribute element\n                        \/\/ TODO the attribute name needs to be preserved from the XML\n                        String elementType = types.writeType(fieldType);\n                        Element elem = types.createAttributeElement(propName,\n                                elementType,\n                                false,\n                                extension.getOwnerDocument());\n                        extension.appendChild(elem);\n                    }\n                }\n                continue;\n            }\n\n            BeanPropertyDescriptor bpd = propertyDescriptor[i];\n            Class type = bpd.getType();\n            \/\/ Attribute must extend a simple type, enum or SimpleType\n            if (!types.isAcceptableAsAttribute(type)) {\n                throw new AxisFault(Messages.getMessage(\"AttrNotSimpleType01\",\n                        type.getName()));\n            }\n            base = types.writeType(type);\n            extension.setAttribute(\"base\", base);\n        }\n\n        \/\/ done\n        return true;\n\n    }\n","new_comment_raw":"Return XML schema for the specified type, suitable for insertion into the &lt;types&gt; element of a WSDL document, or underneath an &lt;element&gt; or &lt;attribute&gt; declaration.","old_comment_raw":"Return XML schema for the specified type, suitable for insertion into the element of a WSDL document.","label":1,"pre_label":0,"AST_level":16,"line_counts":73,"new_code_token_num":428},{"new_code_raw":"public static String[] getModulePrefixes(ServletContext context) { return (String[]) context.getAttribute(Globals.MODULE_PREFIXES_KEY); }","old_code_raw":"    public synchronized static String[] getModulePrefixes(ServletContext context) {\n        \/\/ TODO Move prefix list initialization to ActionServlet.init() and unsynchronize\n        \/\/ this method in Struts 1.2 \n        \n        String prefixes[] = (String[]) context.getAttribute(PREFIXES_KEY);\n        if (prefixes != null) {\n            return (prefixes);\n        }\n\n        ArrayList list = new ArrayList();\n        Enumeration names = context.getAttributeNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            if (!name.startsWith(Globals.MODULE_KEY)) {\n                continue;\n            }\n            String prefix = name.substring(Globals.MODULE_KEY.length());\n            if (prefix.length() > 0) {\n                list.add(prefix);\n            }\n        }\n        prefixes = (String[]) list.toArray(new String[list.size()]);\n        context.setAttribute(PREFIXES_KEY, prefixes);\n        return (prefixes);\n\n    }\n","new_comment_raw":"Return the list of module prefixes that are defined for this web application.","old_comment_raw":"Return the list of module prefixes that are defined for this web application, creating it if necessary.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public boolean isConnectedAndHealthy() { Map<String, DiscoveryNode> nodeMap = nodes.get(); if (nodeMap == null || nodeMap.isEmpty()) { return false; } if (!deflector.isUp()) { return false; } try { return getHealth() != ClusterHealthStatus.RED; } catch (ElasticsearchException e) { LOG.trace(\"Couldn't determine Elasticsearch health properly\", e); return false; } }","old_code_raw":"    public boolean isConnectedAndHealthy() {\n        try {\n            return getHealth() != ClusterHealthStatus.RED;\n        } catch (ElasticsearchException e) {\n            LOG.trace(\"Couldn't determine Elasticsearch health properly\", e);\n            return false;\n        }\n    }\n","new_comment_raw":"Check if the Elasticsearch  Node is connected and that the cluster health status is not  ClusterHealthStatus#RED and that the  org.graylog2.indexer.Deflector#isUp() deflector is up.","old_comment_raw":"Check if the Elasticsearch Node is connected and that the cluster health status is not ClusterHealthStatus#RED.","label":1,"pre_label":0,"AST_level":7,"line_counts":17,"new_code_token_num":83},{"new_code_raw":"protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) { ASTNode declaringClass = null; ASTNode parent = findMe.getParent(); ASTNode ret = null; ArrayList<Integer> constrains = new ArrayList<Integer>(); if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) { Expression exp = (Expression) ((MethodInvocation) parent) .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY); \/\/TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION); \/\/ Possibly a bug here. Investigate later. if (((MethodInvocation) parent).getName().toString() .equals(findMe.toString())) { constrains.add(ASTNode.METHOD_DECLARATION); if (exp != null) { constrains.add(ASTNode.TYPE_DECLARATION); \/\/ log(\"MI EXP: \" + exp.toString() + \" of type \" \/\/ + exp.getClass().getName() + \" parent: \" + exp.getParent()); if (exp instanceof MethodInvocation) { SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } else if (exp instanceof FieldAccess) { SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2((stp.getName()), alternateParent); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } if (exp instanceof SimpleName) { SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); \/\/ log(\"MI.SN \" + getNodeAsString(declaringClass)); constrains.add(ASTNode.METHOD_DECLARATION); return definedIn(declaringClass, ((MethodInvocation) parent) .getName().toString(), constrains, declaringClass); } } } else { parent = parent.getParent(); \/\/ Move one up the ast. V V IMP!! alternateParent = alternateParent.getParent(); } } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) { FieldAccess fa = (FieldAccess) parent; Expression exp = fa.getExpression(); if (fa.getName().toString().equals(findMe.toString())) { constrains.add(ASTNode.FIELD_DECLARATION); if (exp != null) { constrains.add(ASTNode.TYPE_DECLARATION); \/\/ log(\"FA EXP: \" + exp.toString() + \" of type \" \/\/ + exp.getClass().getName() + \" parent: \" + exp.getParent()); if (exp instanceof MethodInvocation) { SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } else if (exp instanceof FieldAccess) { SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp) .getName(), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2((stp.getName()), alternateParent); constrains.add(ASTNode.TYPE_DECLARATION); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } if (exp instanceof SimpleName) { SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp), alternateParent)); if (stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); \/\/ log(\"FA.SN \" + getNodeAsString(declaringClass)); constrains.add(ASTNode.METHOD_DECLARATION); return definedIn(declaringClass, fa.getName().toString(), constrains, declaringClass); } } } else { parent = parent.getParent(); \/\/ Move one up the ast. V V IMP!! alternateParent = alternateParent.getParent(); } } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) { QualifiedName qn = (QualifiedName) parent; if (!findMe.toString().equals(qn.getQualifier().toString())) { SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()), alternateParent)); if(stp == null) return null; declaringClass = findDeclaration2(stp.getName(), alternateParent); \/\/ log(qn.getQualifier() + \"->\" + qn.getName()); \/\/ log(\"QN decl class: \" + getNodeAsString(declaringClass)); constrains.clear(); constrains.add(ASTNode.TYPE_DECLARATION); constrains.add(ASTNode.FIELD_DECLARATION); return definedIn(declaringClass, qn.getName().toString(), constrains, null); } else{ if(findMe instanceof QualifiedName){ QualifiedName qnn = (QualifiedName) findMe; \/\/ log(\"findMe is a QN, \" \/\/ + (qnn.getQualifier().toString() + \" other \" + qnn.getName() \/\/ .toString())); SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent)); if (stp == null) { return null; } \/\/ log(qnn.getQualifier() + \"->\" + qnn.getName()); declaringClass = findDeclaration2(stp.getName(), alternateParent); \/\/ log(\"QN decl class: \" \/\/ + getNodeAsString(declaringClass)); constrains.clear(); constrains.add(ASTNode.TYPE_DECLARATION); constrains.add(ASTNode.FIELD_DECLARATION); return definedIn(declaringClass, qnn.getName().toString(), constrains, null); } } } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) { constrains.add(ASTNode.TYPE_DECLARATION); if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION) constrains.add(ASTNode.CLASS_INSTANCE_CREATION); } else if (parent instanceof Expression) { \/\/ constrains.add(ASTNode.TYPE_DECLARATION); \/\/ constrains.add(ASTNode.METHOD_DECLARATION); \/\/ constrains.add(ASTNode.FIELD_DECLARATION); } \/\/ TODO: in findDec, we also have a case where parent of type TD is handled. \/\/ Figure out if needed here as well. \/\/ log(\"Alternate parent: \" + getNodeAsString(alternateParent)); while (alternateParent != null) { \/\/ log(\"findDeclaration2 -> \" \/\/ + getNodeAsString(alternateParent)); for (Object oprop : alternateParent.structuralPropertiesForType()) { StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop; if (prop.isChildProperty() || prop.isSimpleProperty()) { if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) { \/\/ log(prop + \" C\/S Prop of -> \" \/\/ + getNodeAsString(alternateParent)); ret = definedIn((ASTNode) alternateParent .getStructuralProperty(prop), findMe.toString(), constrains, declaringClass); if (ret != null) return ret; } } else if (prop.isChildListProperty()) { \/\/ log((prop) + \" ChildList props of \" \/\/ + getNodeAsString(alternateParent)); List<ASTNode> nodelist = (List<ASTNode>) alternateParent .getStructuralProperty(prop); for (ASTNode retNode : nodelist) { ret = definedIn(retNode, findMe.toString(), constrains, declaringClass); if (ret != null) return ret; } } } alternateParent = alternateParent.getParent(); } return null; }","old_code_raw":"  protected static ASTNode findDeclaration2(Name findMe, ASTNode alternateParent) {\n    ASTNode declaringClass = null;\n    ASTNode parent = findMe.getParent();\n    ASTNode ret = null;\n    ArrayList<Integer> constrains = new ArrayList<Integer>();\n    if (parent.getNodeType() == ASTNode.METHOD_INVOCATION) {\n      Expression exp = (Expression) ((MethodInvocation) parent)\n          .getStructuralProperty(MethodInvocation.EXPRESSION_PROPERTY);\n      \/\/TODO: Note the imbalance of constrains.add(ASTNode.METHOD_DECLARATION);\n      \/\/ Possibly a bug here. Investigate later.\n      if (((MethodInvocation) parent).getName().toString()\n          .equals(findMe.toString())) {\n        constrains.add(ASTNode.METHOD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n\/\/          log(\"MI EXP: \" + exp.toString() + \" of type \"\n\/\/              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\/\/            log(\"MI.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, ((MethodInvocation) parent)\n                .getName().toString(), constrains, declaringClass);\n          }\n\n        }\n      } else {\n        parent = parent.getParent(); \/\/ Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.FIELD_ACCESS) {\n      FieldAccess fa = (FieldAccess) parent;\n      Expression exp = fa.getExpression();\n      if (fa.getName().toString().equals(findMe.toString())) {\n        constrains.add(ASTNode.FIELD_DECLARATION);\n\n        if (exp != null) {\n          constrains.add(ASTNode.TYPE_DECLARATION);\n\/\/          log(\"FA EXP: \" + exp.toString() + \" of type \"\n\/\/              + exp.getClass().getName() + \" parent: \" + exp.getParent());\n          if (exp instanceof MethodInvocation) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((MethodInvocation) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          } else if (exp instanceof FieldAccess) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((FieldAccess) exp)\n                                                                 .getName(),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2((stp.getName()), alternateParent);\n            constrains.add(ASTNode.TYPE_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n          if (exp instanceof SimpleName) {\n            SimpleType stp = extracTypeInfo(findDeclaration2(((SimpleName) exp),\n                                                             alternateParent));\n            if (stp == null)\n              return null;\n            declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\/\/            log(\"FA.SN \" + getNodeAsString(declaringClass));\n            constrains.add(ASTNode.METHOD_DECLARATION);\n            return definedIn(declaringClass, fa.getName().toString(),\n                             constrains, declaringClass);\n          }\n        }\n\n      } else {\n        parent = parent.getParent(); \/\/ Move one up the ast. V V IMP!!\n        alternateParent = alternateParent.getParent();\n      }\n    } else if (parent.getNodeType() == ASTNode.QUALIFIED_NAME) {\n\n      QualifiedName qn = (QualifiedName) parent;\n      if (!findMe.toString().equals(qn.getQualifier().toString())) {\n\n        SimpleType stp = extracTypeInfo(findDeclaration2((qn.getQualifier()),\n                                                         alternateParent));\n        if(stp == null)\n          return null;\n        declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\/\/        log(qn.getQualifier() + \"->\" + qn.getName());\n\/\/        log(\"QN decl class: \" + getNodeAsString(declaringClass));\n        constrains.clear();\n        constrains.add(ASTNode.TYPE_DECLARATION);\n        constrains.add(ASTNode.FIELD_DECLARATION);\n        return definedIn(declaringClass, qn.getName().toString(), constrains,\n                         null);\n      }\n      else{\n        if(findMe instanceof QualifiedName){\n          QualifiedName qnn = (QualifiedName) findMe;\n\/\/          log(\"findMe is a QN, \"\n\/\/              + (qnn.getQualifier().toString() + \" other \" + qnn.getName()\n\/\/                  .toString()));\n\n          SimpleType stp = extracTypeInfo(findDeclaration2((qnn.getQualifier()), alternateParent));\n\/\/          log(qnn.getQualifier() + \"->\" + qnn.getName());\n          declaringClass = findDeclaration2(stp.getName(), alternateParent);\n\n\/\/          log(\"QN decl class: \"\n\/\/              + getNodeAsString(declaringClass));\n          constrains.clear();\n          constrains.add(ASTNode.TYPE_DECLARATION);\n          constrains.add(ASTNode.FIELD_DECLARATION);\n          return definedIn(declaringClass, qnn.getName().toString(), constrains,\n                           null);\n        }\n      }\n    } else if (parent.getNodeType() == ASTNode.SIMPLE_TYPE) {\n      constrains.add(ASTNode.TYPE_DECLARATION);\n      if (parent.getParent().getNodeType() == ASTNode.CLASS_INSTANCE_CREATION)\n        constrains.add(ASTNode.CLASS_INSTANCE_CREATION);\n    } else if (parent instanceof Expression) {\n\/\/      constrains.add(ASTNode.TYPE_DECLARATION);\n\/\/      constrains.add(ASTNode.METHOD_DECLARATION);\n\/\/      constrains.add(ASTNode.FIELD_DECLARATION);\n    } \/\/ TODO: in findDec, we also have a case where parent of type TD is handled.\n      \/\/ Figure out if needed here as well.\n\/\/    log(\"Alternate parent: \" + getNodeAsString(alternateParent));\n    while (alternateParent != null) {\n\/\/      log(\"findDeclaration2 -> \"\n\/\/          + getNodeAsString(alternateParent));\n      for (Object oprop : alternateParent.structuralPropertiesForType()) {\n        StructuralPropertyDescriptor prop = (StructuralPropertyDescriptor) oprop;\n        if (prop.isChildProperty() || prop.isSimpleProperty()) {\n          if (alternateParent.getStructuralProperty(prop) instanceof ASTNode) {\n\/\/            log(prop + \" C\/S Prop of -> \"\n\/\/                + getNodeAsString(alternateParent));\n            ret = definedIn((ASTNode) alternateParent\n                                .getStructuralProperty(prop),\n                            findMe.toString(), constrains, declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        } else if (prop.isChildListProperty()) {\n\/\/          log((prop) + \" ChildList props of \"\n\/\/              + getNodeAsString(alternateParent));\n          List<ASTNode> nodelist = (List<ASTNode>) alternateParent\n              .getStructuralProperty(prop);\n          for (ASTNode retNode : nodelist) {\n            ret = definedIn(retNode, findMe.toString(), constrains,\n                            declaringClass);\n            if (ret != null)\n              return ret;\n          }\n        }\n      }\n      alternateParent = alternateParent.getParent();\n    }\n    return null;\n  }\n","new_comment_raw":"A variation of findDeclaration() but accepts an alternate parent ASTNode","old_comment_raw":"A variation of findDeclaration() but accepts an alternate parent ASTNode","label":0,"pre_label":1,"AST_level":18,"line_counts":188,"new_code_token_num":1441},{"new_code_raw":"private boolean isKeepLock(String serverName, String lockPath) { try { if (zkClient.checkExists().forPath(lockPath) != null) { byte[] data = zkClient.getData().forPath(lockPath); String lockServerName = new String(data, Charset.forName(\"UTF-8\")); return lockServerName.equalsIgnoreCase(serverName); } } catch (Exception e) { logger.error(\"fail to get the serverName for the path: \" + lockPath, e); } return false; }","old_code_raw":"\n    private boolean isKeepLock(String lockClient, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(lockClient);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the lockClient for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n","new_comment_raw":"Returns true if, the job server is keeping the lock for the lockPath","old_comment_raw":"Returns true if, the lockClient is keeping the lock for the lockPath","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":98},{"new_code_raw":"public boolean isFlagSet(int flagsToCheck) { return (flags & flagsToCheck) != 0; }","old_code_raw":"    public boolean isFlagSet(int flag) {\n        return (flags & flag) != 0;\n    }\n","new_comment_raw":"Returns  true if any of the flags supplied in the argument are set.","old_comment_raw":"Checks if a flag is set.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"public Client build() { if ((environment == null) && (executorService == null) && (objectMapper == null)) { throw new IllegalStateException(\"Must have either an environment or both \" + \"an executor service and an object mapper\"); } if (environment == null) { return build(executorService, objectMapper); } return build(environment.getLifecycleEnvironment() .managedExecutorService(\"jersey-client-%d\", configuration.getMinThreads(), configuration.getMaxThreads(), 60, TimeUnit.SECONDS), environment.getJsonEnvironment().build()); }","old_code_raw":"    public Client build() {\n        if ((environment == null) && (executorService == null) && (objectMapper == null)) {\n            throw new IllegalStateException(\"Must have either an environment or both \" +\n                                                    \"an executor service and an object mapper\");\n        }\n\n        if (environment == null) {\n            return build(executorService, objectMapper);\n        }\n\n        return build(environment.getLifecycleEnvironment()\n                                .managedExecutorService(\"jersey-client-%d\",\n                                                        configuration.getMinThreads(),\n                                                        configuration.getMaxThreads(),\n                                                        60,\n                                                        TimeUnit.SECONDS),\n                     environment.getJsonEnvironment().buildObjectMapper());\n    }\n","new_comment_raw":"Builds the  Client instance.","old_comment_raw":"Builds the Client instance.","label":0,"pre_label":1,"AST_level":8,"line_counts":19,"new_code_token_num":111},{"new_code_raw":"public static IType createType(IASTDeclarator declarator) { IASTDeclSpecifier declSpec = null; IASTNode node = declarator.getParent(); while( node instanceof IASTDeclarator ){ declarator = (IASTDeclarator) node; node = node.getParent(); } if( node instanceof IASTParameterDeclaration ) declSpec = ((IASTParameterDeclaration) node).getDeclSpecifier(); else if( node instanceof IASTSimpleDeclaration ) declSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier(); else if( node instanceof IASTFunctionDefinition ) declSpec = ((IASTFunctionDefinition)node).getDeclSpecifier(); else if( node instanceof IASTTypeId ) declSpec = ((IASTTypeId)node).getDeclSpecifier(); boolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); IType type = null; \/\/C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \/\/members of the parameter type list for a function definition. if( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){ type = createBaseType( declSpec ); } else { type = createType( declSpec ); } type = createType( type, declarator ); if( isParameter ) { \/\/C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the \/\/type qualifiers (if any) are those specified within the [ and ] of the array type derivation if( type instanceof IArrayType ){ CArrayType at = (CArrayType) type; type = new CQualifiedPointerType( at.getType(), at.getModifier() ); } else if( type instanceof IFunctionType ) { \/\/-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\" type = new CPointerType( type ); } } return type; }","old_code_raw":"\tpublic static IType createType(IASTName name) {\n\t\tif (!(name.getParent() instanceof IASTDeclarator)) return null;\n\t\t\n\t    IASTDeclSpecifier declSpec = null;\n\t\tIASTDeclarator declarator = (IASTDeclarator) name.getParent();\n\t\t\n\t\tIASTNode node = declarator.getParent();\n\t\twhile( node instanceof IASTDeclarator ){\n\t\t\tdeclarator = (IASTDeclarator) node;\n\t\t\tnode = node.getParent();\n\t\t}\n\t\t\n\t\tif( node instanceof IASTParameterDeclaration )\n\t\t\tdeclSpec = ((IASTParameterDeclaration) node).getDeclSpecifier();\n\t\telse if( node instanceof IASTSimpleDeclaration )\n\t\t\tdeclSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTFunctionDefinition )\n\t\t\tdeclSpec = ((IASTFunctionDefinition)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTTypeId )\n\t\t    declSpec = ((IASTTypeId)node).getDeclSpecifier();\n\t\n\t\tboolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); \n\t\t\n\t\tIType type = null;\n\t\t\n\t\t\/\/C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \n\t\t\/\/members of the parameter type list for a function definition.\n\t\tif( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){\n\t\t    type = createBaseType( declSpec );\n\t\t} else {\n\t\t    type = createType( declSpec );\n\t\t}\n\t\t\n\t\ttype = createType( type, declarator );\n\t\t\n\t\t\n        if( isParameter ) {\n            \/\/C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the\n    \t\t\/\/type qualifiers (if any) are those specified within the [ and ] of the array type derivation\n            if( type instanceof IArrayType ){\n\t            CArrayType at = (CArrayType) type;\n\t            type = new CQualifiedPointerType( at.getType(), at.getModifier() );\n\t        } else if( type instanceof IFunctionType ) {\n\t            \/\/-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\"\n\t            type = new CPointerType( type );\n\t        }\n        }\n        \n\t\treturn type;\n\t}\n","new_comment_raw":"Create an IType for an IASTDeclarator.","old_comment_raw":"Create an IType for an IASTName.","label":1,"pre_label":0,"AST_level":11,"line_counts":49,"new_code_token_num":347},{"new_code_raw":"public static CodegenConfig forName(String name) { ServiceLoader<CodegenConfig> loader = load(CodegenConfig.class); StringBuilder availableConfigs = new StringBuilder(); for (CodegenConfig config : loader) { if (config.getName().equals(name)) { return config; } availableConfigs.append(config.getName()).append(\"\\n\"); } \/\/ else try to load directly try { return (CodegenConfig) Class.forName(name).getDeclaredConstructor().newInstance(); } catch (Exception e) { throw new GeneratorNotFoundException(\"Can't load config class with name '\".concat(name) + \"'\\nAvailable:\\n\" + availableConfigs.toString(), e); } }","old_code_raw":"    public static CodegenConfig forName(String name) {\n        ServiceLoader<CodegenConfig> loader = load(CodegenConfig.class);\n\n        StringBuilder availableConfigs = new StringBuilder();\n\n        for (CodegenConfig config : loader) {\n            if (config.getName().equals(name)) {\n                return config;\n            }\n\n            availableConfigs.append(config.getName()).append(\"\\n\");\n        }\n\n        \/\/ else try to load directly\n        try {\n            return (CodegenConfig) Class.forName(name).newInstance();\n        } catch (Exception e) {\n            throw new GeneratorNotFoundException(\"Can't load config class with name '\".concat(name) + \"'\\nAvailable:\\n\" + availableConfigs.toString(), e);\n        }\n    }\n","new_comment_raw":"Tries to load config class with SPI first, then with class name directly from classpath","old_comment_raw":"Tries to load config class with SPI first, then with class name directly from classpath","label":0,"pre_label":1,"AST_level":11,"line_counts":21,"new_code_token_num":137},{"new_code_raw":"public static EBoolean endsWith(Expr<String> left, String right) { return factory.createBoolean(Ops.ENDSWITH, left, factory.createConstant(right)); }","old_code_raw":"    public static EBoolean endsWith(Expr<String> left, String right) {\n        return createBoolean(Ops.ENDSWITH, left, createConstant(right));\n    }\n","new_comment_raw":"Expr : left.endsWith(right)","old_comment_raw":"Expr : left.endsWith(right)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"private ZapTextArea getTxtSkipURL() { if (txtSkipURL == null) { txtSkipURL = new ZapTextArea(); txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11)); if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) { txtSkipURL.setSize(new java.awt.Dimension(290,52)); } } return txtSkipURL; }","old_code_raw":"    private JTextArea getTxtSkipURL() {\n        if (txtSkipURL == null) {\n            txtSkipURL = new JTextArea();\n            txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));\n    \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\n    \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));\n    \t    }\n        }\n        return txtSkipURL;\n    }\n","new_comment_raw":"This method initializes ZapTextArea","old_comment_raw":"This method initializes jTextArea","label":1,"pre_label":0,"AST_level":12,"line_counts":11,"new_code_token_num":77},{"new_code_raw":"public static Boolean areColumnsUnique(RelNode rel, BitSet columns) { final BuiltInMetadata.ColumnUniqueness metadata = rel.metadata(BuiltInMetadata.ColumnUniqueness.class); return metadata.areColumnsUnique(columns, false); }","old_code_raw":"  public static Boolean areColumnsUnique(RelNode rel, BitSet columns) {\n    return (Boolean) rel.getCluster().getMetadataProvider().getRelMetadata(\n        rel,\n        \"areColumnsUnique\",\n        new Object[]{columns, false});\n  }\n","new_comment_raw":"Returns the  BuiltInMetadata.ColumnUniqueness#areColumnsUnique(BitSet, boolean) statistic.","old_comment_raw":"Determines if a specified set of columns from a specified relational expression are unique.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":34},{"new_code_raw":"public static Observable<Boolean> observeInternetConnectivity() { return observeInternetConnectivity(DEFAULT_INITIAL_PING_INTERVAL_IN_MS, DEFAULT_PING_INTERVAL_IN_MS, DEFAULT_PING_HOST, DEFAULT_PING_PORT, DEFAULT_PING_TIMEOUT_IN_MS, new DefaultErrorHandler()); }","old_code_raw":"  public static Observable<Boolean> observeInternetConnectivity() {\n    return observeInternetConnectivity(DEFAULT_INITIAL_PING_INTERVAL_IN_MS,\n        DEFAULT_PING_INTERVAL_IN_MS, DEFAULT_PING_HOST, DEFAULT_PING_PORT,\n        DEFAULT_PING_TIMEOUT_IN_MS, new DefaultSocketErrorHandler());\n  }\n","new_comment_raw":"Observes connectivity with the Internet with default settings.","old_comment_raw":"Observes connectivity with the Internet with default settings.","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":28},{"new_code_raw":"public static EBoolean endsWith(Expr<String> left, String right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, exprFactory .createConstant(right)); }","old_code_raw":"    public static EBoolean endsWith(Expr<String> left, String right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, exprFactory.createConstant(right));\n        }                \n    }\n","new_comment_raw":"Expr : left.endsWith(right)","old_comment_raw":"Expr : left.endsWith(right) (ignore case)","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public SubselectFetch getSubselect(EntityKey key) { return subselectsByEntityKey.get( key ); }","old_code_raw":"\tpublic SubselectFetch getSubselect(EntityKey key) {\n\t\treturn (SubselectFetch) subselectsByEntityKey.get(key);\n\t}\n","new_comment_raw":"Retrieve the fetch descriptor associated with the given entity key.","old_comment_raw":"Retrieve the fetch descriptor associated with the given entity key.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public MenuItem addItem(String text, boolean asHTML, Command cmd) { return addItem(new MenuItem(text, asHTML, cmd)); }","old_code_raw":"  public MenuItem addItem(SafeHtml html, ScheduledCommand cmd) {\n    return addItem(new MenuItem(html, Roles.getMenuitemRole(), false, cmd));\n  }\n","new_comment_raw":"Adds a menu item to the bar, that will fire the given command when it is selected.","old_comment_raw":"Adds a menu item to the bar containing SafeHtml, that will fire the given command when it is selected.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"private ColumnDescriptor getColumn(int columnIndex) { Tree tree = viewer.getTree(); TreeColumn column = tree.getColumn(columnIndex); ColumnDescriptor descriptor = (ColumnDescriptor) column.getData(); return descriptor; }","old_code_raw":"\tprivate ColumnDescriptor getColumn(int columnIndex) {\n\t\tTree tree = viewer.getTree();\n\t\tTreeColumn column = tree.getColumn(columnIndex);\n\t\tColumnDescriptor context = (ColumnDescriptor) column.getData();\n\t\treturn context;\n\t}\n","new_comment_raw":"Get the specific column's ColumnDescriptor object.","old_comment_raw":"Get the specific column's ContextColumn object.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":37},{"new_code_raw":"public ENumber<Integer> length() { if (length == null) { length = ONumber.create(Integer.class, Ops.STRING_LENGTH, this); } return length; }","old_code_raw":"    public ENumber<Long> length() {\n        if (length == null) {\n            length = ONumber.create(Long.class, Ops.STRING_LENGTH, this);\n        }\n        return length;\n    }\n","new_comment_raw":"Return the length of this String","old_comment_raw":"Return the length of this String","label":0,"pre_label":1,"AST_level":9,"line_counts":7,"new_code_token_num":31},{"new_code_raw":"public final DBCompareColExpr in(Collection<?> values) { if (values==null || values.isEmpty()) return cmp(DBCmpType.EQUAL, null); \/\/ create expression return cmp(DBCmpType.IN, values); }","old_code_raw":"    public DBCompareColExpr in(Object value)\n    {\n        return cmp(DBCmpType.IN, listToArray(value));\n    }\n","new_comment_raw":"Creates and returns an expression for the SQL \"in\" operator.","old_comment_raw":"Creates and returns a new comparison object for the SQL \"in\" operator.","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":44},{"new_code_raw":"public boolean equals(Object obj) { if (obj == null) { return false; } if (obj == this) { return true; } if (obj.getClass() != getClass()) { return false; } FiltersAggregation rhs = (FiltersAggregation) obj; return super.equals(obj) && Objects.equals(bucketMap, rhs.bucketMap); }","old_code_raw":"    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (obj.getClass() != getClass()) {\n            return false;\n        }\n\n        FiltersAggregation rhs = (FiltersAggregation) obj;\n        return new EqualsBuilder()\n                .appendSuper(super.equals(obj))\n                .append(bucketMap, rhs.bucketMap)\n                .isEquals();\n    }\n","new_comment_raw":"Method for getting counts using named filters","old_comment_raw":"Method for getting counts using named filters","label":0,"pre_label":1,"AST_level":6,"line_counts":15,"new_code_token_num":69},{"new_code_raw":"public String getMatchedSentences() { StringBuilder sb = new StringBuilder(); for (int i = 0, sz = list.getModel().getSize(); i < sz; i++) { String t = list.getModel().getElementAt(i).getLabel().getText(); sb.append(t); sb.append(\"\\n\"); } return sb.toString(); }","old_code_raw":"  public StringBuffer getMatchedSentences() {\n    StringBuffer sb = new StringBuffer();\n    for(int i = 0; i < list.getModel().getSize(); i++) {\n      String t = ((TreeFromFile) list.getModel().getElementAt(i)).getLabel().getText();\n      sb.append(t);\n      sb.append(\"\\n\");\n    }\n    return sb;\n  }\n","new_comment_raw":"Returns all currently displayed sentences in plain text form.","old_comment_raw":"Returns all currently displayed sentences in string buffer, plain text form","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":76},{"new_code_raw":"public static List handleHTML(HttpURLConnection httpCon) throws IOException { ContentHandler handler = new HTMLHandler(); handler.parse(httpCon.getInputStream()); if (handler.getRobotFollow()) { List links = handler.getLinks(); return links; } return null; }","old_code_raw":"    public static java.util.List handleHTML(HttpURLConnection httpCon)\n        throws java.io.IOException {\n        ContentHandler handler = new HTMLHandler();\n        handler.parse(httpCon.getInputStream());\n\n        if (handler.getRobotFollow()) {\n            java.util.List links = handler.getLinks();\n\n            return links;\n        }\n\n        return null;\n    }\n","new_comment_raw":"Returns a list of links for a HTTP connection","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":50},{"new_code_raw":"public static Schema getReferencedSchema(OpenAPI openAPI, Schema schema) { if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { String name = getSimpleRef(schema.get$ref()); Schema referencedSchema = getSchema(openAPI, name); if(referencedSchema != null) { return referencedSchema; } } return schema; }","old_code_raw":"    public static Schema getReferencedSchema(OpenAPI openAPI, Schema schema) {\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            String name = getSimpleRef(schema.get$ref());\n            return getSchema(openAPI, name);\n        }\n        return schema;\n    }\n","new_comment_raw":"If a Schema contains a reference to an other Schema with '$ref', returns the referenced Schema if it is found or the actual Schema in the other cases.","old_comment_raw":"If a Schema contains a reference to an other Schema with '$ref', returns the referenced Schema or the actual Schema in the other cases.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public ArrayList<GridView> getCurrentGridViews() { return getCurrentViews(GridView.class); }","old_code_raw":"\tpublic ArrayList<GridView> getCurrentGridViews() {\n\t\tArrayList<GridView> gridViewList = new ArrayList<GridView>();\n\t\tArrayList<View> viewList = getViews();\n\t\tfor(View view : viewList){\n\t\t\tif (view instanceof android.widget.GridView)\n\t\t\t\tgridViewList.add((GridView) view);\n\t\t}\n\t\treturn gridViewList;\n\t}\n","new_comment_raw":"Returns a  List of the  GridViews contained in the current  Activity.","old_comment_raw":"Returns a List of the GridViews contained in the current Activity.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public boolean updateComponent(Widget component, UIDL uidl, boolean manageCaption) { \/\/ Switch to correct implementation if neede if (!widgetFactory.isCorrectImplementation(component, uidl)) { Layout parent = getParentLayout(component); if (parent != null) { Widget w = widgetFactory.createWidget(uidl); registerPaintable(uidl.getId(), (Paintable) w); parent.replaceChildComponent(component, w); ((Paintable) w).updateFromUIDL(uidl, this); return true; } } \/\/ Set captions \/\/ TODO Manage Error messages if (manageCaption) { Layout parent = getParentLayout(component); if (parent != null) parent.updateCaption(component, uidl); } \/\/ Visibility, Disabling and read-only status if (component instanceof FocusWidget) ((FocusWidget) component).setEnabled(!uidl .getBooleanAttribute(\"disabled\")); boolean visible = !uidl.getBooleanAttribute(\"invisible\"); component.setVisible(visible); if (!visible) return true; return false; }","old_code_raw":"\tpublic boolean updateComponent(Widget component, UIDL uidl,\n\t\t\tboolean manageCaption) {\n\n\t\tif (manageCaption) {\n\t\t\tLayout parent = getParentLayout(component);\n\t\t\tif (parent != null)\n\t\t\t\tparent.updateCaption(component, uidl);\n\t\t}\n\t\t\n\t\tboolean visible = !uidl.getBooleanAttribute(\"invisible\");\n\t\tcomponent.setVisible(visible);\n\t\tif (!visible) return true;\n\t\t\n\t\tif (widgetFactory.isCorrectImplementation(component, uidl))\n\t\t\treturn false;\n\t\tLayout parent = getParentLayout(component);\n\t\tif (parent == null)\n\t\t\treturn false;\n\t\tWidget w = widgetFactory.createWidget(uidl);\n\t\tregisterPaintable(uidl.getId(), (Paintable) w);\n\t\tparent.replaceChildComponent(component, w);\n\t\t((Paintable) w).updateFromUIDL(uidl, this);\n\n\t\treturn true;\n\t}\n","new_comment_raw":"Update generic component features.","old_comment_raw":"Ensure that correct implementation is used for the component.","label":1,"pre_label":0,"AST_level":10,"line_counts":36,"new_code_token_num":195},{"new_code_raw":"private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) { Collection<HttpSession> sessionsCopy; synchronized (sessions) { sessionsCopy = new ArrayList<>(sessions); } return CookieBasedSessionManagementHelper.getMatchingHttpSession(sessionsCopy, cookies, siteTokens); }","old_code_raw":"\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\n\t\treturn CookieBasedSessionManagementHelper.getMatchingHttpSession(sessions, cookies, siteTokens);\n\t}\n","new_comment_raw":"Gets the matching http session for a particular message containing a list of cookies.","old_comment_raw":"Gets the matching http session for a particular message containing a list of cookies.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":42},{"new_code_raw":"public static String encodeValue(Value value) { return NTriplesUtil.toNTriplesString(value); }","old_code_raw":"\tpublic static String encodeValue(Value value) {\r\n\t\tif (value instanceof BNode) {\r\n\t\t\t\/\/ SES-2129 special treatment of blank node names to avoid problems with round-tripping.\r\n\t\t\treturn \"_:\" + ((BNode)value).getID();\r\n\t\t}\r\n\t\t\r\n\t\t\/\/ for everything else we just use N-Triples serialization.\r\n\t\treturn NTriplesUtil.toNTriplesString(value);\r\n\t}\r\n","new_comment_raw":"Encodes a value for use in a URL.","old_comment_raw":"Encodes a value in a canonical serialized string format, for use in a URL query parameter.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public Action timedout(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { AtmosphereResourceImpl r = null; try { SessionTimeoutSupport.restoreTimeout(request); if (trackActiveRequest) { long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { \/\/ The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(\"Timing out the connection for request {}\", request); \/\/ Something went wrong. if (request == null || response == null) { logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response); return timedoutAction; } r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null && r.getAtmosphereResourceEvent().isSuspended()) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = r.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster) b).broadcastOnResume(r); } if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) { r.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(r); } } catch (Throwable t) { logger.error(\"failed to timeout resource {}\", r, t); } finally { config.framework().notify(Action.TYPE.TIMEOUT, request, response); try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(\"timedout\", t); } finally { try { response.getOutputStream().close(); } catch (Throwable t) { try { response.getWriter().close(); } catch (Throwable t2) { } } if (r != null) { destroyResource(r); } } } return timedoutAction; }","old_code_raw":"    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n\n        try {\n            SessionTimeoutSupport.restoreTimeout(request);\n\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    \/\/ The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            \/\/ Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.isCancelled()) {\n                return cancelledAction;\n            }\n\n            if (r == null) {\n                logger.debug(\"AtmosphereResource was null, failed to timeout AtmosphereRequest {}\", request);\n            }\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            config.framework().notify(Action.TYPE.TIMEOUT, request, response);\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    r._destroy();\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"All proprietary Comet based  Servlet must invoke the timedout method when the underlying WebServer time out the  AtmosphereResponse.","old_comment_raw":"All proprietary Comet based Servlet must invoke the timedout method when the underlying WebServer time out the AtmosphereResponse.","label":0,"pre_label":1,"AST_level":13,"line_counts":74,"new_code_token_num":372},{"new_code_raw":"File getBaseDir(final File file1, final File file2) { if (file1 == null || file2 == null) { return null; } final Iterator bases = getParents(file1).iterator(); final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator(); File result = null; while (bases.hasNext() && fileParents.hasNext()) { File next = (File) bases.next(); if (next.equals(fileParents.next())) { result = next; } else { break; } } return result; }","old_code_raw":"    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n","new_comment_raw":"Returns the common base directory between the passed file1 and file2.","old_comment_raw":"Returns the common base directory between a current base directory and a given file.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":105},{"new_code_raw":"public ArrayList<RadioButton> getCurrentRadioButtons() { return viewFetcher.getCurrentViews(RadioButton.class); }","old_code_raw":"\tpublic ArrayList<RadioButton> getCurrentRadioButtons() {\n\t\treturn ensureArrayListOrNull(viewFetcher.getCurrentViews(RadioButton.class));\n\t}\n","new_comment_raw":"Returns an  ArrayList of the  RadioButtons contained in the current  Activity.","old_comment_raw":"Returns an ArrayList of the RadioButtons contained in the current Activity.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public boolean contains(ReadableInterval interval) { if (interval == null) { return containsNow(); } long otherStart = interval.getStartMillis(); long otherEnd = interval.getEndMillis(); long thisStart = getStartMillis(); long thisEnd = getEndMillis(); return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd) || (thisStart == otherStart && thisEnd == otherEnd); }","old_code_raw":"    public boolean contains(ReadableInterval interval) {\n        if (interval == null) {\n            return containsNow();\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (otherStart >= thisStart && otherStart < thisEnd && otherEnd <= thisEnd);\n    }\n","new_comment_raw":"Does this time interval contain or equal the specified time interval.","old_comment_raw":"Does this time interval contain the specified time interval completely.","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":71},{"new_code_raw":"public static StringExpression stringTemplate(String template, Object... args) { return new StringTemplate(createTemplate(template), ImmutableList.copyOf(args)); }","old_code_raw":"    public static StringExpression stringTemplate(String template, Object... args) {\n        return StringTemplate.create(template, args);\n    }\n","new_comment_raw":"Create a new Template expression","old_comment_raw":"Create a new Template expression","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"private boolean installRemotePackages( @NonNull List<RemotePackage> requestPackages, @NonNull RepoManager repoManager, @NonNull Downloader downloader, @NonNull ProgressIndicator progress) { List<RemotePackage> remotePackages = InstallerUtil.computeRequiredPackages( requestPackages, repoManager.getPackages(), progress); if (remotePackages == null) { return false; } for (RemotePackage p : remotePackages) { if (p.getLicense() != null && !p.getLicense().checkAccepted( repoManager.getLocalPath(), mSdkHandler.getFileOp())) { progress.setText( \"The license for package \" + p.getDisplayName() + \" was not accepted. \" + \"Please install this package through Android Studio SDK \" + \"Manager.\"); return false; } Installer installer = SdkInstallerUtil .findBestInstallerFactory(p, mSdkHandler) .createInstaller(p, repoManager, downloader, mSdkHandler.getFileOp()); boolean result = installer.prepare(progress) && installer.complete(progress); if (!result) { return false; } } return true; }","old_code_raw":"    private Map<RemotePackage, InstallResultType> installRemotePackages(\n            @NonNull List<RemotePackage> requestPackages,\n            @NonNull RepoManager repoManager,\n            @NonNull Downloader downloader,\n            @NonNull ProgressIndicator progress) {\n\n        List<RemotePackage> remotePackages =\n                InstallerUtil.computeRequiredPackages(\n                        requestPackages, repoManager.getPackages(), progress);\n        Map<RemotePackage, InstallResultType> installResults = new HashMap<>();\n\n        if (remotePackages == null) {\n            requestPackages.forEach(p -> installResults.put(p, InstallResultType.INSTALL_FAIL));\n\n        } else {\n            for (RemotePackage p : remotePackages) {\n                if (p.getLicense() != null && !p.getLicense()\n                        .checkAccepted(repoManager.getLocalPath(), mSdkHandler.getFileOp())) {\n                    progress.setText(\n                            \"The license for package \" + p.getDisplayName() + \" was not accepted. \"\n                                    + \"Please install this package through Android Studio SDK \"\n                                    + \"Manager.\");\n                    installResults.put(p, InstallResultType.LICENSE_FAIL);\n                } else {\n                    Installer installer = SdkInstallerUtil\n                            .findBestInstallerFactory(p, mSdkHandler)\n                            .createInstaller(p, repoManager, downloader, mSdkHandler.getFileOp());\n                    if (installer.prepare(progress) && installer.complete(progress)) {\n                        installResults.put(p, InstallResultType.SUCCESS);\n                    } else {\n                        installResults.put(p, InstallResultType.INSTALL_FAIL);\n                    }\n                }\n            }\n        }\n        return installResults;\n    }\n","new_comment_raw":"Installs a  RemotePackage and its dependent packages.","old_comment_raw":"Installs a list of RemotePackage and their dependent packages.","label":1,"pre_label":0,"AST_level":13,"line_counts":39,"new_code_token_num":183},{"new_code_raw":"public ApiResponse<Void> createXmlItemWithHttpInfo(XmlItem xmlItem) throws ApiException { okhttp3.Call localVarCall = createXmlItemValidateBeforeCall(xmlItem, null, null); return localVarApiClient.execute(localVarCall); }","old_code_raw":"    public ApiResponse<Void> createXmlItemWithHttpInfo(XmlItem xmlItem) throws ApiException {\n        okhttp3.Call call = createXmlItemValidateBeforeCall(xmlItem, null, null);\n        return apiClient.execute(call);\n    }\n","new_comment_raw":"creates an XmlItem this route creates an XmlItem","old_comment_raw":"creates an XmlItem this route creates an XmlItem","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":31},{"new_code_raw":"private String getConfigurationTable(Connection con) { try { if (StorageManager.getStorageImpl(con.getMetaData().getDatabaseProductName()).requiresConfigSchema()) { if (DatabaseConst.getConfigSchema().endsWith(\".\")) return DatabaseConst.getConfigSchema() + TBL_GLOBAL_CONFIG; else return DatabaseConst.getConfigSchema() + \".\" + TBL_GLOBAL_CONFIG; } } catch (SQLException e) { LOG.warn(e); } return TBL_GLOBAL_CONFIG; }","old_code_raw":"    private String getConfigurationTable(Connection con) {\n        try {\n            if (StorageManager.getStorageImpl(con.getMetaData().getDatabaseProductName()).escapeSchema())\n                return \"\\\"\" + DatabaseConst.getConfigSchema() + \"\\\".\" + TBL_GLOBAL_CONFIG;\n        } catch (SQLException e) {\n            LOG.warn(e);\n        }\n        return DatabaseConst.getConfigSchema() + \".\" + TBL_GLOBAL_CONFIG;\n    }\n","new_comment_raw":"Get the global configuration table name including the correct schema","old_comment_raw":"Get the global configuration table name including the correct escaped schema","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":79},{"new_code_raw":"public List<Tree> getChildrenAsList() { return new ArrayList<>(Arrays.asList(children())); }","old_code_raw":"  public List<Tree> getChildrenAsList() {\n    return new ArrayList<Tree>(Arrays.asList(children()));\n  }\n","new_comment_raw":"Returns a List of children for the current node.","old_comment_raw":"Returns a List of children for the current node.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public UninstallationResult calculateUninstallChanges(Set<AddOn> selectedAddOns) { List<AddOn> remainingAddOns = new ArrayList<>(installedAddOns.getAddOns()); remainingAddOns.removeAll(selectedAddOns); Set<AddOn> uninstallations = new HashSet<>(); List<AddOn> addOnsToCheck = new ArrayList<>(remainingAddOns); while (!addOnsToCheck.isEmpty()) { AddOn addOn = addOnsToCheck.remove(0); AddOn.AddOnRunRequirements requirements = addOn.calculateRunRequirements(remainingAddOns); if (!requirements.hasDependencyIssue()) { addOnsToCheck.removeAll(requirements.getDependencies()); } else if (AddOn.InstallationStatus.UNINSTALLATION_FAILED != addOn.getInstallationStatus()) { uninstallations.add(addOn); } } for (Iterator<AddOn> it = uninstallations.iterator(); it.hasNext();) { AddOn addOn = it.next(); if (addOn.calculateRunRequirements(installedAddOns.getAddOns()).hasDependencyIssue() && !containsAny(addOn.getIdsAddOnDependencies(), uninstallations)) { it.remove(); } } remainingAddOns.removeAll(uninstallations); Set<Extension> extensions = new HashSet<>(); for (AddOn addOn : remainingAddOns) { if (addOn.hasExtensionsWithDeps()) { for (Extension ext : addOn.getLoadedExtensions()) { AddOn.AddOnRunRequirements requirements = addOn.calculateExtensionRunRequirements(ext, remainingAddOns); if (!requirements.getExtensionRequirements().isEmpty()) { AddOn.ExtensionRunRequirements extReqs = requirements.getExtensionRequirements().get(0); if (!extReqs.isRunnable()) { extensions.add(ext); } } } } } uninstallations.addAll(selectedAddOns); return new UninstallationResult(selectedAddOns, uninstallations, extensions); }","old_code_raw":"    public UninstallationResult calculateUninstallChanges(Set<AddOn> selectedAddOns) {\n        List<AddOn> remainingAddOns = new ArrayList<>(installedAddOns.getAddOns());\n        remainingAddOns.removeAll(selectedAddOns);\n\n        Set<AddOn> uninstallations = new HashSet<>();\n        List<AddOn> addOnsToCheck = new ArrayList<>(remainingAddOns);\n        while (!addOnsToCheck.isEmpty()) {\n            AddOn addOn = addOnsToCheck.remove(0);\n            RunRequirements requirements = addOn.calculateRunRequirements(remainingAddOns);\n\n            if (!requirements.hasDependencyIssue()) {\n                addOnsToCheck.removeAll(requirements.getDependencies());\n            } else if (AddOn.InstallationStatus.UNINSTALLATION_FAILED != addOn.getInstallationStatus()) {\n                uninstallations.add(addOn);\n            }\n        }\n\n        for (Iterator<AddOn> it = uninstallations.iterator(); it.hasNext();) {\n            AddOn addOn = it.next();\n            if (addOn.calculateRunRequirements(installedAddOns.getAddOns()).hasDependencyIssue()\n                    && !containsAny(addOn.getIdsAddOnDependencies(), uninstallations)) {\n                it.remove();\n            }\n        }\n\n        uninstallations.addAll(selectedAddOns);\n        return new UninstallationResult(selectedAddOns, uninstallations);\n    }\n","new_comment_raw":"Calculates the changes required to uninstall the given add-ons.","old_comment_raw":"Calculates the changes required to uninstall the given add-ons.","label":0,"pre_label":1,"AST_level":15,"line_counts":45,"new_code_token_num":282},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(StructuredTextTypeHandler handler, StructuredTextEnvironment environment) { if (environment == null) environment = StructuredTextEnvironment.DEFAULT; return new StructuredTextImpl(handler, environment, true); }","old_code_raw":"\tstatic public ISTextExpert getStatefulExpert(STextTypeHandler handler, STextEnvironment environment) {\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\treturn new STextImpl(handler, environment, true);\n\t}\n","new_comment_raw":"Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler and the specified environment.","old_comment_raw":"Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":33},{"new_code_raw":"public String print(ReadablePartial partial) { StringBuilder builder = new StringBuilder(requirePrinter().estimatePrintedLength()); try { printTo(builder, partial); } catch (IOException e) { \/\/ StringBuilder does not throw IOException } return builder.toString(); }","old_code_raw":"    public String print(ReadablePartial partial) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, partial);\n        return buf.toString();\n    }\n","new_comment_raw":"Prints a ReadablePartial to a new String.","old_comment_raw":"Prints a ReadablePartial to a new String.","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":52},{"new_code_raw":"public User executeAs(Function<Response, Response> handler) { Type type = new TypeToken<User>(){}.getType(); return execute(handler).as(type); }","old_code_raw":"        public User executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<User>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n","new_comment_raw":"GET \/user\/username","old_comment_raw":"GET \/user\/username","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public Button getButton(String text, boolean onlyVisible) { return getter.getView(Button.class, text, onlyVisible); }","old_code_raw":"\tpublic Button getButton(String text, boolean onlyVisible)\n\t{\n\t\treturn viewFetcher.getView(Button.class, text, onlyVisible);\n\t}\n","new_comment_raw":"Returns a Button which shows a given text.","old_comment_raw":"Returns a Button which shows a given text.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"@GET public Set<CassandraInstance> findAll() { return service.findAll(); }","old_code_raw":"  @GET\n  public List<CassandraInstance> findAll() {\n    return service.findAll();\n  }\n","new_comment_raw":"Return the set of Cassandra instances.","old_comment_raw":"Return the list of Cassandra instances ordered by position on ring, indicated by token.","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":16},{"new_code_raw":"public static PathMetadata<String> forProperty(Path<?> parent, String property) { return new PathMetadata<String>(parent, Assert.hasLength(property,\"property\"), PathType.PROPERTY); }","old_code_raw":"    public static PathMetadata<String> forProperty(Path<?> parent, String property) {\n        return new PathMetadata<String>(parent, ConstantImpl.create(Assert.hasLength(property,\"property\"), true), PathType.PROPERTY);\n    }\n","new_comment_raw":"Create a new PathMetadata for property access","old_comment_raw":"Create a new PathMetadata for property access","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":36},{"new_code_raw":"public String getReplicationDirectory() { return this.replicationDirectory; }","old_code_raw":"    public String getReplicationDirectory() {\n        return replicationDirectory;\n    }\n","new_comment_raw":"Returns the path to the replication directory","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"protected ApiResponse findMethodResponse(ApiResponses responses) { String code = null; for (String responseCode : responses.keySet()) { if (responseCode.startsWith(\"2\") || responseCode.equals(\"default\")) { if (code == null || code.compareTo(responseCode) > 0) { code = responseCode; } } } if (code == null) { return null; } return responses.get(code); }","old_code_raw":"    protected Response findMethodResponse(Map<String, Response> responses) {\n\n        String code = null;\n        for (String responseCode : responses.keySet()) {\n            if (responseCode.startsWith(\"2\") || responseCode.equals(\"default\")) {\n                if (code == null || code.compareTo(responseCode) > 0) {\n                    code = responseCode;\n                }\n            }\n        }\n        if (code == null) {\n            return null;\n        }\n        return responses.get(code);\n    }\n","new_comment_raw":"Override with any special handling of response codes","old_comment_raw":"Override with any special handling of response codes","label":0,"pre_label":1,"AST_level":11,"line_counts":15,"new_code_token_num":81},{"new_code_raw":"public String getValue(String key) throws NotFoundException, NotLeaderException { if (cluster.getLocalRole() != Role.LEADER) { throw new NotLeaderException(); } if (!entries.containsKey(key)) { throw new NotFoundException(); } String value = entries.get(key); logger.info(String.format(\"Get key %s: %s\", key, value)); return value; }","old_code_raw":"    public String getValue(String entryId) throws RecordNotFoundException {\n        if (!entries.containsKey(entryId)) {\n            throw new RecordNotFoundException();\n        }\n        return entries.get(entryId);\n    }\n","new_comment_raw":"Returns the value stored at the specified key.","old_comment_raw":"Get entry data, read directly from internal data structure.","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":81},{"new_code_raw":"public static Token seek(String path, Parser parser) { \/\/ return current token if no path is given if (!StringUtils.hasText(path)) { return null; } List<String> tokens = StringUtils.tokenize(path, \"\/\"); return seek(parser, tokens.toArray(new String[tokens.size()])); }","old_code_raw":"    public static Token seek(String path, Parser parser) {\n        \/\/ return current token if no path is given\n        if (!StringUtils.hasText(path)) {\n            return null;\n        }\n\n        List<String> tokens = StringUtils.tokenize(path, \"\/\");\n        ListIterator<String> li = tokens.listIterator();\n        return doSeekToken(li.next(), li, parser);\n    }\n","new_comment_raw":"Seeks the field with the given name in the stream and positions (and returns) the parser to the next available token (value or not).","old_comment_raw":"Seeks the field with the given name in the stream and positions (and returns) the parser to the next available token (value or not).","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":69},{"new_code_raw":"static public Allocation createFromBitmap(RenderScript rs, Bitmap b, MipmapControl mips, int usage) { if (rs.isNative) { RenderScriptThunker rst = (RenderScriptThunker)rs; return AllocationThunker.createFromBitmap(rst, b, mips, usage); } rs.validate(); \/\/ WAR undocumented color formats if (b.getConfig() == null) { if ((usage & USAGE_SHARED) != 0) { throw new RSIllegalArgumentException(\"USAGE_SHARED cannot be used with a Bitmap that has a null config.\"); } Bitmap newBitmap = Bitmap.createBitmap(b.getWidth(), b.getHeight(), Bitmap.Config.ARGB_8888); Canvas c = new Canvas(newBitmap); c.drawBitmap(b, 0, 0, null); return createFromBitmap(rs, newBitmap, mips, usage); } Type t = typeFromBitmap(rs, b, mips); \/\/ enable optimized bitmap path only with no mipmap and script-only usage if (mips == MipmapControl.MIPMAP_NONE && t.getElement().isCompatible(Element.RGBA_8888(rs)) && usage == (USAGE_SHARED | USAGE_SCRIPT)) { int id = rs.nAllocationCreateBitmapBackedAllocation(t.getID(rs), mips.mID, b, usage); if (id == 0) { throw new RSRuntimeException(\"Load failed.\"); } \/\/ keep a reference to the Bitmap around to prevent GC Allocation alloc = new Allocation(id, rs, t, usage); alloc.setBitmap(b); return alloc; } int id = rs.nAllocationCreateFromBitmap(t.getID(rs), mips.mID, b, usage); if (id == 0) { throw new RSRuntimeException(\"Load failed.\"); } return new Allocation(id, rs, t, usage); }","old_code_raw":"    static public Allocation createFromBitmap(RenderScript rs, Bitmap b,\n                                              MipmapControl mips,\n                                              int usage) {\n        rs.validate();\n        Type t = typeFromBitmap(rs, b, mips);\n\n        int id = rs.nAllocationCreateFromBitmap(t.getID(rs), mips.mID, b, usage);\n        if (id == 0) {\n            throw new RSRuntimeException(\"Load failed.\");\n        }\n        return new Allocation(id, rs, t, usage);\n    }\n","new_comment_raw":"Creates an Allocation from a  android.graphics.Bitmap.","old_comment_raw":"Creates a renderscript allocation from a bitmap","label":1,"pre_label":0,"AST_level":9,"line_counts":46,"new_code_token_num":327},{"new_code_raw":"public boolean isValid(Litmus litmus) { return super.isValid(litmus) && litmus.check(Util.isDistinct(getRowType().getFieldNames()), \"distinct field names: {}\", getRowType()); }","old_code_raw":"  public boolean isValid(Litmus litmus) {\n    return super.isValid(litmus)\n        && litmus.check(Util.isDistinct(getRowType().getFieldNames()), getRowType());\n  }\n","new_comment_raw":"Computes the row type of an  Aggregate before it exists.","old_comment_raw":"Computes the row type of an Aggregate before it exists.","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":45},{"new_code_raw":"public String toString() { return ISODateTimeFormat.getInstance().dateTime().print(this); }","old_code_raw":"    public String toString() {\n        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);\n    }\n","new_comment_raw":"Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).","old_comment_raw":"Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public byte[] evaluateChallenge(byte[] challenge) throws MessagingException { try { String result = \"\\0\"+username+\"\\0\"+password; if(authzid != null && authzid.length() > 0) { result = authzid+result; } complete = true; return result.getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) { \/\/ got an error, fail this throw new MessagingException(\"Invalid encoding\"); } }","old_code_raw":"    public byte[] evaluateChallenge(byte[] challenge) throws MessagingException {\n        try {\n            \/\/ get the username and password in an UTF-8 encoding to create the\n            \/\/ token\n            byte[] userBytes = username.getBytes(\"UTF-8\");\n            byte[] passBytes = password.getBytes(\"UTF-8\");\n\n            \/\/ our token has two copies of the username, one copy of the\n            \/\/ password, and nulls\n            \/\/ between\n            byte[] tokenBytes = new byte[(userBytes.length * 2) + passBytes.length + 2];\n\n            System.arraycopy(userBytes, 0, tokenBytes, 0, userBytes.length);\n            System.arraycopy(userBytes, 0, tokenBytes, userBytes.length + 1, userBytes.length);\n            System.arraycopy(passBytes, 0, tokenBytes, (userBytes.length * 2) + 2, passBytes.length);\n\n            complete = true;\n            return tokenBytes;\n\n        } catch (UnsupportedEncodingException e) {\n            \/\/ got an error, fail this\n            throw new MessagingException(\"Invalid encoding\");\n        }\n    }\n","new_comment_raw":"Evaluate a PLAIN login challenge, returning the a result string that should satisfy the challenge.","old_comment_raw":"Evaluate a PLAIN login challenge, returning the a result string that should satisfy the clallenge.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":93},{"new_code_raw":"public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) { validateView(view); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } return getViewToHeaderPositionImpl(view, start, end); }","old_code_raw":"    public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) {\n        validateView(view);\n        validateStartEnd(start, end, view.getDocument().getLength());\n        return getViewToHeaderPositionImpl(view, start, end);\n    }\n","new_comment_raw":"Gets the given  start and  end view positions offset to a header.","old_comment_raw":"Gets the given start and end view positions offset to a header.","label":0,"pre_label":1,"AST_level":6,"line_counts":11,"new_code_token_num":63},{"new_code_raw":"public static ENumber<Integer> lastIndexOf(Expr<String> left, String right) { return factory.createNumber(Integer.class,Ops.LAST_INDEX, left, factory.createConstant(right)); }","old_code_raw":"    public static ENumber<Integer> lastIndexOf(Expr<String> left, String right) {\n        return createNumber(Integer.class,Ops.LAST_INDEX, left, createConstant(right));\n    }\n","new_comment_raw":"Expr : left.lastIndexOf(right)","old_comment_raw":"Expr : left.lastIndexOf(right)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public static String asJson(Object object) throws IOException { return JSON.writeValueAsString(object); }","old_code_raw":"    public static JsonNode asJson(Object object) throws IOException {\n        return JSON.writeValueAsTree(object);\n    }\n","new_comment_raw":"Converts the given object into a canonical JSON string.","old_comment_raw":"Converts the given object into a JSON AST.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"boolean hasClient() { return listeningThread != null && listeningThread.hasClient && !listeningThread.sockets.isEmpty(); }","old_code_raw":"  boolean hasClient() {\n    return listeningThread != null && listeningThread.hasClient;\n  }\n","new_comment_raw":"Returns whether an instance of Chrome is currently connected","old_comment_raw":"Returns whether an instance of Chrome is currently connected","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public EAttribute getChange_State() { return (EAttribute) changeEClass.getEStructuralFeatures().get(5); }","old_code_raw":"\tpublic EReference getChange_State() {\n\t\treturn (EReference) changeEClass.getEStructuralFeatures().get(5);\n\t}\n","new_comment_raw":"Returns the meta object for the attribute ' org.eclipse.mylyn.reviews.core.model.IChange#getState State'.","old_comment_raw":"Returns the meta object for the containment reference ' org.eclipse.mylyn.reviews.core.model.IChange#getState State'.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"public ImageSource tilingDisabled() { return setTiling(false); }","old_code_raw":"    public ImageSource tilingDisabled() {\n        return tiling(false);\n    }\n","new_comment_raw":"Disable tiling of the image.","old_comment_raw":"Disable tiling of the image.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public Subject login(AuthenticationToken token) throws AuthenticationException { Account account; try { account = authenticate(token); rememberMeSuccessfulLogin(token, account); } catch (AuthenticationException ae) { rememberMeFailedLogin(token, ae); throw ae; \/\/propagate } Subject secCtx = createSubject(token, account); assertCreation(secCtx); bind(secCtx); return secCtx; }","old_code_raw":"    public SecurityContext login(AuthenticationToken token) throws AuthenticationException {\r\n        Account account;\r\n        try {\r\n            account = authenticate(token);\r\n            rememberMeSuccessfulLogin(token, account);\r\n        } catch (AuthenticationException ae) {\r\n            rememberMeFailedLogin(token, ae);\r\n            throw ae; \/\/propagate\r\n        }\r\n        SecurityContext secCtx = createSecurityContext(token, account);\r\n        assertCreation(secCtx);\r\n        bind(secCtx);\r\n        return secCtx;\r\n    }\r\n","new_comment_raw":"First authenticates the AuthenticationToken argument, and if successful, constructs a Subject instance representing the authenticated account's identity.","old_comment_raw":"First authenticates the AuthenticationToken argument, and if successful, constructs a SecurityContext instance representing the authenticated account's identity.","label":1,"pre_label":0,"AST_level":7,"line_counts":16,"new_code_token_num":72},{"new_code_raw":"protected int intersectsValidDropTarget(int id) { LauncherAccessibilityDelegate delegate = LauncherAppState.getInstance().getAccessibilityDelegate(); if (delegate == null) { return -1; } int y = id % mCountY; int x = id \/ mCountY; LauncherAccessibilityDelegate.DragInfo dragInfo = delegate.getDragInfo(); if (dragInfo.dragType == DragType.WIDGET) { \/\/ For a widget, every cell must be vacant. In addition, we will return any valid \/\/ drop target by which the passed id is contained. boolean fits = false; \/\/ These represent the amount that we can back off if we hit a problem. They \/\/ get consumed as we move up and to the right, trying new regions. int spanX = dragInfo.info.spanX; int spanY = dragInfo.info.spanY; for (int m = 0; m < spanX; m++) { for (int n = 0; n < spanY; n++) { fits = true; int x0 = x - m; int y0 = y - n; if (x0 < 0 || y0 < 0) continue; for (int i = x0; i < x0 + spanX; i++) { if (!fits) break; for (int j = y0; j < y0 + spanY; j++) { if (i >= mCountX || j >= mCountY || mOccupied[i][j]) { fits = false; break; } } } if (fits) { return x0 * mCountY + y0; } } } return -1; } else { \/\/ For an icon, we simply check the view directly below View child = getChildAt(x, y); if (child == null || child == dragInfo.item) { \/\/ Empty cell. Good for an icon or folder. return id; } else if (dragInfo.dragType != DragType.FOLDER) { \/\/ For icons, we can consider cells that have another icon or a folder. ItemInfo info = (ItemInfo) child.getTag(); if (info instanceof AppInfo || info instanceof FolderInfo || info instanceof ShortcutInfo) { return id; } } return -1; } }","old_code_raw":"        protected int intersectsValidDropTarget(int id) {\n            LauncherAccessibilityDelegate delegate =\n                    LauncherAppState.getInstance().getAccessibilityDelegate();\n            LauncherAccessibilityDelegate.DragInfo dragInfo = delegate.getDragInfo();\n\n            int y = id % mCountY;\n            int x = id \/ mCountY;\n\n            if (dragInfo.dragType == DragType.WIDGET) {\n                \/\/ For a widget, every cell must be vacant. In addition, we will return any valid\n                \/\/ drop target by which the passed id is contained.\n                boolean fits = false;\n\n                \/\/ These represent the amount that we can back off if we hit a problem. They\n                \/\/ get consumed as we move up and to the right, trying new regions.\n                int spanX = dragInfo.info.spanX;\n                int spanY = dragInfo.info.spanY;\n\n                for (int m = 0; m < spanX; m++) {\n                    for (int n = 0; n < spanY; n++) {\n\n                        fits = true;\n                        int x0 = x - m;\n                        int y0 = y - n;\n\n                        if (x0 < 0 || y0 < 0) continue;\n\n                        for (int i = x0; i < x0 + spanX; i++) {\n                            if (!fits) break;\n                            for (int j = y0; j < y0 + spanY; j++) {\n                                if (i >= mCountX || j >= mCountY || mOccupied[i][j]) {\n                                    fits = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (fits) {\n                            return x0 * mCountY + y0;\n                        }\n                    }\n                }\n                return -1;\n            } else {\n                \/\/ For an icon, we simply check the view directly below\n                View child = getChildAt(x, y);\n                if (child == null || child == dragInfo.item) {\n                    \/\/ Empty cell. Good for an icon or folder.\n                    return id;\n                } else if (dragInfo.dragType != DragType.FOLDER) {\n                    \/\/ For icons, we can consider cells that have another icon or a folder.\n                    ItemInfo info = (ItemInfo) child.getTag();\n                    if (info instanceof AppInfo || info instanceof FolderInfo ||\n                            info instanceof ShortcutInfo) {\n                        return id;\n                    }\n                }\n                return -1;\n            }\n        }\n","new_comment_raw":"Find the virtual view id corresponding to the top left corner of any drop region by which the passed id is contained.","old_comment_raw":"Find the virtual view id corresponding to the top left corner of any drop region by which the passed id is contained.","label":0,"pre_label":1,"AST_level":17,"line_counts":63,"new_code_token_num":389},{"new_code_raw":"private static URI makeFullQualifiedURI(String uriName) throws IOException { Path uriPath = new Path(uriName); if (isNormalized(uriName) && uriPath.isUriPathAbsolute()) { \/\/ add scheme and\/or authority if either is missing if ((uriPath.toUri().getScheme() == null || uriPath.toUri().getAuthority() == null)) { URI defaultUri = FileSystem.getDefaultUri(CONF); uriPath = uriPath.makeQualified(defaultUri, uriPath); } return uriPath.toUri(); } else { \/\/ relative URI path is unacceptable return null; } }","old_code_raw":"  private static URI makeFullQualifiedURI(String uriName) throws IOException, URISyntaxException {\n    Path uriPath = new Path(uriName);\n\n    if (uriPath.isAbsoluteAndSchemeAuthorityNull()) {\n\n      URI defaultUri = FileSystem.getDefaultUri(CONF);\n      uriPath = uriPath.makeQualified(defaultUri, uriPath);\n      return uriPath.toUri();\n    }\n\n    return new URI(uriName);\n  }\n","new_comment_raw":"Make fully qualified URI if Scheme and\/or Authority is missing, based on the default file system Scheme and Authority.","old_comment_raw":"Make fully qualified URI based on the default file system Scheme and Authority","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":108},{"new_code_raw":"public RollCycle getRollCycle() { return queue.rollCycle(); }","old_code_raw":"\tpublic RollCycle getRollCycle() {\n\t\treturn rollCycle;\n\t}\n","new_comment_raw":"Returns the queue file roll cycle","old_comment_raw":"Returns","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"protected DimensionValueLoadTask buildDruidDimensionsLoader( DruidWebService webService, PhysicalTableDictionary physicalTableDictionary, DimensionDictionary dimensionDictionary ) { DruidDimensionValueLoader druidDimensionRowProvider = new DruidDimensionValueLoader( physicalTableDictionary, dimensionDictionary, webService ); return new DimensionValueLoadTask(Collections.singletonList(druidDimensionRowProvider)); }","old_code_raw":"    protected DruidDimensionsLoader buildDruidDimensionsLoader(\n            DruidWebService webService,\n            PhysicalTableDictionary physicalTableDictionary,\n            DimensionDictionary dimensionDictionary\n    ) {\n        return new DruidDimensionsLoader(\n                physicalTableDictionary,\n                dimensionDictionary,\n                webService\n        );\n    }\n","new_comment_raw":"Build a DimensionValueLoadTask.","old_comment_raw":"Build a DruidDimensionsLoader.","label":1,"pre_label":0,"AST_level":6,"line_counts":14,"new_code_token_num":38},{"new_code_raw":"public boolean overlaps(ReadableInterval interval) { if (interval == null) { return containsNow(); } long otherStart = interval.getStartMillis(); long otherEnd = interval.getEndMillis(); long thisStart = getStartMillis(); long thisEnd = getEndMillis(); return (thisStart < otherEnd && otherStart < thisEnd); }","old_code_raw":"    public boolean overlaps(ReadableInterval interval) {\n        if (interval == null) {\n            throw new IllegalArgumentException(\"The time interval must not be null\");\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        return (thisStart < otherEnd && otherStart < thisEnd);\n    }\n","new_comment_raw":"Does this time interval overlap the specified time interval.","old_comment_raw":"Does this time interval overlap the specified time interval.","label":0,"pre_label":1,"AST_level":6,"line_counts":11,"new_code_token_num":57},{"new_code_raw":"public static int getAccentColorFromThemeIfAvailable(Context context) { TypedValue typedValue = new TypedValue(); \/\/ First, try the android:colorAccent if (Build.VERSION.SDK_INT >= 21) { context.getTheme().resolveAttribute(android.R.attr.colorAccent, typedValue, true); return typedValue.data; } \/\/ Next, try colorAccent from support lib int colorAccentResId = context.getResources().getIdentifier(\"colorAccent\", \"attr\", context.getPackageName()); if (colorAccentResId != 0 && context.getTheme().resolveAttribute(colorAccentResId, typedValue, true)) { return typedValue.data; } \/\/ Return the value in mdtp_accent_color return ContextCompat.getColor(context, R.color.mdtp_accent_color); }","old_code_raw":"    public static int getAccentColorFromThemeIfAvailable(Context context) {\n        TypedValue typedValue = new TypedValue();\n        \/\/ First, try the android:colorAccent\n        if (Build.VERSION.SDK_INT >= 21) {\n            context.getTheme().resolveAttribute(android.R.attr.colorAccent, typedValue, true);\n            return typedValue.data;\n        }\n        \/\/ Next, try colorAccent from support lib\n        int colorAccentResId = context.getResources().getIdentifier(\"colorAccent\", \"attr\", context.getPackageName());\n        if (colorAccentResId != 0 && context.getTheme().resolveAttribute(colorAccentResId, typedValue, true)) {\n            return typedValue.data;\n        }\n        \/\/ Return the value in mdtp_accent_color\n        return Utils.getColor(context, R.color.mdtp_accent_color);\n    }\n","new_comment_raw":"Gets the colorAccent from the current context, if possible\/available","old_comment_raw":"Gets the colorAccent from the current context, if possible\/available","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":130},{"new_code_raw":"protected String getChromeFile() throws IOException { if (!isChromeBinaryLocationKnown()) { chromeBinaryLocation = System.getProperty(\"webdriver.chrome.bin\"); if (chromeBinaryLocation == null) { if (Platform.getCurrent().is(Platform.WINDOWS)) { chromeBinaryLocation = getWindowsBinaryLocation(); } else if (Platform.getCurrent().is(Platform.UNIX)) { chromeBinaryLocation = \"\/usr\/bin\/google-chrome\"; } else if (Platform.getCurrent().is(Platform.MAC)) { String[] paths = new String[] { \"\/Applications\/Google Chrome.app\/Contents\/MacOS\/Google Chrome\", \"\/Users\/\" + System.getProperty(\"user.name\") + \"\/Applications\/Google Chrome.app\/Contents\/MacOS\/Google Chrome\"}; for (String path : paths) { File binary = new File(path); if (binary.exists()) { chromeBinaryLocation = binary.getCanonicalFile().getAbsoluteFile().toString(); break; } } } else { throw new WebDriverException(\"Unsupported operating system. \" + \"Could not locate Chrome. Set webdriver.chrome.bin\"); } } if (!isChromeBinaryLocationKnown()) { throw new WebDriverException(\"Couldn't locate Chrome. \" + \"Set webdriver.chrome.bin\"); } } return chromeBinaryLocation; }","old_code_raw":"  protected String getChromeFile() throws IOException {\n    String chromeFileString = System.getProperty(\"webdriver.chrome.bin\");\n    if (chromeFileString == null) {\n      if (Platform.getCurrent().is(Platform.WINDOWS)) {\n        chromeFileString = getWindowsBinaryLocation();\n      } else if (Platform.getCurrent().is(Platform.UNIX)) {\n        chromeFileString = \"\/usr\/bin\/google-chrome\";\n      } else if (Platform.getCurrent().is(Platform.MAC)) {\n        String[] paths = new String[] {\n          \"\/Applications\/Google Chrome.app\/Contents\/MacOS\/Google Chrome\",\n          \"\/Users\/\" + System.getProperty(\"user.name\") +\n              \"\/Applications\/Google Chrome.app\/Contents\/MacOS\/Google Chrome\"};\n        for (String path : paths) {\n          File binary = new File(path);\n          if (binary.exists()) {\n            chromeFileString = binary.getCanonicalFile().getAbsoluteFile().toString();\n            break;\n          }\n        }\n      } else {\n        throw new WebDriverException(\"Unsupported operating system.  \" +\n            \"Could not locate Chrome.  Set webdriver.chrome.bin\");\n      }\n      if (chromeFileString == null ||\n          !new File(chromeFileString.toString()).exists()) {\n        throw new WebDriverException(\"Couldn't locate Chrome.  \" +\n            \"Set webdriver.chrome.bin\");\n      }\n    }\n    return chromeFileString;\n  }\n","new_comment_raw":"Locates the Chrome executable on the current platform.","old_comment_raw":"Locates the Chrome executable on the current platform.","label":0,"pre_label":1,"AST_level":18,"line_counts":33,"new_code_token_num":251},{"new_code_raw":"public ArrayList getAllLinkHRefs() { return this.link_href_all; }","old_code_raw":"    public ArrayList getAllLinkHRefs() {\n        return link_href_all;\n    }\n","new_comment_raw":"Get a list of all links","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public Mono<Client> testClientModel(Client body) throws RestClientException { Object postBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\"); } String path = UriComponentsBuilder.fromPath(\"\/fake\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<Client> testClientModel(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        \/\/ verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"To test \\&quot;client\\&quot; model","old_comment_raw":"To test \\&quot;client\\&quot; model","label":0,"pre_label":1,"AST_level":8,"line_counts":30,"new_code_token_num":217},{"new_code_raw":"private String getTag() { if (lineage.isEmpty()) { return name; } else { return lineage.get(0).getName(); } }","old_code_raw":"        private String getTag() {\n            return dictionary.getJsonAliasFor(type);\n        }\n","new_comment_raw":"All Paths are 'tagged' in swagger with the root entity name in the path.","old_comment_raw":"All Paths are 'tagged' in swagger with the final entity type name in the path.","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":32},{"new_code_raw":"public boolean isFull() { return getPrefetchSize() == 0 ? prefetchExtension.get() == 0 : dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize(); }","old_code_raw":"    public boolean isFull() {\n        return dispatched.size() - prefetchExtension.get() >= info.getPrefetchSize();\n    }\n","new_comment_raw":"Used to determine if the broker can dispatch to the consumer.","old_comment_raw":"Used to determine if the broker can dispatch to the consumer.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":33},{"new_code_raw":"public static final Element elementFromUse(ExpressionTree node) { return InternalUtils.symbol(node); }","old_code_raw":"    public static final ExecutableElement elementFromUse(MethodInvocationTree node) {\n        return (ExecutableElement)TreeInfo.symbol((JCTree)node.getMethodSelect());\n    }\n","new_comment_raw":"Gets the element for the declaration corresponding to this use of an element.","old_comment_raw":"Gets the element for the method corresponding to this invocation.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"public float duration() { float sec = gplayer.queryDuration().toSeconds(); float nanosec = gplayer.queryDuration().getNanoSeconds(); return sec + Video.nanoSecToSecFrac(nanosec); }","old_code_raw":"  public float duration() {\n    float sec = gplayer.queryDuration().toSeconds();\n    float nanosec = gplayer.queryDuration().getNanoSeconds();\n    return sec + GSVideo.nanoSecToSecFrac(nanosec);\n  }  \n","new_comment_raw":"Get the full length of this movie (in seconds).","old_comment_raw":"Get the full length of this movie (in seconds).","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"public static Struct fromLogical(Schema schema, SpecialValueDecimal value) { return fromLogical(schema, value.getDecimalValue().orElse(null)); }","old_code_raw":"    public static Struct fromLogical(Schema schema, SpecialValueDecimal value) {\n        Struct result = new Struct(schema);\n        final BigDecimal decimalValue = value.getDecimalValue().orElse(null);\n        assert decimalValue != null : \"Unable to encode special value\";\n        result.put(VALUE_FIELD, decimalValue.unscaledValue().toByteArray());\n        result.put(SCALE_FIELD, decimalValue.scale());\n        return result;\n    }\n","new_comment_raw":"Converts a value from its logical format to its encoded format - a struct containing the scale of the number and a binary representation of the number.","old_comment_raw":"Converts a value from its logical format (BigDecimal) to its encoded format - a struct containing the scale of the number and a binary representation of the number.","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public Struct offsetStructForEvent(String replicaSetName, Document oplogEvent) { Position position = INITIAL_POSITION; String namespace = \"\"; if (oplogEvent != null) { BsonTimestamp ts = extractEventTimestamp(oplogEvent); Long opId = oplogEvent.getLong(\"h\"); position = new Position(ts, opId); namespace = oplogEvent.getString(\"ns\"); } positionsByReplicaSetName.put(replicaSetName, position); return offsetStructFor(replicaSetName, CollectionId.parse(replicaSetName + \".\" + namespace), position, isInitialSyncOngoing(replicaSetName)); }","old_code_raw":"    public Struct offsetStructForEvent(String replicaSetName, Document oplogEvent) {\n        Position position = INITIAL_POSITION;\n        String namespace = \"\";\n        if (oplogEvent != null) {\n            BsonTimestamp ts = extractEventTimestamp(oplogEvent);\n            Long opId = oplogEvent.getLong(\"h\");\n            position = new Position(ts, opId);\n            namespace = oplogEvent.getString(\"ns\");\n        }\n        positionsByReplicaSetName.put(replicaSetName, position);\n        return offsetStructFor(replicaSetName, namespace, position, isInitialSyncOngoing(replicaSetName));\n    }\n","new_comment_raw":"Get a  Struct representation of the source  #partition(String) partition and  #lastOffset(String) offset information.","old_comment_raw":"Get a Struct representation of the source #partition(String) partition and #lastOffset(String) offset information.","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":96},{"new_code_raw":"private boolean makeSureFileLockRemainsGone(File lock, long timeToWait) { for (long start = System.currentTimeMillis(); System.currentTimeMillis() < start + timeToWait;) { AsyncExecute.sleepTight(500); if (lock.exists()) return false; } return !lock.exists(); }","old_code_raw":"    private boolean makeSureFileLockRemainsGone(File lock, long timeToWait) {\n        for (long start = System.currentTimeMillis(); System.currentTimeMillis() < start + timeToWait;) {\n            AsyncExecute.sleepTight(500);\n            if (lock.exists()) return false;\n        }\n        if (!lock.exists()) return true;\n        return false;\n    }\n","new_comment_raw":"When initializing the profile, Opera rapidly starts, stops, restarts and stops again; we need to wait a bit to make sure the file lock is really gone.","old_comment_raw":"When initializing the profile, Opera rapidly starts, stops, restarts and stops again; we need to wait a bit to make sure the file lock is really gone.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":55},{"new_code_raw":"public static UserSpinnerAdapter createUserSpinnerAdapter(UserManager userManager, Context context) { List<UserHandle> userProfiles = userManager.getUserProfiles(); if (userProfiles.size() < 2) { return null; } UserHandle myUserHandle = new UserHandle(UserHandle.myUserId()); \/\/ The first option should be the current profile userProfiles.remove(myUserHandle); userProfiles.add(0, myUserHandle); ArrayList<UserDetails> userDetails = new ArrayList<UserDetails>(userProfiles.size()); final int count = userProfiles.size(); for (int i = 0; i < count; i++) { userDetails.add(new UserDetails(userProfiles.get(i), userManager, context)); } return new UserSpinnerAdapter(context, userDetails); }","old_code_raw":"    public static UserAdapter createUserSpinnerAdapter(UserManager userManager,\n            Context context) {\n        List<UserHandle> userProfiles = userManager.getUserProfiles();\n        if (userProfiles.size() < 2) {\n            return null;\n        }\n\n        UserHandle myUserHandle = new UserHandle(UserHandle.myUserId());\n        \/\/ The first option should be the current profile\n        userProfiles.remove(myUserHandle);\n        userProfiles.add(0, myUserHandle);\n\n        return createUserAdapter(userManager, context, userProfiles);\n    }\n","new_comment_raw":"Creates a  UserSpinnerAdapter if there is more than one profile on the device.","old_comment_raw":"Creates a UserAdapter if there is more than one profile on the device.","label":1,"pre_label":0,"AST_level":9,"line_counts":21,"new_code_token_num":132},{"new_code_raw":"public List<WebElement> apply(WebDriver webDriver) { Boolean displayed = false; Boolean exists = false; try { exists = findElements(sub_locator, webDriver).size() > 0; \/\/duplicating search is to avoid dom rebuilding problems displayed = findElement(sub_locator, webDriver).isDisplayed(); } catch (Exception e) {\/**\/} return (exists && displayed) ? findElements(sub_locator, webDriver) : null; }","old_code_raw":"      public List<WebElement> apply(WebDriver webDriver) {\n        Boolean displayed = false;\n        Boolean exists = false;\n        try {\n          exists =\n            element.findElements(sub_locator).size()\n            > 0; \/\/duplicating search is to avoid dom rebuilding problems\n          displayed = element.findElement(sub_locator).isDisplayed();\n        } catch (Exception e) {\/**\/}\n        return (exists && displayed) ? element.findElements(sub_locator) : null;\n      }\n","new_comment_raw":"An expectation for checking child WebElement as a part of parent element to be visible","old_comment_raw":"An expectation for checking child WebElement as a part of parent element to be visible","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":82},{"new_code_raw":"public Mono<Pet> getPetById(Long petId) throws RestClientException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling getPetById\"); } \/\/ create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(\"petId\", petId); String path = UriComponentsBuilder.fromPath(\"\/pet\/{petId}\").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/xml\", \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"api_key\" }; ParameterizedTypeReference<Pet> returnType = new ParameterizedTypeReference<Pet>() {}; return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<Pet> getPetById(Long petId) throws RestClientException {\n        Object postBody = null;\n        \n        \/\/ verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling getPetById\");\n        }\n        \n        \/\/ create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"\/pet\/{petId}\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/xml\", \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key\" };\n\n        ParameterizedTypeReference<Pet> returnType = new ParameterizedTypeReference<Pet>() {};\n        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"Find pet by ID","old_comment_raw":"Find pet by ID","label":0,"pre_label":1,"AST_level":8,"line_counts":31,"new_code_token_num":257},{"new_code_raw":"public Set<TSentryRole> getTSentryRolesByGroupName(final Set<String> groupNames, final boolean checkAllGroups) throws Exception { if (groupNames.isEmpty()) { return Collections.emptySet(); } return tm.executeTransaction( new TransactionBlock<Set<TSentryRole>>() { @Override public Set<TSentryRole> execute(PersistenceManager pm) throws Exception { pm.setDetachAllOnCommit(false); \/\/ No need to detach objects \/\/ Pre-allocate large sets for role names and results. \/\/ roleNames is used to avoid adding the same role mutiple times into \/\/ result. The result is set, but comparisons between TSentryRole objects \/\/ is more expensive then String comparisons. Set<String> roleNames = new HashSet<>(1024); Set<TSentryRole> result = new HashSet<>(1024); for(String group: groupNames) { if (group == null) { \/\/ Special case - return all roles List<MSentryRole> roles = getAllRoles(pm); for (MSentryRole role: roles) { result.add(convertToTSentryRole(role)); } return result; } \/\/ Find group by name and all roles belonging to this group String trimmedGroup = group.trim(); Query query = pm.newQuery(MSentryGroup.class); query.setFilter(\"this.groupName == :groupName\"); query.setUnique(true); MSentryGroup mGroup = (MSentryGroup) query.execute(trimmedGroup); if (mGroup != null) { \/\/ For each unique role found, add a new TSentryRole version of the role to result. for (MSentryRole role: mGroup.getRoles()) { String roleName = role.getRoleName(); if (roleNames.add(roleName)) { result.add(convertToTSentryRole(role)); } } } else if (!checkAllGroups) { throw noSuchGroup(trimmedGroup); } query.closeAll(); } return result; } }); }","old_code_raw":"  public Set<TSentryRole> getTSentryRolesByGroupName(Set<String> groupNames,\n      boolean checkAllGroups) throws Exception {\n    Set<MSentryRole> roleSet = Sets.newHashSet();\n    for (String groupName : groupNames) {\n      try {\n        roleSet.addAll(getMSentryRolesByGroupName(groupName));\n      } catch (SentryNoSuchObjectException e) {\n        \/\/ if we are checking for all the given groups, then continue searching\n        if (!checkAllGroups) {\n          throw e;\n        }\n      }\n    }\n    return convertToTSentryRoles(roleSet);\n  }\n","new_comment_raw":"Return set of roles corresponding to the groups provided.","old_comment_raw":"Gets sentry role objects for a given groupName from the persistence layer","label":1,"pre_label":0,"AST_level":18,"line_counts":55,"new_code_token_num":335},{"new_code_raw":"static String boxClassName(Type type) { if (!(type instanceof Class)) { return type.toString(); } Primitive primitive = Primitive.of(type); if (primitive != null) { return primitive.boxClass.getSimpleName(); } else { return className(type); } }","old_code_raw":"    static String boxClassName(Type type) {\n        if (!(type instanceof Class)) {\n            return type.toString();\n        }\n        Class clazz = (Class) type;\n        if (clazz.isPrimitive()) {\n            return PRIMITIVES.get(clazz).getSimpleName();\n        } else {\n            return className(clazz);\n        }\n    }\n","new_comment_raw":"Boxes a type, if it is primitive, and returns the type name.","old_comment_raw":"Boxes a type, if it is primitive, and returns the type name.","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":58},{"new_code_raw":"public static DrillFileSystem createFileSystem(String proxyUserName, Configuration fsConf) { return createFileSystem(createProxyUgi(proxyUserName), fsConf, null); }","old_code_raw":"  public static DrillFileSystem createFileSystem(String proxyUserName, Configuration fsConf, OperatorStats stats) {\n    return createFileSystem(createProxyUgi(proxyUserName), fsConf, stats);\n  }\n","new_comment_raw":"Create DrillFileSystem for given proxyUserName and configuration.","old_comment_raw":"Create DrillFileSystem for given proxyUserName, configuration and stats.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"@CheckForNull public final SCMRevision fetch(@NonNull String thingName, @CheckForNull TaskListener listener) throws IOException, InterruptedException { return retrieve(thingName, defaultListener(listener)); }","old_code_raw":"    @CheckForNull\n    public final SCMRevision fetch(@NonNull String revision, @CheckForNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return retrieve(revision, defaultListener(listener));\n    }\n","new_comment_raw":"Looks up a specific thingName based on some SCM-specific set of permissible syntaxes.","old_comment_raw":"Looks up a specific revision based on some SCM-specific set of permissible syntaxes.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":34},{"new_code_raw":"public static boolean isTree(SemanticGraph tree) { for (IndexedWord vertex : tree.vertexSet()) { \/\/ Check one and only one incoming edge if (tree.getRoots().contains(vertex)) { if (tree.incomingEdgeIterator(vertex).hasNext()) { return false; } } else { Iterator<SemanticGraphEdge> iter = tree.incomingEdgeIterator(vertex); if (!iter.hasNext()) { return false; } iter.next(); if (iter.hasNext()) { return false; } } \/\/ Check incoming and outgoing edges match for (SemanticGraphEdge edge : tree.outgoingEdgeIterable(vertex)) { boolean foundReverse = false; for (SemanticGraphEdge reverse : tree.incomingEdgeIterable(edge.getDependent())) { if (reverse == edge) { foundReverse = true; } } if (!foundReverse) { return false; } } for (SemanticGraphEdge edge : tree.incomingEdgeIterable(vertex)) { boolean foundReverse = false; for (SemanticGraphEdge reverse : tree.outgoingEdgeIterable(edge.getGovernor())) { if (reverse == edge) { foundReverse = true; } } if (!foundReverse) { return false; } } } \/\/ Check topological sort -- sometimes fails? \/\/ try { \/\/ tree.topologicalSort(); \/\/ } catch (Exception e) { \/\/ e.printStackTrace(); \/\/ return false; \/\/ } return true; }","old_code_raw":"  public static boolean isTree(SemanticGraph tree) {\n    for (IndexedWord vertex : tree.vertexSet()) {\n      if (tree.getRoots().contains(vertex)) {\n        if (tree.incomingEdgeIterator(vertex).hasNext()) {\n          return false;\n        }\n      } else {\n        Iterator<SemanticGraphEdge> iter = tree.incomingEdgeIterator(vertex);\n        if (!iter.hasNext()) {\n          return false;\n        }\n        iter.next();\n        if (iter.hasNext()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n","new_comment_raw":"A little utility function to make sure a SemanticGraph is a tree.","old_comment_raw":"A little utility function to make sure a SemanticGraph is a tree.","label":0,"pre_label":1,"AST_level":13,"line_counts":47,"new_code_token_num":264},{"new_code_raw":"public static Builder create() { return new Builder() { private Configuration config; private Consumer<SourceRecord> consumer; private ClassLoader classLoader; private Clock clock; @Override public Builder using(Configuration config) { this.config = config; return this; } @Override public Builder using(ClassLoader classLoader) { this.classLoader = classLoader; return this; } @Override public Builder using(Clock clock) { this.clock = clock; return this; } @Override public Builder notifying(Consumer<SourceRecord> consumer) { this.consumer = consumer; return this; } @Override public EmbeddedConnector build() { if (classLoader == null) classLoader = getClass().getClassLoader(); if (clock == null) clock = Clock.system(); Objects.requireNonNull(config, \"A connector configuration must be specified.\"); Objects.requireNonNull(consumer, \"A connector consumer must be specified.\"); return new EmbeddedConnector(config, classLoader, clock, consumer); } }; }","old_code_raw":"    public static Builder create() {\n        return new Builder() {\n            private Configuration config;\n            private OffsetBackingStore offsetStore;\n            private OffsetCommitPolicy offsetCommitPolicy;\n            private Consumer<SourceRecord> consumer;\n            private ClassLoader classLoader;\n            private Clock clock;\n\n            @Override\n            public Builder using(Configuration config) {\n                this.config = config;\n                return this;\n            }\n\n            @Override\n            public Builder using(OffsetBackingStore offsetStore) {\n                this.offsetStore = offsetStore;\n                return this;\n            }\n\n            @Override\n            public Builder using(OffsetCommitPolicy policy) {\n                this.offsetCommitPolicy = policy;\n                return this;\n            }\n\n            @Override\n            public Builder using(ClassLoader classLoader) {\n                this.classLoader = classLoader;\n                return this;\n            }\n\n            @Override\n            public Builder using(Clock clock) {\n                this.clock = clock;\n                return this;\n            }\n\n            @Override\n            public Builder notifying(Consumer<SourceRecord> consumer) {\n                this.consumer = consumer;\n                return this;\n            }\n\n            @Override\n            public EmbeddedConnector build() {\n                if (offsetStore == null) offsetStore = new MemoryOffsetBackingStore();\n                if (offsetCommitPolicy == null) offsetCommitPolicy = OffsetCommitPolicy.always();\n                if (classLoader == null) classLoader = getClass().getClassLoader();\n                if (clock == null) clock = Clock.system();\n                Objects.requireNonNull(config, \"A connector configuration must be specified.\");\n                Objects.requireNonNull(consumer, \"A connector consumer must be specified.\");\n                return new EmbeddedConnector(config, offsetStore, offsetCommitPolicy, classLoader, clock, consumer);\n            }\n\n        };\n    }\n","new_comment_raw":"Obtain a new  Builder instance that can be used to construct runnable  EmbeddedConnector instances.","old_comment_raw":"Obtain a new Builder instance that can be used to construct runnable EmbeddedConnector instances.","label":0,"pre_label":1,"AST_level":10,"line_counts":43,"new_code_token_num":182},{"new_code_raw":"public static String[] splitPrincipalIntoParts(final String principal) { final String[] components = principal.split(\"[\/@]\"); checkState(components.length < 4); checkState(components.length > 1); checkNotNull(components[0]); checkNotNull(components[1]); if (components.length == 2) { return new String[] { components[0], \"\", components[1] }; } else { checkNotNull(components[2]); return components; } }","old_code_raw":"  public static String[] splitPrincipalIntoParts(final String principal) {\n    final String[] components = principal.split(\"[\/@]\");\n    checkState(components.length == 3);\n    checkNotNull(components[0]);\n    checkNotNull(components[1]);\n    checkNotNull(components[2]);\n    return components;\n  }\n","new_comment_raw":"Expects principal of the format primary\/instance@REALM or primary@REALM.","old_comment_raw":"Expects principal of the format primary\/instance@REALM.","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":101},{"new_code_raw":"public static String getHostFromUrl(String url) { String authority = getAuthorityFromUrl(url); \/\/ no port int idx = authority.indexOf(\":\"); if (idx == -1) return authority; \/\/ port, return only the portion preceding the port return authority.substring(0, idx); }","old_code_raw":"   public static String getHostFromUrl(String url)\n   {\n      \/\/ no work to do\n      if (url.indexOf('\/') == -1)\n         return url;\n      \n      \/\/ presume no protocol; if present, skip those slashes\n      int slashes = 0;\n      if (url.contains(\":\/\/\"))\n         slashes += 2;\n      \n      \/\/ split on slashes and return first component\n      String[] parts = url.split(\"\/\");\n      if (parts.length < slashes)\n         return url;\n      return parts[slashes];\n   }\n","new_comment_raw":"Given a URL, attempt to return the host portion (not including the port).","old_comment_raw":"Given a URL, attempt to infer and return the hostname from the URL.","label":1,"pre_label":0,"AST_level":6,"line_counts":13,"new_code_token_num":60},{"new_code_raw":"public String escapeReservedWord(String name) { \/\/ Can't start with an underscore, as our fields need to start with an \/\/ UppercaseLetter so that Go treats them as public\/visible. \/\/ Options? \/\/ - MyName \/\/ - AName \/\/ - TheName \/\/ - XName \/\/ - X_Name \/\/ ... or maybe a suffix? \/\/ - Name_ ... think this will work. if (this.reservedWordsMappings().containsKey(name)) { return this.reservedWordsMappings().get(name); } return org.openapitools.codegen.utils.StringUtils.camelize(name) + '_'; }","old_code_raw":"    public String escapeReservedWord(String name) {\n        \/\/ Can't start with an underscore, as our fields need to start with an\n        \/\/ UppercaseLetter so that Go treats them as public\/visible.\n\n        \/\/ Options?\n        \/\/ - MyName\n        \/\/ - AName\n        \/\/ - TheName\n        \/\/ - XName\n        \/\/ - X_Name\n        \/\/ ... or maybe a suffix?\n        \/\/ - Name_ ... think this will work.\n        if (this.reservedWordsMappings().containsKey(name)) {\n            return this.reservedWordsMappings().get(name);\n        }\n        return camelize(name) + '_';\n    }\n","new_comment_raw":"Escapes a reserved word as defined in the `reservedWords` array.","old_comment_raw":"Escapes a reserved word as defined in the `reservedWords` array.","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":116},{"new_code_raw":"public Method getMethod() { return method; }","old_code_raw":"    public int getMethod() {\n        return method;\n    }\n","new_comment_raw":"Gets the request method.","old_comment_raw":"Gets an integer value of the request method.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"private static int parseOffset(String str) { Chronology chrono; if (cDefault != null) { chrono = ISOChronology.getInstanceUTC(); } else { \/\/ Can't use a real chronology if called during class \/\/ initialization. Offset parser doesn't need it anyhow. chrono = new BaseChronology() { public DateTimeZone getZone() { return null; } public Chronology withUTC() { return this; } public Chronology withZone(DateTimeZone zone) { return this; } public String toString() { return getClass().getName(); } }; } return -(int) offsetFormatter().withChronology(chrono).parseMillis(str); }","old_code_raw":"    private static int parseOffset(String str) {\n        Chronology chrono;\n        if (cDefault != null) {\n            chrono = ISOChronology.getInstanceUTC();\n        } else {\n            \/\/ Can't use a real chronology if called during class\n            \/\/ initialization. Offset parser doesn't need it anyhow.\n            chrono = new BaseChronology() {\n                public DateTimeZone getZone() {\n                    return null;\n                }\n                public Chronology withUTC() {\n                    return this;\n                }\n                public Chronology withZone(DateTimeZone zone) {\n                    return this;\n                }\n                public String toString() {\n                    return getClass().getName();\n                }\n            };\n        }\n\n        return -(int) offsetFormatter().parseMillis(str, chrono);\n    }\n","new_comment_raw":"Converts an old style id to a new style id.","old_comment_raw":"Converts an old style id to a new style id.","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":126},{"new_code_raw":"private String functionReplacement(FunctionCall functionCall) { String funcName = functionCall.getName(); if (functionCall.args.size() == 0) { return funcName; } boolean castToNullableNumeric = optionManager != null && optionManager.getOption(ExecConstants.CAST_TO_NULLABLE_NUMERIC_OPTION); if (! castToNullableNumeric) { return funcName; } MajorType majorType = functionCall.args.get(0).getMajorType(); DataMode dataMode = majorType.getMode(); MinorType minorType = majorType.getMinorType(); if (CastFunctions.isReplacementNeeded(funcName, minorType)) { funcName = CastFunctions.getReplacingCastFunction(funcName, dataMode, minorType); } return funcName; }","old_code_raw":"  private String functionReplacement(FunctionCall functionCall) {\n    String funcName = functionCall.getName();\n      if (functionCall.args.size() > 0) {\n          MajorType majorType =  functionCall.args.get(0).getMajorType();\n          DataMode dataMode = majorType.getMode();\n          MinorType minorType = majorType.getMinorType();\n          if (optionManager != null\n              && optionManager.getOption(ExecConstants.CAST_TO_NULLABLE_NUMERIC).bool_val\n              && CastFunctions.isReplacementNeeded(funcName, minorType)) {\n              funcName = CastFunctions.getReplacingCastFunction(funcName, dataMode, minorType);\n          }\n      }\n\n    return funcName;\n  }\n","new_comment_raw":"Checks if this function replacement is needed.","old_comment_raw":"Checks if this function replacement is needed.","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":106},{"new_code_raw":"public final int getEndColumn() { return this.bufcolumn[this.bufpos]; }","old_code_raw":"    public final int getEndColumn() {\n        return bufcolumn[bufpos];\n    }\n","new_comment_raw":"Get the column position","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public boolean isWordwrap() { return wordwrap; }","old_code_raw":"    @Override\n    public boolean isWordwrap() {\n        \/\/ TODO implement here once the API from TextField is removed\n        return super.isWordwrap();\n    }\n","new_comment_raw":"Tests if the text area is in word-wrap mode.","old_comment_raw":"Tests if the editor is in word-wrap mode.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public static ApiResponse getReferencedApiResponse(OpenAPI openAPI, ApiResponse apiResponse) { if (apiResponse != null && StringUtils.isNotEmpty(apiResponse.get$ref())) { String name = getSimpleRef(apiResponse.get$ref()); ApiResponse referencedApiResponse = getApiResponse(openAPI, name); if(referencedApiResponse != null) { return referencedApiResponse; } } return apiResponse; }","old_code_raw":"    public static ApiResponse getReferencedApiResponse(OpenAPI openAPI, ApiResponse apiResponse) {\n        if (apiResponse != null && StringUtils.isNotEmpty(apiResponse.get$ref())) {\n            String name = getSimpleRef(apiResponse.get$ref());\n            return getApiResponse(openAPI, name);\n        }\n        return apiResponse;\n    }\n","new_comment_raw":"If a ApiResponse contains a reference to an other ApiResponse with '$ref', returns the referenced ApiResponse if it is found or the actual ApiResponse in the other cases.","old_comment_raw":"If a ApiResponse contains a reference to an other ApiResponse with '$ref', returns the referenced ApiResponse or the actual ApiResponse in the other cases.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public String loginUser(String username, String password) throws ApiException { Object postBody = null; \/\/ create path and map variables String path = \"\/user\/login\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); queryParams.addAll(apiClient.parameterToPairs(\"\", \"username\", username)); queryParams.addAll(apiClient.parameterToPairs(\"\", \"password\", password)); final String[] accepts = { \"application\/json\", \"application\/xml\" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; GenericType<String> returnType = new GenericType<String>() {}; return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"  public String loginUser(String username, String password) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/user\/login\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n    \n    localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"username\", username));\n    \n    localVarQueryParams.addAll(apiClient.parameterToPairs(\"\", \"password\", password));\n    \n\n    \n\n    \n\n    final String[] localVarAccepts = {\n      \"application\/json\", \"application\/xml\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    \n    GenericType<String> localVarReturnType = new GenericType<String>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n    \n  }\n","new_comment_raw":"Logs user into the system","old_comment_raw":"Logs user into the system","label":0,"pre_label":1,"AST_level":8,"line_counts":39,"new_code_token_num":217},{"new_code_raw":"public static InetAddress guessPrimaryNetworkAddress(boolean preferIPv4) throws SocketException { final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces(); if (interfaces != null) { for (NetworkInterface interf : Collections.list(interfaces)) { if (!interf.isLoopback() && interf.isUp()) { \/\/ Interface is not loopback and up. Try to get the first address. for (InetAddress addr : Collections.list(interf.getInetAddresses())) { if (preferIPv4 && addr instanceof Inet4Address) { return addr; } if (!preferIPv4 && addr instanceof Inet6Address) { return addr; } } } } } return InetAddress.getLoopbackAddress(); }","old_code_raw":"    public static InetAddress guessPrimaryNetworkAddress() throws SocketException {\n        final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n\n        if (interfaces != null) {\n            for (NetworkInterface interf : Collections.list(interfaces)) {\n                if (!interf.isLoopback() && interf.isUp()) {\n                    \/\/ Interface is not loopback and up. Try to get the first address.\n                    for (InetAddress addr : Collections.list(interf.getInetAddresses())) {\n                        if (addr instanceof Inet4Address) {\n                            return addr;\n                        }\n                    }\n                }\n            }\n        }\n\n        return InetAddress.getLoopbackAddress();\n    }\n","new_comment_raw":"Try to get the primary  InetAddress of the primary network interface with fallback to the local loopback address (usually  127.0.0.1 or  ::1.","old_comment_raw":"Try to get the primary java.net.InetAddress of the primary network interface with fallback to the local loopback address (usually 127.0.0.1 or ::1.","label":1,"pre_label":0,"AST_level":14,"line_counts":23,"new_code_token_num":123},{"new_code_raw":"public String doCommand(String command, String field, String value) { resultExpected = true; doCommandWithoutWaitingForAResponse(command, field, value); try { return queueGetResult(\"doCommand\"); } finally { resultExpected = false; } }","old_code_raw":"    public String doCommand(String command, String field, String value) {\n        resultExpected = true;\n        doCommandWithoutWaitingForAResponse(command, field, value);\n        try {\n            return (String) queueGet(\"commandResultHolder\", commandResultHolder);\n        } catch (SeleniumCommandTimedOutException e) {\n            return \"ERROR: Command timed out\";\n        }\n        finally {\n            resultExpected = false;\n        }\n    }\n","new_comment_raw":"Schedules the specified command to be retrieved by the next call to handle command result, and returns the result of that command.","old_comment_raw":"Schedules the specified command to be retrieved by the next call to handle command result, and returns the result of that command.","label":0,"pre_label":1,"AST_level":6,"line_counts":11,"new_code_token_num":44},{"new_code_raw":"public DurationConverter removeDurationConverter(DurationConverter converter) throws SecurityException { checkAlterDurationConverters(); if (converter == null) { return null; } DurationConverter[] removed = new DurationConverter[1]; iDurationConverters = iDurationConverters.remove(converter, removed); return removed[0]; }","old_code_raw":"    public DurationConverter removeDurationConverter(int index) throws SecurityException {\n        checkAlterDurationConverters();\n        DurationConverter[] removed = new DurationConverter[1];\n        iDurationConverters = iDurationConverters.remove(index, removed);\n        return removed[0];\n    }\n","new_comment_raw":"Removes a converter from the set of converters.","old_comment_raw":"Removes a converter from the set of converters, by index.","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":50},{"new_code_raw":"protected int[] JavaToPdeOffsets(int line, int offset) { return new int[] { 0, 0 }; \/\/ TODO \/* int codeIndex = 0; int x = line - mainClassOffset; if (x < 0) { \/\/ log(\"Negative line number \" \/\/ + problem.getSourceLineNumber() + \" , offset \" \/\/ + mainClassOffset); x = line - 2; \/\/ Another -1 for 0 index if (x < programImports.size() && x >= 0) { ImportStatement is = programImports.get(x); \/\/ log(is.importName + \", \" + is.tab + \", \" \/\/ + is.lineNumber); return new int[] { 0, 0 }; \/\/ TODO } else { \/\/ Some seriously ugly stray error, just can't find the source \/\/ line! Simply return first line for first tab. return new int[] { 0, 1 }; } } try { for (SketchCode sc : editor.getSketch().getCode()) { if (sc.isExtension(\"pde\")) { int len; if (editor.getSketch().getCurrentCode().equals(sc)) { len = Util.countLines(sc.getDocumentText()) + 1; } else { len = Util.countLines(sc.getProgram()) + 1; } \/\/ log(\"x,len, CI: \" + x + \",\" + len + \",\" \/\/ + codeIndex); if (x >= len) { \/\/ We're in the last tab and the line count is greater \/\/ than the no. \/\/ of lines in the tab, if (codeIndex >= editor.getSketch().getCodeCount() - 1) { \/\/ log(\"Exceeds lc \" + x + \",\" + len \/\/ + problem.toString()); \/\/ x = len x = editor.getSketch().getCode(codeIndex) .getLineCount(); \/\/ TODO: Obtain line having last non-white space \/\/ character in the code. break; } else { x -= len; codeIndex++; } } else { if (codeIndex >= editor.getSketch().getCodeCount()) { codeIndex = editor.getSketch().getCodeCount() - 1; } break; } } } } catch (Exception e) { System.err.println(\"Error inside ErrorCheckerService.JavaToPdeOffset()\"); e.printStackTrace(); } return new int[] { codeIndex, x }; *\/ }","old_code_raw":"  protected int[] JavaToPdeOffsets(int line, int offset) {\n    int codeIndex = 0;\n\n    int x = line - mainClassOffset;\n    if (x < 0) {\n      \/\/ log(\"Negative line number \"\n      \/\/ + problem.getSourceLineNumber() + \" , offset \"\n      \/\/ + mainClassOffset);\n      x = line - 2; \/\/ Another -1 for 0 index\n      if (x < programImports.size() && x >= 0) {\n        ImportStatement is = programImports.get(x);\n        \/\/ log(is.importName + \", \" + is.tab + \", \"\n        \/\/ + is.lineNumber);\n        return new int[] { is.getTab(), is.getLineNumber() };\n      } else {\n\n        \/\/ Some seriously ugly stray error, just can't find the source\n        \/\/ line! Simply return first line for first tab.\n        return  new int[] { 0, 1 };\n      }\n\n    }\n\n    try {\n      for (SketchCode sc : editor.getSketch().getCode()) {\n        if (sc.isExtension(\"pde\")) {\n          int len;\n          if (editor.getSketch().getCurrentCode().equals(sc)) {\n            len = Util.countLines(sc.getDocumentText()) + 1;\n          } else {\n            len = Util.countLines(sc.getProgram()) + 1;\n          }\n\n          \/\/ log(\"x,len, CI: \" + x + \",\" + len + \",\"\n          \/\/ + codeIndex);\n\n          if (x >= len) {\n\n            \/\/ We're in the last tab and the line count is greater\n            \/\/ than the no.\n            \/\/ of lines in the tab,\n            if (codeIndex >= editor.getSketch().getCodeCount() - 1) {\n              \/\/ log(\"Exceeds lc \" + x + \",\" + len\n              \/\/ + problem.toString());\n              \/\/ x = len\n              x = editor.getSketch().getCode(codeIndex)\n                  .getLineCount();\n              \/\/ TODO: Obtain line having last non-white space\n              \/\/ character in the code.\n              break;\n            } else {\n              x -= len;\n              codeIndex++;\n            }\n          } else {\n\n            if (codeIndex >= editor.getSketch().getCodeCount()) {\n              codeIndex = editor.getSketch().getCodeCount() - 1;\n            }\n            break;\n          }\n\n        }\n      }\n    } catch (Exception e) {\n      System.err.println(\"Error inside ErrorCheckerService.JavaToPdeOffset()\");\n      e.printStackTrace();\n    }\n    return new int[] { codeIndex, x };\n  }\n","new_comment_raw":"Maps offset from java code to pde code.","old_comment_raw":"Maps offset from java code to pde code.","label":0,"pre_label":1,"AST_level":6,"line_counts":76,"new_code_token_num":484},{"new_code_raw":"public User getUserByName (String username) throws ApiException { Object postBody = null; byte[] postBinaryBody = null; \/\/ verify the required parameter 'username' is set if (username == null) { throw new ApiException(400, \"Missing the required parameter 'username' when calling getUserByName\"); } \/\/ create path and map variables String path = \"\/user\/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiClient.escapeString(username.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); final String[] accepts = { \"application\/json\", \"application\/xml\" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; TypeRef returnType = new TypeRef<User>() {}; return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"  public User getUserByName (String username) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'username' is set\n    if (username == null) {\n       throw new ApiException(400, \"Missing the required parameter 'username' when calling getUserByName\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/user\/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiClient.escapeString(username.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application\/json\", \"application\/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n    \n    TypeRef returnType = new TypeRef<User>() {};\n    return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    \n  }\n","new_comment_raw":"Get user by user name","old_comment_raw":"Get user by user name","label":0,"pre_label":1,"AST_level":9,"line_counts":48,"new_code_token_num":254},{"new_code_raw":"public boolean isSelected(final ToolItem toolItem) { boolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() { @Override public Boolean run() { return toolItem.getSelection(); } }); return selectionState; }","old_code_raw":"\tpublic boolean isSelected(final ToolItem w) {\n\t\tboolean selectionState = Display.syncExec(new ResultRunnable<Boolean>() {\n\t\t\t@Override\n\t\t\tpublic Boolean run() {\n\t\t\t\t\treturn w.getSelection(); \n\t\t\t}\n\t\t});\n\t\treturn selectionState;\n\t}\n","new_comment_raw":"Finds out whether specified  ToolItem is selected or not.","old_comment_raw":"Checks if toolitem is selected","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":42},{"new_code_raw":"private boolean getStatusBasedOnPos() { return getProgress() > 0.5f; }","old_code_raw":"    private boolean getStatusBasedOnPos() {\n        return getProcess() > 0.5f;\n    }\n","new_comment_raw":"return the status based on position of thumb","old_comment_raw":"return the status based on position of thumb","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) { \/\/ epoch is the fallback value return convertValue(column, fieldDefn, data, 0L, (r) -> { try { r.deliver(new java.util.Date(Timestamp.toEpochMillis(data, adjuster))); } catch (IllegalArgumentException e) { } }); }","old_code_raw":"    protected Object convertTimestampToEpochMillisAsDate(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return new java.util.Date(0L); \/\/ return epoch\n        }\n        try {\n            return new java.util.Date(Timestamp.toEpochMillis(data, adjuster));\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#TIMESTAMP to  java.util.Date values representing milliseconds past epoch.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#TIMESTAMP to java.util.Date values representing milliseconds past epoch.","label":0,"pre_label":1,"AST_level":12,"line_counts":10,"new_code_token_num":69},{"new_code_raw":"public String convert(Object object) { if (object == null) { return null; } try { JsonElement json = convertObject(object); return new GsonBuilder().serializeNulls().create().toJson(json); } catch (Exception e) { throw new WebDriverException(\"Unable to convert: \" + object, e); } }","old_code_raw":"  public String convert(Object object) {\n    if (object == null) {\n      return null;\n    }\n\n    try {\n      Object converted = convertObject(object, MAX_DEPTH);\n      if (converted instanceof JSONObject\n          || converted instanceof JSONArray\n          || converted instanceof String\n          || converted instanceof Number) {\n        return converted.toString();\n      }\n\n      return String.valueOf(object);\n    } catch (Exception e) {\n      throw new WebDriverException(\"Unable to convert: \" + object, e);\n    }\n  }\n","new_comment_raw":"Convert an object that may or may not be a JsonElement into its JSON string representation, handling the case where it is neither in a graceful way.","old_comment_raw":"Convert an object that may or may not be a JSONArray or JSONObject into its JSON string representation, handling the case where it is neither in a graceful way.","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":68},{"new_code_raw":"private static Provider getDefaultProvider() { \/\/ approach 1 try { String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\"); if (providerClass != null) { try { Provider provider = (Provider) Class.forName(providerClass).newInstance(); return validateProvider(provider); } catch (Exception ex) { throw new RuntimeException(ex); } } } catch (SecurityException ex) { \/\/ ignored } \/\/ approach 2 try { String dataFolder = System.getProperty(\"org.joda.time.DateTimeZone.Folder\"); if (dataFolder != null) { try { Provider provider = new ZoneInfoProvider(new File(dataFolder)); return validateProvider(provider); } catch (Exception ex) { throw new RuntimeException(ex); } } } catch (SecurityException ex) { \/\/ ignored } \/\/ approach 3 try { Provider provider = new ZoneInfoProvider(\"org\/joda\/time\/tz\/data\"); return validateProvider(provider); } catch (Exception ex) { ex.printStackTrace(); } \/\/ approach 4 return new UTCProvider(); }","old_code_raw":"    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            \/\/ ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org\/joda\/time\/tz\/data\");\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        } else {\n            validateProvider(provider);\n        }\n        return provider;\n    }\n","new_comment_raw":"Gets the default zone provider.","old_comment_raw":"Gets the default zone provider.","label":0,"pre_label":1,"AST_level":11,"line_counts":40,"new_code_token_num":211},{"new_code_raw":"public CyclicCoreLabel label() { return label; }","old_code_raw":"  public CoreLabel label() {\n    return label;\n  }\n","new_comment_raw":"Returns the label associated with the current node, or null if there is no label.","old_comment_raw":"Returns the label associated with the current node, or null if there is no label.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"@NonNull protected List<Action> retrieveActions(@NonNull SCMHead head, @NonNull SCMHeadEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }","old_code_raw":"    @NonNull\n    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull SCMHead head,\n                                                                   @NonNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return Collections.emptyMap();\n    }\n","new_comment_raw":"SPI for  #fetchActions(SCMHead, SCMHeadEvent, TaskListener).","old_comment_raw":"SPI for #fetchActions(SCMHead, TaskListener).","label":1,"pre_label":0,"AST_level":5,"line_counts":9,"new_code_token_num":34},{"new_code_raw":"public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) { if (allSchemas == null || allSchemas.isEmpty()) { \/\/ skip the warning as the spec can have no model defined \/\/LOGGER.warn(\"allSchemas cannot be null\/empty in unaliasSchema. Returned 'schema'\"); return schema; } if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) { Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())); if (ref == null) { LOGGER.warn(\"{} is not defined\", schema.get$ref()); return schema; } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) { \/\/ top-level enum class return schema; } else if (isFreeFormObject(ref)) { return schema; } else if (isArraySchema(ref) || isComposedSchema(ref)) { \/\/ array def should be created as models return schema; } else if (isMapSchema(ref)) { if (ref.getProperties() != null && !ref.getProperties().isEmpty()) \/\/ has properties return schema; \/\/ treat it as model else { \/\/ treat it as a typical map \/* TODO unalias the map item if it's an alias if (ref.getAdditionalProperties() != null) { Schema innerSchema = (Schema) ref.getAdditionalProperties(); if (StringUtils.isNotEmpty(innerSchema.get$ref())) { \/\/ map item is a ref to something else \/\/Schema unaliasInnerSchema = unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(innerSchema.get$ref()))); \/\/ref.setAdditionalProperties(unaliasInnerSchema); } }*\/ return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } else if (isObjectSchema(ref)) { \/\/ model return schema; } else { return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()))); } } return schema; }","old_code_raw":"    public static Schema unaliasSchema(Map<String, Schema> allSchemas, Schema schema) {\n        if (allSchemas == null || allSchemas.isEmpty()) {\n            LOGGER.warn(\"allSchemas cann't be null\/empty in unaliasSchema. Returned 'schema'\");\n            return schema;\n        }\n\n        if (schema != null && StringUtils.isNotEmpty(schema.get$ref())) {\n            Schema ref = allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref()));\n            if (ref == null) {\n                LOGGER.warn(\"{} is not defined\", schema.get$ref());\n                return schema;\n            } else if (ref.getEnum() != null && !ref.getEnum().isEmpty()) {\n                \/\/ top-level enum class\n                return schema;\n            } else if (isArraySchema(ref) || isComposedSchema(ref)) { \/\/ array def should be created as models\n                return schema;\n            } else if (isMapSchema(ref)) {\n                if (ref.getProperties() != null && !ref.getProperties().isEmpty()) \/\/ has properties\n                    return schema; \/\/ treat it as model\n                else {\n                    \/\/ treat it as a typical map\n                    \/* TODO unalias the map item if it's an alias\n                    if (ref.getAdditionalProperties() != null) {\n\n                        Schema innerSchema = (Schema) ref.getAdditionalProperties();\n                        if (StringUtils.isNotEmpty(innerSchema.get$ref())) { \/\/ map item is a ref to something else\n                            \/\/Schema unaliasInnerSchema = unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(innerSchema.get$ref())));\n                            \/\/ref.setAdditionalProperties(unaliasInnerSchema);\n                        }\n                    }*\/\n                    return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n                }\n            } else if (isObjectSchema(ref)) { \/\/ model\n                return schema;\n            } else {\n                return unaliasSchema(allSchemas, allSchemas.get(ModelUtils.getSimpleRef(schema.get$ref())));\n            }\n        }\n        return schema;\n    }\n","new_comment_raw":"Get the actual schema from aliases.","old_comment_raw":"Get the actual schema from aliases.","label":0,"pre_label":1,"AST_level":17,"line_counts":44,"new_code_token_num":415},{"new_code_raw":"public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) { return appendDecimal(iChronoUTC.minuteOfDay(), minDigits, 4); }","old_code_raw":"    public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {\n        return appendNumeric(iChronoUTC.minuteOfDay(), minDigits, 4);\n    }\n","new_comment_raw":"Instructs the printer to emit a numeric minuteOfDay field.","old_comment_raw":"Instructs the printer to emit a numeric minuteOfDay field.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean matches( Method method, Class targetClass) { return ( (method.getAnnotation( RequiresPermissions.class ) != null ) || (method.getAnnotation( RequiresRoles.class ) != null ) ); }","old_code_raw":"    public boolean matches( Method method, Class targetClass) {\n        return ( (method.getAnnotation( PermissionsRequired.class ) != null ) ||\n                 (method.getAnnotation( RolesRequired.class ) != null ) );\n    }\n","new_comment_raw":"Returns true if the method has a JSecurity RequiresRoles or RequiresPermissions annotation, false otherwise.","old_comment_raw":"Returns true if the method has a JSecurity RolesRequired or PermissionsRequired annotation, false otherwise.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":38},{"new_code_raw":"public static EBoolean contains(Expr<String> left, String right) { return factory.createBoolean(Ops.CONTAINS, left, factory.createConstant(right)); }","old_code_raw":"    public static EBoolean contains(Expr<String> left, String right) {\n        return createBoolean(Ops.CONTAINS, left, createConstant(right));\n    }\n","new_comment_raw":"Expr : left || right","old_comment_raw":"Expr : left || right","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public boolean isEmpty() { return propertyPathsByTransientEntity == null || propertyPathsByTransientEntity.isEmpty(); }","old_code_raw":"\tpublic boolean isEmpty() {\n\t\treturn propertyPathsByTransientEntity.isEmpty();\n\t}\n","new_comment_raw":"Are there any paths currently tracked here?","old_comment_raw":"Are there any paths currently tracked here?","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public static Map<String, String> getProperties(Object object) throws Exception { if (object == null) { return Collections.emptyMap(); } Map<String, String> props = new LinkedHashMap<String, String>(); BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass()); Object[] NULL_ARG = {}; PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); if (propertyDescriptors != null) { for (int i = 0; i < propertyDescriptors.length; i++) { PropertyDescriptor pd = propertyDescriptors[i]; if (pd.getReadMethod() != null && !pd.getName().equals(\"class\") && !pd.getName().equals(\"properties\") && !pd.getName().equals(\"reference\")) { Object value = pd.getReadMethod().invoke(object, NULL_ARG); if (value != null) { if (value instanceof Boolean || value instanceof Number || value instanceof String || value instanceof URI || value instanceof URL) { props.put(pd.getName(), (\"\" + value)); } else if (value instanceof SSLContext) { \/\/ ignore this one.. } else { Map<String, String> inner = getProperties(value); for (Map.Entry<String, String> entry : inner.entrySet()) { props.put(pd.getName() + \".\" + entry.getKey(), entry.getValue()); } } } } } } return props; }","old_code_raw":"    public static Map<String, String> getProperties(Object object) throws Exception {\n        Map<String, String> props = new LinkedHashMap<String, String>();\n        BeanInfo beanInfo = Introspector.getBeanInfo(object.getClass());\n        Object[] NULL_ARG = {};\n        PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();\n        if (propertyDescriptors != null) {\n            for (int i = 0; i < propertyDescriptors.length; i++) {\n                PropertyDescriptor pd = propertyDescriptors[i];\n                if (pd.getReadMethod() != null && !pd.getName().equals(\"class\") && !pd.getName().equals(\"properties\") && !pd.getName().equals(\"reference\")) {\n                    Object value = pd.getReadMethod().invoke(object, NULL_ARG);\n                    if (value != null) {\n                        if (value instanceof Boolean || value instanceof Number || value instanceof String || value instanceof URI || value instanceof URL) {\n                            props.put(pd.getName(), (\"\" + value));\n                        } else if (value instanceof SSLContext) {\n                            \/\/ ignore this one..\n                        } else {\n                            Map<String, String> inner = getProperties(value);\n                            for (Map.Entry<String, String> entry : inner.entrySet()) {\n                                props.put(pd.getName() + \".\" + entry.getKey(), entry.getValue());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return props;\n    }\n","new_comment_raw":"Get properties from an object using reflection.","old_comment_raw":"Get properties from an object","label":1,"pre_label":0,"AST_level":20,"line_counts":33,"new_code_token_num":282},{"new_code_raw":"public Iterator getPorts() throws ServiceException { if (wsdlService == null || wsdlService.getPorts() == null){ \/\/ Return an empty iterator; return new Vector().iterator(); } return wsdlService.getPorts().keySet().iterator(); }","old_code_raw":"    public Iterator getPorts() throws ServiceException {\n        if (wsdlService == null || wsdlService.getPorts() == null){\n            \/\/ Return an empty iterator;\n            return new Vector().iterator();\n        }\n        return wsdlService.getPorts().values().iterator();\n    }\n","new_comment_raw":"Returns an Iterator for the list of QNames of service endpoints grouped by this service","old_comment_raw":"Returns an Iterator that can be used to get all of the ports specified in the WSDL file associated with this Service (if there is a WSDL file).","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":51},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); if (DEBUG) { System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(\"target\")) continue; System.err.println(\" node \" + nodeName + \": \" + m.getNode(nodeName)); } } } } return nodeList; }","old_code_raw":"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"Given a Tree node t, attempts to return a list of nodes to which node t has this grammatical relation.","old_comment_raw":"Given a Tree node t, attempts to return a list of nodes to which node t has this grammatical relation, with t as the governor.","label":1,"pre_label":0,"AST_level":18,"line_counts":22,"new_code_token_num":200},{"new_code_raw":"@Override public String toString() { return \"[\" + name + \" \" + state + \"]\"; }","old_code_raw":"\t@Override\n\tpublic String toString() {\n\t\treturn \"[\" + name + \" \" + state + \"\/stats=\" + getStatProcessor().getType() + \"]\";\n\t}\n","new_comment_raw":"Returns name and state of the Simon as a human readable string.","old_comment_raw":"Returns name, state and stats of the Simon as a human readable string.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":25},{"new_code_raw":"public static DateTimeFormatter basicTime() { return Constants.bt; }","old_code_raw":"    public static DateTimeFormatter basicTime() {\n        if (bt == null) {\n            bt = new DateTimeFormatterBuilder()\n                .appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2)\n                .appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2)\n                .appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2)\n                .appendLiteral('.')\n                .appendFractionOfSecond(3, 9)\n                .appendTimeZoneOffset(\"Z\", false, 2, 2)\n                .toFormatter();\n        }\n        return bt;\n    }\n","new_comment_raw":"Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone offset (HHmmss.SSSZ).","old_comment_raw":"Returns a basic formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit millis, and time zone offset (HHmmss.SSSZ).","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public Action cancelled(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { synchronized (req) { SessionTimeoutSupport.restoreTimeout(req); AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) req.getAttribute(MAX_INACTIVE); if (l == -1) { \/\/ The closedDetector closed the connection. return timedoutAction; } req.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(\"Cancelling the connection for request {}\", req); r = (AtmosphereResourceImpl) req.resource(); if (r != null) { r.getAtmosphereResourceEvent().setCancelled(true); invokeAtmosphereHandler(r); try { r.getResponse().getOutputStream().close(); } catch (Throwable t) { try { r.getResponse().getWriter().close(); } catch (Throwable t2) { } } } } catch (Throwable ex) { \/\/ Something wrong happenned, ignore the exception logger.debug(\"failed to cancel resource: \" + r, ex); } finally { config.framework().notify(Action.TYPE.CANCELLED, req, res); try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(\"cancel\", t); } finally { if (r != null) { destroyResource(r); } } } } return cancelledAction; }","old_code_raw":"    public Action cancelled(AtmosphereRequest req, AtmosphereResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            SessionTimeoutSupport.restoreTimeout(req);\n\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    try {\n                        long l = (Long) req.getAttribute(MAX_INACTIVE);\n                        if (l == -1) {\n                            \/\/ The closedDetector closed the connection.\n                            return timedoutAction;\n                        }\n                        req.setAttribute(MAX_INACTIVE, (long) -1);\n                        \/\/ GlassFish\n                    } catch (NullPointerException ex) {\n                        \/\/ Request is no longer active, return\n                        return cancelledAction;\n\n                    }\n                }\n\n                r = (AtmosphereResourceImpl) req.resource();\n                if (r != null) {\n                    logger.debug(\"Cancelling the connection for AtmosphereResource {}\", r.uuid());\n\n                    if (r.isCancelled()) {\n                        logger.trace(\"{} is already cancelled\", r.uuid());\n                        return cancelledAction;\n                    }\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }  else {\n                    logger.debug(\"AtmosphereResource was null, failed to cancel AtmosphereRequest {}\", req);\n                }\n            } catch (Throwable ex) {\n                \/\/ Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: {}\", r == null ? \"\" : r.uuid() , ex);\n            } finally {\n                config.framework().notify(Action.TYPE.CANCELLED, req, res);\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.debug(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        r._destroy();\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    }\n","new_comment_raw":"All proprietary Comet based  Servlet must invoke the cancelled method when the underlying WebServer detect that the client closed the connection.","old_comment_raw":"All proprietary Comet based Servlet must invoke the cancelled method when the underlying WebServer detect that the client closed the connection.","label":0,"pre_label":1,"AST_level":12,"line_counts":57,"new_code_token_num":284},{"new_code_raw":"public InstantConverter removeInstantConverter(InstantConverter converter) throws SecurityException { checkAlterInstantConverters(); if (converter == null) { return null; } InstantConverter[] removed = new InstantConverter[1]; iInstantConverters = iInstantConverters.remove(converter, removed); return removed[0]; }","old_code_raw":"    public InstantConverter removeInstantConverter(int index) throws SecurityException {\n        checkAlterInstantConverters();\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(index, removed);\n        return removed[0];\n    }\n","new_comment_raw":"Removes a converter from the set of converters.","old_comment_raw":"Removes a converter from the set of converters, by index.","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":50},{"new_code_raw":"public static Schema getKeyWriterSchema(Configuration conf) { String json = conf.get(CONF_KEY_WRITER_SCHEMA); return null == json ? null : new Schema.Parser().parse(json); }","old_code_raw":"  public static Schema getKeyWriterSchema(Configuration conf) {\n    String json = conf.get(CONF_KEY_WRITER_SCHEMA);\n    return null == json ? null : Schema.parse(json);\n  }\n","new_comment_raw":"Gets the writer schema of the AvroKey datum that is being serialized\/deserialized.","old_comment_raw":"Gets the writer schema of the AvroKey datum that is being serialized\/deserialized.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":34},{"new_code_raw":"static boolean observe( @Nullable final Object object ) { return !( object instanceof ComponentObservable ) || asComponentObservable( object ).observe(); }","old_code_raw":"  static boolean observe( @Nonnull final Object object )\n  {\n    return asComponentObservable( object ).observe();\n  }\n","new_comment_raw":"Invoke  #observe() on the supplied object if any.","old_comment_raw":"Invoke #observe() on the supplied object.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":29},{"new_code_raw":"public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling uploadFile\", new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\")); } \/\/ create path and map variables String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"multipart\/form-data\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { localVarBuilder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { localVarBuilder.addBinaryBody(\"file\", file); } HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata)); } String[] authNames = new String[] { \"petstore_auth\" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return (ApiResponse) ApiInvoker.deserialize(localVarResponse, \"\", ApiResponse.class); } else { return null; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling uploadFile\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"multipart\/form-data\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (additionalMetadata != null) {\n        localVarBuilder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (file != null) {\n        localVarBuilder.addBinaryBody(\"file\", file);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n       if (ex.getCause() instanceof VolleyError) {\n         VolleyError volleyError = (VolleyError)ex.getCause();\n         if (volleyError.networkResponse != null) {\n           throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n         }\n       }\n       throw ex;\n    } catch (TimeoutException ex) {\n       throw ex;\n    }\n  }\n","new_comment_raw":"uploads an image","old_comment_raw":"uploads an image","label":0,"pre_label":1,"AST_level":11,"line_counts":64,"new_code_token_num":467},{"new_code_raw":"private boolean propertyHasBreakingCharacters(String str) { final String regex = \"^.*[+*:;,.()-]+.*$\"; final Pattern pattern = Pattern.compile(regex); final Matcher matcher = pattern.matcher(str); return matcher.matches(); }","old_code_raw":"    private boolean propertyHasBreakingCharacters(String str) {\n        final String regex = \"^.*[+*:;,.()-]+.*$\";\n        final Pattern pattern = Pattern.compile(regex);\n        final Matcher matcher = pattern.matcher(str);\n        boolean matches = matcher.matches();\n        return matches;\n    }\n","new_comment_raw":"Checks whether property names have breaking characters like ':', '-'.","old_comment_raw":"Checks whether property names have breaking characters like ':', '-'.","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"public SequenceService createSequenceService() { return createSequenceService(defaultEndpointUrl); }","old_code_raw":"    public SequenceService createSequenceService() {\n        return createSequenceService(defaultServerUrl);\n    }\n","new_comment_raw":"Create and return a new sequence service with the default endpoint URL.","old_comment_raw":"Create and return a new sequence service with the default server URL.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"public Reader getReader() { debug(\"\\nContents: \" + this.contentsBuffer.toString()); return new StringReader(this.contentsBuffer.toString()); }","old_code_raw":"    public Reader getReader() {\n        debug(\"\\nContents: \" + contentsBuffer.toString());\n\n        return new StringReader(contentsBuffer.toString());\n    }\n","new_comment_raw":"Obtain the reader","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":33},{"new_code_raw":"public Remote getPort(QName portName, Class proxyInterface) throws ServiceException { \/\/ First, try to find a generated stub. If that \/\/ returns null, then find a dynamic stub. Remote stub = getGeneratedStub(portName, proxyInterface); return stub != null ? stub : getPort(null, portName, proxyInterface); }","old_code_raw":"    public Remote getPort(QName portName, Class proxyInterface)\n                           throws ServiceException {\n        return getPort(null, portName, proxyInterface);\n    }\n","new_comment_raw":"Return either an instance of a generated stub, if it can be found, or a dynamic proxy for the given proxy interface.","old_comment_raw":"Not implemented yet","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":61},{"new_code_raw":"static public StringList packageListFromClassPath(String path) { \/\/ Map<String, Object> map = new HashMap<String, Object>(); StringList list = new StringList(); String pieces[] = PApplet.split(path, File.pathSeparatorChar); for (int i = 0; i < pieces.length; i++) { \/\/System.out.println(\"checking piece '\" + pieces[i] + \"'\"); if (pieces[i].length() == 0) continue; if (pieces[i].toLowerCase().endsWith(\".jar\") || pieces[i].toLowerCase().endsWith(\".zip\")) { \/\/System.out.println(\"checking \" + pieces[i]); packageListFromZip(pieces[i], list); } else { \/\/ it's another type of file or directory File dir = new File(pieces[i]); if (dir.exists() && dir.isDirectory()) { packageListFromFolder(dir, null, list); \/\/importCount = magicImportsRecursive(dir, null, \/\/ map); \/\/imports, importCount); } } } \/\/ int mapCount = map.size(); \/\/ String output[] = new String[mapCount]; \/\/ int index = 0; \/\/ Set<String> set = map.keySet(); \/\/ for (String s : set) { \/\/ output[index++] = s.replace('\/', '.'); \/\/ } \/\/ return output; StringList outgoing = new StringList(list.size()); for (String item : list) { outgoing.append(item.replace('\/', '.')); } return outgoing; }","old_code_raw":"  static public String[] packageListFromClassPath(String path) {\n    Map<String, Object> map = new HashMap<String, Object>();\n    String pieces[] =\n      PApplet.split(path, File.pathSeparatorChar);\n\n    for (int i = 0; i < pieces.length; i++) {\n      \/\/System.out.println(\"checking piece '\" + pieces[i] + \"'\");\n      if (pieces[i].length() == 0) continue;\n\n      if (pieces[i].toLowerCase().endsWith(\".jar\") ||\n          pieces[i].toLowerCase().endsWith(\".zip\")) {\n        \/\/System.out.println(\"checking \" + pieces[i]);\n        packageListFromZip(pieces[i], map);\n\n      } else {  \/\/ it's another type of file or directory\n        File dir = new File(pieces[i]);\n        if (dir.exists() && dir.isDirectory()) {\n          packageListFromFolder(dir, null, map);\n          \/\/importCount = magicImportsRecursive(dir, null,\n          \/\/                                  map);\n                                              \/\/imports, importCount);\n        }\n      }\n    }\n    int mapCount = map.size();\n    String output[] = new String[mapCount];\n    int index = 0;\n    Set<String> set = map.keySet();\n    for (String s : set) {\n      output[index++] = s.replace('\/', '.');\n    }\n    \/\/System.arraycopy(imports, 0, output, 0, importCount);\n    \/\/PApplet.printarr(output);\n    return output;\n  }\n","new_comment_raw":"A classpath, separated by the path separator, will contain a series of .jar\/.zip files or directories containing .class files, or containing subdirectories that have .class files.","old_comment_raw":"A classpath, separated by the path separator, will contain a series of .jar\/.zip files or directories containing .class files, or containing subdirectories that have .class files.","label":0,"pre_label":1,"AST_level":12,"line_counts":40,"new_code_token_num":337},{"new_code_raw":"private boolean nonValueAnno(AnnotatedTypeMirror mirror) { return AnnotationUtils.areSameIgnoringValues( getValueAnnotation(mirror), UNKNOWNVAL) || AnnotationUtils .areSameIgnoringValues( mirror.getAnnotationInHierarchy(ARRAYLEN), ARRAYLEN); }","old_code_raw":"        private boolean nonValueAnno(AnnotatedTypeMirror mirror) {\n            AnnotationMirror valueAnno = getValueAnnotation(mirror);\n            return AnnotationUtils.areSameIgnoringValues(valueAnno, UNKNOWNVAL)\n                    || AnnotationUtils.areSameByClass(valueAnno,\n                            BottomVal.class)\n                    || AnnotationUtils\n                            .areSameIgnoringValues(\n                                    mirror.getAnnotationInHierarchy(ARRAYLEN),\n                                    ARRAYLEN);\n        }\n","new_comment_raw":"To make these numerous calls to check if an annotation is UnknownVal or ArrayLen a little nicer looking","old_comment_raw":"Check that the annotation in the Value Checker hierarchy has a value of some kind.","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":34},{"new_code_raw":"public BaseSliderView getCurrentSlider(){ if(getRealAdapter() == null) throw new IllegalStateException(\"You did not set a slider adapter\"); int count = getRealAdapter().getCount(); int realCount = mViewPager.getCurrentItem() % count; return getRealAdapter().getSliderView(realCount); }","old_code_raw":"    public BaseSliderView getCurrentSlider(){\n\n        if(getRealAdapter() == null)\n            return null;\n\n        int count = getRealAdapter().getCount();\n        int realCount = mViewPager.getCurrentItem() % count;\n        return  getRealAdapter().getSliderView(realCount);\n    }\n","new_comment_raw":"get current slider.","old_comment_raw":"get current slider.","label":0,"pre_label":1,"AST_level":6,"line_counts":10,"new_code_token_num":56},{"new_code_raw":"public float getX() { if(left == null) { calculateLeft(); } return left.floatValue(); }","old_code_raw":"    public float getX() {\r\n        return center[0];\r\n    }\r\n","new_comment_raw":"Get the x location of the left side of this shape.","old_comment_raw":"Get the x location of the center of this circle","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":24},{"new_code_raw":"public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException { SqlDropTable dropTableNode = ((SqlDropTable) sqlNode); SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier(); SchemaPlus defaultSchema = config.getConverter().getDefaultSchema(); AbstractSchema drillSchema = null; if (tableIdentifier != null) { drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema()); } String tableName = dropTableNode.getName(); if (drillSchema == null) { throw UserException.validationError() .message(\"Invalid table_name [%s]\", tableName) .build(logger); } if (dropTableNode.checkTableExistence()) { final Table tableToDrop = SqlHandlerUtil.getTableFromSchema(drillSchema, tableName); if (tableToDrop == null || tableToDrop.getJdbcTableType() != Schema.TableType.TABLE) { return DirectPlan.createDirectPlan(context, true, String.format(\"Table [%s] not found\", tableName)); } } drillSchema.dropTable(tableName); return DirectPlan.createDirectPlan(context, true, String.format(\"Table [%s] %s\", tableName, \"dropped\")); }","old_code_raw":"  public PhysicalPlan getPlan(SqlNode sqlNode) throws ValidationException, RelConversionException, IOException {\n\n    SqlDropTable dropTableNode = ((SqlDropTable) sqlNode);\n    SqlIdentifier tableIdentifier = dropTableNode.getTableIdentifier();\n\n    SchemaPlus defaultSchema = config.getConverter().getDefaultSchema();\n    AbstractSchema drillSchema = null;\n\n    if (tableIdentifier != null) {\n      drillSchema = SchemaUtilites.resolveToMutableDrillSchema(defaultSchema, dropTableNode.getSchema());\n    }\n\n    String tableName = ((SqlDropTable) sqlNode).getName();\n    if (drillSchema == null) {\n      throw UserException.validationError()\n          .message(\"Invalid table_name [%s]\", tableName)\n          .build(logger);\n    }\n\n    drillSchema.dropTable(tableName);\n\n    return DirectPlan.createDirectPlan(context, true,\n        String.format(\"Table [%s] %s\", tableName, \"dropped\"));\n  }\n","new_comment_raw":"Function resolves the schema and invokes the drop method (while IF EXISTS statement is used function invokes the drop method only if table exists).","old_comment_raw":"Function resolves the schema and invokes the drop method.","label":1,"pre_label":0,"AST_level":10,"line_counts":33,"new_code_token_num":199},{"new_code_raw":"public char get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public char get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.","old_comment_raw":"Analogous to #get(WithAttributes) except returning a primitive char.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public RelOptTable getTableOrigin(RelNode rel) { \/\/ Determine the simple origin of the first column in the \/\/ RelNode. If it's simple, then that means that the underlying \/\/ table is also simple, even if the column itself is derived. if (rel.getRowType().getFieldCount() == 0) { return null; } final Set<RelColumnOrigin> colOrigins = getColumnOrigins(rel, 0); if (colOrigins == null || colOrigins.size() == 0) { return null; } return colOrigins.iterator().next().getOriginTable(); }","old_code_raw":"  public RelOptTable getTableOrigin(RelNode rel) {\n    \/\/ Determine the simple origin of the first column in the\n    \/\/ RelNode.  If it's simple, then that means that the underlying\n    \/\/ table is also simple, even if the column itself is derived.\n    final Set<RelColumnOrigin> colOrigins = getColumnOrigins(rel, 0);\n    if (colOrigins == null || colOrigins.size() == 0) {\n      return null;\n    }\n    return colOrigins.iterator().next().getOriginTable();\n  }\n","new_comment_raw":"Determines the origin of a  RelNode, provided it maps to a single table, optionally with filtering and projection.","old_comment_raw":"Determines the origin of a RelNode, provided it maps to a single table, optionally with filtering and projection.","label":0,"pre_label":1,"AST_level":6,"line_counts":14,"new_code_token_num":106},{"new_code_raw":"public static String launchProcess(final String command, final Map<String, String> environment, boolean backend) throws IOException { String[] cmds = command.split(\" \"); ArrayList<String> cmdList = new ArrayList<String>(); for (String tok : cmds) { if (!StringUtils.isBlank(tok)) { cmdList.add(tok); } } return launchProcess(command, cmdList, environment, backend); }","old_code_raw":"    public static ByteArrayOutputStream launchProcess(String command, final Map environment, final String workDir, ExecuteResultHandler resultHandler)\n            throws IOException {\n\n        String[] cmdlist = command.split(\" \");\n\n        CommandLine cmd = new CommandLine(cmdlist[0]);\n        for (String cmdItem : cmdlist) {\n            if (StringUtils.isBlank(cmdItem) == false) {\n                cmd.addArgument(cmdItem);\n            }\n        }\n\n        DefaultExecutor executor = new DefaultExecutor();\n\n        executor.setExitValue(0);\n        if (StringUtils.isBlank(workDir) == false) {\n            executor.setWorkingDirectory(new File(workDir));\n        }\n\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        PumpStreamHandler streamHandler = new PumpStreamHandler(out, out);\n        if (streamHandler != null) {\n            executor.setStreamHandler(streamHandler);\n        }\n\n        try {\n            if (resultHandler == null) {\n                executor.execute(cmd, environment);\n            } else {\n                executor.execute(cmd, environment, resultHandler);\n            }\n        } catch (ExecuteException e) {\n\n            \/\/ @@@@\n            \/\/ failed to run command\n        }\n\n        return out;\n\n    }\n","new_comment_raw":"Attention","old_comment_raw":"If it is backend, please set resultHandler, such as DefaultExecuteResultHandler If it is frontend, ByteArrayOutputStream.toString get the result","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":81},{"new_code_raw":"private Type buildAttributeConverterTypeAdapter() { \/\/ todo : validate the number of columns present here? final Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType(); final Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType(); \/\/ resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \/\/ For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of \/\/ the AttributeConverter to resolve the corresponding descriptor. final JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType ); \/\/ build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \/\/ Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String \/\/ conversions. This is the more complicated piece. First we need to determine the JDBC type code \/\/ corresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out \/\/ of ResultSets). See JdbcTypeJavaClassMappings for details. Again, given example, this should return \/\/ VARCHAR\/CHAR final int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType ); \/\/ find the standard SqlTypeDescriptor for that JDBC type code. final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode ); \/\/ find the JavaTypeDescriptor representing the \"intermediate database type representation\". Back to the \/\/ illustration, this should be the type descriptor for Strings final JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType ); \/\/ and finally construct the adapter, which injects the AttributeConverter calls into the binding\/extraction \/\/ process... final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter( jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptor, intermediateJavaTypeDescriptor ); \/\/ todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times. final String name = String.format( \"BasicType adapter for AttributeConverter<%s,%s>\", entityAttributeJavaType.getSimpleName(), databaseColumnJavaType.getSimpleName() ); return new AttributeConverterTypeAdapter( name, jpaAttributeConverterDefinition.getAttributeConverter(), sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor ); }","old_code_raw":"\tprivate Type buildAttributeConverterTypeAdapter() {\n\t\t\/\/ todo : validate the number of columns present here?\n\n\t\tfinal Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();\n\t\tfinal Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();\n\n\n\t\t\/\/ resolve the JavaTypeDescriptor ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t\/\/ For the JavaTypeDescriptor portion we simply resolve the \"entity attribute representation\" part of\n\t\t\/\/ the AttributeConverter to resolve the corresponding descriptor.\n\t\tfinal JavaTypeDescriptor entityAttributeJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );\n\n\n\t\t\/\/ build the SqlTypeDescriptor adapter ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t\t\/\/ Going back to the illustration, this should be a SqlTypeDescriptor that handles the Integer <-> String\n\t\t\/\/\t\tconversions.  This is the more complicated piece.  First we need to determine the JDBC type code\n\t\t\/\/\t\tcorresponding to the AttributeConverter's declared \"databaseColumnJavaType\" (how we read that value out\n\t\t\/\/ \t\tof ResultSets).  See JdbcTypeJavaClassMappings for details.  Again, given example, this should return\n\t\t\/\/ \t\tVARCHAR\/CHAR\n\t\tfinal int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );\n\t\t\/\/ find the standard SqlTypeDescriptor for that JDBC type code.\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );\n\t\t\/\/ find the JavaTypeDescriptor representing the \"intermediate database type representation\".  Back to the\n\t\t\/\/ \t\tillustration, this should be the type descriptor for Strings\n\t\tfinal JavaTypeDescriptor intermediateJavaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( databaseColumnJavaType );\n\t\t\/\/ and finally construct the adapter, which injects the AttributeConverter calls into the binding\/extraction\n\t\t\/\/ \t\tprocess...\n\t\tfinal SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(\n\t\t\t\tjpaAttributeConverterDefinition.getAttributeConverter(),\n\t\t\t\tsqlTypeDescriptor,\n\t\t\t\tintermediateJavaTypeDescriptor\n\t\t);\n\n\t\t\/\/ todo : cache the AttributeConverterTypeAdapter in case that AttributeConverter is applied multiple times.\n\n\t\tfinal String name = \"BasicType adapter for AttributeConverter<\" + entityAttributeJavaType + \",\" + databaseColumnJavaType + \">\";\n\t\treturn new AttributeConverterTypeAdapter( sqlTypeDescriptorAdapter, entityAttributeJavaTypeDescriptor, name );\n\t}\n","new_comment_raw":"Build a Hibernate Type that incorporates the JPA AttributeConverter.","old_comment_raw":"Build a Hibernate Type that incorporates the JPA AttributeConverter.","label":0,"pre_label":1,"AST_level":6,"line_counts":48,"new_code_token_num":326},{"new_code_raw":"private static int getMaxOrLimit(final RowSelection selection, final Dialect dialect) { final int firstRow = dialect.convertToFirstRowValue( getFirstRow( selection ) ); final int lastRow = selection.getMaxRows(); return dialect.useMaxForLimit() ? lastRow + firstRow : lastRow; }","old_code_raw":"\tprivate static int getMaxOrLimit(final RowSelection selection, final Dialect dialect) {\n\t\tfinal int firstRow = dialect.convertToFirstRowValue( getFirstRow( selection ) );\n\t\tfinal int lastRow = selection.getMaxRows().intValue();\n\t\tif ( dialect.useMaxForLimit() ) {\n\t\t\treturn lastRow + firstRow;\n\t\t}\n\t\telse {\n\t\t\treturn lastRow;\n\t\t}\n\t}\n","new_comment_raw":"Some dialect-specific LIMIT clauses require the maximum last row number (aka, first_row_number + total_row_count), while others require the maximum returned row count (the total maximum number of rows to return).","old_comment_raw":"Some dialect-specific LIMIT clauses require the maximum last row number (aka, first_row_number + total_row_count), while others require the maximum returned row count (the total maximum number of rows to return).","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":47},{"new_code_raw":"public int toStatusCode(Throwable thrown) { if (thrown == null) { return SUCCESS; } else if (thrown instanceof InvalidCookieDomainException) { return INVALID_COOKIE_DOMAIN; } else if (thrown instanceof UnableToSetCookieException) { return UNABLE_TO_SET_COOKIE; } else if (thrown instanceof NoSuchWindowException) { return NO_SUCH_WINDOW; } else if (thrown instanceof InvalidSelectorException) { return INVALID_SELECTOR_ERROR; } else if (thrown instanceof NoSuchElementException) { return NO_SUCH_ELEMENT; } else if (thrown instanceof NoSuchFrameException) { return NO_SUCH_FRAME; } else if (thrown instanceof StaleElementReferenceException) { return STALE_ELEMENT_REFERENCE; } else if (thrown instanceof ElementNotVisibleException) { return ELEMENT_NOT_VISIBLE; } else if (thrown instanceof InvalidElementStateException) { return INVALID_ELEMENT_STATE; } else if (thrown instanceof XPathLookupException) { return XPATH_LOOKUP_ERROR; } else if (thrown instanceof TimeoutException) { return ASYNC_SCRIPT_TIMEOUT; } else if (thrown instanceof InvalidCoordinatesException) { return INVALID_ELEMENT_COORDINATES; } else if (thrown instanceof ImeNotAvailableException) { return IME_NOT_AVAILABLE; } else if (thrown instanceof ImeActivationFailedException) { return IME_ENGINE_ACTIVATION_FAILED; } else if (thrown instanceof NoAlertPresentException) { return NO_ALERT_PRESENT; } else if (thrown instanceof MoveTargetOutOfBoundsException) { return MOVE_TARGET_OUT_OF_BOUNDS; } else { return UNHANDLED_ERROR; } }","old_code_raw":"  public int toStatusCode(Throwable thrown) {\n    if (thrown == null) {\n      return SUCCESS;\n    } else if (thrown instanceof InvalidCookieDomainException) {\n      return INVALID_COOKIE_DOMAIN;\n    } else if (thrown instanceof UnableToSetCookieException) {\n      return UNABLE_TO_SET_COOKIE;\n    } else if (thrown instanceof NoSuchWindowException) {\n      return NO_SUCH_WINDOW;\n    } else if (thrown instanceof InvalidSelectorException) {\n      return INVALID_SELECTOR_ERROR;\n    } else if (thrown instanceof NoSuchElementException) {\n      return NO_SUCH_ELEMENT;\n    } else if (thrown instanceof NoSuchFrameException) {\n      return NO_SUCH_FRAME;\n    } else if (thrown instanceof StaleElementReferenceException) {\n      return STALE_ELEMENT_REFERENCE;\n    } else if (thrown instanceof ElementNotVisibleException) {\n      return ELEMENT_NOT_VISIBLE;\n    } else if (thrown instanceof InvalidElementStateException) {\n      return INVALID_ELEMENT_STATE;\n    } else if (thrown instanceof XPathLookupException) {\n      return XPATH_LOOKUP_ERROR;\n    } else if (thrown instanceof TimeoutException) {\n      return ASYNC_SCRIPT_TIMEOUT;\n    } else if (thrown instanceof InvalidCoordinatesException) {\n      return INVALID_ELEMENT_COORDINATES;\n    } else if (thrown instanceof ImeNotAvailableException) {\n      return IME_NOT_AVAILABLE;\n    } else if (thrown instanceof ImeActivationFailedException) {\n      return IME_ENGINE_ACTIVATION_FAILED;\n    } else if (thrown instanceof NoAlertPresentException) {\n      return NO_ALERT_PRESENT;\n    } else {\n      return UNHANDLED_ERROR;\n    }\n  }\n","new_comment_raw":"Converts a thrown error into the corresponding status code.","old_comment_raw":"Converts a thrown error into the corresponding status code.","label":0,"pre_label":1,"AST_level":22,"line_counts":40,"new_code_token_num":217},{"new_code_raw":"public Tuplizer getTuplizerOrNull(EntityMode entityMode) { return tuplizers.get( entityMode ); }","old_code_raw":"\tpublic Tuplizer getTuplizerOrNull(EntityMode entityMode) {\n\t\treturn ( Tuplizer ) tuplizers.get( entityMode );\n\t}\n","new_comment_raw":"Locate the contained tuplizer responsible for the given entity-mode.","old_comment_raw":"Locate the contained tuplizer responsible for the given entity-mode.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public Future<Map<String, Object>> asyncGetBulk(String... keys) { return asyncGetBulk(Arrays.asList(keys)); }","old_code_raw":"\tpublic Future<Map<String, Object>> asyncGetBulk(Collection<String> keys) {\n\t\treturn asyncGetBulk(keys, transcoder);\n\t}\n","new_comment_raw":"Varargs wrapper for asynchronous bulk gets.","old_comment_raw":"Asynchronously get a bunch of objects from the cache and decode them with the given transcoder.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":23},{"new_code_raw":"private String generateMessage(boolean includeErrorIdAndIdentity) { return errorType + \" ERROR: \" + super.getMessage() + \"\\n\\n\" + context.generateContextMessage(includeErrorIdAndIdentity); }","old_code_raw":"  private String generateMessage() {\n    return errorType + \" ERROR: \" + super.getMessage() + \"\\n\\n\" +\n      context.generateContextMessage();\n  }\n","new_comment_raw":"Generates a user error message that has the following structure:","old_comment_raw":"Generates a user error message that has the following structure:","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public <RX extends RxInvokerProvider> Client buildRx(String name, Class<RX> invokerType) { return build(name).register(invokerType); }","old_code_raw":"    public <RX extends RxInvoker> RxClient<RX> buildRx(String name, Class<RX> invokerType) {\n        return Rx.from(build(name), invokerType, executorService);\n    }\n","new_comment_raw":"Builds the  Client instance with a custom reactive client provider.","old_comment_raw":"Builds the RxClient instance.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":26},{"new_code_raw":"public Set<Warning> getWarnings() { return Collections.unmodifiableSet(project.getWarnings(packageName)); }","old_code_raw":"    public Collection<Warning> getWarnings() {\n        return project.getWarnings(packageName);\n    }\n","new_comment_raw":"Returns all warnings for this package details view.","old_comment_raw":"Returns all the warnings in this package.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"@SuppressWarnings(\"unchecked\") protected Class[] getClassContext() { return VMStack.getClasses(-1, false); }","old_code_raw":"    @SuppressWarnings(\"unchecked\")\n    protected Class[] getClassContext() {\n        return Class.getStackClasses(-1, false);\n    }\n","new_comment_raw":"Returns an array containing one entry for each method in the current execution stack.","old_comment_raw":"Returns an array containing one entry for each method in the stack.","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":26},{"new_code_raw":"public TregexMatcher matcher(Tree t) { return matcher(t, t, null, new HashMap<String, Tree>(), new VariableStrings()); }","old_code_raw":"  public TregexMatcher matcher(Tree t) {\n    return matcher(t, t, null, Generics.<String, Tree>newHashMap(), new VariableStrings());\n  }\n","new_comment_raw":"Get a  TregexMatcher for this pattern on this tree.","old_comment_raw":"Get a TregexMatcher for this pattern on this tree.","label":0,"pre_label":1,"AST_level":8,"line_counts":4,"new_code_token_num":32},{"new_code_raw":"public Field getField(String name) throws NoSuchFieldException, SecurityException { checkPublicMemberAccess(); Field[] fields = getClassCache().getAllPublicFields(); Field field = findFieldByName(fields, name); \/* * Make a copy of the private (to the package) object, so that * setAccessible() won't alter the private instance. *\/ return REFLECT.clone(field); }","old_code_raw":"    public Field getField(String name) throws NoSuchFieldException, SecurityException {\n        checkPublicMemberAccess();\n        return getMatchingField(getFullListOfFields(true), name);\n    }\n","new_comment_raw":"Returns a  Field object which represents the public field with the specified name.","old_comment_raw":"Returns a Field object describing the field in the receiver named by the argument which must be visible from the current execution context.","label":1,"pre_label":0,"AST_level":6,"line_counts":14,"new_code_token_num":75},{"new_code_raw":"public boolean isTextPresent(String pattern) { return (Boolean) seleneseMethods.get(\"isTextPresent\").apply(driver, pattern); }","old_code_raw":"  public boolean isTextPresent(String pattern) {\n    String text = driver.findElement(By.xpath(\"\/html\/body\")).getText();\n    text = text.trim();\n\n    String strategyName = \"implicit\";\n    String use = pattern;\n    Matcher matcher = TEXT_MATCHING_STRATEGY_AND_VALUE_PATTERN.matcher(pattern);\n    if (matcher.matches()) {\n      strategyName = matcher.group(1);\n      use = matcher.group(2);\n    }\n    TextMatchingStrategy strategy = textMatchingStrategies.get(strategyName);\n\n    return strategy.isAMatch(use, text);\n  }\n","new_comment_raw":"Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.","old_comment_raw":"Verifies that the specified text pattern appears somewhere on the rendered page shown to the user.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public static String encrypt(String plain) { return getMD5(plain); \/* org.w3c.tools.crypt.Md5 md5 = new org.w3c.tools.crypt.Md5(plain); byte[] b = md5.processString(); return md5.getStringDigest(); *\/ }","old_code_raw":"    public static String encrypt(String plain) {\n        Md5 md5 = new Md5(plain);\n        byte[] b = md5.processString();\n\n        return md5.getStringDigest();\n    }\n","new_comment_raw":"Encrypt plain text password","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":11,"new_code_token_num":51},{"new_code_raw":"public RelOptTableImpl getTable(final List<String> names) { RelOptTableImpl temporaryTable = null; if (mightBeTemporaryTable(names, session.getDefaultSchemaPath(), drillConfig)) { String temporaryTableName = session.resolveTemporaryTableName(names.get(names.size() - 1)); if (temporaryTableName != null) { List<String> temporaryNames = Lists.newArrayList(temporarySchema, temporaryTableName); temporaryTable = super.getTable(temporaryNames); } } if (temporaryTable != null) { if (allowTemporaryTables) { return temporaryTable; } throw UserException .validationError() .message(\"Temporary tables usage is disallowed. Used temporary table name: %s.\", names) .build(logger); } RelOptTableImpl table = super.getTable(names); \/\/ Check the schema and throw a valid SchemaNotFound exception instead of TableNotFound exception. if (table == null) { isValidSchema(names); } return table; }","old_code_raw":"    public RelOptTableImpl getTable(final List<String> names) {\n      RelOptTableImpl temporaryTable = null;\n\n      if (mightBeTemporaryTable(names, session.getDefaultSchemaPath(), drillConfig)) {\n        String temporaryTableName = session.resolveTemporaryTableName(names.get(names.size() - 1));\n        if (temporaryTableName != null) {\n          List<String> temporaryNames = Lists.newArrayList(temporarySchema, temporaryTableName);\n          temporaryTable = super.getTable(temporaryNames);\n        }\n      }\n      if (temporaryTable != null) {\n        if (allowTemporaryTables) {\n          return temporaryTable;\n        }\n        throw UserException\n            .validationError()\n            .message(\"Temporary tables usage is disallowed. Used temporary table name: %s.\", names)\n            .build(logger);\n      }\n      return super.getTable(names);\n    }\n","new_comment_raw":"If schema is not indicated (only one element in the list) or schema is default temporary workspace, we need to check among session temporary tables in default temporary workspace first.","old_comment_raw":"If schema is not indicated (only one element in the list) or schema is default temporary workspace, we need to check among session temporary tables in default temporary workspace first.","label":0,"pre_label":1,"AST_level":10,"line_counts":30,"new_code_token_num":158},{"new_code_raw":"public int atAdPos(final int pos) { final int take_int = (int) Math.floor((pos + 1) \/ adfrequency); Log.d(\"atAdPosE2\", take_int + \"\"); return take_int; }","old_code_raw":"    public int atAdPos(final int pos) {\n        return (int) Math.floor(pos \/ adfrequency);\n    }\n","new_comment_raw":"to display the accumulator for the Ad position","old_comment_raw":"to display the accumulator for the Ad position","label":0,"pre_label":1,"AST_level":9,"line_counts":6,"new_code_token_num":44},{"new_code_raw":"public List<LogicalInputSplit> getInputSplits(final HiveReadEntry hiveReadEntry) { final Stopwatch timeGetSplits = Stopwatch.createStarted(); try { if (!isPartitionedTable) { return getTableInputSplits(); } final List<LogicalInputSplit> splits = Lists.newArrayList(); for (HivePartition p : hiveReadEntry.getPartitions()) { splits.addAll(getPartitionInputSplits(p)); } return splits; } catch (final Exception e) { logger.error(\"Failed to get InputSplits\", e); throw new DrillRuntimeException(\"Failed to get InputSplits\", e); } finally { logger.debug(\"Took {} \u00c2\u00b5s to get InputSplits from {}.{}\", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) \/ 1000, hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName()); } }","old_code_raw":"  public List<InputSplitWrapper> getInputSplits(final HiveReadEntry hiveReadEntry) {\n    final Stopwatch timeGetSplits = Stopwatch.createStarted();\n    try {\n      if (!isPartitionedTable) {\n        return getTableInputSplits();\n      }\n\n      final List<InputSplitWrapper> splits = Lists.newArrayList();\n      for (HivePartition p : hiveReadEntry.getPartitions()) {\n        splits.addAll(getPartitionInputSplits(p));\n      }\n      return splits;\n    } catch (final Exception e) {\n      logger.error(\"Failed to get InputSplits\", e);\n      throw new DrillRuntimeException(\"Failed to get InputSplits\", e);\n    } finally {\n      logger.debug(\"Took {} \u00c2\u00b5s to get InputSplits from {}.{}\", timeGetSplits.elapsed(TimeUnit.NANOSECONDS) \/ 1000,\n          hiveReadEntry.getTable().getDbName(), hiveReadEntry.getTable().getTableName());\n    }\n  }\n","new_comment_raw":"Return  LogicalInputSplits for given  HiveReadEntry.","old_comment_raw":"Return InputSplitWrappers for given HiveReadEntry.","label":1,"pre_label":0,"AST_level":9,"line_counts":21,"new_code_token_num":149},{"new_code_raw":"private TimerTask getServiceUrlUpdateTask(final String zone) { return new TimerTask() { @Override public void run() { try { List<String> serviceUrlList = timedGetDiscoveryServiceUrls(zone); if (serviceUrlList.isEmpty()) { logger.warn(\"The service url list is empty\"); return; } if (!serviceUrlList.equals(eurekaServiceUrls.get())) { logger.info( \"Updating the serviceUrls as they seem to have changed from {} to {} \", Arrays.toString(eurekaServiceUrls.get() .toArray()), Arrays .toString(serviceUrlList.toArray())); eurekaServiceUrls.set(serviceUrlList); } } catch (Throwable e) { logger.error(\"Cannot get the eureka service urls :\", e); } } }; }","old_code_raw":"    private TimerTask getServiceUrlUpdateTask(final String zone) {\n        return new TimerTask() {\n            @Override\n            public void run() {\n                try {\n                    List<String> serviceUrlList = getDiscoveryServiceUrls(zone);\n                    if (serviceUrlList.isEmpty()) {\n                        logger.warn(\"The service url list is empty\");\n                        return;\n                    }\n                    if (!serviceUrlList.equals(eurekaServiceUrls.get())) {\n                        logger.info(\n                                \"Updating the serviceUrls as they seem to have changed from {} to {} \",\n                                Arrays.toString(eurekaServiceUrls.get()\n                                        .toArray()), Arrays\n                                        .toString(serviceUrlList.toArray()));\n\n                        eurekaServiceUrls.set(serviceUrlList);\n                    }\n                } catch (Throwable e) {\n                    logger.error(\"Cannot get the eureka service urls :\", e);\n                }\n\n            }\n        };\n    }\n","new_comment_raw":"Gets the task that is responsible for fetching the eureka service Urls.","old_comment_raw":"Gets the task that is responsible for fetching the eureka service Urls.","label":0,"pre_label":1,"AST_level":13,"line_counts":27,"new_code_token_num":148},{"new_code_raw":"public String preprocess(String buildPath) throws RunnerException { try { return preprocess(buildPath, new PdePreprocessor(buildPath, name)); } catch (IOException e) { throw new RunnerException(\"Error while preprocessing\", true); } }","old_code_raw":"  public String preprocess(String buildPath) throws RunnerException {\n    return preprocess(buildPath, new PdePreprocessor());\n  }\n","new_comment_raw":"Build all the code for this sketch.","old_comment_raw":"Build all the code for this sketch.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":48},{"new_code_raw":"private File[] getDirectoryHistory() { File[] dirhist = Settings.instance().getDirectoryHistory(); if (dirhist == null || dirhist.length == 0) return new File[] { new File(\".\").getAbsoluteFile() }; else return dirhist; }","old_code_raw":"    private String[] getDirectoryHistory() {\n        return new String[] { directory.getAbsolutePath(), \"resources\", \"mursukas\", \"heppa\", \"marsupapana\" };\n\n        \/\/ TODO:\n        \/\/return Settings.instance().getDirectoryHistory();\n    }\n","new_comment_raw":"Reads current directory history from Settings.","old_comment_raw":"Gets current directory history from TODO.","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":52},{"new_code_raw":"protected Object getComponentValue(ComponentType type, Object component, String propertyPath) { final int loc = propertyPath.indexOf( '.' ); final String basePropertyName = loc > 0 ? propertyPath.substring( 0, loc ) : propertyPath; final int index = findSubPropertyIndex( type, basePropertyName ); final Object baseValue = type.getPropertyValue( component, index, getEntityMode() ); if ( loc > 0 ) { if ( baseValue == null ) { return null; } return getComponentValue( (ComponentType) type.getSubtypes()[index], baseValue, propertyPath.substring(loc+1) ); } else { return baseValue; } }","old_code_raw":"\tprotected Object getComponentValue(ComponentType type, Object component, String propertyPath) {\n\t\t\n\t\tint loc = propertyPath.indexOf('.');\n\t\tString basePropertyName = loc>0 ?\n\t\t\tpropertyPath.substring(0, loc) : propertyPath;\n\t\t\n\t\tString[] propertyNames = type.getPropertyNames();\n\t\tint index=0;\n\t\tfor ( ; index<propertyNames.length; index++ ) {\n\t\t\tif ( basePropertyName.equals( propertyNames[index] ) ) break;\n\t\t}\n\t\tif (index==propertyNames.length) {\n\t\t\tthrow new MappingException( \"component property not found: \" + basePropertyName );\n\t\t}\n\t\t\n\t\tObject baseValue = type.getPropertyValue( component, index, getEntityMode() );\n\t\t\n\t\tif ( loc>0 ) {\n\t\t\tComponentType subtype = (ComponentType) type.getSubtypes()[index];\n\t\t\treturn getComponentValue( subtype, baseValue, propertyPath.substring(loc+1) );\n\t\t}\n\t\telse {\n\t\t\treturn baseValue;\n\t\t}\n\t\t\n\t}\n","new_comment_raw":"Extract a component property value.","old_comment_raw":"Extract a component property value.","label":0,"pre_label":1,"AST_level":10,"line_counts":23,"new_code_token_num":114},{"new_code_raw":"public ArrayList<View> getViews() { try { return viewFetcher.getViews(null, false); } catch (Exception e) { e.printStackTrace(); return null; } }","old_code_raw":"\t\n\tpublic ArrayList<View> getViews() {\n\t\ttry {\n\t\t\treturn viewFetcher.getViews(null);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n","new_comment_raw":"Returns an  ArrayList of all the  View objects located in the focused window e.g.","old_comment_raw":"Returns an ArrayList of the View objects located in the current Activity.","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":35},{"new_code_raw":"public static Log named(String name) { \/\/ a thread-safe SLF4J initialization routine is apparently hard, so I get to do dumb \/\/ shit like this while (true) { final org.slf4j.Logger logger = LoggerFactory.getLogger(name); if (logger instanceof Logger) { return forSlf4jLogger(logger); } } }","old_code_raw":"    public static Log named(String name) {\n        return forSlf4jLogger(LoggerFactory.getLogger(name));\n    }\n","new_comment_raw":"Returns a  Log instance with the given name.","old_comment_raw":"Returns a Log instance with the given name.","label":0,"pre_label":1,"AST_level":9,"line_counts":11,"new_code_token_num":65},{"new_code_raw":"private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) { final List<BatchResponse> responseList = new ArrayList<>(requestList.size()); final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList); checkList.clear(); if(batchRequestNodes.isEmpty()) { final BatchResponse response = new BatchResponse(); ErrorInfo ex = ErrorHandler.handler(new ClientDetailsNotFoundException()); response.setStatusCode(500); response.setBody(ex.getMessage()); responseList.add(response) ; return responseList ; } for (BatchRequestNode rootNode : batchRequestNodes) { final BatchRequest rootRequest = rootNode.getRequest(); final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build()); final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo); responseList.add(rootResponse); responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo)); } Collections.sort(responseList, new Comparator<BatchResponse>() { @Override public int compare(BatchResponse source, BatchResponse testee) { return source.getRequestId().compareTo(testee.getRequestId()); } }); checkList = responseList; return responseList; }","old_code_raw":"    private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) {\n\n        final List<BatchResponse> responseList = new ArrayList<>(requestList.size());\n\n        final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList);\n        checkList.clear();\n\n        for (BatchRequestNode rootNode : batchRequestNodes) {\n            final BatchRequest rootRequest = rootNode.getRequest();\n            final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext\n                    .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build());\n            final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo);\n\n            responseList.add(rootResponse);\n            responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo));\n        }\n\n        Collections.sort(responseList, new Comparator<BatchResponse>() {\n\n            @Override\n            public int compare(BatchResponse source, BatchResponse testee) {\n                return source.getRequestId().compareTo(testee.getRequestId());\n            }\n        });\n\n        checkList = responseList;\n        return responseList;\n\n    }\n","new_comment_raw":"Returns the response list by getting a proper  org.apache.fineract.batch.command.CommandStrategy.","old_comment_raw":"Returns the response list by getting a proper org.apache.fineract.batch.command.CommandStrategy.","label":0,"pre_label":1,"AST_level":11,"line_counts":37,"new_code_token_num":219},{"new_code_raw":"private List<CardViewWrapper> getVisibleViewsForCards(List<Card> cardsCopy) { List<CardViewWrapper> originalViews = new ArrayList<CardViewWrapper>(); for (Card card:cardsCopy){ originalViews.add(card.getCardView()); } \/*List<CardView> views = new ArrayList<CardView>(); for (int i = 0; i < mCardListView.getChildCount(); i++) { View child = mCardListView.getChildAt(i); if (cardsCopy.contains(views)){ views.add((CardView) child); } }*\/ return originalViews; }","old_code_raw":"    private List<CommonCardView> getVisibleViewsForCards(List<Card> cardsCopy) {\n        List<CommonCardView> originalViews = new ArrayList<CommonCardView>();\n        for (Card card:cardsCopy){\n            originalViews.add(card.getCardView());\n        }\n\n        \/*List<CardView> views = new ArrayList<CardView>();\n        for (int i = 0; i < mCardListView.getChildCount(); i++) {\n            View child = mCardListView.getChildAt(i);\n            if (cardsCopy.contains(views)){\n                views.add((CardView) child);\n            }\n        }*\/\n        return originalViews;\n    }\n","new_comment_raw":"Returns the visible view for the cards","old_comment_raw":"Returns the visible view for the cards","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":99},{"new_code_raw":"public AlgorithmIdentifier getDigestAlgorithm() { if (holder.getObjectDigestInfo() != null) { return holder.getObjectDigestInfo().getDigestAlgorithm(); } return null; }","old_code_raw":"    public String getDigestAlgorithm()\n    {\n        if (holder.getObjectDigestInfo() != null)\n        {\n            holder.getObjectDigestInfo().getDigestAlgorithm().getObjectId()\n                .getId();\n        }\n        return null;\n    }\n","new_comment_raw":"Returns algorithm identifier for the digest used if ObjectDigestInfo is present.","old_comment_raw":"Returns the other object type ID if an object digest info is used.","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":30},{"new_code_raw":"public List<SentenceFragment> clausesInSentence(CoreMap sentence) { return clausesInSentence(sentence.get(SemanticGraphCoreAnnotations.EnhancedPlusPlusDependenciesAnnotation.class), true); }","old_code_raw":"  public List<SentenceFragment> clausesInSentence(CoreMap sentence) {\n    return clausesInSentence(sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class), true);\n  }\n","new_comment_raw":"Find the clauses in a sentence.","old_comment_raw":"Find the clauses in a sentence.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public static String jenkinsJobName(String namespace, String buildConfigName, String defaultNamespace) { if (namespace == null || namespace.length() == 0 || namespace.equals(defaultNamespace)) { return buildConfigName; } return namespace + \"-\" + buildConfigName; }","old_code_raw":"  public static String jenkinsJobName(String namespace, String buildConfigName) {\n    return namespace + \"-\" + buildConfigName;\n  }\n","new_comment_raw":"Creates the Jenkins Job name for the given buildConfigName in a namespace and the default namespace for jenkins","old_comment_raw":"Creates the Jenkins Job name for the given buildConfigName","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":49},{"new_code_raw":"public static ModuleConfig getModuleConfig(PageContext pageContext) { ModuleConfig moduleConfig = (ModuleConfig) pageContext.getRequest().getAttribute(Globals.MODULE_KEY); if (moduleConfig == null) { \/\/ Backwards compatibility hack moduleConfig = (ModuleConfig) pageContext.getServletContext().getAttribute(Globals.MODULE_KEY); } return moduleConfig; }","old_code_raw":"    public static ApplicationConfig getModuleConfig(PageContext pageContext) {\n       ApplicationConfig appConfig = (ApplicationConfig)\n           pageContext.getRequest().getAttribute(Globals.MODULE_KEY);\n       if (appConfig == null) { \/\/ Backwards compatibility hack\n           appConfig = (ApplicationConfig)\n               pageContext.getServletContext().getAttribute(Globals.MODULE_KEY);\n       }\n       return appConfig;\n    }\n","new_comment_raw":"Return the ModuleConfig object is it exists, null otherwise.","old_comment_raw":"Return the ApplicationConfig object is it exists, null otherwise.","label":1,"pre_label":0,"AST_level":10,"line_counts":11,"new_code_token_num":54},{"new_code_raw":"public static boolean isSameType(MajorType type1, MajorType type2) { return isSameTypeAndMode(type1, type2) && type1.getScale() == type2.getScale() && type1.getPrecision() == type2.getPrecision(); }","old_code_raw":"  public static boolean isSameType(MajorType type1, MajorType type2) {\n    return type1.getMinorType() == type2.getMinorType() &&\n           type1.getMode() == type2.getMode() &&\n           type1.getScale() == type2.getScale() &&\n           type1.getPrecision() == type2.getPrecision();\n  }\n","new_comment_raw":"Check if two \"core\" types are the same, ignoring subtypes and children.","old_comment_raw":"Check if two \"core\" types are the same, ignoring subtypes and children.","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":41},{"new_code_raw":"private Timestamp[] getTimeframe() { Timestamp oldest = Timestamp.ZERO.plus(1000000); Timestamp newest = Timestamp.ZERO; for (Habit h : selectedHabits) { if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null) continue; Timestamp currOld = h.getRepetitions().getOldest().getTimestamp(); Timestamp currNew = h.getRepetitions().getNewest().getTimestamp(); oldest = currOld.isOlderThan(oldest) ? oldest : currOld; newest = currNew.isNewerThan(newest) ? newest : currNew; } return new Timestamp[]{oldest, newest}; }","old_code_raw":"    private long[] getTimeframe()\n    {\n        long oldest = Long.MAX_VALUE;\n        long newest = -1;\n        for (Habit h : selectedHabits)\n        {\n            if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null)\n                continue;\n            long currOld = h.getRepetitions().getOldest().getTimestamp();\n            long currNew = h.getRepetitions().getNewest().getTimestamp();\n            oldest = currOld > oldest ? oldest : currOld;\n            newest = currNew < newest ? newest : currNew;\n        }\n        return new long[]{oldest, newest};\n    }\n","new_comment_raw":"Gets the overall timeframe of the selected habits.","old_comment_raw":"Gets the overall timeframe of the selected habits.","label":0,"pre_label":1,"AST_level":9,"line_counts":16,"new_code_token_num":114},{"new_code_raw":"static int calcLevels(double start, int end, double multiple) { return (int) Math.ceil(calcMultipliedLevels(start, end, multiple)); }","old_code_raw":"\tstatic int calcLevels(double start, int end, double multiple)\n\t{\n\t\treturn (int) Math.ceil((end - start) \/ multiple);\n\t}\n","new_comment_raw":"Calculate skill levels required for increasing combat level, meant for all combat skills besides prayer, ranged, and magic.","old_comment_raw":"Calculate skill levels required for increasing combat level, meant for all combat skills besides ranged and magic.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public DurationField millis() { return UnsupportedDurationField.getInstance(DurationFieldType.millis()); }","old_code_raw":"    public DurationField millis() {\n        return UnsupportedDurationField.getInstance(\"millis\");\n    }\n","new_comment_raw":"Get the millis duration field for this chronology.","old_comment_raw":"Get the millis duration field for this chronology.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public boolean waitForText(String text, int matches, long timeout, boolean scroll) { long now = System.currentTimeMillis(); final long endTime = now + timeout; while (!searcher.searchFor(TextView.class, text, matches, scroll) && !searcher.searchForEditText(text, scroll) && now < endTime) { now = System.currentTimeMillis(); } final boolean timedOut = now > endTime; return !timedOut; }","old_code_raw":"\tpublic boolean waitForText(String text, int matches, long timeout, boolean scroll)\n    {\n\t\tlong now = System.currentTimeMillis();\n        final long endTime = now + timeout;\n\n\t\twhile (!searcher.searchFor(TextView.class, text, matches, scroll) && !searcher.searchForEditText(text, scroll) && now < endTime) {\n        \tnow = System.currentTimeMillis();\t\n        }    \n        if (now > endTime)\n        \treturn false;\n        \n       return true;\n    }\n","new_comment_raw":"Waits for a text to be shown.","old_comment_raw":"Waits for a text to be shown.","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":80},{"new_code_raw":"public double getAssignmentValue(int[] assignment) { double d = super.getAssignmentValue(assignment); \/\/ if (d == null) d = Double.NEGATIVE_INFINITY; return Math.exp(d); }","old_code_raw":"    public double getAssignmentValue(int[] assignment) {\n        double d = super.getAssignmentValue(assignment);\n        \/\/ if (d == null) d = Double.NEGATIVE_INFINITY;\n        return FastMath.exp(d);\n    }\n","new_comment_raw":"Just a pass through to the NDArray version, plus a Math.exp to ensure that to the outside world the TableFactor doesn't look like it's in log-space","old_comment_raw":"Just a pass through to the NDArray version, plus a FastMath.exp to ensure that to the outside world the TableFactor doesn't look like it's in log-space","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":37},{"new_code_raw":"public static Builder create() { return new Builder() { private Configuration config; private Consumer<SourceRecord> consumer; private ClassLoader classLoader; private Clock clock; private CompletionCallback completionCallback; @Override public Builder using(Configuration config) { this.config = config; return this; } @Override public Builder using(ClassLoader classLoader) { this.classLoader = classLoader; return this; } @Override public Builder using(Clock clock) { this.clock = clock; return this; } @Override public Builder using(CompletionCallback completionCallback) { this.completionCallback = completionCallback; return this; } @Override public Builder notifying(Consumer<SourceRecord> consumer) { this.consumer = consumer; return this; } @Override public EmbeddedEngine build() { if (classLoader == null) classLoader = getClass().getClassLoader(); if (clock == null) clock = Clock.system(); Objects.requireNonNull(config, \"A connector configuration must be specified.\"); Objects.requireNonNull(consumer, \"A connector consumer must be specified.\"); return new EmbeddedEngine(config, classLoader, clock, consumer, completionCallback); } }; }","old_code_raw":"    public static Builder create() {\n        return new Builder() {\n            private Configuration config;\n            private Consumer<SourceRecord> consumer;\n            private ClassLoader classLoader;\n            private Clock clock;\n\n            @Override\n            public Builder using(Configuration config) {\n                this.config = config;\n                return this;\n            }\n\n            @Override\n            public Builder using(ClassLoader classLoader) {\n                this.classLoader = classLoader;\n                return this;\n            }\n\n            @Override\n            public Builder using(Clock clock) {\n                this.clock = clock;\n                return this;\n            }\n\n            @Override\n            public Builder notifying(Consumer<SourceRecord> consumer) {\n                this.consumer = consumer;\n                return this;\n            }\n\n            @Override\n            public EmbeddedEngine build() {\n                if (classLoader == null) classLoader = getClass().getClassLoader();\n                if (clock == null) clock = Clock.system();\n                Objects.requireNonNull(config, \"A connector configuration must be specified.\");\n                Objects.requireNonNull(consumer, \"A connector consumer must be specified.\");\n                return new EmbeddedEngine(config, classLoader, clock, consumer);\n            }\n\n        };\n    }\n","new_comment_raw":"Obtain a new  Builder instance that can be used to construct runnable  EmbeddedEngine instances.","old_comment_raw":"Obtain a new Builder instance that can be used to construct runnable EmbeddedEngine instances.","label":0,"pre_label":1,"AST_level":10,"line_counts":50,"new_code_token_num":206},{"new_code_raw":"public final Entity getEntity() { return entity; }","old_code_raw":"    public final BranchingInputStream getEntity() {\n        return entity;\n    }\n","new_comment_raw":"Returns the entity.","old_comment_raw":"Returns the entity as an input stream.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public android.telecom.Connection.VideoProvider getVideoProvider() { return mVideoProvider; }","old_code_raw":"    public android.telecomm.Connection.VideoProvider getVideoProvider() {\n        return mVideoProvider;\n    }\n","new_comment_raw":"Returns the  android.telecom.Connection.VideoProvider for the connection.","old_comment_raw":"Returns the android.telecomm.Connection.VideoProvider for the connection.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"public String getLivePath() { return this.livePath; }","old_code_raw":"    public String getLivePath() {\n        return livePath;\n    }\n","new_comment_raw":"Returns the live path","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public static Object deserialize(InputStream inputStream) throws SerializationException { return deserialize( inputStream, Thread.currentThread().getContextClassLoader() ); }","old_code_raw":"    public static Object deserialize(InputStream inputStream) throws SerializationException {\n        if (inputStream == null) {\n            throw new IllegalArgumentException(\"The InputStream must not be null\");\n        }\n\n\t\tlog.trace(\"Starting deserialization of object\");\n\n        CustomObjectInputStream in = null;\n        try {\n            \/\/ stream closed in the finally\n            in = new CustomObjectInputStream(inputStream);\n            return in.readObject();\n\n        }\n        catch (ClassNotFoundException ex) {\n            throw new SerializationException(\"could not deserialize\", ex);\n        }\n        catch (IOException ex) {\n            throw new SerializationException(\"could not deserialize\", ex);\n        }\n        finally {\n            try {\n                if (in != null) in.close();\n            }\n            catch (IOException ex) {}\n        }\n    }\n","new_comment_raw":"Deserializes an object from the specified stream using the Thread Context","old_comment_raw":"Deserializes an Object from the specified stream. The stream will be closed once the object is written.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public static Socket socket(URI uri, Options opts) { if (opts == null) { opts = new Options(); } URL parsed = Url.parse(uri); URI source; try { source = parsed.toURI(); } catch (URISyntaxException e) { throw new RuntimeException(e); } String id = Url.extractId(parsed); String path = parsed.getPath(); boolean sameNamespace = managers.containsKey(id) && managers.get(id).nsps.containsKey(path); boolean newConnection = opts.forceNew || !opts.multiplex || sameNamespace; Manager io; if (newConnection) { logger.fine(String.format(\"ignoring socket cache for %s\", source)); io = new Manager(source, opts); } else { if (!managers.containsKey(id)) { logger.fine(String.format(\"new io instance for %s\", source)); managers.putIfAbsent(id, new Manager(source, opts)); } io = managers.get(id); } String query = parsed.getQuery(); if (query != null && (opts.query == null || opts.query.isEmpty())) { opts.query = query; } return io.socket(parsed.getPath(), opts); }","old_code_raw":"    public static Socket socket(URI uri, Options opts) {\n        if (opts == null) {\n            opts = new Options();\n        }\n\n        URL parsed = Url.parse(uri);\n        URI source;\n        try {\n            source = parsed.toURI();\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n        String id = Url.extractId(parsed);\n        String path = parsed.getPath();\n        boolean sameNamespace = managers.containsKey(id)\n                && managers.get(id).nsps.containsKey(path);\n        boolean newConnection = opts.forceNew || !opts.multiplex || sameNamespace;\n        Manager io;\n\n        if (newConnection) {\n            logger.fine(String.format(\"ignoring socket cache for %s\", source));\n            io = new Manager(source, opts);\n        } else {\n            if (!managers.containsKey(id)) {\n                logger.fine(String.format(\"new io instance for %s\", source));\n                managers.putIfAbsent(id, new Manager(source, opts));\n            }\n            io = managers.get(id);\n        }\n\n        return io.socket(parsed.getPath());\n    }\n","new_comment_raw":"Initializes a  Socket from an existing  Manager for multiplexing.","old_comment_raw":"Initializes a Socket from an existing Manager for multiplexing.","label":0,"pre_label":1,"AST_level":10,"line_counts":38,"new_code_token_num":244},{"new_code_raw":"public User getUserByName(String username) throws ApiException { ApiResponse<User> localVarResp = getUserByNameWithHttpInfo(username); return localVarResp.getData(); }","old_code_raw":"    public User getUserByName(String username) throws ApiException {\n        ApiResponse<User> resp = getUserByNameWithHttpInfo(username);\n        return resp.getData();\n    }\n","new_comment_raw":"Get user by user name","old_comment_raw":"Get user by user name","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public DateTimeField[] getFields() { DateTimeField[] result = new DateTimeField[getFieldSize()]; for (int i = 0; i < result.length; i++) { result[i] = getField(i); } return result; }","old_code_raw":"    public DateTimeField[] getFields() {\n        return (DateTimeField[]) iFields.clone();\n    }\n","new_comment_raw":"Gets an array of the fields that this partial supports.","old_comment_raw":"Gets an array of the fields that this partial supports.","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":49},{"new_code_raw":"public Optional<GraphQLError> add(SDLDefinition definition) { \/\/ extensions if (definition instanceof ObjectTypeExtensionDefinition) { ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition; return defineExt(objectTypeExtensions, newEntry, ObjectTypeExtensionDefinition::getName); } else if (definition instanceof InterfaceTypeExtensionDefinition) { InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition; return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName); } else if (definition instanceof UnionTypeExtensionDefinition) { UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition; return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName); } else if (definition instanceof EnumTypeExtensionDefinition) { EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition; return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName); } else if (definition instanceof ScalarTypeExtensionDefinition) { ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition; return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName); } else if (definition instanceof InputObjectTypeExtensionDefinition) { InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition; return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName); \/\/ \/\/ normal } else if (definition instanceof ScalarTypeDefinition) { ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition; return define(scalarTypes, scalarTypes, newEntry); } else if (definition instanceof TypeDefinition) { TypeDefinition newEntry = (TypeDefinition) definition; return define(types, types, newEntry); } else if (definition instanceof DirectiveDefinition) { DirectiveDefinition newEntry = (DirectiveDefinition) definition; return define(directiveDefinitions, directiveDefinitions, newEntry); } else if (definition instanceof SchemaDefinition) { SchemaDefinition newSchema = (SchemaDefinition) definition; if (schema != null) { return Optional.of(new SchemaRedefinitionError(this.schema, newSchema)); } else { schema = newSchema; } } else { return Assert.assertShouldNeverHappen(); } return Optional.empty(); }","old_code_raw":"    public Optional<GraphQLError> add(Definition definition) {\n        \/\/ extensions\n        if (definition instanceof ObjectTypeExtensionDefinition) {\n            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;\n            return defineExt(objectTypeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);\n        } else if (definition instanceof InterfaceTypeExtensionDefinition) {\n            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;\n            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);\n        } else if (definition instanceof UnionTypeExtensionDefinition) {\n            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;\n            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);\n        } else if (definition instanceof EnumTypeExtensionDefinition) {\n            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;\n            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);\n        } else if (definition instanceof ScalarTypeExtensionDefinition) {\n            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;\n            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);\n        } else if (definition instanceof InputObjectTypeExtensionDefinition) {\n            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;\n            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);\n            \/\/\n            \/\/ normal\n        } else if (definition instanceof ScalarTypeDefinition) {\n            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;\n            return define(scalarTypes, scalarTypes, newEntry);\n        } else if (definition instanceof TypeDefinition) {\n            TypeDefinition newEntry = (TypeDefinition) definition;\n            return define(types, types, newEntry);\n        } else if (definition instanceof DirectiveDefinition) {\n            DirectiveDefinition newEntry = (DirectiveDefinition) definition;\n            return define(directiveDefinitions, directiveDefinitions, newEntry);\n        } else if (definition instanceof SchemaDefinition) {\n            SchemaDefinition newSchema = (SchemaDefinition) definition;\n            if (schema != null) {\n                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));\n            } else {\n                schema = newSchema;\n            }\n        }\n        return Optional.empty();\n    }\n","new_comment_raw":"Adds a definition to the registry","old_comment_raw":"Adds a definition to the registry","label":0,"pre_label":1,"AST_level":20,"line_counts":44,"new_code_token_num":328},{"new_code_raw":"public static RelDataTypeField extra(RelDataType rowType) { \/\/ Even in a case-insensitive connection, the name must be precisely \/\/ \"_extra\". return rowType.getField(\"_extra\", true, false); }","old_code_raw":"  public static RelDataTypeField extra(RelDataType rowType) {\n    \/\/ Even in a case-insensitive connection, the name must be precisely\n    \/\/ \"_extra\".\n    return rowType.getField(\"_extra\", true);\n  }\n","new_comment_raw":"Returns the \"extra\" field in a row type whose presence signals that fields will come into existence just by asking for them.","old_comment_raw":"Returns the \"extra\" field in a row type whose presence signals that fields will come into existence just by asking for them.","label":0,"pre_label":1,"AST_level":5,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"public int start() { FileDownloadLog.d(this, \"begin call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" + \" tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc, tag); if (savePath == null) { savePath = FileDownloadUtils.getDefaultSaveFilePath(url); FileDownloadLog.e(this, \"save path is null to %s\", savePath); } addEventListener(); if (isNeedNotification) { \/\/ TODO \u00e6\u009b\u00bf\u00e6\u008d\u00a2app name notificationTitle = notificationTitle == null ? \"app name\" : notificationTitle; } try { checkFile(savePath); \/\/ \u00e6\u009c\u008d\u00e5\u008a\u00a1\u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e5\u0090\u00af\u00e5\u008a\u00a8 if (!checkCanStart()) { \/\/ \u00e6\u00b2\u00a1\u00e6\u009c\u0089\u00e5\u0087\u0086\u00e5\u00a4\u0087\u00e5\u00a5\u00bd return getDownloadId(); } FileDownloadList.getImpl().add(this); \/\/ \u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd if (checkDownloading(getUrl(), getSavePath())) { \/\/ \u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd \/\/ \u00e8\u00bf\u0099\u00e9\u0087\u008c\u00e5\u00b0\u00b1\u00e7\u009b\u00b4\u00e6\u008e\u00a5\u00e7\u00bb\u0093\u00e6\u009d\u009f\u00e4\u00ba\u0086 FileDownloadLog.d(this, \"Current is downloading %d\", getDownloadId()); setStatus(FileDownloadStatus.warn); FileDownloadList.getImpl().removeByWarn(this); return getDownloadId(); } if (checkCanReuse()) { FileDownloadLog.d(this, \"reuse downloaded file %s\", getUrl()); this.isReusedOldFile = true; setStatus(FileDownloadStatus.completed); FileDownloadList.getImpl().removeByCompleted(this); } else { FileDownloadLog.d(this, \"start downloaded by ui process %s\", getUrl()); this.isReusedOldFile = false; if (startExecute() == 0) { setEx(new RuntimeException(\"not run download, not got download id\")); FileDownloadList.getImpl().removeByError(this); } } } catch (Throwable e) { e.printStackTrace(); setEx(e); FileDownloadList.getImpl().removeByError(this); } FileDownloadLog.d(this, \"end call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" + \"tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc, tag); return getDownloadId(); }","old_code_raw":"    public int start() {\n        FileDownloadLog.d(this, \"begin call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" +\n                \" tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc, tag);\n\n        if (savePath == null) {\n            savePath = FileDownloadUtils.getDefaultSaveFilePath(url);\n            FileDownloadLog.e(this, \"save path is null to %s\", savePath);\n        }\n\n\n        addEventListener();\n\n        if (isNeedNotification) {\n            \/\/ TODO \u00e6\u009b\u00bf\u00e6\u008d\u00a2app name\n            notificationTitle = notificationTitle == null ? \"app name\" : notificationTitle;\n        }\n\n\n        this.downloadId = 0;\n\n        try {\n            checkFile(savePath);\n\n            \/\/ \u00e6\u009c\u008d\u00e5\u008a\u00a1\u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e5\u0090\u00af\u00e5\u008a\u00a8\n            if (!checkCanStart()) {\n                \/\/ \u00e6\u00b2\u00a1\u00e6\u009c\u0089\u00e5\u0087\u0086\u00e5\u00a4\u0087\u00e5\u00a5\u00bd\n                return 0;\n            }\n\n            FileDownloadList.getImpl().add(this);\n\n            \/\/ \u00e6\u0098\u00af\u00e5\u0090\u00a6\u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd\n            if (checkDownloading(getUrl(), getSavePath())) {\n                \/\/ \u00e6\u00ad\u00a3\u00e5\u009c\u00a8\u00e4\u00b8\u008b\u00e8\u00bd\u00bd\n                \/\/ \u00e8\u00bf\u0099\u00e9\u0087\u008c\u00e5\u00b0\u00b1\u00e7\u009b\u00b4\u00e6\u008e\u00a5\u00e7\u00bb\u0093\u00e6\u009d\u009f\u00e4\u00ba\u0086\n                FileDownloadLog.d(this, \"Current is downloading %d\", getDownloadId());\n\n                setStatus(FileDownloadStatus.warn);\n                FileDownloadList.getImpl().removeByWarn(this);\n\n                return 0;\n            }\n\n            if (checkCanReuse()) {\n                FileDownloadLog.d(this, \"reuse downloaded file %s\", getUrl());\n                this.isReusedOldFile = true;\n\n\n                setStatus(FileDownloadStatus.completed);\n                FileDownloadList.getImpl().removeByCompleted(this);\n\n            } else {\n                FileDownloadLog.d(this, \"start downloaded by ui process %s\", getUrl());\n                this.isReusedOldFile = false;\n\n                downloadId = startExecute();\n                if (downloadId == 0) {\n                    setEx(new RuntimeException(\"not run download, not got download id\"));\n                    FileDownloadList.getImpl().removeByError(this);\n                }\n            }\n\n        } catch (Throwable e) {\n            e.printStackTrace();\n\n            setEx(e);\n            FileDownloadList.getImpl().removeByError(this);\n        }\n\n        FileDownloadLog.d(this, \"end call start url[%s], savePath[%s], listener[%s], isNeedNotification[%B], notificationTitle[%s], notificationDesc[%s],\" +\n                        \"tag[%s]\", url, savePath, listener, isNeedNotification, notificationTitle, notificationDesc,\n                tag);\n\n        return downloadId;\n\n    }\n","new_comment_raw":"start download","old_comment_raw":"start download","label":0,"pre_label":1,"AST_level":11,"line_counts":74,"new_code_token_num":470},{"new_code_raw":"public static boolean isComparable(RelDataType type1, RelDataType type2) { if (type1.isStruct() != type2.isStruct()) { return false; } if (type1.isStruct()) { int n = type1.getFieldCount(); if (n != type2.getFieldCount()) { return false; } for (int i = 0; i < n; ++i) { RelDataTypeField field1 = (RelDataTypeField) type1.getFieldList().get(i); RelDataTypeField field2 = (RelDataTypeField) type2.getFieldList().get(i); if (!isComparable( field1.getType(), field2.getType())) { return false; } } return true; } RelDataTypeFamily family1 = null; RelDataTypeFamily family2 = null; \/\/ REVIEW jvs 2-June-2005: This is needed to keep \/\/ the Saffron type system happy. if (type1.getSqlTypeName() != null) { family1 = type1.getSqlTypeName().getFamily(); } if (type2.getSqlTypeName() != null) { family2 = type2.getSqlTypeName().getFamily(); } if (family1 == null) { family1 = type1.getFamily(); } if (family2 == null) { family2 = type2.getFamily(); } if (family1 == family2) { return true; } \/* If one of the operators is of type 'ANY', return true *\/ if (family1 == SqlTypeFamily.ANY || family2 == SqlTypeFamily.ANY) return true; return false; }","old_code_raw":"    public static boolean isComparable(RelDataType type1, RelDataType type2)\n    {\n        if (type1.isStruct() != type2.isStruct()) {\n            return false;\n        }\n\n        if (type1.isStruct()) {\n            int n = type1.getFieldCount();\n            if (n != type2.getFieldCount()) {\n                return false;\n            }\n            for (int i = 0; i < n; ++i) {\n                RelDataTypeField field1 =\n                    (RelDataTypeField) type1.getFieldList().get(i);\n                RelDataTypeField field2 =\n                    (RelDataTypeField) type2.getFieldList().get(i);\n                if (!isComparable(\n                        field1.getType(),\n                        field2.getType()))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        RelDataTypeFamily family1 = null;\n        RelDataTypeFamily family2 = null;\n\n        \/\/ REVIEW jvs 2-June-2005:  This is needed to keep\n        \/\/ the Saffron type system happy.\n        if (type1.getSqlTypeName() != null) {\n            family1 = type1.getSqlTypeName().getFamily();\n        }\n        if (type2.getSqlTypeName() != null) {\n            family2 = type2.getSqlTypeName().getFamily();\n        }\n        if (family1 == null) {\n            family1 = type1.getFamily();\n        }\n        if (family2 == null) {\n            family2 = type2.getFamily();\n        }\n        if (family1 == family2) {\n            return true;\n        }\n        return false;\n    }\n","new_comment_raw":"Returns whether two types are comparable.","old_comment_raw":"Returns whether two types are comparable.","label":0,"pre_label":1,"AST_level":12,"line_counts":54,"new_code_token_num":268},{"new_code_raw":"public Definition emit(Class cls, String allowedMethods) throws Exception { this.cls = cls; this.allowedMethods = allowedMethods; \/** @todo ravi: getting the serviceName from cls name or explicitly ask the user? *\/ String name = cls.getName(); name = name.substring(name.lastIndexOf('.') + 1); setServiceName(name); return emit(); }","old_code_raw":"    public Document emit(Class cls, String allowedMethods) throws Exception {\n        this.cls = cls;\n        this.allowedMethods = allowedMethods;\n\n        \/** @todo ravi: getting the serviceName from cls name or explicitly ask the user? *\/\n        String name = cls.getName();\n        name = name.substring(name.lastIndexOf('.') + 1);\n        setServiceName(name);\n        return emit();\n    }\n","new_comment_raw":"Generates a WSDL Definition for a given Class and a space seperated list of methods at design time","old_comment_raw":"Generates a WSDL Document for a given Class and a space seperated list of methods at design time","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":74},{"new_code_raw":"public DateOnly roundHalfFloorCopy() { DateOnly instant = iInstant; return (DateOnly)instant.withMillis(iField.roundHalfFloor(instant.getMillis())); }","old_code_raw":"    public DateOnly roundHalfFloorCopy() {\n        DateOnly instant = iInstant;\n        return (DateOnly)instant.toCopy(iField.roundHalfFloor(instant.getMillis()));\n    }\n","new_comment_raw":"Rounds to the nearest whole unit of this field on a copy of this DateOnly, favoring the floor if halfway.","old_comment_raw":"Rounds to the nearest whole unit of this field on a copy of this DateOnly, favoring the floor if halfway.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"public static long toNanoOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration); } return ((Duration) value).toNanos(); } \/\/ TODO only needed for SQL Server\/Oracle, where we don't produce Duration right away; \/\/ this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return time.toNanoOfDay(); }","old_code_raw":"    public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) {\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster !=null) {\n            time = time.with(adjuster);\n        }\n        return time.toNanoOfDay();\n    }\n","new_comment_raw":"Get the number of nanoseconds past midnight of the given  Duration.","old_comment_raw":"Get the number of nanoseconds past midnight of the given java.time.LocalDateTime, java.time.LocalDate, java.time.LocalTime, java.util.Date, java.sql.Date, java.sql.Time, or java.sql.Timestamp, ignoring any date portions of the supplied value.","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":141},{"new_code_raw":"public Observable<Connectivity> observeNetworkConnectivity(final Context context) { final IntentFilter filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); return Observable.create(new Observable.OnSubscribe<Connectivity>() { @Override public void call(final Subscriber<? super Connectivity> subscriber) { final BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { subscriber.onNext(Connectivity.create(context)); } }; context.registerReceiver(receiver, filter); subscriber.add(unsubscribeInUiThread(new Action0() { @Override public void call() { context.unregisterReceiver(receiver); } })); } }).defaultIfEmpty(Connectivity.create()); }","old_code_raw":"  public Observable<ConnectivityStatus> observeNetworkConnectivity(final Context context) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);\n\n    return Observable.create(new Observable.OnSubscribe<ConnectivityStatus>() {\n      @Override public void call(final Subscriber<? super ConnectivityStatus> subscriber) {\n        final BroadcastReceiver receiver = new BroadcastReceiver() {\n          @Override public void onReceive(Context context, Intent intent) {\n            final ConnectivityStatus newStatus = getConnectivityStatus(context);\n\n            \/\/ we need to perform check below,\n            \/\/ because after going off-line, onReceive() is called twice\n            if (newStatus != status) {\n              status = newStatus;\n              subscriber.onNext(newStatus);\n            }\n          }\n        };\n\n        context.registerReceiver(receiver, filter);\n\n        subscriber.add(unsubscribeInUiThread(new Action0() {\n          @Override public void call() {\n            context.unregisterReceiver(receiver);\n          }\n        }));\n      }\n    }).defaultIfEmpty(ConnectivityStatus.OFFLINE);\n  }\n","new_comment_raw":"Observes network connectivity.","old_comment_raw":"Observes ConnectivityStatus, which can be WIFI_CONNECTED, MOBILE_CONNECTED or OFFLINE","label":1,"pre_label":0,"AST_level":14,"line_counts":24,"new_code_token_num":133},{"new_code_raw":"public boolean isCached(String requestUrl, int maxWidth, int maxHeight) { return isCached(requestUrl, maxWidth, maxHeight, ScaleType.CENTER_INSIDE); }","old_code_raw":"    public boolean isCached(String requestUrl, int maxWidth, int maxHeight) {\n        throwIfNotOnMainThread();\n\n        String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight);\n        return mCache.getBitmap(cacheKey) != null;\n    }\n","new_comment_raw":"Checks if the item is available in the cache.","old_comment_raw":"Checks if the item is available in the cache.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public Float getTopValue() { return topValue; }","old_code_raw":"        public float getTopValue() {\n            return topValue == null ? 0 : topValue.floatValue();\n        }\n","new_comment_raw":"Gets the 'top' attributes value in current units.","old_comment_raw":"Gets the 'top' CSS-attributes value in specified units.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public Chat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException { return dccHandler.sendChatRequest(sender); }","old_code_raw":"\tpublic DccChat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException {\r\n\t\tif (sender == null)\r\n\t\t\tthrow new IllegalArgumentException(\"Can't send chat request to null user\");\r\n\t\tServerSocket ss = null;\/\/dccManager.createServerSocket();\r\n\t\tss.setSoTimeout(timeout);\r\n\t\tint serverPort = ss.getLocalPort();\r\n\r\n\t\tInetAddress ourAddress = getDccInetAddress();\r\n\t\tif (ourAddress == null)\r\n\t\t\tourAddress = getInetAddress();\r\n\t\tString ipNum = DccManager.addressToInteger(ourAddress);\r\n\r\n\t\tsendCTCPCommand(sender, \"DCC CHAT chat \" + ipNum + \" \" + serverPort);\r\n\r\n\t\t\/\/ The client may now connect to us to chat.\r\n\t\tSocket userSocket = ss.accept();\r\n\r\n\t\t\/\/ Close the server socket now that we've finished with it.\r\n\t\tss.close();\r\n\r\n\t\treturn new DccChat(this, sender, userSocket);\r\n\t}\r\n","new_comment_raw":"Utility method to send a chat request to a user.","old_comment_raw":"Attempts to establish a DCC CHAT session with a client.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":23},{"new_code_raw":"public DateTime getShipDate() { return shipDate; }","old_code_raw":"    public Date getShipDate() {\n        return shipDate;\n    }\n","new_comment_raw":"Get shipDate","old_comment_raw":"Get shipDate","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public Throwable initCause(Throwable cause) { return super.initCause(cause); }","old_code_raw":"\tpublic Throwable initCause(Throwable cause) {\n\t\tthrow new IllegalStateException();\n\t}\n","new_comment_raw":"Initializes the cause of this exception to the specified value.","old_comment_raw":"The cause of this exception can only be set when constructed.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(final DiscoveryGroupConfiguration groupConfiguration, JMSFactoryType jmsFactoryType) { ActiveMQConnectionFactory factory = null; if (jmsFactoryType.equals(JMSFactoryType.CF)) { factory = new ActiveMQJMSConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) { factory = new ActiveMQQueueConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) { factory = new ActiveMQTopicConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) { factory = new ActiveMQXAConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) { factory = new ActiveMQXAQueueConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) { factory = new ActiveMQXATopicConnectionFactory(false, groupConfiguration); } return factory; }","old_code_raw":"   public static HornetQConnectionFactory createConnectionFactoryWithoutHA(final DiscoveryGroupConfiguration groupConfiguration, JMSFactoryType jmsFactoryType)\n   {\n      HornetQConnectionFactory factory = null;\n      if (jmsFactoryType.equals(JMSFactoryType.CF))\n      {\n         factory = new HornetQJMSConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF))\n      {\n         factory = new HornetQQueueConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF))\n      {\n         factory = new HornetQTopicConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.XA_CF))\n      {\n         factory = new HornetQXAConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF))\n      {\n         factory = new HornetQXAQueueConnectionFactory(false, groupConfiguration);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF))\n      {\n         factory = new HornetQXATopicConnectionFactory(false, groupConfiguration);\n      }\n\n      return factory;\n   }\n","new_comment_raw":"Create a ActiveMQConnectionFactory which creates session factories from a set of live servers, no HA backup information is propagated to the client","old_comment_raw":"Create a HornetQConnectionFactory which creates session factories from a set of live servers, no HA backup information is propagated to the client","label":1,"pre_label":0,"AST_level":13,"line_counts":32,"new_code_token_num":146},{"new_code_raw":"public static HashMap getXmlRpcWorkflowInstancePage( WorkflowInstancePage page) { HashMap pageHash = new HashMap(); pageHash.put(\"totalPages\", String.valueOf(page.getTotalPages())); pageHash.put(\"pageNum\", String.valueOf(page.getPageNum())); pageHash.put(\"pageSize\", String.valueOf(page.getPageSize())); pageHash.put(\"pageWorkflows\", getXmlRpcWorkflowInstances(page.getPageWorkflows())); return pageHash; }","old_code_raw":"  public static Hashtable getXmlRpcWorkflowInstancePage(\n      WorkflowInstancePage page) {\n    Hashtable pageHash = new Hashtable();\n    pageHash.put(\"totalPages\", String.valueOf(page.getTotalPages()));\n    pageHash.put(\"pageNum\", String.valueOf(page.getPageNum()));\n    pageHash.put(\"pageSize\", String.valueOf(page.getPageSize()));\n    pageHash.put(\"pageWorkflows\",\n        getXmlRpcWorkflowInstances(page.getPageWorkflows()));\n\n    return pageHash;\n\n  }\n","new_comment_raw":"Gets a  HashMap representation of a  WorkflowInstancePage that is serializable over the XML-RPC wire.","old_comment_raw":"Gets a Hashtable representation of a WorkflowInstancePage that is serializable over the XML-RPC wire.","label":1,"pre_label":0,"AST_level":6,"line_counts":14,"new_code_token_num":87},{"new_code_raw":"public Options useAstDefinitions(boolean flag) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeSchemaDefinition, flag, this.descriptionsAsHashComments, this.includeDirective, this.comparatorRegistry); }","old_code_raw":"        public Options useAstDefinitions(boolean flag) {\n            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, flag, this.descriptionsAsHashComments, this.includeDirective, this.comparatorRegistry);\n        }\n","new_comment_raw":"This flag controls whether schema printer will use the  graphql.schema.GraphQLType's original Ast  graphql.language.TypeDefinitions when printing the type.","old_comment_raw":"This flag controls whether schema printer will use the graphql.schema.GraphQLType's original Ast graphql.language.TypeDefinitions when printing the type.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException { checkClosed(); if (topic instanceof CustomDestination) { CustomDestination customDestination = (CustomDestination) topic; return customDestination.createSubscriber(this, messageSelector, noLocal); } ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy(); return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation .transformDestination(topic), null, messageSelector, prefetchPolicy.getTopicPrefetch(), prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch); }","old_code_raw":"    public TopicSubscriber createSubscriber(Topic topic, String messageSelector, boolean noLocal) throws JMSException {\n        checkClosed();\n        ActiveMQPrefetchPolicy prefetchPolicy = this.connection.getPrefetchPolicy();\n        return new ActiveMQTopicSubscriber(this, getNextConsumerId(), ActiveMQMessageTransformation\n                .transformDestination(topic), null, messageSelector, prefetchPolicy.getTopicPrefetch(), \n                prefetchPolicy.getMaximumPendingMessageLimit(), noLocal, false, asyncDispatch);\n    }\n","new_comment_raw":"Creates a nondurable subscriber to the specified topic, using a message selector or specifying whether messages published by its own connection should be delivered to it.","old_comment_raw":"Creates a nondurable subscriber to the specified topic, using a message selector or specifying whether messages published by its own connection should be delivered to it.","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":92},{"new_code_raw":"public VariableInspector variableInspector() { return inspector; }","old_code_raw":"  public VariableInspector variableInspector() {\n    return tray;\n  }\n","new_comment_raw":"Access variable inspector window.","old_comment_raw":"Access variable inspector window.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public DateTimeField minuteOfHour() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfHour(), minutes()); }","old_code_raw":"    public DateTimeField minuteOfHour() {\n        return UnsupportedDateTimeField.getInstance(\"minuteOfHour\", minutes());\n    }\n","new_comment_raw":"Get the minute of hour field for this chronology.","old_comment_raw":"Get the minute of hour field for this chronology.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public Hashtable getBuiltInTypes() { return (Hashtable)fBuiltInTypes.clone(); }","old_code_raw":"    @Override\n    public Map<String, DatatypeValidator> getBuiltInTypes() {\n        return new HashMap<>(fBuiltInTypes);\n    }\n","new_comment_raw":"get all built-in DVs, which are stored in a hashtable keyed by the name","old_comment_raw":"get all built-in DVs, which are stored in a Map keyed by the name","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public static String versionName() { return \"1.0.3\"; }","old_code_raw":"    public static String versionName() {\n        return \"1.0.2\";\n    }\n","new_comment_raw":"Get version name of NoHttp.","old_comment_raw":"Get version name of NoHttp.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public ArrayList getLinkHRefs() { return this.link_href; }","old_code_raw":"    public ArrayList getLinkHRefs() {\n        return link_href;\n    }\n","new_comment_raw":"Get a list of links","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"@Override public Object clone() { try { DBTable clone = (DBTable) super.clone(); \/\/ clone all columns Class<?> colClass = columns.get(0).getClass(); Class<?> colBase = colClass.getSuperclass(); clone.columns = new ArrayList<DBColumn>(); Field[] fields = getClass().getFields(); for (int i = 0; i < columns.size(); i++) { DBTableColumn srcCol = (DBTableColumn) columns.get(i); DBTableColumn newCol = new DBTableColumn(clone, srcCol); \/\/ Replace all references for oldCol to newCol for (int j = 0; j < fields.length; j++) { \/\/ Find a class of Type DBColumn or DBTableColumn Class<?> type = fields[j].getType(); if (type == colClass || type == colBase) { try { \/\/ Check if the field points to the old Value if (fields[j].get(clone) == srcCol) fields[j].set(clone, newCol); } catch (Exception e) { \/\/ IllegalAccessException or IllegalArgumentException String fieldName = fields[j].getName(); log.error(\"Cannot adjust declared table field: \" + fieldName + \". Reason is: \" + e.getMessage()); \/\/ throw CloneNotSupportedException CloneNotSupportedException cnse = new CloneNotSupportedException(\"Unable to replace field reference for field \" + fieldName); cnse.initCause(e); throw cnse; } } } } \/\/ set new alias clone.alias = \"t\" + String.valueOf(tableCount.incrementAndGet()); \/\/ done log.info(\"clone: Table \" + name + \" cloned! Alias old=\" + alias + \" new=\" + clone.alias); return clone; } catch (CloneNotSupportedException e) { \/\/ unable to clone table log.error(\"Unable to clone table \" + getName()); throw new RuntimeException(e); } }","old_code_raw":"    @Override\n    public Object clone()\n    {\n        try\n        {\n            DBTable clone = (DBTable) super.clone();\n            \/\/ clone all columns\n            Class<?> colClass = columns.get(0).getClass();\n            Class<?> colBase = colClass.getSuperclass();\n            clone.columns = new ArrayList<DBColumn>();\n            Field[] fields = getClass().getDeclaredFields();\n            for (int i = 0; i < columns.size(); i++)\n            {\n                DBTableColumn srcCol = (DBTableColumn) columns.get(i);\n                DBTableColumn newCol = new DBTableColumn(clone, srcCol);\n                \/\/ Replace all references for oldCol to newCol\n                for (int j = 0; j < fields.length; j++)\n                { \/\/ Find a class of Type DBColumn or DBTableColumn\n                    Class<?> type = fields[j].getType();\n                    if (type == colClass || type == colBase)\n                    {\n                        try\n                        {\n                            \/\/ Check if the field points to the old Value\n                            if (fields[j].get(clone) == srcCol)\n                                fields[j].set(clone, newCol);\n                        } catch (Exception e)\n                        {\n                            \/\/ IllegalAccessException or IllegalArgumentException\n                            log.error(\"clone: Cannot clone table-member: \" + fields[j].getName() + \"-->\" + e.getMessage());\n                        }\n                    }\n                }\n            }\n            \/\/ set new alias\n            clone.alias = \"t\" + String.valueOf(tableCount.incrementAndGet());\n            \/\/ done\n            log.info(\"clone: Table \" + name + \" cloned! Alias old=\" + alias + \" new=\" + clone.alias);\n            return clone;\n        } catch (CloneNotSupportedException e)\n        {\n            return null;\n        }\n    }\n","new_comment_raw":"Clones this table and assigns a new table alias.","old_comment_raw":"Clones this object.","label":1,"pre_label":0,"AST_level":17,"line_counts":50,"new_code_token_num":367},{"new_code_raw":"private static CoreMap fromProto(CoreNLPProtos.Sentence proto) { CoreMap sentence = new ArrayCoreMap(); \/\/ Required fields sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin()); sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd()); \/\/ Optional fields if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); } if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); } if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); } if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); } \/\/ Non-default fields if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) { \/\/ set entities List<EntityMention> entities = new ArrayList<EntityMention>(); for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); } sentence.set(EntityMentionsAnnotation.class, entities); \/\/ set relations List<RelationMention> relations = new ArrayList<RelationMention>(); for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); } sentence.set(RelationMentionsAnnotation.class, relations); } \/\/ Return return sentence; }","old_code_raw":"  protected CoreLabel fromProto(CoreNLPProtos.Token proto) {\n    CoreLabel word = new CoreLabel();\n    \/\/ Required fields\n    word.setWord(proto.getWord());\n    \/\/ Optional fields\n    if (proto.hasPos()) { word.setTag(proto.getPos()); }\n    if (proto.hasValue()) { word.setValue(proto.getValue()); }\n    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }\n    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }\n    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }\n    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }\n    if (proto.hasNer()) { word.setNER(proto.getNer()); }\n    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }\n    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }\n    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }\n    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }\n    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }\n    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }\n    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }\n    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }\n    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }\n    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }\n    if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); }\n    if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); }\n    if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); }\n    if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); }\n    \/\/ Non-default annotators\n    if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); }\n    if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); }\n    if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); }\n    \/\/ Return\n    return word;\n  }\n","new_comment_raw":"Create a CoreMap representing a sentence from this protocol buffer.","old_comment_raw":"Create a CoreLabel from its serialized counterpart.","label":1,"pre_label":0,"AST_level":10,"line_counts":25,"new_code_token_num":256},{"new_code_raw":"public boolean isSentenceFinalPunctuationTag(String str) { return sFPunctTagStringAcceptFilter.test(str); }","old_code_raw":"  public boolean isSentenceFinalPunctuationTag(String str) {\n    return sFPunctTagStringAcceptFilter.accept(str);\n  }\n","new_comment_raw":"Accepts a String that is a sentence end punctuation tag, and rejects everything else.","old_comment_raw":"Accepts a String that is a sentence end punctuation tag, and rejects everything else.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"private GridHubConfiguration getHubConfiguration() throws Exception { String hubApi = \"http:\/\/\" + registrationRequest.getConfiguration().getHubHost() + \":\" + registrationRequest.getConfiguration().getHubPort() + \"\/grid\/api\/hub\"; URL api = new URL(hubApi); HttpClient client = httpClientFactory.createClient(api); String url = api.toExternalForm(); HttpRequest request = new HttpRequest(GET, url); HttpResponse response = client.execute(request); try (Reader reader = new StringReader(response.getContentString()); JsonInput jsonInput = new Json().newInput(reader)) { return StandaloneConfiguration.loadFromJson(jsonInput, GridHubConfiguration.class); } }","old_code_raw":"  private GridHubConfiguration getHubConfiguration() throws Exception {\n    String hubApi =\n      \"http:\/\/\" + registrationRequest.getConfiguration().getHubHost() + \":\"\n      + registrationRequest.getConfiguration().getHubPort() + \"\/grid\/api\/hub\";\n\n    URL api = new URL(hubApi);\n    HttpClient client = httpClientFactory.createClient(api);\n    String url = api.toExternalForm();\n    HttpRequest request = new HttpRequest(GET, url);\n\n    HttpResponse response = client.execute(request);\n    return GridHubConfiguration.loadFromJSON(extractObject(response));\n  }\n","new_comment_raw":"uses the hub API to get some of its configuration.","old_comment_raw":"uses the hub API to get some of its configuration.","label":0,"pre_label":1,"AST_level":10,"line_counts":17,"new_code_token_num":124},{"new_code_raw":"public Chronology getChronology(Object object, DateTimeZone zone) { if (object.getClass().getName().endsWith(\".BuddhistCalendar\")) { return BuddhistChronology.getInstance(zone); } else if (object instanceof GregorianCalendar) { GregorianCalendar gc = (GregorianCalendar) object; long cutover = gc.getGregorianChange().getTime(); if (cutover == Long.MIN_VALUE) { return GregorianChronology.getInstance(zone); } else if (cutover == Long.MAX_VALUE) { return JulianChronology.getInstance(zone); } else { return GJChronology.getInstance(zone, cutover, 4); } } else { return ISOChronology.getInstance(zone); } }","old_code_raw":"    public Chronology getChronology(Object object, DateTimeZone zone) {\n        if (object.getClass().getName().endsWith(\".BuddhistCalendar\")) {\n            return BuddhistChronology.getInstance(zone);\n        } else if (object instanceof GregorianCalendar) {\n            GregorianCalendar gc = (GregorianCalendar) object;\n            long cutover = gc.getGregorianChange().getTime();\n            if (cutover == Long.MIN_VALUE) {\n                return GregorianChronology.getInstance(zone);\n            } else if (cutover == Long.MAX_VALUE) {\n                return JulianChronology.getInstance(zone);\n            } else {\n                return GJChronology.getInstance(zone, cutover, 4);\n            }\n        } else {\n            return ChronologyType.iso().getChronology(zone);\n        }\n    }\n","new_comment_raw":"Gets the chronology, which is the GJChronology if a GregorianCalendar is used,","old_comment_raw":"Gets the chronology, which is the GJChronology if a GregorianCalendar is used,","label":0,"pre_label":1,"AST_level":11,"line_counts":18,"new_code_token_num":118},{"new_code_raw":"public static TsurgeonPattern parseOperation(String operationString) { try { TsurgeonParser parser = new TsurgeonParser(new StringReader(operationString + \"\\n\")); return new TsurgeonPatternRoot(new TsurgeonPattern[] {parser.Root()} ); } catch(ParseException e) { throw new TsurgeonParseException(\"Error parsing Tsurgeon expression: \" + operationString, e); } catch(TokenMgrError e) { throw new TsurgeonParseException(\"Error parsing Tsurgeon expression: \" + operationString, e); } }","old_code_raw":"  public static TsurgeonPattern parseOperation(String operationString) {\n    try {\n      TsurgeonParser parser =\n        new TsurgeonParser(new StringReader(operationString + '\\n'));\n      return parser.Root();\n    } catch (ParseException | TokenMgrError e) {\n      throw new TsurgeonParseException(\"Error parsing Tsurgeon expression: \" +\n                                       operationString, e);\n    }\n  }\n","new_comment_raw":"Parses an operation string into a  TsurgeonPattern.","old_comment_raw":"Parses an operation string into a TsurgeonPattern.","label":0,"pre_label":1,"AST_level":9,"line_counts":14,"new_code_token_num":94},{"new_code_raw":"@Override public Object put(Object value) { return put(value, false); }","old_code_raw":"\t@Override\n\tpublic Object put(Object value) {\n\t\treturn put(null, value);\n\t}\n","new_comment_raw":"encode = false","old_comment_raw":"encode = true","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":19},{"new_code_raw":"public static EString concat(Expr<String> left, String right) { return factory.createString(Ops.CONCAT, left, factory.createConstant(right)); }","old_code_raw":"    public static EString concat(Expr<String> left, String right) {\n        return createString(Ops.CONCAT, left, createConstant(right));\n    }\n","new_comment_raw":"Expr : left || right","old_comment_raw":"Expr : left || right","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public boolean useFollowOnLocking() { return useFollowOnLocking( null ); }","old_code_raw":"\tpublic boolean useFollowOnLocking() {\n\t\treturn false;\n\t}\n","new_comment_raw":"Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).","old_comment_raw":"Some dialects have trouble applying pessimistic locking depending upon what other query options are specified (paging, ordering, etc).","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public int getRowStatus(int aRow) throws IndexOutOfBoundsException { RowData row = this.getRow(aRow); if (row.isNew()) { return RowData.NEW; } else if (row.isModified()) { return RowData.MODIFIED; } else { return RowData.NOT_MODIFIED; } }","old_code_raw":"\tpublic Integer getRowStatus(int aRow)\n\t\tthrows IndexOutOfBoundsException\n\t{\n\t\tRowData row = this.getRow(aRow);\n\t\tif (row.isOriginal())\n\t\t{\n\t\t\treturn ROW_ORIGINAL;\n\t\t}\n\t\telse if (row.isNew())\n\t\t{\n\t\t\treturn ROW_NEW;\n\t\t}\n\t\telse if (row.isModified())\n\t\t{\n\t\t\treturn ROW_MODIFIED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ROW_ORIGINAL;\n\t\t}\n\t}\n","new_comment_raw":"Return the status value for the given row.","old_comment_raw":"Return the status object for the given row.","label":1,"pre_label":0,"AST_level":7,"line_counts":19,"new_code_token_num":53},{"new_code_raw":"public static EBoolean like(Expr<String> left, String right) { return operationFactory.createBoolean(Ops.LIKE, left, exprFactory.createConstant(right)); }","old_code_raw":"    public static EBoolean like(Expr<String> left, String right) {                \n        return factory.createBoolean(Ops.LIKE, left, factory.createConstant(right));\n    }\n","new_comment_raw":"Expr : left like right","old_comment_raw":"Expr : left like right","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public boolean add(E o) { return super.add(o); }","old_code_raw":"    public boolean add(E e) {\n        return offer(e);\n    }\n","new_comment_raw":"Adds the specified element to this queue.","old_comment_raw":"Inserts the specified element into this priority queue.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"private Iterable<TransactionObserver> observers() { if ( observers == null || observers.isEmpty() ) { return Collections.emptyList(); } else { return new ArrayList<>( observers ); } }","old_code_raw":"\tprivate Iterable<TransactionObserver> observers() {\n\t\treturn new ArrayList<>( observers );\n\t}\n","new_comment_raw":"Needed because while iterating the observers list and executing the before\/update callbacks, some observers might get removed from the list.","old_comment_raw":"Needed because while iterating the observers list and executing the before\/update callbacks, some observers might get removed from the list.","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":37},{"new_code_raw":"public File getGeneratedOutput() throws CurnException { return null; }","old_code_raw":"    public InputStream getGeneratedOutput()\n        throws CurnException\n    {\n        return null;\n    }\n","new_comment_raw":"Get the File that represents the output produced by the handler, if applicable.","old_comment_raw":"Get an InputStream that can be used to read the output data produced by the handler, if applicable.","label":1,"pre_label":0,"AST_level":4,"line_counts":7,"new_code_token_num":12},{"new_code_raw":"public HBaseResponse getHTableInfo(String tableName) throws IOException { Configuration hconf = HadoopUtil.getCurrentHBaseConfiguration(); HTable table = null; HBaseResponse hr = null; long tableSize = 0; int regionCount = 0; try { table = new HTable(hconf, tableName); HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table); Map<byte[], Long> sizeMap = cal.getRegionSizeMap(); for (long s : sizeMap.values()) { tableSize += s; } regionCount = sizeMap.size(); \/\/ Set response. hr = new HBaseResponse(); hr.setTableSize(tableSize); hr.setRegionCount(regionCount); } finally { if (null != table) { table.close(); } } return hr; }","old_code_raw":"    public HBaseResponse getHTableInfo(String tableName) throws IOException {\n        if (htableInfoCache.containsKey(tableName)) {\n            return htableInfoCache.get(tableName);\n        }\n\n        \/\/ Get HBase storage conf.\n        String hbaseUrl = KylinConfig.getInstanceFromEnv().getStorageUrl();\n        Configuration hconf = HBaseConnection.newHBaseConfiguration(hbaseUrl);\n\n        HTable table = null;\n        HBaseResponse hr = null;\n        long tableSize = 0;\n        int regionCount = 0;\n\n        try {\n            table = new HTable(hconf, tableName);\n\n            HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table);\n            Map<byte[], Long> sizeMap = cal.getRegionSizeMap();\n\n            for (long s : sizeMap.values()) {\n                tableSize += s;\n            }\n\n            regionCount = sizeMap.size();\n\n            \/\/ Set response.\n            hr = new HBaseResponse();\n            hr.setTableSize(tableSize);\n            hr.setRegionCount(regionCount);\n        } finally {\n            if (null != table) {\n                table.close();\n            }\n        }\n\n        htableInfoCache.put(tableName, hr);\n\n        return hr;\n    }\n","new_comment_raw":"Calculate size of each region for given table and other info of the table.","old_comment_raw":"Calculate size of each region for given table and other info of the table.","label":0,"pre_label":1,"AST_level":8,"line_counts":32,"new_code_token_num":129},{"new_code_raw":"public ReporterData getSingleData(Xref idc) { List<ReporterData> dlist = data.get(idc); if(dlist != null && dlist.size() > 0) return dlist.get(0); return null; }","old_code_raw":"\tpublic Data getSingleData(Xref idc) {\n\t\tList<Data> dlist = data.get(idc);\n\t\tif(dlist != null && dlist.size() > 0) return dlist.get(0);\n\t\treturn null;\n\t}\n","new_comment_raw":"Get the first  ReporterData instance of the cached data for this gene-product.","old_comment_raw":"Get the first Data instance of the cached data for this gene-product.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 48: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 49: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 50: break; case 15: { return handleQuotes(yytext(), false); } case 51: break; case 30: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 52: break; case 42: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 53: break; case 29: { return getNormalizedAmpNext(); } case 54: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return getNext(); } case 55: break; case 40: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return getNext(); } case 56: break; case 37: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 57: break; case 4: { return getNext(); } case 58: break; case 21: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 59: break; case 34: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 60: break; case 35: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 61: break; case 44: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 62: break; case 47: { String txt = yytext(); if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 63: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 64: break; case 7: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 65: break; case 27: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 66: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 67: break; case 41: { yypushback(2) ; return getNext(); } case 68: break; case 32: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, yytext()); } case 69: break; case 24: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 70: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 71: break; case 43: { yypushback(3) ; return getNext(); } case 72: break; case 22: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 73: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 74: break; case 23: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 75: break; case 33: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 76: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 77: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 78: break; case 11: { return handleEllipsis(yytext()); } case 79: break; case 31: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 80: break; case 13: { return normalizeFractions(yytext()); } case 81: break; case 14: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 82: break; case 38: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 83: break; case 10: { if (invertible) { prevWordAfter.append(yytext()); } } case 84: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 85: break; case 39: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 86: break; case 12: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 87: break; case 26: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 88: break; case 9: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 89: break; case 28: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 90: break; case 25: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 91: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 92: break; case 36: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 93: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 94: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 23: \n          { final String origTxt = yytext();\n\t\t\t  String txt = origTxt;\n       \t\t\t  if (normalizeSpace) {\n\t\t\t    txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n\t\t\t  }\n                          return getNext(txt, origTxt);\n          }\n        case 45: break;\n        case 31: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { \/* invert quote - often but not always right *\/\n\t\t  return handleQuotes(yytext(), true);\n          }\n        case 46: break;\n        case 8: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 47: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 48: break;\n        case 38: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 49: break;\n        case 15: \n          { return handleQuotes(yytext(), false);\n          }\n        case 50: break;\n        case 30: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 51: break;\n        case 12: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n\t            return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n\t\t  }\n          }\n        case 52: break;\n        case 40: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 53: break;\n        case 29: \n          { return getNormalizedAmpNext();\n          }\n        case 54: break;\n        case 37: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 55: break;\n        case 4: \n          { return getNext();\n          }\n        case 56: break;\n        case 21: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 57: break;\n        case 34: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 58: break;\n        case 35: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 59: break;\n        case 42: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 60: break;\n        case 6: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 61: break;\n        case 27: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 62: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 63: break;\n        case 32: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 64: break;\n        case 24: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 65: break;\n        case 44: \n          { String txt = yytext();\n\t\t\t  if (normalizeSpace) {\n\t\t\t    txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n\t\t\t  }\n\t\t\t  if (normalizeParentheses) {\n\t\t\t    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n\t\t\t    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n\t\t\t  }\n\t\t\t  return getNext(txt, yytext());\n          }\n        case 66: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 67: break;\n        case 41: \n          { yypushback(3) ; return getNext();\n          }\n        case 68: break;\n        case 22: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 69: break;\n        case 2: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 70: break;\n        case 33: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 71: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 72: break;\n        case 25: \n          { \/\/ this one should only match if we're basically at the end of file\n\t\t\t  \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 73: break;\n        case 43: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n\t\t\t    char last = yycharat(yylength()-1);\n\t\t\t    if (last == ' ' || last == '\\t') {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 74: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 75: break;\n        case 11: \n          { return handleEllipsis(yytext());\n          }\n        case 76: break;\n        case 13: \n          { return normalizeFractions(yytext());\n          }\n        case 77: break;\n        case 14: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 78: break;\n        case 10: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 79: break;\n        case 3: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 80: break;\n        case 39: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 81: break;\n        case 26: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 82: break;\n        case 7: \n          { final String origTxt = yytext();\n\t\t\t  String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 83: break;\n        case 9: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 84: break;\n        case 28: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 85: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 86: break;\n        case 36: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 87: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 88: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) { \n            prevWordAfter.append(yytext()); \n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","old_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","label":0,"pre_label":1,"AST_level":17,"line_counts":593,"new_code_token_num":3467},{"new_code_raw":"public Set<String> getKeySet() throws CoreException { return DBProperty.getKeySet(db, index); }","old_code_raw":"\tpublic Set getKeySet() throws CoreException {\n\t\treturn DBProperty.getKeySet(db, index);\n\t}\n","new_comment_raw":"Returns the Set of property names stored in this object","old_comment_raw":"Returns a Set of property names (Strings) stored in this object","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"private StreamEvent findIfActualMax(AttributeDetails latestEvent) { int indexCurrentMax = valueStack.indexOf(currentMax); int postBound = valueStack.indexOf(latestEvent) - indexCurrentMax; \/\/ If latest event is at a distance greater than maxPostBound from max, max is not eligible to be sent as output if (postBound > maxPostBound) { currentMax.notEligibleForRealMax(); return null; } \/\/ If maxPreBound is 0, no need to check preBoundChange. Send output with postBound value if (maxPreBound == 0) { StreamEvent outputEvent = eventStack.get(indexCurrentMax); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { \"max\", 0, postBound }); currentMax.sentOutputAsRealMax(); return outputEvent; } int preBound = 1; double dThreshold = currentMax.getValue() - currentMax.getValue() * preBoundChange \/ 100; while (preBound <= maxPreBound && indexCurrentMax - preBound >= 0) { if (valueStack.get(indexCurrentMax - preBound).getValue() <= dThreshold) { StreamEvent outputEvent = eventStack.get(indexCurrentMax); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { \"max\", preBound, postBound }); currentMax.sentOutputAsRealMax(); return outputEvent; } ++preBound; } \/\/ Completed iterating through maxPreBound older events. No events which satisfy preBoundChange condition found. \/\/ Therefore max is not eligible to be sent as output. currentMax.notEligibleForRealMax(); return null; }","old_code_raw":"    private StreamEvent findIfActualMax(attributeDetails latestEvent) {\n        int indexCurrentMax = valueStack.indexOf(currentMax);\n        int actual_L = valueStack.indexOf(latestEvent) - indexCurrentMax;\n        \/\/ If latest event is at a distance greater than L from max, max is not eligible to be sent as output\n        if (actual_L > L) {\n            currentMax.notEligibleForRealMax();\n            return null;\n        }\n        int actual_l = 1;\n        double dThreshold = currentMax.getValue() - currentMax.getValue() * d \/ 100;\n        while (actual_l <= l && indexCurrentMax - actual_l >= 0) {\n            if (valueStack.get(indexCurrentMax - actual_l).getValue() <= dThreshold) {\n                StreamEvent outputEvent = eventStack.get(indexCurrentMax);\n                complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { \"max\", actual_l, actual_L });\n                currentMax.sentOutputAsRealMax();\n                return outputEvent;\n            }\n            ++actual_l;\n        }\n        \/\/ Completed iterating through l older events. No events which satisfy d condition found.\n        \/\/ Therefore max is not eligible to be sent as output.\n        currentMax.notEligibleForRealMax();\n        return null;\n    }\n","new_comment_raw":"Method to find whether a value preBoundChange% less than or equal to max exists within maxPreBound length window, by looping through older events.","old_comment_raw":"Method to find whether a value d% less than or equal to max exists within l length window, by looping through older events.","label":1,"pre_label":0,"AST_level":11,"line_counts":33,"new_code_token_num":250},{"new_code_raw":"public static RequestBody getReferencedRequestBody(OpenAPI openAPI, RequestBody requestBody) { if (requestBody != null && StringUtils.isNotEmpty(requestBody.get$ref())) { String name = getSimpleRef(requestBody.get$ref()); RequestBody referencedRequestBody = getRequestBody(openAPI, name); if(referencedRequestBody != null) { return referencedRequestBody; } } return requestBody; }","old_code_raw":"    public static RequestBody getReferencedRequestBody(OpenAPI openAPI, RequestBody requestBody) {\n        if (requestBody != null && StringUtils.isNotEmpty(requestBody.get$ref())) {\n            String name = getSimpleRef(requestBody.get$ref());\n            return getRequestBody(openAPI, name);\n        }\n        return requestBody;\n    }\n","new_comment_raw":"If a RequestBody contains a reference to an other RequestBody with '$ref', returns the referenced RequestBody if it is found or the actual RequestBody in the other cases.","old_comment_raw":"If a RequestBody contains a reference to an other RequestBody with '$ref', returns the referenced RequestBody or the actual RequestBody in the other cases.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public PayloadBuilder resizeAlertBody(int payloadLength) { return resizeAlertBody(payloadLength, \"\"); }","old_code_raw":"    public PayloadBuilder resizeAlertBody(int payloadLength) {\n        int currLength = length();\n        if (currLength < payloadLength)\n            return this;\n\n        int d = currLength - payloadLength;\n        String body = (String)aps.get(\"alert\");\n\n        if (body.length() < d)\n            aps.remove(\"alert\");\n        else\n            aps.put(\"alert\", body.subSequence(0, body.length() - d));\n\n        return this;\n    }\n","new_comment_raw":"Shrinks the alert message body so that the resulting payload message fits within the passed expected payload length.","old_comment_raw":"Shrinks the alert message body so that the resulting payload message fits within the passed expected payload length.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile requiredFile, String additionalMetadata) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, fut); })); }","old_code_raw":"    public Single<ModelApiResponse> rxUploadFileWithRequiredFile(Long petId, AsyncFile file, String additionalMetadata) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.uploadFileWithRequiredFile(petId, file, additionalMetadata, fut);\n        }));\n    }\n","new_comment_raw":"uploads an image (required)","old_comment_raw":"uploads an image (required)","label":0,"pre_label":1,"AST_level":10,"line_counts":6,"new_code_token_num":46},{"new_code_raw":"public EReference getTopic_Item() { return (EReference) topicEClass.getEStructuralFeatures().get(4); }","old_code_raw":"\tpublic EReference getTopic_Item() {\n\t\treturn (EReference) topicEClass.getEStructuralFeatures().get(5);\n\t}\n","new_comment_raw":"Returns the meta object for the container reference ' org.eclipse.mylyn.reviews.core.model.ITopic#getItem Item'.","old_comment_raw":"Returns the meta object for the reference ' org.eclipse.mylyn.reviews.core.model.ITopic#getItem Item'.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"public YearMonth addWrapFieldToCopy(int valueToAdd) { int[] newValues = iBase.getValues(); newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd); return new YearMonth(iBase, newValues); }","old_code_raw":"        public YearMonth addWrapFieldToCopy(int valueToAdd) {\n            int[] newValues = iYearMonth.getValues();\n            newValues = getField().addWrapField(iYearMonth, iFieldIndex, newValues, valueToAdd);\n            return new YearMonth(iYearMonth, newValues);\n        }\n","new_comment_raw":"Adds to the value of this field in a copy of this YearMonth wrapping within this field if the maximum value is reached.","old_comment_raw":"Adds to the value of this field in a copy of this YearMonth wrapping within this field if the maximum value is reached.","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":42},{"new_code_raw":"public MutableDirectBuffer buffer() { return mutableDirectBuffer; }","old_code_raw":"    public ClientProtocolBuffer buffer() {\n        return protocolBuffer;\n    }\n","new_comment_raw":"The  MutableDirectBuffer that encapsulates the internal buffer.","old_comment_raw":"The ClientProtocolBuffer that encapsulates the internal buffer.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public EditText getEditText(String text) { return getter.getView(EditText.class, text, false); }","old_code_raw":"\tpublic EditText getEditText(String text)\n\t{\n\t\treturn viewFetcher.getView(EditText.class, text, false);\n\t}\n","new_comment_raw":"Returns an EditText which shows a given text.","old_comment_raw":"Returns an EditText which shows a given text.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":21},{"new_code_raw":"public boolean needCache() { return RequestMethod.GET == getRequestMethod(); }","old_code_raw":"\tpublic boolean needCache() {\n\t\treturn !TextUtils.isEmpty(getCacheKey());\n\t}\n","new_comment_raw":"Randomly generated boundary mark","old_comment_raw":"Randomly generated boundary mark","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public int getReadTimeout() { return httpClient.readTimeoutMillis(); }","old_code_raw":"    public int getReadTimeout() {\n        return httpClient.getReadTimeout();\n    }\n","new_comment_raw":"Get read timeout (in milliseconds).","old_comment_raw":"Get read timeout (in milliseconds).","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public ArrayList<View> getViews() { try { return ensureArrayListOrNull(viewFetcher.getViews()); } catch (Exception e) { e.printStackTrace(); return null; } }","old_code_raw":"\tpublic ArrayList<View> getViews() {\n\t\treturn ensureArrayListOrNull(viewFetcher.getViews());\n\t}\n","new_comment_raw":"Returns a  List of the  Views located in the current  Activity.","old_comment_raw":"Returns a List of the Views located in the current Activity.","label":0,"pre_label":1,"AST_level":6,"line_counts":9,"new_code_token_num":35},{"new_code_raw":"public EvictionConfig getEvictionConfig() { return evictionConfig; }","old_code_raw":"    public CacheEvictionConfig getEvictionConfig() {\n        return evictionConfig;\n    }\n","new_comment_raw":"Gets the  EvictionConfig instance for eviction configuration of the cache config.","old_comment_raw":"Gets the CacheEvictionConfig instance for eviction configuration of the cache config.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public Table removeTable(TableId tableId) { return lock.write(() -> { changes.add(tableId); return tablesByTableId.remove(tableId); }); }","old_code_raw":"    public Table removeTable(TableId tableId) {\n        return lock.write(() -> tablesByTableId.remove(tableId));\n    }\n","new_comment_raw":"Remove the definition of the identified table.","old_comment_raw":"Remove the definition of the identified table.","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":33},{"new_code_raw":"public static MatchFinder allOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (!finder.matches(element)) { return false; } } return true; } @Override public String toString() { return \"allOf(\" + Joiner.on(\",\").join(finders) + \")\"; } }; }","old_code_raw":"  public static ElementMatcher allOf(final ElementMatcher... matchers) {\n    return new ElementMatcher() {\n      @Override\n      public boolean matches(UiElement element) {\n        for (ElementMatcher matcher : matchers) {\n          if (!matcher.matches(element)) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      @Override\n      public String toString() {\n        return \"allOf(\" + Joiner.on(\",\").join(matchers) + \")\";\n      }\n    };\n  }\n","new_comment_raw":"Evaluates given @finders in short-circuit fashion in the order they are passed.","old_comment_raw":"Evaluates given @matchers in short-circuit fashion in the order they are passed.","label":1,"pre_label":0,"AST_level":11,"line_counts":20,"new_code_token_num":87},{"new_code_raw":"@SuppressWarnings(\"static-access\") public ObjectName getQueueObjectName(String virtualHostName, String queue) { \/\/ Get the name of the test manager AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = \"org.apache.qpid:type=VirtualHost.Queue,VirtualHost=\" + virtualHostName + \",name=\" + queue + \",*\"; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(\"Null ObjectName Set returned\", objectNames); _test.assertEquals(\"Incorrect number of queues with name '\" + allObject.querystring + \"' returned\", 1, objectNames.size()); \/\/ We have verified we have only one value in objectNames so return it ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(\"Loading: \" + objectName); return objectName; }","old_code_raw":"    public ObjectName getQueueObjectName(String virtualHostName, String queue)\n    {\n        \/\/ Get the name of the test manager\n        AllObjects allObject = new AllObjects(_mbsc);\n        allObject.querystring = \"org.apache.qpid:type=VirtualHost.Queue,VirtualHost=\" + virtualHostName + \",name=\" + queue + \",*\";\n\n        Set<ObjectName> objectNames = allObject.returnObjects();\n\n        _test.assertNotNull(\"Null ObjectName Set returned\", objectNames);\n        _test.assertEquals(\"Incorrect number of queues with name '\" + allObject.querystring +\n                           \"' returned\", 1, objectNames.size());\n\n        \/\/ We have verified we have only one value in objectNames so return it\n        return objectNames.iterator().next();\n    }\n","new_comment_raw":"Retrive the ObjectName for the given Queue on a Virtualhost.","old_comment_raw":"Retrive the ObjectName for the given Exchange on the test Virtualhost.","label":1,"pre_label":0,"AST_level":9,"line_counts":20,"new_code_token_num":158},{"new_code_raw":"public List<CodegenSecurity> fromSecurity(Map<String, SecurityScheme> securitySchemeMap) { if (securitySchemeMap == null) { return Collections.emptyList(); } List<CodegenSecurity> codegenSecurities = new ArrayList<CodegenSecurity>(securitySchemeMap.size()); for (String key : securitySchemeMap.keySet()) { final SecurityScheme securityScheme = securitySchemeMap.get(key); CodegenSecurity cs = CodegenModelFactory.newInstance(CodegenModelType.SECURITY); cs.name = key; cs.type = securityScheme.getType().toString(); cs.isCode = cs.isPassword = cs.isApplication = cs.isImplicit = false; if (SecurityScheme.Type.APIKEY.equals(securityScheme.getType())) { cs.isBasic = cs.isOAuth = false; cs.isApiKey = true; cs.keyParamName = securityScheme.getName(); cs.isKeyInHeader = securityScheme.getIn() == SecurityScheme.In.HEADER; cs.isKeyInQuery = !cs.isKeyInHeader; } else if (SecurityScheme.Type.HTTP.equals(securityScheme.getType())) { cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isOAuth = false; cs.isBasic = true; } else if (SecurityScheme.Type.OAUTH2.equals(securityScheme.getType())) { cs.isKeyInHeader = cs.isKeyInQuery = cs.isApiKey = cs.isBasic = false; cs.isOAuth = true; final OAuthFlows flows = securityScheme.getFlows(); if (securityScheme.getFlows() == null) { throw new RuntimeException(\"missing oauth flow in \" + cs.name); } if (flows.getPassword() != null) { setOauth2Info(cs, flows.getPassword()); cs.isPassword = true; cs.flow = \"password\"; } else if (flows.getImplicit() != null) { setOauth2Info(cs, flows.getImplicit()); cs.isImplicit = true; cs.flow = \"implicit\"; } else if (flows.getClientCredentials() != null) { setOauth2Info(cs, flows.getClientCredentials()); cs.isApplication = true; cs.flow = \"application\"; } else if (flows.getAuthorizationCode() != null) { setOauth2Info(cs, flows.getAuthorizationCode()); cs.isCode = true; cs.flow = \"accessCode\"; } else { throw new RuntimeException(\"Could not identify any oauth2 flow in \" + cs.name); } } codegenSecurities.add(cs); } \/\/ sort auth methods to maintain the same order Collections.sort(codegenSecurities, new Comparator<CodegenSecurity>() { @Override public int compare(CodegenSecurity one, CodegenSecurity another) { return ObjectUtils.compare(one.name, another.name); } }); \/\/ set 'hasMore' Iterator<CodegenSecurity> it = codegenSecurities.iterator(); while (it.hasNext()) { final CodegenSecurity security = it.next(); security.hasMore = it.hasNext(); } return codegenSecurities; }","old_code_raw":"    public List<CodegenSecurity> fromSecurity(Map<String, SecuritySchemeDefinition> schemes) {\n        if (schemes == null) {\n            return Collections.emptyList();\n        }\n\n        List<CodegenSecurity> secs = new ArrayList<CodegenSecurity>(schemes.size());\n        for (Iterator<Map.Entry<String, SecuritySchemeDefinition>> it = schemes.entrySet().iterator(); it.hasNext(); ) {\n            final Map.Entry<String, SecuritySchemeDefinition> entry = it.next();\n            final SecuritySchemeDefinition schemeDefinition = entry.getValue();\n\n            CodegenSecurity sec = CodegenModelFactory.newInstance(CodegenModelType.SECURITY);\n            sec.name = entry.getKey();\n            sec.type = schemeDefinition.getType();\n            sec.isCode = sec.isPassword = sec.isApplication = sec.isImplicit = false;\n            sec.vendorExtensions = schemeDefinition.getVendorExtensions();\n\n            if (schemeDefinition instanceof ApiKeyAuthDefinition) {\n                final ApiKeyAuthDefinition apiKeyDefinition = (ApiKeyAuthDefinition) schemeDefinition;\n                sec.isBasic = sec.isOAuth = false;\n                sec.isApiKey = true;\n                sec.keyParamName = apiKeyDefinition.getName();\n                sec.isKeyInHeader = apiKeyDefinition.getIn() == In.HEADER;\n                sec.isKeyInQuery = !sec.isKeyInHeader;\n            } else if(schemeDefinition instanceof BasicAuthDefinition) {\n                sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = sec.isOAuth = false;\n                sec.isBasic = true;\n            } else {\n                final OAuth2Definition oauth2Definition = (OAuth2Definition) schemeDefinition;\n                sec.isKeyInHeader = sec.isKeyInQuery = sec.isApiKey = sec.isBasic = false;\n                sec.isOAuth = true;\n                sec.flow = oauth2Definition.getFlow();\n                if (sec.flow == null) {\n                    throw new RuntimeException(\"missing oauth flow in \" + sec.name);\n                }\n                switch(sec.flow) {\n                    case \"accessCode\":\n                        sec.isCode = true;\n                        break;\n                    case \"password\":\n                        sec.isPassword = true;\n                        break;\n                    case \"application\":\n                        sec.isApplication = true;\n                        break;\n                    case \"implicit\":\n                        sec.isImplicit = true;\n                        break;\n                    default:\n                        throw new RuntimeException(\"unknown oauth flow: \" + sec.flow);\n                }\n                sec.authorizationUrl = oauth2Definition.getAuthorizationUrl();\n                sec.tokenUrl = oauth2Definition.getTokenUrl();\n                if (oauth2Definition.getScopes() != null) {\n                    List<Map<String, Object>> scopes = new ArrayList<Map<String, Object>>();\n                    int count = 0, numScopes = oauth2Definition.getScopes().size();\n                    for(Map.Entry<String, String> scopeEntry : oauth2Definition.getScopes().entrySet()) {\n                        Map<String, Object> scope = new HashMap<String, Object>();\n                        scope.put(\"scope\", scopeEntry.getKey());\n                        scope.put(\"description\", escapeText(scopeEntry.getValue()));\n\n                        count += 1;\n                        if (count < numScopes) {\n                            scope.put(\"hasMore\", \"true\");\n                        } else {\n                            scope.put(\"hasMore\", null);\n                        }\n\n                        scopes.add(scope);\n                    }\n                    sec.scopes = scopes;\n                }\n            }\n\n            secs.add(sec);\n        }\n\n        \/\/ sort auth methods to maintain the same order\n        Collections.sort(secs, new Comparator<CodegenSecurity>() {\n            @Override\n            public int compare(CodegenSecurity one, CodegenSecurity another) {\n                return ObjectUtils.compare(one.name, another.name);\n            }\n        });\n        \/\/ set 'hasMore'\n        Iterator<CodegenSecurity> it = secs.iterator();\n        while (it.hasNext()) {\n            final CodegenSecurity security = it.next();\n            security.hasMore = it.hasNext();\n        }\n\n        return secs;\n    }\n","new_comment_raw":"Convert map of OAS SecurityScheme objects to a list of Codegen Security objects","old_comment_raw":"Convert map of Swagger SecuritySchemeDefinition objects to a list of Codegen Security objects","label":1,"pre_label":0,"AST_level":17,"line_counts":71,"new_code_token_num":478},{"new_code_raw":"public ArrayList<EditText> getCurrentEditTexts() { return getCurrentViews(EditText.class); }","old_code_raw":"\tpublic ArrayList<EditText> getCurrentEditTexts() {\n\t\tArrayList<EditText>editTextList = new ArrayList<EditText>();\n\t\tArrayList<View> viewList = getViews();\n\t\tfor(View view : viewList){\n\t\t\tif (view instanceof android.widget.EditText)\n\t\t\t\teditTextList.add((EditText) view);\n\t\t}\n\t\treturn editTextList;\t\n\t}\n","new_comment_raw":"Returns a  List of the  EditTexts contained in the current  Activity.","old_comment_raw":"Returns a List of the EditTexts contained in the current Activity.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public static Builder newSchema(GraphQLSchema existingSchema) { return new Builder() .query(existingSchema.getQueryType()) .mutation(existingSchema.getMutationType()) .subscription(existingSchema.getSubscriptionType()) .codeRegistry(existingSchema.getCodeRegistry()) .clearAdditionalTypes() .clearDirectives() .additionalDirectives(existingSchema.directives) .additionalTypes(existingSchema.additionalTypes); }","old_code_raw":"    public static Builder newSchema(GraphQLSchema existingSchema) {\n        return new Builder()\n                .query(existingSchema.getQueryType())\n                .mutation(existingSchema.getMutationType())\n                .subscription(existingSchema.getSubscriptionType())\n                .fieldVisibility(existingSchema.getFieldVisibility())\n                .clearAdditionalTypes()\n                .clearDirectives()\n                .additionalDirectives(existingSchema.directives)\n                .additionalTypes(existingSchema.additionalTypes);\n    }\n","new_comment_raw":"This allows you to build a schema from an existing schema.","old_comment_raw":"This allows you to build a schema from an existing schema.","label":0,"pre_label":1,"AST_level":6,"line_counts":12,"new_code_token_num":60},{"new_code_raw":"public static BinaryResourceFile fromInputStream(InputStream is) throws IOException { byte[] buf = ByteStreams.toByteArray(is); return new BinaryResourceFile(buf); }","old_code_raw":"  public static ResourceFile fromInputStream(InputStream is) throws IOException {\n    byte[] buf = ByteStreams.toByteArray(is);\n    return new ResourceFile(buf);\n  }\n","new_comment_raw":"Given an input stream, reads the stream until the end and returns a  BinaryResourceFile representing the contents of the stream.","old_comment_raw":"Given an input stream, reads the stream until the end and returns a ResourceFile representing the contents of the stream.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":29},{"new_code_raw":"public static Tree UCPtransform(Tree t) { if (t == null) { return null; } Tree firstChild = t.firstChild(); if (firstChild != null) { List<Pair<TregexPattern,TsurgeonPattern>> ops = Generics.newArrayList(); for (int i = 0; i < operations.length; i++) { for (TregexPattern pattern : matchPatterns[i]) { ops.add(Generics.newPair(pattern, operations[i])); } } return Tsurgeon.processPatternsOnTree(ops, t); } else { return t; } }","old_code_raw":"  public static Tree UCPtransform(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    return Tsurgeon.processPattern(ucpRenameTregex, ucpRenameTsurgeon, t);\n  }\n","new_comment_raw":"Transforms t if it contains an UCP, it will change the UCP tag into the phrasal tag of the first word of the UCP (UCP (JJ electronic) (, ,) (NN computer) (CC and) (NN building)) will become (ADJP (JJ electronic) (, ,) (NN computer) (CC and) (NN building))","old_comment_raw":"Transforms t if it contains an UCP, it will change the UCP tag into the phrasal tag of the first word of the UCP (UCP (JJ electronic) (, ,) (NN computer) (CC and) (NN building)) will become (ADJP (JJ electronic) (, ,) (NN computer) (CC and) (NN building))","label":0,"pre_label":1,"AST_level":14,"line_counts":20,"new_code_token_num":104},{"new_code_raw":"Class[] getServiceClasses( final Class type, final List issues ) { final ServiceDescriptorSet set = (ServiceDescriptorSet)type.getAnnotation( ServiceDescriptorSet.class ); if( null != set ) { final ServiceDescriptor[] descriptors = set.value(); final Class[] services = new Class[descriptors.length]; for( int i = 0; i < descriptors.length; i++ ) { ServiceDescriptor descriptor = descriptors[i]; services[i] = descriptor.type(); } return services; } else { return new Class[0]; } }","old_code_raw":"    Class[] getServiceClasses( final Class type, final List issues )\n    {\n        final List services = new ArrayList();\n        final ClassLoader classLoader = type.getClassLoader();\n        final Attribute[] attributes =\n            Attributes.getAttributes( type, \"dna.service\" );\n        for( int i = 0; i < attributes.length; i++ )\n        {\n            final String classname = attributes[ i ].getParameter( \"type\" );\n            try\n            {\n                final Class clazz = classLoader.loadClass( classname );\n                services.add( clazz );\n            }\n            catch( final Throwable t )\n            {\n                final Object[] args = new Object[]{classname, t};\n                final String message = getMessage( \"CV014\", args );\n                final VerifyIssue issue =\n                    new VerifyIssue( VerifyIssue.ERROR, message );\n                issues.add( issue );\n            }\n        }\n\n        return (Class[])services.toArray( new Class[ services.size() ] );\n    }\n","new_comment_raw":"Retrieve an array of Classes for all the value that a Component offers.","old_comment_raw":"Retrieve an array of Classes for all the services that a Component offers.","label":1,"pre_label":0,"AST_level":11,"line_counts":22,"new_code_token_num":103},{"new_code_raw":"List<ExtensionState> getExtensions() { return extensions; }","old_code_raw":"    List<ExtensionState> getExtensions() {\n        return Collections.unmodifiableList(extensions);\n    }\n","new_comment_raw":"Gets the extensions' state (as saved in the configuration file).","old_comment_raw":"Gets the extensions' state (as saved in the configuration file).","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public String getAuthoringPath() { return this.authoringPath; }","old_code_raw":"    public String getAuthoringPath() {\n        return authoringPath;\n    }\n","new_comment_raw":"Returns the authoring path","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"protected Object convertDurationToMicroseconds(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, 0L, (r) -> { try { if (data instanceof Duration) { r.deliver(((Duration)data).toNanos() \/ 1_000); } } catch (IllegalArgumentException e) { } }); }","old_code_raw":"    protected Object convertDurationToMicroseconds(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L;\n        }\n        try {\n            if (data instanceof Duration) return ((Duration) data).toNanos() \/ 1_000;\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"Converts a value object for an expected type of  java.time.Duration to  Long values that represents the time in microseconds.","old_comment_raw":"Converts a value object for an expected type of java.time.Duration to Long values that represents the time in microseconds.","label":0,"pre_label":1,"AST_level":13,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public Order placeOrder(Order body) throws ApiException { Object localVarPostBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\"); } \/\/ create path and map variables String localVarPath = \"\/store\/order\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Order placeOrder(Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/store\/order\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"Place an order for a pet","old_comment_raw":"Place an order for a pet","label":0,"pre_label":1,"AST_level":8,"line_counts":36,"new_code_token_num":213},{"new_code_raw":"protected static Serializable deserializeTime(ByteArrayInputStream inputStream) throws IOException { \/\/ Times are stored as an integer as `HHMMSS`, so we need to split out the digits ... int value = inputStream.readInteger(3); int[] split = split(value, 100, 3); int hours = split[2]; int minutes = split[1]; int seconds = split[0]; return Duration.ofHours(hours).plusMinutes(minutes).plusSeconds(seconds); }","old_code_raw":"    protected static Serializable deserializeTime(ByteArrayInputStream inputStream) throws IOException {\n        \/\/ Times are stored as an integer as `HHMMSS`, so we need to split out the digits ...\n        int value = inputStream.readInteger(3);\n        int[] split = split(value, 100, 3);\n        int hours = split[2];\n        int minutes = split[1];\n        int seconds = split[0];\n        int nanoOfSecond = 0; \/\/ This version does not support fractional seconds\n        return LocalTime.of(hours, minutes, seconds, nanoOfSecond);\n    }\n","new_comment_raw":"Converts a MySQL  TIME value without fractional seconds to a  java.time.Duration.","old_comment_raw":"Converts a MySQL TIME value without fractional seconds to a LocalTime.","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":88},{"new_code_raw":"private BigDecimal getCurrentCostPriceLL(MPPProductBOM bom, MCostElement element) { log.info(\"ElementType: \"+ element.getCostElementType()); BigDecimal costPriceLL = Env.ZERO; if(bom == null) return costPriceLL; for (MPPProductBOMLine bomline : bom.getLines()) { MProduct component = MProduct.get(getCtx(), bomline.getM_Product_ID()); \/\/ get the rate for this resource for (MCost cost : getCosts(component, element.getCostElementType())) { BigDecimal qtyPercentage = bomline.getQtyBatch().divide(Env.ONEHUNDRED, 8, BigDecimal.ROUND_UP); BigDecimal qtyBOM = bomline.getQtyBOM(); BigDecimal scrapDec = bomline.getScrap().divide(Env.ONEHUNDRED, 4, BigDecimal.ROUND_UP); BigDecimal qtyTotal = Env.ZERO; if (bomline.isQtyPercentage()) { qtyTotal = qtyPercentage.divide(Env.ONE.subtract(scrapDec), 4, BigDecimal.ROUND_HALF_UP); } else { qtyTotal = qtyBOM.divide(Env.ONE.subtract(scrapDec), 4, BigDecimal.ROUND_HALF_UP); } BigDecimal costPrice = cost.getCurrentCostPrice().add(cost.getCurrentCostPriceLL()); costPriceLL = costPriceLL.add(costPrice.multiply(qtyTotal)); log.info(\"Cost Element:\"+element.getName() + \", Total Cost Element: \" + costPriceLL + \", QtyPercentage: \" + qtyPercentage + \", QtyBOM: \" + qtyBOM); } \/\/ for each cost } \/\/ for each BOM line return costPriceLL; }","old_code_raw":"\tprivate BigDecimal getCurrentCostPriceLL(MPPProductBOM bom, MCostElement element ,int Yield)\n\t{\n\t\tlog.info(\"ElementType: \"+ element.getCostElementType());\n\t\tBigDecimal costPriceLL = Env.ZERO;\n\n\t\tfor (MPPProductBOMLine bomline : bom.getLines())\n\t\t{\n\t\t\tMProduct component = MProduct.get(getCtx(), bomline.getM_Product_ID());\n\t\t\t\n\t\t\t\/\/ get the rate for this resource     \n\t\t\tfor (MCost cost : getCosts(component, element.getCostElementType()))\n\t\t\t{                 \n\t\t\t\t\/\/ check if current cost element type is specified cost element type\n\t\t\t\tif (element.getCostElementType().equals(element.getCostElementType()))\n\t\t\t\t{\n\t\t\t\t\tBigDecimal qtyPercentage = bomline.getQtyBatch().divide(Env.ONEHUNDRED, 8, BigDecimal.ROUND_UP);\n\t\t\t\t\tBigDecimal qtyBOM = bomline.getQtyBOM(); \n\t\t\t\t\tBigDecimal scrapDec = bomline.getScrap().divide(Env.ONEHUNDRED, 4, BigDecimal.ROUND_UP);\n\t\t\t\t\tBigDecimal qtyTotal = Env.ZERO;\n\t\t\t\t\tif (bomline.isQtyPercentage())\n\t\t\t\t\t{\n\t\t\t\t\t\tqtyTotal =  qtyPercentage.divide(Env.ONE.subtract(scrapDec), 4, BigDecimal.ROUND_HALF_UP);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tqtyTotal =  qtyBOM.divide(Env.ONE.subtract(scrapDec), 4, BigDecimal.ROUND_HALF_UP);\n\t\t\t\t\t}\n\n\t\t\t\t\tBigDecimal costPrice = cost.getCurrentCostPrice().add(cost.getCurrentCostPriceLL());\n\t\t\t\t\tcostPriceLL = costPriceLL.add(costPrice.multiply(qtyTotal));\n\t\t\t\t\tlog.info(\"Cost Element:\"+element.getName()\n\t\t\t\t\t\t\t\t+ \", Total Cost Element: \" +   costPriceLL\n\t\t\t\t\t\t\t\t+ \", QtyPercentage: \" + qtyPercentage\n\t\t\t\t\t\t\t\t+ \", QtyBOM: \" + qtyBOM);\n\t\t\t\t}\n\t\t\t} \/\/ for each cost\n\t\t} \/\/ for each BOM line  \n\n\t\tif(Yield != 0)\n\t\t{\n\t\t\tBigDecimal decimalYield = new BigDecimal(Yield \/ 100);\n\t\t\tcostPriceLL = costPriceLL.divide(decimalYield, 4 ,BigDecimal.ROUND_HALF_UP);\n\t\t}\n       \n\t\treturn costPriceLL;     \n\t}\n","new_comment_raw":"get the sum Current Cost Price Level Low for this Cost Element","old_comment_raw":"get the sum Current Cost Price Level Low for this Cost Element Type","label":1,"pre_label":0,"AST_level":16,"line_counts":38,"new_code_token_num":263},{"new_code_raw":"public VisualItem findItem(Point p) { Point2D p2 = (m_itransform==null ? p : m_itransform.transform(p, m_tmpPoint)); synchronized (m_registry) { Iterator items = m_registry.getItemsReversed(); while (items.hasNext()) { VisualItem vi = (VisualItem) items.next(); Renderer r = vi.getRenderer(); if (r != null && r.locatePoint(p2, vi)) { return vi; } } } return null; } \/\/","old_code_raw":"\tpublic GraphItem findItem(Point p) {\n        Point2D p2 = (m_itransform==null ? p : \n                        m_itransform.transform(p, m_tmpPoint));\n\t\tsynchronized (m_registry) {\n\t\t\tIterator items = m_registry.getItemsReversed();\n\t\t\twhile (items.hasNext()) {\n\t\t\t\tGraphItem gi = (GraphItem) items.next();\n\t\t\t\tRenderer r = gi.getRenderer();\n\t\t\t\tif (r != null && r.locatePoint(p2, gi)) {\n\t\t\t\t\treturn gi;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t} \/\/\n","new_comment_raw":"Returns the VisualItem located at the given point.","old_comment_raw":"Returns the GraphItem located at the given point.","label":1,"pre_label":0,"AST_level":9,"line_counts":17,"new_code_token_num":90},{"new_code_raw":"public Order placeOrder(Order body) throws ApiException { ApiResponse<Order> localVarResp = placeOrderWithHttpInfo(body); return localVarResp.getData(); }","old_code_raw":"    public Order placeOrder(Order body) throws ApiException {\n        ApiResponse<Order> resp = placeOrderWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"Place an order for a pet","old_comment_raw":"Place an order for a pet","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public static long nextPowerOfTwo(long value) { if (!isPowerOfTwo(value)) { value--; value |= value >> 1; value |= value >> 2; value |= value >> 4; value |= value >> 8; value |= value >> 16; value |= value >> 32; value++; } return value; }","old_code_raw":"    public static long nextPowerOfTwo(final long value) {\n        return 1L << (64 - Long.numberOfLeadingZeros(value - 1));\n    }\n","new_comment_raw":"Returns the next power of two that is larger than the specified long value.","old_comment_raw":"Fast method of finding the next power of 2 greater than or equal to the supplied value.","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":61},{"new_code_raw":"public Iterable<RelNode> getRels() { return new Iterable<RelNode>() { public Iterator<RelNode> iterator() { return Linq4j.asEnumerable(set.rels) .where( new Predicate1<RelNode>() { public boolean apply(RelNode v1) { return v1.getTraitSet().satisfies(traitSet); } }) .iterator(); } }; }","old_code_raw":"  public Iterable<RelNode> getRels() {\n    return new Iterable<RelNode>() {\n      public Iterator<RelNode> iterator() {\n        return Linq4j.asEnumerable(set.rels)\n            .where(\n                new Predicate1<RelNode>() {\n                  public boolean apply(RelNode v1) {\n                    return v1.getTraitSet().subsumes(traitSet);\n                  }\n                })\n            .iterator();\n      }\n    };\n  }\n","new_comment_raw":"Returns the rel nodes in this rel subset.","old_comment_raw":"Returns the rel nodes in this rel subset.","label":0,"pre_label":1,"AST_level":14,"line_counts":15,"new_code_token_num":65},{"new_code_raw":"public org.apache.poi.ss.usermodel.Workbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException, InvalidFormatException { org.apache.poi.ss.usermodel.Workbook hssfWorkbook = null; try { hssfWorkbook = WorkbookFactory.create(is); transformWorkbook(hssfWorkbook, beanParams); } catch (IOException e) { e.printStackTrace(); } return hssfWorkbook; }","old_code_raw":"    public HSSFWorkbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException {\n        HSSFWorkbook hssfWorkbook = null;\n        try {\n            POIFSFileSystem fs = new POIFSFileSystem(is);\n            hssfWorkbook = new HSSFWorkbook(fs);\n            transformWorkbook(hssfWorkbook, beanParams);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return hssfWorkbook;\n    }\n","new_comment_raw":"Creates Workbook instance based on .xls template from a given InputStream and a number of beans","old_comment_raw":"Creates HSSFWorkbook instance based on .xls template from a given InputStream and a number of beans","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":62},{"new_code_raw":"public static PathMetadata<String> forVariable(String variable) { return new PathMetadata<String>(null, Assert.hasLength(variable,\"variable\"), PathType.VARIABLE); }","old_code_raw":"    public static PathMetadata<String> forVariable(String variable) {\n        return new PathMetadata<String>(null, ConstantImpl.create(Assert.hasLength(variable,\"variable\"), true), PathType.VARIABLE);\n    }\n","new_comment_raw":"Create a new PathMetadata for a variable","old_comment_raw":"Create a new PathMetadata for a variable","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":32},{"new_code_raw":"private static String buildPropertyPath(String parent, String child) { return new StringBuilder( parent.length() + child.length() + 1 ) .append(parent).append('.').append(child).toString(); }","old_code_raw":"\tprivate static String buildPropertyPath(String parent, String child) {\n\t\treturn new StringBuffer( parent.length() + child.length() + 1 )\n\t\t\t.append(parent).append('.').append(child).toString();\n\t}\n","new_comment_raw":"Return a well formed property path.","old_comment_raw":"Return a well formed property path.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":46},{"new_code_raw":"public int getDays() { return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX); }","old_code_raw":"    public int getDays() {\n        return getPeriodType().getDays(this);\n    }\n","new_comment_raw":"Gets the days field part of the period.","old_comment_raw":"Gets the days field part of the period.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public ChromeDriverService build() { return (ChromeDriverService) super.build(); }","old_code_raw":"    public ChromeDriverService build() {\n      if (port == 0) {\n        port = PortProber.findFreePort();\n      }\n\n      checkState(exe != null, \"Path to the chromedriver executable not specified\");\n\n      try {\n        return new ChromeDriverService(exe, port, environment, logFile);\n      } catch (IOException e) {\n        throw new WebDriverException(e);\n      }\n    }\n","new_comment_raw":"Creates a new binary to manage the chromedriver server.","old_comment_raw":"Creates a new binary to manage the chromedriver server.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public boolean scroll(int direction, boolean allTheWay) { final ArrayList<View> viewList = RobotiumUtils. removeInvisibleViews(viewFetcher.getAllViews(true)); @SuppressWarnings(\"unchecked\") ArrayList<View> views = RobotiumUtils.filterViewsToSet(new Class[] { ListView.class, ScrollView.class, GridView.class, WebView.class}, viewList); View view = viewFetcher.getFreshestView(views); if (view == null) { view = getRecyclerView(viewList); if(view == null){ return false; } } if (view instanceof AbsListView) { return scrollList((AbsListView)view, direction, allTheWay); } if(view instanceof WebView){ return scrollWebView((WebView)view, direction, allTheWay); } if (allTheWay) { scrollViewAllTheWay(view, direction); return false; } else { return scrollView(view, direction); } }","old_code_raw":"\tpublic boolean scroll(int direction, boolean allTheWay) {\n\t\tfinal ArrayList<View> viewList = RobotiumUtils.\n\t\t\t\tremoveInvisibleViews(viewFetcher.getAllViews(true));\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<View> views = RobotiumUtils.filterViewsToSet(new Class[] { ListView.class,\n\t\t\t\tScrollView.class, GridView.class, WebView.class}, viewList);\n\t\tView view = viewFetcher.getFreshestView(views);\n\t\t\n\t\tif (view == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (view instanceof AbsListView) {\n\t\t\treturn scrollList((AbsListView)view, direction, allTheWay);\n\t\t}\n\n\t\tif (view instanceof ScrollView) {\n\t\t\tif (allTheWay) {\n\t\t\t\tscrollScrollViewAllTheWay((ScrollView) view, direction);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn scrollScrollView((ScrollView)view, direction);\n\t\t\t}\n\t\t}\n\t\tif(view instanceof WebView){\n\t\t\treturn scrollWebView((WebView)view, direction, allTheWay);\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"Scrolls up and down.","old_comment_raw":"Scrolls up and down.","label":0,"pre_label":1,"AST_level":9,"line_counts":33,"new_code_token_num":160},{"new_code_raw":"public String preprocess(String buildPath) throws RunnerException { try { return preprocess(buildPath, new PdePreprocessor(name)); } catch (IOException e) { throw new RunnerException(\"Error while preprocessing\", true); } }","old_code_raw":"  public String preprocess(String buildPath) throws RunnerException {\n    try {\n      return preprocess(buildPath, new PdePreprocessor(buildPath, name));\n    } catch (IOException e) {\n      throw new RunnerException(\"Error while preprocessing\", true);\n    }\n  }\n","new_comment_raw":"Build all the code for this sketch.","old_comment_raw":"Build all the code for this sketch.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":46},{"new_code_raw":"boolean findCellForSpan(int[] cellXY, int spanX, int spanY) { \/\/ return the span represented by the CellInfo only there is no view there \/\/ (this.cell == null) and there is enough space if (this.cell == null && this.spanX >= spanX && this.spanY >= spanY) { if (cellXY != null) { cellXY[0] = cellX; cellXY[1] = cellY; } return true; } int startX = 0; if (intersectX >= 0) { startX = Math.max(startX, intersectX - (spanX - 1)); } int endX = mCountX - (spanX - 1); if (intersectX >= 0) { endX = Math.min(endX, intersectX + (spanX - 1)); } int startY = 0; if (intersectY >= 0) { startY = Math.max(startY, intersectY - (spanY - 1)); } int endY = mCountY - (spanY - 1); if (intersectY >= 0) { endY = Math.min(endY, intersectY + (spanY - 1)); } for (int x = startX; x < endX + 1; x++) { inner: for (int y = startY; y < endY; y++) { for (int i = 0; i < spanX; i++) { for (int j = 0; j < spanY; j++) { if (mOccupied[x + i][y + j]) { \/\/ small optimization: we can skip to below the row we just found \/\/ an occupied cell y += j; continue inner; } } } if (cellXY != null) { cellXY[0] = x; cellXY[1] = y; } return true; } } return false; }","old_code_raw":"        boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {\n            return findCellForSpan(cellXY, spanX, spanY, true);\n        }\n","new_comment_raw":"Finds the upper-left coordinate of the first rectangle in the grid that can hold a cell of the specified dimensions.","old_comment_raw":"This method can be called only once! Calling #findVacantCellsFromOccupied will restore the ability to call this method.","label":1,"pre_label":0,"AST_level":15,"line_counts":52,"new_code_token_num":333},{"new_code_raw":"public SQLInsertClause populate(Object bean) { return populate(bean, DefaultMapper.DEFAULT); }","old_code_raw":"    public SQLInsertClause populate(Object bean) {\n        try {\n            Class<?> beanClass = bean.getClass();\n            Map<String, Field> fields = getPathFields(entity.getClass());\n            for (Field beanField : beanClass.getDeclaredFields()) {\n                if (!Modifier.isStatic(beanField.getModifiers())) {\n                    Field field = fields.get(beanField.getName());                    \n                    Path path = (Path<?>) field.get(entity);\n                    beanField.setAccessible(true);\n                    Object propertyValue = beanField.get(bean);\n                    if (propertyValue != null) {\n                        set(path, propertyValue);\n                    }     \n                }\n            }\n\/\/            BeanMap map = new BeanMap(bean);\n\/\/            for (Map.Entry entry : map.entrySet()) {\n\/\/                String property = entry.getKey().toString();\n\/\/                if (!property.equals(\"class\")) {\n\/\/                    Field field = entity.getClass().getDeclaredField(property);\n\/\/                    field.setAccessible(true);\n\/\/                    Path path = (Path<?>) field.get(entity);\n\/\/                    if (entry.getValue() != null) {\n\/\/                        set(path, entry.getValue());    \n\/\/                    }                    \n\/\/                }\n\/\/            }\n            return this;\n        } catch (SecurityException e) {\n            throw new QueryException(e);\n        } catch (IllegalAccessException e) {\n            throw new QueryException(e);\n        }\n    }\n","new_comment_raw":"Populate the INSERT clause with the properties of the given bean.","old_comment_raw":"Populate the INSERT clause with the properties of the given bean.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public final File getGeneratedOutput() throws CurnException { return hasGeneratedOutput() ? outputFile : null; }","old_code_raw":"    public final InputStream getGeneratedOutput()\n        throws CurnException\n    {\n        InputStream result = null;\n\n        if (hasGeneratedOutput())\n        {\n            try\n            {\n                result = new FileInputStream (outputFile);\n            }\n\n            catch (FileNotFoundException ex)\n            {\n                throw new CurnException (Curn.BUNDLE_NAME,\n                                         \"FileOutputHandler.cantReopenFile\",\n                                         \"Cannot reopen file \\\"{0}\\\".\",\n                                         new Object[] {outputFile},\n                                         ex);\n            }\n        }\n\n        return result;\n    }\n","new_comment_raw":"Get the File that represents the output produced by the handler, if applicable.","old_comment_raw":"Get an InputStream that can be used to read the output data produced by the handler, if applicable.","label":1,"pre_label":0,"AST_level":5,"line_counts":7,"new_code_token_num":19},{"new_code_raw":"public static SchemaRefreshMode parse(String value) { if (value == null) return null; value = value.trim(); for (SchemaRefreshMode option : SchemaRefreshMode.values()) { if (option.getValue().equalsIgnoreCase(value)) return option; } return null; }","old_code_raw":"        public static TopicSelectionStrategy parse(String value) {\n            if (value == null) return null;\n            value = value.trim();\n            for (TopicSelectionStrategy option : TopicSelectionStrategy.values()) {\n                if (option.getValue().equalsIgnoreCase(value)) return option;\n            }\n            return null;\n        }\n","new_comment_raw":"Determine if the supplied value is one of the predefined options.","old_comment_raw":"Determine if the supplied value is one of the predefined options.","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":53},{"new_code_raw":"public String[] getTaskIds() { return (String[]) this.tasks.keySet().toArray(new String[this.tasks.size()]); }","old_code_raw":"    public String[] getTaskIds() {\n        return (String[]) tasks.keySet().toArray(new String[tasks.size()]);\n    }\n","new_comment_raw":"Return all task ids","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":9,"line_counts":5,"new_code_token_num":33},{"new_code_raw":"public static AnnotationMirror getAnnotationMirror(Element element, String fqcn) { assert element != null; assert fqcn != null; AnnotationMirror mirror = null; for ( AnnotationMirror am : element.getAnnotationMirrors() ) { if ( isAnnotationMirrorOfType( am, fqcn ) ) { mirror = am; break; } } return mirror; }","old_code_raw":"\tpublic static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) {\n\t\tassert clazz != null;\n\t\treturn getAnnotationMirror( element, clazz.getName() );\n\t}\n","new_comment_raw":"Checks whether the  Element hosts the annotation with the given fully qualified class name.","old_comment_raw":"Checks whether the Element hosts an annotation of the specified class.","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":58},{"new_code_raw":"private static String literalValue(RexLiteral literal) { Object value = literal.getValue2(); return String.valueOf(value); }","old_code_raw":"    private static String literalValue(RexLiteral literal) {\n      Object value = literal.getValue2();\n      StringBuilder buf = new StringBuilder();\n      buf.append(value);\n      return buf.toString();\n    }\n","new_comment_raw":"Convert the value of a literal to a string.","old_comment_raw":"Convert the value of a literal to a string.","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public static SlantType getSlant(World world, Vector3 position) { TileEntity t = position.getTileEntity(world); if (t != null) { if (t instanceof TileEntityConveyorBelt) { TileEntityConveyorBelt tileEntity = (TileEntityConveyorBelt) t; Vector3 frontCheck = position.clone(); frontCheck.modifyPositionFromSide(tileEntity.getDirection()); Vector3 backCheck = position.clone(); backCheck.modifyPositionFromSide(tileEntity.getDirection().getOpposite()); if (Vector3.add(frontCheck, new Vector3(0, 1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID && Vector3.add(backCheck, new Vector3(0, -1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID) { return SlantType.UP; } else if (Vector3.add(frontCheck, new Vector3(0, -1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID && Vector3.add(backCheck, new Vector3(0, 1, 0)).getBlockID(world) == AssemblyLine.blockConveyorBelt.blockID) { return SlantType.DOWN; } } } return null; }","old_code_raw":"\tpublic ForgeDirection getSlant(World world, Vector3 position)\n\t{\n\t\tTileEntity t = position.getTileEntity(world);\n\n\t\tif (t != null)\n\t\t{\n\t\t\tif (t instanceof TileEntityConveyorBelt)\n\t\t\t{\n\t\t\t\tTileEntityConveyorBelt tileEntity = (TileEntityConveyorBelt) t;\n\t\t\t\tVector3 highCheck = position.clone();\n\t\t\t\thighCheck.modifyPositionFromSide(tileEntity.getDirection());\n\t\t\t}\n\t\t}\n\n\t\treturn ForgeDirection.UNKNOWN;\n\t}\n","new_comment_raw":"Checks the front and the back position to find any conveyor blocks either higher or lower than this block to determine if it this conveyor block needs to slant.","old_comment_raw":"Is this conveyor belt slanted towards a direction?","label":1,"pre_label":0,"AST_level":13,"line_counts":26,"new_code_token_num":195},{"new_code_raw":"public AnsiClazzes processCode(String code) { if (code == null || code.length() < 2) return null; if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm') return null; if (code.length() == 2) { clazzes_.clear(); \/\/ CSIm is equivalent to CSI0m, which is 'reset' blockClazzes_.clear(); return null; } int extendedColor = 0; boolean extendedMarkerSeen = false; boolean extendedRGBMarkerSeen = false; int extendedRGBColorsSeen = 0; String[] tokens = code.substring(2, code.length() - 1).split(\";\"); for (String token : tokens) { int codeVal = StringUtil.parseInt(token, -1); if (codeVal == -1) continue; if (extendedColor > 0) { if (!extendedMarkerSeen && !extendedRGBMarkerSeen) { if (codeVal == EXT_BY_INDEX) { extendedMarkerSeen = true; continue; } else if (codeVal == EXT_BY_RGB) { extendedRGBMarkerSeen = true; extendedRGBColorsSeen = 0; } else { \/\/ unknown extended color format; hard to recover so \/\/ just reset back to defaults and return clazzes_.clear(); blockClazzes_.clear(); return null; } } else { \/\/ We don't support colors specified via RGB, but parse the \/\/ sequence then ignore it in case there are supported \/\/ sequences after it if (extendedRGBMarkerSeen) { extendedRGBColorsSeen++; if (extendedRGBColorsSeen == 3 \/*red, green, blue*\/) { extendedColor = 0; extendedRGBMarkerSeen = false; extendedRGBColorsSeen = 0; } } else { if (extendedColor == FOREGROUND_EXT) { if (codeVal >= 0 && codeVal <= 255) { currentColor_.setExtended(codeVal); resetForeground(); clazzes_.add(Color.clazzForColorIndex(codeVal, false \/*background*\/)); } } else { if (codeVal >= 0 && codeVal <= 255) { currentBgColor_.setExtended(codeVal); resetBackground(); clazzes_.add(Color.clazzForColorIndex(codeVal, true \/*background*\/)); } } extendedColor = 0; extendedMarkerSeen = false; } } } else if (codeVal == RESET) { inverted_ = false; currentColor_.reset(); currentBgColor_.reset(); clazzes_.clear(); blockClazzes_.clear(); } else if (codeVal == BOLD) { clazzes_.add(BOLD_STYLE); } else if (codeVal == BLURRED) { \/\/ NYI clazzes_.add(BLURRED_STYLE); } else if (codeVal == BOLD_BLURRED_OFF) { clazzes_.remove(BOLD_STYLE); \/\/ NYI clazzes_.remove(BLURRED_STYLE); } else if (codeVal == ITALIC) { clazzes_.add(ITALIC_STYLE); } else if (codeVal == ITALIC_OFF) { clazzes_.remove(ITALIC_STYLE); } else if (codeVal == UNDERLINE) { clazzes_.add(UNDERLINE_STYLE); } else if (codeVal == UNDERLINE_OFF) { clazzes_.remove(UNDERLINE_STYLE); } else if (codeVal == BLINKSLOW || codeVal == BLINKFAST) { clazzes_.add(BLINK_STYLE); } else if (codeVal == BLINK_OFF) { clazzes_.remove(BLINK_STYLE); } else if (codeVal == INVERSE) { if (!inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = true; } } else if (codeVal == INVERSE_OFF) { if (inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = false; } } else if (codeVal == HIDDEN) { clazzes_.add(HIDDEN_STYLE); } else if (codeVal == HIDDEN_OFF) { clazzes_.remove(HIDDEN_STYLE); } else if (codeVal == STRIKETHROUGH) { clazzes_.add(STRIKETHROUGH_STYLE); } else if (codeVal == STRIKETHROUGH_OFF) { clazzes_.remove(STRIKETHROUGH_STYLE); } else if (Color.isFgColorCode(codeVal)) { currentColor_.setCode(codeVal); resetForeground(); clazzes_.add(clazzForColor(codeVal)); } else if (Color.isBgColorCode(codeVal)) { currentBgColor_ = new Color(false, codeVal); resetBackground(); clazzes_.add(clazzForBgColor(codeVal)); } else if (codeVal == RESET_FOREGROUND) { currentColor_.reset(); resetForeground(); } else if (codeVal == RESET_BACKGROUND) { currentBgColor_.reset(); resetBackground(); } else if (codeVal == FOREGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == BACKGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == FONT_NINE) { blockClazzes_.add(FONT_NINE_STYLE); } else if (codeVal == DEFAULT_FONT || (codeVal >= FONT_ONE && codeVal <= FONT_EIGHT)) { blockClazzes_.remove(FONT_NINE_STYLE); } else { \/\/ ignore all others } } return getStyles(); }","old_code_raw":"   public String processCode(String code)\n   {\n      if (code == null || code.length() < 2)\n         return null;\n      if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm')\n         return null;\n      if (code.length() == 2)\n      {\n         clazzes_.clear(); \/\/ CSIm is equivalent to CSI0m, which is 'reset'\n         return null;\n      }\n      \n      int extendedColor = 0;\n      boolean extendedMarkerSeen = false;\n      boolean extendedRGBMarkerSeen = false;\n      int extendedRGBColorsSeen = 0;\n      \n      String[] tokens = code.substring(2, code.length() - 1).split(\";\");\n      for (String token : tokens)\n      {\n         int codeVal = StringUtil.parseInt(token,  -1);\n         if (codeVal == -1)\n            continue;\n\n         if (extendedColor > 0)\n         {\n            if (!extendedMarkerSeen && !extendedRGBMarkerSeen)\n            {\n               if (codeVal == EXT_BY_INDEX)\n               {\n                  extendedMarkerSeen = true;\n                  continue;\n               }\n               else if (codeVal == EXT_BY_RGB)\n               {\n                  extendedRGBMarkerSeen = true;\n                  extendedRGBColorsSeen = 0;\n               }\n               else\n               {\n                  \/\/ unknown extended color format; hard to recover so\n                  \/\/ just reset back to defaults and return\n                  clazzes_.clear();\n                  return null;\n               }\n            }\n            else\n            {\n               \/\/ We don't support colors specified via RGB, but parse the\n               \/\/ sequence then ignore it in case there are supported \n               \/\/ sequences after it\n               if (extendedRGBMarkerSeen)\n               {\n                  extendedRGBColorsSeen++;\n                  if (extendedRGBColorsSeen == 3 \/*red, green, blue*\/)\n                  {\n                     extendedColor = 0;\n                     extendedRGBMarkerSeen = false;\n                     extendedRGBColorsSeen = 0;\n                  }\n               }\n               else \n               {\n                  if (extendedColor == FOREGROUND_EXT)\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentColor_.setExtended(codeVal);\n                        resetForeground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              false \/*background*\/));\n                     }\n                  }\n                  else\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentBgColor_.setExtended(codeVal);\n                        resetBackground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              true \/*background*\/));\n                     }\n                  }\n                  extendedColor = 0;\n                  extendedMarkerSeen = false;\n               }\n            }\n         }\n         else if (codeVal == RESET)\n         {\n            inverted_ = false;\n            currentColor_.reset();\n            currentBgColor_.reset();\n            clazzes_.clear();\n         }\n         else if (codeVal == BOLD)\n         {\n            clazzes_.add(BOLD_STYLE);\n         }\n         else if (codeVal == BLURRED)\n         {\n            \/\/ NYI clazzes_.add(BLURRED_STYLE);\n         }\n         else if (codeVal == BOLD_BLURRED_OFF)\n         {\n            clazzes_.remove(BOLD_STYLE);\n            \/\/ NYI clazzes_.remove(BLURRED_STYLE);\n         }\n         else if (codeVal == ITALIC)\n         {\n            clazzes_.add(ITALIC_STYLE);\n         }\n         else if (codeVal == ITALIC_OFF)\n         {\n            clazzes_.remove(ITALIC_STYLE);\n         }\n         else if (codeVal == UNDERLINE)\n         {\n            clazzes_.add(UNDERLINE_STYLE);\n         }\n         else if (codeVal == UNDERLINE_OFF)\n         {\n            clazzes_.remove(UNDERLINE_STYLE);\n         }\n         else if (codeVal == BLINKSLOW || codeVal == BLINKFAST)\n         {\n            clazzes_.add(BLINK_STYLE);\n         }\n         else if (codeVal == BLINK_OFF)\n         {\n            clazzes_.remove(BLINK_STYLE);\n         }\n         else if (codeVal == INVERSE)\n         {\n            if (!inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = true;\n            }\n         }\n         else if (codeVal == INVERSE_OFF)\n         {\n            if (inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = false;\n            }\n         }\n         else if (codeVal == HIDDEN)\n         {\n            clazzes_.add(HIDDEN_STYLE);\n         }\n         else if (codeVal == HIDDEN_OFF)\n         {\n            clazzes_.remove(HIDDEN_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH)\n         {\n            clazzes_.add(STRIKETHROUGH_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH_OFF)\n         {\n            clazzes_.remove(STRIKETHROUGH_STYLE);\n         }\n         else if (Color.isFgColorCode(codeVal))\n         {\n            currentColor_.setCode(codeVal);\n            resetForeground();\n            clazzes_.add(clazzForColor(codeVal));\n         }\n         else if (Color.isBgColorCode(codeVal))\n         {\n            currentBgColor_ = new Color(false, codeVal);\n            resetBackground();\n            clazzes_.add(clazzForBgColor(codeVal));\n         }\n         else if (codeVal == RESET_FOREGROUND)\n         {\n            currentColor_.reset();\n            resetForeground();\n         }\n         else if (codeVal == RESET_BACKGROUND)\n         {\n            currentBgColor_.reset();\n            resetBackground();\n         }\n         else if (codeVal == FOREGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else if (codeVal == BACKGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else\n         {\n            \/\/ ignore all others\n         }\n      }\n      return getStyle();\n   }\n","new_comment_raw":"Map an ANSI escape sequence to the appropriate css styles; only handles colors and visual appearance covered by SGR codes; other sequences such as cursor movement are ignored.","old_comment_raw":"Map an ANSI escape sequence to the appropriate css styles; only handles colors and visual appearance covered by SGR codes; other sequences such as cursor movement are ignored.","label":0,"pre_label":1,"AST_level":33,"line_counts":226,"new_code_token_num":895},{"new_code_raw":"public final ProviderDescriptor getDescriptor() { return mDescriptor; }","old_code_raw":"    public final RouteProviderDescriptor getDescriptor() {\n        return mDescriptor;\n    }\n","new_comment_raw":"Gets the provider's descriptor.","old_comment_raw":"Gets the current route provider descriptor.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public List<Media> getMedia() { return this.media; }","old_code_raw":"    public List<Image> getMedia() {\n        return this.media;\n    }\n","new_comment_raw":"Media items","old_comment_raw":"Image items","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":12},{"new_code_raw":"public static Criterion ilike(String propertyName, Object value) { if ( value == null ) { throw new IllegalArgumentException( \"Comparison value passed to ilike cannot be null\" ); } return ilike( propertyName, value.toString(), MatchMode.EXACT ); }","old_code_raw":"\tpublic static Criterion ilike(String propertyName, Object value) {\n\t\tif ( value == null ) {\n\t\t\tthrow new IllegalArgumentException( \"Comparison value passed to ilike cannot be null\" );\n\t\t}\n\t\treturn ilike( propertyName, value.toString(), MatchMode.ANYWHERE );\n\t}\n","new_comment_raw":"A case-insensitive \"like\", similar to Postgres ilike operator","old_comment_raw":"A case-insensitive \"like\", similar to Postgres ilike operator","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":50},{"new_code_raw":"public CometSupport defaultCometSupport(final boolean preferBlocking) { if (!preferBlocking && testClassExists(SERVLET_30)) { if (detectWebSocketPresent().size() > 0) { return new Servlet30CometSupportWithWebSocket(config); } return new Servlet30CometSupport(config); } else { return new BlockingIOCometSupport(config); } }","old_code_raw":"    public CometSupport defaultCometSupport(final boolean preferBlocking) {\n        if (!preferBlocking && testClassExists(SERVLET_30)) {\n            return new Servlet30CometSupport(config);\n        } else {\n            return new BlockingIOCometSupport(config);\n        }\n    }\n","new_comment_raw":"This method is used to determine the default CometSupport if all else fails","old_comment_raw":"This method is used to determine the default CometSupport if all else fails","label":0,"pre_label":1,"AST_level":9,"line_counts":11,"new_code_token_num":59},{"new_code_raw":"public int compareTo(IndexedWord w) { if (this.equals(IndexedWord.NO_WORD)) { if (w.equals(IndexedWord.NO_WORD)) { return 0; } else { return -1; } } if (w.equals(IndexedWord.NO_WORD)) { return 1; } \/\/ Override the default comparator if pseudo-positions are set. \/\/ This is needed for splicing trees together awkwardly in OpenIE. if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) { double val = this.pseudoPosition() - w.pseudoPosition(); if (val < 0) { return -1; } if (val > 0) { return 1; } else { return 0; } } \/\/ Otherwise, compare using the normal doc\/sentence\/token index hierarchy String docID = this.getString(CoreAnnotations.DocIDAnnotation.class); int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class)); if (docComp != 0) return docComp; int sentComp = Integer.compare(sentIndex(), w.sentIndex()); if (sentComp != 0) return sentComp; int indexComp = Integer.compare(index(), w.index()); if (indexComp != 0) return indexComp; return Integer.compare(copyCount(), w.copyCount()); }","old_code_raw":"  public int compareTo(IndexedWord w) {\n    if (this.equals(IndexedWord.NO_WORD)) {\n      if (w.equals(IndexedWord.NO_WORD)) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n    if (w.equals(IndexedWord.NO_WORD)) {\n      return 1;\n    }\n\n    \/\/ Override the default comparator if pseudo-positions are set.\n    \/\/ This is needed for splicing trees together awkwardly in OpenIE.\n    if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) {\n      double val = this.pseudoPosition() - w.pseudoPosition();\n      if (val < 0) { return -1; }\n      if (val > 0) { return 1; }\n      else { return 0; }\n    }\n\n    \/\/ Otherwise, compare using the normal doc\/sentence\/token index hierarchy\n    String docID = this.getString(CoreAnnotations.DocIDAnnotation.class);\n    int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class));\n    if (docComp != 0) return docComp;\n\n    int sentComp = sentIndex() - w.sentIndex();\n    if (sentComp != 0) return sentComp;\n\n    int indexComp = index() - w.index();\n    if (indexComp != 0) return indexComp;\n\n    return copyCount() - w.copyCount();\n  }\n","new_comment_raw":"NOTE: For this compareTo, you must have a DocIDAnnotation,","old_comment_raw":"NOTE: This compareTo is based on and made to be compatible with the one from IndexedFeatureLabel.","label":1,"pre_label":0,"AST_level":9,"line_counts":35,"new_code_token_num":249},{"new_code_raw":"public static Optional<Add> create(String statement) { Matcher argumentMatcher = ARGUMENT_TOKENIZER.matcher(statement.trim()); if (!argumentMatcher.find()) { return Optional.absent(); } String commandName = argumentMatcher.group(); if (!(StringUtils.equals(commandName, \"ADD\") || StringUtils.equals(commandName, \"COPY\"))) { return Optional.absent(); } String lastToken = null; Collection<String> sources = new ArrayList<>(); while (argumentMatcher.find()) { if (lastToken != null) { sources.add(lastToken); } lastToken = argumentMatcher.group().replaceAll(\"(^\\\")|(\\\"$)\", \"\"); } if (sources.isEmpty()) { throw new DockerClientException(\"Wrong ADD or COPY format\"); } return Optional.of(new Add(sources, lastToken)); }","old_code_raw":"        public static Optional<Add> create(String statement) {\n            Matcher matcher = ADD_OR_COPY_PATTERN.matcher(statement.trim());\n            if (!matcher.find()) {\n                return Optional.absent();\n            }\n\n            if (matcher.groupCount() != 3) {\n                throw new DockerClientException(\"Wrong ADD or COPY format\");\n            }\n\n            return Optional.of(new Add(matcher));\n        }\n","new_comment_raw":"Createa an Add if it matches, or missing if not.","old_comment_raw":"Createa an Add if it matches, or missing if not.","label":0,"pre_label":1,"AST_level":9,"line_counts":29,"new_code_token_num":174},{"new_code_raw":"public Collection<OsmPrimitive> getSelected() { return Collections.unmodifiableSet(selectedPrimitives); }","old_code_raw":"    public Collection<OsmPrimitive> getSelected() {\n        \/\/ It would be nice to have this be a copy-on-write list\n        \/\/ or an Collections.unmodifiableList().  It would be\n        \/\/ much faster for large selections.  May users just\n        \/\/ call this, and only check the .size().\n        return new ArrayList<OsmPrimitive>(selectedPrimitives);\n    }\n","new_comment_raw":"Replies an unmodifiable collection of primitives currently selected in this dataset","old_comment_raw":"Return a list of all selected objects.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":15},{"new_code_raw":"public String[] createText(MilStd2525TacticalGraphic graphic) { String[] result; String functionId = graphic.getFunctionId(); if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId)) { result = new String[] { graphic.getText() }; } else { boolean useSeparateTimeLabel = this.isShowSeparateTimeLabel(functionId); String mainText = this.createMainText(graphic, functionId, !useSeparateTimeLabel); if (useSeparateTimeLabel) { String timeText = this.createTimeRangeText(graphic); result = new String[] { mainText, timeText }; } else { result = new String[] { mainText }; } } return result; }","old_code_raw":"    public String createText(MilStd2525TacticalGraphic graphic)\n    {\n        String functionId = graphic.getFunctionId();\n        if (CircularFireSupportArea.FUNCTION_ID_TARGET.equals(functionId))\n            return graphic.getText();\n        else\n            return createDateRangeText(graphic, functionId);\n    }\n","new_comment_raw":"Construct the text for labels in a Fire Support area graphic.","old_comment_raw":"Construct the text for the main label of a graphic.","label":1,"pre_label":0,"AST_level":11,"line_counts":28,"new_code_token_num":110},{"new_code_raw":"public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) { return new InstrumentationFieldCompleteParameters( this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, this.fetchedValue, instrumentationState); }","old_code_raw":"    public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) {\n        return new InstrumentationFieldCompleteParameters(\n                this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, instrumentationState);\n    }\n","new_comment_raw":"Returns a cloned parameters object with the new state","old_comment_raw":"Returns a cloned parameters object with the new state","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public Constructor[] getDeclaredConstructors() throws SecurityException { \/\/ BEGIN android-note \/\/ trying to get closer to the RI which returns a raw constructor array. \/\/ copied from newer version of harmony \/\/ END android-note checkDeclaredMemberAccess(); return getDeclaredConstructors(this, false); }","old_code_raw":"    public Constructor<T>[] getDeclaredConstructors() throws SecurityException {\n        checkDeclaredMemberAccess();\n        return getDeclaredConstructors(this, false);\n    }\n","new_comment_raw":"Returns an array containing  Constructor objects for all constructors declared in the class represented by this  Class.","old_comment_raw":"Returns an array containing Constructor objects describing all constructor which are defined by the receiver.","label":1,"pre_label":0,"AST_level":5,"line_counts":10,"new_code_token_num":58},{"new_code_raw":"public static Predicate and(Predicate left, Predicate right){ return PredicateOperation.create(Ops.AND, left, right); }","old_code_raw":"    public static Predicate and(Predicate left, Predicate right){\n        return new PredicateOperation(Ops.AND, left, right);\n    }\n","new_comment_raw":"Create the intersection of the given arguments","old_comment_raw":"Create the intersection of the given arguments","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public static XpiDriverService createDefaultService() { try { return new Builder().build(); } catch (WebDriverException e) { throw new IllegalStateException(e.getMessage(), e.getCause()); } }","old_code_raw":"  public static XpiDriverService createDefaultService() {\n    try {\n      return new XpiDriverService.Builder().usingAnyFreePort().build();\n    } catch (WebDriverException e) {\n      throw new IllegalStateException(e.getMessage(), e.getCause());\n    }\n  }\n","new_comment_raw":"Configures and returns a new  XpiDriverService using the default configuration.","old_comment_raw":"Configures and returns a new XpiDriverService using the default configuration.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":42},{"new_code_raw":"@NonNull protected List<Action> retrieveActions(@NonNull SCMSourceEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }","old_code_raw":"    @NonNull\n    protected Map<Class<? extends Action>, Action> retrieveActions(@NonNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return Collections.emptyMap();\n    }\n","new_comment_raw":"SPI for  #fetchActions(SCMSourceEvent,TaskListener).","old_comment_raw":"SPI for #fetchActions(TaskListener).","label":1,"pre_label":0,"AST_level":5,"line_counts":8,"new_code_token_num":29},{"new_code_raw":"public static LobCreator getLobCreator(SessionImplementor session) { return session.getFactory() .getServiceRegistry() .getService( JdbcServices.class ) .getLobCreator( session ); }","old_code_raw":"\tpublic static LobCreator getLobCreator(SessionImplementor session) {\n\t\treturn session.getFactory()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getLobCreator( session );\n\t}\n","new_comment_raw":"Obtain a lob creator for the given session.","old_comment_raw":"Obtain a lob creator for the given session.","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":28},{"new_code_raw":"public static final TwitterTokenStream of(TwitterTokenStream... streams) { return new TokenStreamAggregator(streams); }","old_code_raw":"  public static final TokenStream of(TokenStream... streams) {\n    return new TokenStreamAggregator(streams);\n  }\n","new_comment_raw":"Creates a  TwitterTokenStream that aggregates the outputs of a given set of  TokenStreams.","old_comment_raw":"Creates a TokenStream that aggregates the outputs of a given set of TokenStreams.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"public final Map<String, String> validateSubDocuments() { final OOXML ooxml = this.getFormatVersion().getXML(); if (!ooxml.canValidate()) return null; final Map<String, String> res = new HashMap<String, String>(); for (final String s : subdocNames) { if (this.getEntries().contains(s)) { final String valid = ooxml.getValidator(this.getDocument(s)).isValid(); if (valid != null) res.put(s, valid); } } return res; }","old_code_raw":"    public final Map<String, String> validateSubDocuments() {\r\n        final OOXML ooxml = OOXML.get(getVersion());\r\n        final Map<String, String> res = new HashMap<String, String>();\r\n        for (final String s : subdocNames) {\r\n            if (this.getEntries().contains(s)) {\r\n                final String valid = ooxml.getValidator(this.getDocument(s)).isValid();\r\n                if (valid != null)\r\n                    res.put(s, valid);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n","new_comment_raw":"Call  Validator#isValid() on each XML subdocuments.","old_comment_raw":"Call OOXML#isValid(Document) on each XML subdocuments.","label":1,"pre_label":0,"AST_level":12,"line_counts":16,"new_code_token_num":103},{"new_code_raw":"public Schema getDefaultSchema() { return this; }","old_code_raw":"  public AbstractSchema getDefaultSchema() {\n    return this;\n  }\n","new_comment_raw":"The schema can be a top level schema which doesn't have its own tables, but refers to one of the default sub schemas for table look up.","old_comment_raw":"The schema can be a top level schema which doesn't have its own tables, but refers to one of the default sub schemas for table look up.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public static List<CmdLineOptionValidator.Result> validate( CmdLineArgs cmdLineArgs) { Validate.notNull(cmdLineArgs); List<CmdLineOptionValidator.Result> results = Lists.newArrayList(); for (CmdLineOptionInstance optionInst : cmdLineArgs .getSpecifiedOptions()) { results.addAll(CmdLineUtils.validate(optionInst)); } return results; }","old_code_raw":"   public static Set<CmdLineOptionInstance> validate(CmdLineArgs cmdLineArgs) {\n      Validate.notNull(cmdLineArgs);\n\n      HashSet<CmdLineOptionInstance> optionsFailed = new HashSet<CmdLineOptionInstance>();\n      for (CmdLineOptionInstance optionInst : cmdLineArgs\n            .getSpecifiedOptions()) {\n         if (!CmdLineUtils.validate(optionInst)) {\n            optionsFailed.add(optionInst);\n         }\n      }\n      return optionsFailed;\n   }\n","new_comment_raw":"Runs validation on  CmdLineArgs and returns the validation results.","old_comment_raw":"Runs validation on CmdLineArgs and returns the options which failed validation.","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":52},{"new_code_raw":"@Override public boolean equals(Object other) { if (this == other) { return true; } if (other instanceof PwPair) { PwPair otherPwPair = (PwPair) other; return getRank() == otherPwPair.getRank() && mUrlDevice.equals(otherPwPair.mUrlDevice) && mPwsResult.equals(otherPwPair.mPwsResult); } return false; }","old_code_raw":"  public boolean equals(Object other) {\n    if (other instanceof PwPair) {\n      PwPair otherPwPair = (PwPair) other;\n      return getRank() == otherPwPair.getRank();\n    }\n    return false;\n  }\n","new_comment_raw":"Check if two PwPairs are equal.","old_comment_raw":"Check if two PwPairs are equal based on rank.","label":1,"pre_label":0,"AST_level":9,"line_counts":16,"new_code_token_num":64},{"new_code_raw":"public static String asString(final InputStream is, Charset charset) throws IOException { final BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset)); try { final String firstLine = reader.readLine(); if (firstLine == null) { return \"\"; } final StringBuilder builder = new StringBuilder(firstLine); for (String line = reader.readLine(); line != null; line = reader.readLine()) { builder.append(EOL); builder.append(line); } return builder.toString(); } finally { reader.close(); } }","old_code_raw":"    public static String asString(final InputStream is) throws IOException {\n        final BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n        try {\n            return reader.readLine();\n        } finally {\n            reader.close();\n        }\n    }\n","new_comment_raw":"Reads the provided input stream as a string and then closes the stream.","old_comment_raw":"Reads the provided input stream as a UTF-8 string and then closes the stream.","label":1,"pre_label":0,"AST_level":8,"line_counts":19,"new_code_token_num":109},{"new_code_raw":"public String getSchemaType(Schema schema) { if (schema instanceof ComposedSchema) { \/\/ composed schema ComposedSchema cs = (ComposedSchema) schema; List<Schema> schemas = ModelUtils.getInterfaces(cs); if (cs.getAllOf() != null) { for (Schema s : cs.getAllOf()) { if (s != null) { \/\/schema = s; } \/\/LOGGER.info(\"ALL OF SCHEMA: {}\", s); } LOGGER.info(\"Composed schema not yet supported: {}\", cs); \/\/ get the model (allOf) return getAlias(\"UNKNOWN_COMPOSED_SCHMEA\"); } else if (cs.getAnyOf() != null) { \/\/ anyOf List<String> names = new ArrayList<String>(); for (Schema s : schemas) { if (StringUtils.isNotBlank(s.get$ref())) { \/\/ reference to another definition\/schema String schemaName = ModelUtils.getSimpleRef(s.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { names.add(getAlias(schemaName)); } else { LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\"); return \"object\"; } } else { \/\/ primitive type or model names.add(getAlias(getPrimitiveType(s))); } return \"anyOf<\" + String.join(\",\", names) + \">\"; } } else if (cs.getOneOf() != null) { \/\/ oneOf List<String> names = new ArrayList<String>(); for (Schema s : schemas) { if (StringUtils.isNotBlank(s.get$ref())) { \/\/ reference to another definition\/schema String schemaName = ModelUtils.getSimpleRef(s.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { names.add(getAlias(schemaName)); } else { LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\"); return \"object\"; } } else { \/\/ primitive type or model names.add(getAlias(getPrimitiveType(s))); } return \"oneOf<\" + String.join(\",\", names) + \">\"; } } } if (StringUtils.isNotBlank(schema.get$ref())) { \/\/ reference to another definition\/schema \/\/ get the schema\/model name from $ref String schemaName = ModelUtils.getSimpleRef(schema.get$ref()); if (StringUtils.isNotEmpty(schemaName)) { return getAlias(schemaName); } else { LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\"); return \"object\"; } } else { \/\/ primitive type or model return getAlias(getPrimitiveType(schema)); } }","old_code_raw":"    public String getSchemaType(Schema schema) {\n        \/\/ TODO better logic to handle compose schema\n        if (schema instanceof ComposedSchema) { \/\/ composed schema\n            ComposedSchema cs = (ComposedSchema) schema;\n            if (cs.getAllOf() != null) {\n                for (Schema s : cs.getAllOf()) {\n                    if (s != null) {\n                        \/\/ using the first schema defined in allOf\n                        schema = s;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (StringUtils.isNotBlank(schema.get$ref())) { \/\/ reference to another definition\/schema\n            \/\/ get the schema\/model name from $ref\n            String schemaName = ModelUtils.getSimpleRef(schema.get$ref());\n            if (StringUtils.isNotEmpty(schemaName)) {\n                return getAlias(schemaName);\n            } else {\n                LOGGER.warn(\"Error obtaining the datatype from ref:\" + schema.get$ref() + \". Default to 'object'\");\n                return \"object\";\n            }\n        } else { \/\/ primitive type or model\n            return getAlias(getPrimitiveType(schema));\n        }\n    }\n","new_comment_raw":"returns the OpenAPI type for the property.","old_comment_raw":"returns the OpenAPI type for the property.","label":0,"pre_label":1,"AST_level":19,"line_counts":66,"new_code_token_num":569},{"new_code_raw":"public static GraphQLSchema transformSchema(GraphQLSchema schema, GraphQLTypeVisitor visitor) { return transformSchema(schema, TraversalType.ALL, visitor); }","old_code_raw":"    public static GraphQLSchema transformSchema(GraphQLSchema schema, GraphQLTypeVisitor visitor) {\n        SchemaTransformer schemaTransformer = new SchemaTransformer();\n        return schemaTransformer.transform(schema, visitor);\n    }\n","new_comment_raw":"Transforms a GraphQLSchema and returns a new GraphQLSchema object.","old_comment_raw":"Transforms a GrapQLSchema and returns a new GraphQLSchema object.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public static ColumnNameFilter getInstance(String fullyQualifiedColumnNames) { Predicate<ColumnId> delegate = Predicates.excludes(fullyQualifiedColumnNames, ColumnId::toString); return (catalogName, schemaName, tableName, columnName) -> delegate.test(new ColumnId(new TableId(catalogName, schemaName, tableName), columnName)); }","old_code_raw":"        public static ColumnNameFilter getInstance(String fullyQualifiedColumnNames) {\n            Predicate<ColumnId> delegate = Predicates.excludes(fullyQualifiedColumnNames, ColumnId::toString);\n\n            return new ColumnNameFilter() {\n\n                @Override\n                public boolean matches(String catalogName, String schemaName, String tableName, String columnName) {\n                    return delegate.test(new ColumnId(new TableId(catalogName, schemaName, tableName), columnName));\n                }\n            };\n        }\n","new_comment_raw":"Build the  ColumnNameFilter that determines whether a column identified by a given  ColumnId is to be included, using the given comma-separated regular expression patterns defining which columns (if any) should be excluded.","old_comment_raw":"Build the ColumnNameFilter that determines whether a column identified by a given ColumnId is to be included, using the given comma-separated regular expression patterns defining which columns (if any) should be excluded.","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":55},{"new_code_raw":"public static ENumber<Integer> indexOf(Expr<String> left, String right) { return operationFactory.createNumber(Integer.class, Ops.INDEXOF, left, exprFactory.createConstant(right)); }","old_code_raw":"    public static ENumber<Integer> indexOf(Expr<String> left, String right, int i) {\n        return operationFactory.createNumber(Integer.class,Ops.INDEXOF_2ARGS, left, exprFactory.createConstant(right), exprFactory.createConstant(i));\n    }\n","new_comment_raw":"Expr : left.indexOf(right)","old_comment_raw":"Expr : left.indexOf(right, i)","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":34},{"new_code_raw":"public static Result createGemFireErrorResult(String message) { return createErrorResult(ERRORCODE_GEODE_ERROR, \"Could not process command due to error. \" + message); }","old_code_raw":"  public static Result createGemFireErrorResult(String message) {\n    return createErrorResult(ERRORCODE_GEMFIRE_ERROR,\n        \"Could not process command due to GemFire error. \" + message);\n  }\n","new_comment_raw":"Method for convenience to create error result for error in Geode while executing command.","old_comment_raw":"Method for convenience to create error result for error in GemFire while executing command.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":28},{"new_code_raw":"public CubeInstance disableCube(CubeInstance cube) throws IOException { aclEvaluate.hasProjectWritePermission(cube.getProjectInstance()); Message msg = MsgPicker.getMsg(); String cubeName = cube.getName(); RealizationStatusEnum ostatus = cube.getStatus(); if (null != ostatus && !RealizationStatusEnum.READY.equals(ostatus)) { throw new BadRequestException(String.format(msg.getDISABLE_NOT_READY_CUBE(), cubeName, ostatus)); } return getCubeManager().updateCubeStatus(cube, RealizationStatusEnum.DISABLED); }","old_code_raw":"    public CubeInstance disableCube(CubeInstance cube) throws IOException {\n        aclEvaluate.hasProjectWritePermission(cube.getProjectInstance());\n        Message msg = MsgPicker.getMsg();\n\n        String cubeName = cube.getName();\n\n        RealizationStatusEnum ostatus = cube.getStatus();\n        if (null != ostatus && !RealizationStatusEnum.READY.equals(ostatus)) {\n            throw new BadRequestException(String.format(msg.getDISABLE_NOT_READY_CUBE(), cubeName, ostatus));\n        }\n\n        cube.setStatus(RealizationStatusEnum.DISABLED);\n\n        try {\n            CubeUpdate cubeBuilder = new CubeUpdate(cube);\n            cubeBuilder.setStatus(RealizationStatusEnum.DISABLED);\n            return getCubeManager().updateCube(cubeBuilder);\n        } catch (IOException e) {\n            cube.setStatus(ostatus);\n            throw e;\n        }\n    }\n","new_comment_raw":"Update a cube status from ready to disabled.","old_comment_raw":"Update a cube status from ready to disabled.","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":88},{"new_code_raw":"public SortedMap<String, String> getOriginTabContentsAsStrings(final Origin selectedColumn) { openTab(Tab.ORIGIN); return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, false), selectedColumn.column); }","old_code_raw":"    public SortedMap<String, String> getOriginTabContentsAsStrings() {\n        openTab(Tab.ORIGIN);\n        return mapTableCellsKeyValue(String.class, getVisibleTableRows(true, true), 3);\n    }\n","new_comment_raw":"Returns the first and the specified columns of the \"Origin\"-tab as key => value pairs, skipping the header row.","old_comment_raw":"Returns the first two columns of the \"Warnings\"-tab as key => value pairs, skipping the header row.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":36},{"new_code_raw":"public boolean isPullSuccessIndicated() { if (isErrorIndicated() || getStatus() == null) { return false; } return (getStatus().contains(DOWNLOAD_COMPLETE) || getStatus().contains(IMAGE_UP_TO_DATE) || getStatus().contains(DOWNLOADED_NEWER_IMAGE) || getStatus().contains(LEGACY_REGISTRY) || getStatus().contains(DOWNLOADED_SWARM) ); }","old_code_raw":"    public boolean isPullSuccessIndicated() {\n        if (isErrorIndicated() || getStatus() == null) {\n            return false;\n        }\n\n        return (getStatus().contains(DOWNLOAD_COMPLETE) || getStatus().contains(IMAGE_UP_TO_DATE)\n                || getStatus().contains(DOWNLOADED_NEWER_IMAGE) || getStatus().contains(LEGACY_REGISTRY));\n    }\n","new_comment_raw":"Returns whether the status indicates a successful pull operation","old_comment_raw":"Returns whether the status indicates a successful pull operation","label":0,"pre_label":1,"AST_level":10,"line_counts":13,"new_code_token_num":71},{"new_code_raw":"protected AuthenticationInfo doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) { ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy(); AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token); if (log.isDebugEnabled()) { log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\"); } for (Realm realm : realms) { if (realm.supports(token)) { if (log.isDebugEnabled()) { log.debug(\"Attempting to authenticate token [\" + token + \"] \" + \"using realm of type [\" + realm + \"]\"); } AuthenticationInfo info = null; Throwable t = null; try { info = realm.getAuthenticationInfo(token); } catch (Throwable throwable) { t = throwable; if (log.isTraceEnabled()) { String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\"; log.trace(msg, t); } } aggregate = strategy.afterAttempt(realm, token, info, aggregate, t); } else { if (log.isDebugEnabled()) { log.debug(\"Realm of type [\" + realm + \"] does not support token \" + \"[\" + token + \"]. Skipping realm.\"); } } } aggregate = strategy.afterAllAttempts(token, aggregate); return aggregate; }","old_code_raw":"    protected Account doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) {\n\n        ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();\n\n        Account aggregate = strategy.beforeAllAttempts(realms, token);\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"Iterating through [\" + realms.size() + \"] realms for PAM authentication\");\n        }\n\n        for (Realm realm : realms) {\n\n            if (realm.supports(token)) {\n\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Attempting to authenticate token [\" + token + \"] \" +\n                            \"using realm of type [\" + realm + \"]\");\n                }\n\n                aggregate = strategy.beforeAttempt(realm, token, aggregate);\n\n                Account account = null;\n                Throwable t = null;\n                try {\n                    account = realm.getAccount(token);\n                } catch (Throwable throwable) {\n                    t = throwable;\n                    if (log.isTraceEnabled()) {\n                        String msg = \"Realm [\" + realm + \"] threw an exception during a multi-realm authentication attempt:\";\n                        log.trace(msg, t);\n                    }\n                }\n\n                aggregate = strategy.afterAttempt(realm, token, account, aggregate, t);\n\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Realm of type [\" + realm + \"] does not support token \" +\n                            \"[\" + token + \"].  Skipping realm.\");\n                }\n            }\n        }\n\n        aggregate = strategy.afterAllAttempts(token, aggregate);\n\n        return aggregate;\n    }\n","new_comment_raw":"Performs the multi-realm authentication attempt by calling back to a  ModularAuthenticationStrategy object as each realm is consulted for AuthenticationInfo for the specified token.","old_comment_raw":"Performs the multi-realm authentication attempt by calling back to a ModularAuthenticationStrategy object as each realm is consulted for Account for the specified token.","label":1,"pre_label":0,"AST_level":16,"line_counts":47,"new_code_token_num":264},{"new_code_raw":"public boolean areTablesToBeUpdated(Set tables) { return areTablesToUpdated( updates, tables ) || areTablesToUpdated( insertions, tables ) || areTablesToUpdated( unresolvedInsertions.getDependentEntityInsertActions(), tables ) || areTablesToUpdated( deletions, tables ) || areTablesToUpdated( collectionUpdates, tables ) || areTablesToUpdated( collectionCreations, tables ) || areTablesToUpdated( collectionQueuedOps, tables ) || areTablesToUpdated( collectionRemovals, tables ); }","old_code_raw":"\tpublic boolean areTablesToBeUpdated(Set tables) {\n\t\treturn areTablesToUpdated( updates, tables ) ||\n\t\t\t\tareTablesToUpdated( insertions, tables ) ||\n\t\t\t\tareTablesToUpdated( unresolvedInsertions.getDependentEntityInsertActions(), tables ) ||\n\t\t\t\tareTablesToUpdated( deletions, tables ) ||\n\t\t\t\tareTablesToUpdated( collectionUpdates, tables ) ||\n\t\t\t\tareTablesToUpdated( collectionCreations, tables ) ||\n\t\t\t\tareTablesToUpdated( collectionRemovals, tables );\n\t}\n","new_comment_raw":"Check whether the given tables\/query-spaces are to be executed against given the currently queued actions.","old_comment_raw":"Check whether the given tables\/query-spaces are to be executed against given the currently queued actions.","label":0,"pre_label":1,"AST_level":12,"line_counts":11,"new_code_token_num":76},{"new_code_raw":"public double get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public double get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.","old_comment_raw":"Analogous to #get(WithAttributes) except returning a primitive double.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public String getTypeDeclaration(Schema schema) { if (schema == null) { LOGGER.warn(\"Null schema found. Default type to `NULL_SCHMEA_ERR`\"); return \"NULL_SCHMEA_ERR\"; } String oasType = getSchemaType(schema); if (typeMapping.containsKey(oasType)) { return typeMapping.get(oasType); } return oasType; }","old_code_raw":"    public String getTypeDeclaration(Schema schema) {\n        String oasType = getSchemaType(schema);\n        if (typeMapping.containsKey(oasType)) {\n            return typeMapping.get(oasType);\n        }\n        return oasType;\n    }\n","new_comment_raw":"Output the type declaration of the property","old_comment_raw":"Output the type declaration of the property","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":62},{"new_code_raw":"public ScrollableResults scroll(ScrollMode mode, Expr<?>[] args) { Query query = createQuery(args); reset(); return query.scroll(mode); }","old_code_raw":"    public ScrollableResults scroll(ScrollMode mode, Expr<?>[] args) {\n        return createQuery(args).scroll(mode);\n    }\n","new_comment_raw":"Return the query results as ScrollableResults.","old_comment_raw":"Return the query results as ScrollableResults.","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":33},{"new_code_raw":"public ScalewayCloud getCloud() { Jenkins instance = Jenkins.getInstance(); if (instance != null) { return (ScalewayCloud) instance.getCloud(cloudName); } return null; }","old_code_raw":"    public Cloud getCloud() {\n        return (Cloud) Jenkins.getInstance().getCloud(cloudName);\n    }\n","new_comment_raw":"Retrieve a handle to the associated  com.github.segator.jenkins.scaleway.ScalewayCloud","old_comment_raw":"Retrieve a handle to the associated com.segator.jenkins.scaleway.Cloud","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":35},{"new_code_raw":"@Override public boolean equals(Object obj) { if (obj != null && obj.getClass().equals(this.getClass())) { NoteObject that = (NoteObject) obj; if (content == null && that.getContent() != null) return false; if (content != null && !content.equals(that.getContent())) return false; } return true; }","old_code_raw":"\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj != null && obj.getClass().equals(this.getClass())) {\n\t\t\tNoteObject that = (NoteObject) obj;\n\t\t\treturn (this.content.equals(that.getContent()));\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"Tests if two notes are equal.","old_comment_raw":"Tests if two contents are equal.","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":78},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException { return fakeOuterBooleanSerializeWithHttpInfo(body).getData(); }","old_code_raw":"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/boolean\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"Test serialization of outer boolean types","old_comment_raw":"Test serialization of outer boolean types","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"private Timepoint roundToValidTime(Timepoint newSelection, int currentItemShowing) { switch(currentItemShowing) { case HOUR_INDEX: return mController.roundToNearest(newSelection, null); case MINUTE_INDEX: return mController.roundToNearest(newSelection, Timepoint.TYPE.HOUR); default: return mController.roundToNearest(newSelection, Timepoint.TYPE.MINUTE); } }","old_code_raw":"    private Timepoint roundToValidTime(Timepoint newSelection, int currentItemShowing) {\n        switch(currentItemShowing) {\n            case HOUR_INDEX:\n                newSelection = mController.roundToNearest(newSelection, Timepoint.TYPE.HOUR);\n                break;\n            case MINUTE_INDEX:\n                newSelection = mController.roundToNearest(newSelection, Timepoint.TYPE.MINUTE);\n                break;\n            case SECOND_INDEX:\n                newSelection = mController.roundToNearest(newSelection, Timepoint.TYPE.SECOND);\n                break;\n            default:\n                newSelection = mCurrentTime;\n        }\n        return newSelection;\n    }\n","new_comment_raw":"Snap the input to a selectable value","old_comment_raw":"Snap the input to a selectable value","label":0,"pre_label":1,"AST_level":7,"line_counts":11,"new_code_token_num":57},{"new_code_raw":"public static Path createTestingPath(String relativePath) { return Paths.get(dataDir(), relativePath).toAbsolutePath(); }","old_code_raw":"        public static Path createTestingPath(String relativePath) {\n            return Paths.get(\"target\/data\", relativePath).toAbsolutePath();\n        }\n","new_comment_raw":"Create the path to a file within the test data directory at the given relative path.","old_comment_raw":"Create the path to a file within the test data directory at the given relative path.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public EReference getTopic_Comments() { return (EReference) topicEClass.getEStructuralFeatures().get(1); }","old_code_raw":"\tpublic EReference getTopic_Comments() {\n\t\treturn (EReference) topicEClass.getEStructuralFeatures().get(2);\n\t}\n","new_comment_raw":"Returns the meta object for the containment reference list '  org.eclipse.mylyn.reviews.core.model.ITopic#getComments Comments'.","old_comment_raw":"Returns the meta object for the reference list ' org.eclipse.mylyn.reviews.core.model.ITopic#getComments Comments'.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll, false); }","old_code_raw":"\tpublic boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll);\n\t}\n","new_comment_raw":"Searches for a text string and returns  true if the searched text is found a given number of times.","old_comment_raw":"Searches for a text string and returns true if the searched text is found a given number of times.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public static EventProcessingFailureHandlingMode parse(String value) { if (value == null) { return null; } value = value.trim(); for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }","old_code_raw":"        public static Version parse(String value, String defaultValue) {\n            Version mode = parse(value);\n            if (mode == null && defaultValue != null) {\n                mode = parse(defaultValue);\n            }\n            return mode;\n        }\n","new_comment_raw":"Determine if the supplied value is one of the predefined options.","old_comment_raw":"Determine if the supplied value is one of the predefined options.","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":57},{"new_code_raw":"private boolean isSameText() { ArrayList<TextView> textViewList = soloView.getCurrentTextViews(null); int size = textViewList.size(); int constant = 0; if (size > 2) constant = 2; else constant = size; if (checkTextView != null && !checkTextView.getText().equals( textViewList.get(size - constant).getText())) { checkTextView = textViewList.get(size - constant); return false; } else if (checkTextView == null) { checkTextView = textViewList.get(size - constant); return false; } else return true; }","old_code_raw":"\tprivate boolean isSameText() {\n\t\tArrayList<TextView> textViewList = soloView.getCurrentTextViews(null);\n\t\tint size = textViewList.size();\n\t\tint constant = 0;\n\t\tif (size > 2)\n\t\t\tconstant = 2;\n\t\telse\n\t\t\tconstant = size;\n\t\t\n\t\tif (checkTextView != null\n\t\t\t\t&& !checkTextView.getText().equals(\n\t\t\t\t\t\tsoloView.getCurrentTextViews(null).get(\n\t\t\t\t\t\t\t\tsoloView.getCurrentTextViews(null).size()\n\t\t\t\t\t\t\t\t\t\t- constant).getText())) {\n\t\t\tcheckTextView = textViewList.get(size - constant);\n\t\t\treturn true;\n\t\t} else if (checkTextView == null) {\n\t\t\tcheckTextView = textViewList.get(size - constant);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n","new_comment_raw":"Determines if a previous text is the same as the current.","old_comment_raw":"Determines if no more scrolling can be done.","label":1,"pre_label":0,"AST_level":10,"line_counts":22,"new_code_token_num":103},{"new_code_raw":"private File createNewFile() { String filename = \"image-\" + UUID.randomUUID().toString() + \".jpg\"; File path; if (tmpImage) { path = mReactContext.getExternalCacheDir(); } else { path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); } File f = new File(path, filename); try { path.mkdirs(); f.createNewFile(); } catch (IOException e) { e.printStackTrace(); } return f; }","old_code_raw":"  private File createNewFile(final boolean forcePictureDirectory) {\n    String filename = \"image-\" + UUID.randomUUID().toString() + \".jpg\";\n    if (tmpImage && forcePictureDirectory != true) {\n      return new File(mReactContext.getCacheDir(), filename);\n    } else {\n      File path = Environment.getExternalStoragePublicDirectory(\n              Environment.DIRECTORY_PICTURES);\n      File f = new File(path, filename);\n\n      try {\n        path.mkdirs();\n        f.createNewFile();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      return f;\n    }\n  }\n","new_comment_raw":"Create a new file","old_comment_raw":"Create a new file","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":90},{"new_code_raw":"public Button getButton(int index) { Button button = soloView.getButton(index); return button; }","old_code_raw":"\tpublic Button getButton(int index) {\n\t\tArrayList<Button> buttonList = getCurrentButtons();\n\t\treturn buttonList.get(index);\n\t}\n","new_comment_raw":"This method returns a button with a certain index.","old_comment_raw":"This method returns a button with a certain index.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"public long getExecutionRowCount() { return executionRowCount.sum(); }","old_code_raw":"\tpublic long getExecutionRowCount() {\n\t\treturn executionRowCount.get();\n\t}\n","new_comment_raw":"Number of lines returned by all the executions of this query (from DB)","old_comment_raw":"Number of lines returned by all the executions of this query (from DB)","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"protected Object convertDouble(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0.0d; } if (data instanceof Double) return data; if (data instanceof Number) { \/\/ Includes BigDecimal and other numeric values ... Number value = (Number) data; return new Double(value.doubleValue()); } if (data instanceof Boolean) { return NumberConversions.getDouble((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertDouble(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0.0d;\n        }\n        if (data instanceof Double) return data;\n        if (data instanceof Number) {\n            \/\/ Includes BigDecimal and other numeric values ...\n            Number value = (Number) data;\n            return new Double(value.doubleValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? DOUBLE_TRUE : DOUBLE_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#DOUBLE.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#DOUBLE.","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":122},{"new_code_raw":"protected String getNewIdFor(EObject element_p) { return copyXmlIds()? null: EcoreUtil.generateUUID(); }","old_code_raw":"  protected String getNewIdFor(EObject element_p) {\r\n    return copyPhysicalIds()? null: EcoreUtil.generateUUID();\r\n  }\r\n","new_comment_raw":"Return a new unique intrinsic ID for the given element, if relevant.","old_comment_raw":"Return a new unique Ecore identifier for the given element, if relevant.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":21},{"new_code_raw":"public CubeDesc updateCubeDesc(CubeDesc desc) throws IOException { \/\/ Validate CubeDesc if (desc.getUuid() == null || desc.getName() == null) { throw new IllegalArgumentException(); } String name = desc.getName(); if (!cubeDescMap.containsKey(name)) { throw new IllegalArgumentException(\"CubeDesc '\" + name + \"' does not exist.\"); } try { desc.init(config, getMetadataManager().getAllTablesMap()); } catch (Exception e) { desc.addError(e.getMessage()); return desc; } \/\/ Semantic validation CubeMetadataValidator validator = new CubeMetadataValidator(); ValidateContext context = validator.validate(desc); if (!context.ifPass()) { return desc; } desc.setSignature(desc.calculateSignature()); \/\/ Save Source String path = desc.getResourcePath(); getStore().putResource(path, desc, CUBE_DESC_SERIALIZER); \/\/ Reload the CubeDesc CubeDesc ndesc = loadCubeDesc(path, false); \/\/ Here replace the old one cubeDescMap.put(ndesc.getName(), desc); return ndesc; }","old_code_raw":"    public CubeDesc updateCubeDesc(CubeDesc desc) throws IOException {\n        \/\/ Validate CubeDesc\n        if (desc.getUuid() == null || desc.getName() == null) {\n            throw new IllegalArgumentException();\n        }\n        String name = desc.getName();\n        if (!cubeDescMap.containsKey(name)) {\n            throw new IllegalArgumentException(\"CubeDesc '\" + name + \"' does not exist.\");\n        }\n\n        try {\n            desc.init(config, getMetadataManager().getAllTablesMap());\n        } catch (IllegalStateException e) {\n            desc.addError(e.getMessage(), true);\n            return desc;\n        } catch (IllegalArgumentException e) {\n            desc.addError(e.getMessage(), true);\n            return desc;\n        }\n\n        \/\/ Semantic validation\n        CubeMetadataValidator validator = new CubeMetadataValidator();\n        ValidateContext context = validator.validate(desc, true);\n        if (!context.ifPass()) {\n            return desc;\n        }\n\n        desc.setSignature(desc.calculateSignature());\n\n        \/\/ Save Source\n        String path = desc.getResourcePath();\n        getStore().putResource(path, desc, CUBE_DESC_SERIALIZER);\n\n        \/\/ Reload the CubeDesc\n        CubeDesc ndesc = loadCubeDesc(path);\n        \/\/ Here replace the old one\n        cubeDescMap.put(ndesc.getName(), desc);\n\n        return ndesc;\n    }\n","new_comment_raw":"Update CubeDesc with the input.","old_comment_raw":"Update CubeDesc with the input.","label":0,"pre_label":1,"AST_level":9,"line_counts":38,"new_code_token_num":209},{"new_code_raw":"public SessionFactoryImpl getEntityManagerFactory() { return sessionFactory; }","old_code_raw":"\tpublic  EntityManagerFactoryImpl getEntityManagerFactory() {\n\t\treturn entityManagerFactory;\n\t}\n","new_comment_raw":"Provides protected access to the underlying  SessionFactoryImpl.","old_comment_raw":"Provides protected access to the underlying EntityManagerFactoryImpl.","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"private int waitForSocket(Launcher launcher, int port, int timeout) { try { LocalPortReceiveAdbPortTask task = new LocalPortReceiveAdbPortTask(port, timeout); return launcher.getChannel().call(task); } catch (InterruptedException ex) { \/\/ Ignore } catch (IOException e) { \/\/ Ignore } return -1; }","old_code_raw":"    private boolean waitForSocket(Launcher launcher, int port, int timeout) {\n        try {\n            LocalPortOpenTask task = new LocalPortOpenTask(port, timeout);\n            return launcher.getChannel().call(task);\n        } catch (InterruptedException ex) {\n            \/\/ Ignore\n        } catch (IOException e) {\n            \/\/ Ignore\n        }\n\n        return false;\n    }\n","new_comment_raw":"Waits for an emulator to say what socket its using, or times out.","old_comment_raw":"Waits for a socket on the remote machine's localhost to become available, or times out.","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":62},{"new_code_raw":"public float getY() { if(top == null) { calculateTop(); } return top.floatValue(); }","old_code_raw":"    public float getY() {\r\n        return center[1];\r\n    }\r\n","new_comment_raw":"Get the y position of the top of this shape.","old_comment_raw":"Get the y location of the center of this circle","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":24},{"new_code_raw":"protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) { final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex); \/\/ parse this composition into values stored in a Map Map<String,String> ehr13606values = retrieveValues(composition, compositionIndex); \/\/ use the ehr values to build a medication medical history record body return buildBody(ehr13606values); }","old_code_raw":"    protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) {\n        final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex);\n\n        final MedicationMedicalRecordBodyType bodyType = new MedicationMedicalRecordBodyType();\n        \n        \n        AdditionalPatientInformationType apit = new AdditionalPatientInformationType();\n        apit.setDateOfBirth(\"2010-01-31\");\n        \n        CVType gender = new CVType();\n        gender.setCode(\"abc\");\n        gender.setCodeSystem(\"def\");\n        gender.setDisplayName(\"ghi\");\n        gender.setOriginalText(\"jkl\");\n        apit.setGender(gender);\n        \n        bodyType.setAdditionalPatientInformation(apit);\n        \n        MedicationPrescriptionType mpt = new MedicationPrescriptionType();\n        \n        mpt.setDispensationAuthorization(new DispensationAuthorizationType());\n        mpt.setEndOfTreatment(\"2014-12-31\");\n        mpt.setEndOfTreatmentReason(new CVType());\n        mpt.setEvaluator(new HealthcareProfessionalType());\n        mpt.setPrecedingPrescriptionId(new IIType());\n        mpt.setPrescriber(new HealthcareProfessionalType());\n        mpt.setPrescriptionChainId(new IIType());\n        mpt.setPrescriptionId(new IIType());\n        mpt.setPrescriptionStatus(new CVType());\n        mpt.setSelfMedication(false);\n        mpt.setStartOfFirstTreatment(\"2014-01-31\");\n        mpt.setSucceedingPrescriptionId(new IIType());\n        mpt.setTypeOfPrescription(TypeOfPrescriptionEnum.INS\u00c4TTNING);\n        \n        bodyType.setMedicationPrescription(mpt);\n\n        for (final CONTENT content : composition.getContent()) {\n            for (final ITEM item : ((ENTRY) content).getItems()) {\n            \t\n            \t\n            \tlog.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + (item instanceof ELEMENT ? \"ELEMENT\" : \"CLUSTER\"));\n\n                switch (item.getMeaning().getCode()) {\n                    case \"lkm-ord-tid\":   \/\/ Ordinationstidpunkt\n                        mpt.setStartOfTreatment(\"2014-02-28\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-ord-not\":   \/\/ Notat\n                        mpt.setPrescriptionNote(\"Here is a note\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-ord-utv\":   \/\/ Utv\u00e4rderingstidpunkt\n                        mpt.setEvaluationTime(\"123\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-ord-and\":   \/\/ \u00c4ndam\u00e5l\n                        mpt.setTreatmentPurpose(\"There is a purpose to this treatment\");\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                        \n\n                    case \"lkm-dos\"    :   \/\/ Dosering\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue());\n                    \tCLUSTER c = (CLUSTER)item;\n                    \tList<ITEM> parts = c.getParts();\n                    \tfor (ITEM part : parts) {\n                        \tlog.debug(part.getMeaning().getCode());\n                            if (\"lkm-dst\".equals(part.getMeaning().getCode())) {\n                                c = (CLUSTER)part;\n                                \n                                List<ITEM> dosparts = c.getParts();\n                                for (ITEM dospart : dosparts) {\n                                    log.debug(dospart.getMeaning().getCode() + \" \" + dospart.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)dospart));\n                                }\n                            }\n                        }\n                        break;\n                        \n                    case \"lkm-lva\"    :   \/\/ L\u00e4kemedelsval\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue());\n                        c = (CLUSTER)item;\n                        parts = c.getParts();\n                        for (ITEM part : parts) {\n                            log.debug(part.getMeaning().getCode());\n                            \n                            switch (item.getMeaning().getCode()) {\n                            case \"lkm-lva-kom\" :\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            case \"lkm-lva-typ\" :\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            case \"lkm-lva-ext\" :\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            case \"lkm-lkm-lva\":\n                                log.debug(part.getMeaning().getCode() + \" \" + part.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)part));\n                                break;\n                            }\n                        }\n                        \/\/ mpt.setDrug(new DrugChoiceType());\n                        \/\/ EHRUtil.getElementTextValue((ELEMENT)item);\n                        break;\n                        \n                        \n                    case \"lkm-for-tid\":   \/\/ F\u00f6rskrivningstidpunkt\n                        mpt.setStartOfTreatment(\"2014-02-28\");\n                        break;\n                    case \"lkm-for-uiv\":   \/\/ Utl\u00e4mningsintervall\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-mpt\":   \/\/ M\u00e4ngd per tillf\u00e4lle\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-tot\":   \/\/ Totalm\u00e4ngd\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-fpe\":   \/\/ F\u00f6rpackningsenhet\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                    case \"lkm-for-dbs\":   \/\/ Distributionss\u00e4tt\n                        log.debug(item.getMeaning().getCode() + \" \" + item.getMeaning().getDisplayName().getValue() + \" \" + EHRUtil.getElementTextValue((ELEMENT)item));\n                        break;\n                }\n            }\n        }\n        return bodyType;\n    }\n","new_comment_raw":"Create a MedicationMedicalRecord using the information in the current ehr13606 composition.","old_comment_raw":"Maps contact body information.","label":1,"pre_label":0,"AST_level":7,"line_counts":12,"new_code_token_num":69},{"new_code_raw":"public T caseCustomersType(CustomersType object) { return null; }","old_code_raw":"  public Object caseCustomersType(CustomersType object)\n  {\n    return null;\n  }\n","new_comment_raw":"Returns the result of interpretting the object as an instance of 'Customers Type'.","old_comment_raw":"Returns the result of interpretting the object as an instance of 'sType'.","label":1,"pre_label":0,"AST_level":4,"line_counts":6,"new_code_token_num":12},{"new_code_raw":"public static Command<List<Cookie>> getAllCookies() { return new Command<>( DOMAIN_NAME + \".getAllCookies\", ImmutableMap.of(), map(\"cookies\", new TypeToken<List<Cookie>>() {}.getType())); }","old_code_raw":"  public static Command<Cookies> getAllCookies() {\n    return new Command<>(\n      DOMAIN_NAME + \".getAllCookies\",\n      ImmutableMap.of(),\n      map(\"cookies\", Cookies.class));\n  }\n","new_comment_raw":"Returns all browser cookies.","old_comment_raw":"Returns all browser cookies.","label":0,"pre_label":1,"AST_level":11,"line_counts":7,"new_code_token_num":45},{"new_code_raw":"public static boolean isMatchedWithTopN(CubeInstance cube, SQLDigest digest) { boolean hasTopN = hasTopNMeasure(cube.getDescriptor()); if (hasTopN == false) { return false; } Collection<TblColRef> dimensionColumns = CubeDimensionDeriver.getDimensionColumns(digest); boolean matchDimensions = isMatchedWithDimensions(dimensionColumns, cube); if (matchDimensions == true) { return false; } Collection<FunctionDesc> functions = digest.aggregations; if (functions == null || functions.size() != 1) { \/\/ topN only allow one measure return false; } return isMatchedWithTopN(dimensionColumns, cube, digest); }","old_code_raw":"    public static boolean isMatchedWithTopN(CubeInstance cube, SQLDigest digest) {\n        Collection<TblColRef> dimensionColumns = CubeDimensionDeriver.getDimensionColumns(digest);\n        \n        boolean matchDimensions = isMatchedWithDimensions(dimensionColumns, cube);\n\n        if (matchDimensions == true) {\n            return false;\n        }\n\n        Collection<FunctionDesc> functions = digest.aggregations;\n        if (functions == null || functions.size() != 1) {\n            \/\/ topN only allow one measure\n            return false;\n        }\n\n        return isMatchedWithTopN(dimensionColumns, cube, digest);\n    }\n","new_comment_raw":"Check whether the cube can match the sql digest with TopN measure","old_comment_raw":"Check whether the cube can match the sql digest with TopN measure","label":0,"pre_label":1,"AST_level":6,"line_counts":25,"new_code_token_num":102},{"new_code_raw":"public Integer getSocksVersion() { return socksVersion; }","old_code_raw":"  public String getSocksVersion() {\n    return socksVersion;\n  }\n","new_comment_raw":"Gets the SOCKS version (4 or 5).","old_comment_raw":"Gets the SOCKS version (4 or 5).","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public Set<ClassInfo> getInterfaces() { String[] names = classGen.getInterfaceNames(); Set<ClassInfo> interfaces = new HashSet<ClassInfo>(names.length); for (String name : names) { ClassInfo cls = getAppInfo().getClassInfo(name); if (cls != null) { interfaces.add(cls); } } return interfaces; }","old_code_raw":"    public Collection<ClassInfo> getInterfaces() {\n        return interfaces;\n    }\n","new_comment_raw":"Get a set of all (loaded) interfaces this class directly implements.","old_comment_raw":"Get a collection of all (loaded) interfaces this class directly implements.","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":64},{"new_code_raw":"@PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION') or hasPermission(#cube, 'MANAGEMENT')\") public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException { String cubeName = cube.getName(); RealizationStatusEnum ostatus = cube.getStatus(); if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) { throw new InternalErrorException(\"Only disabled cube can be enabled, status of \" + cubeName + \" is \" + ostatus); } if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) { throw new InternalErrorException(\"Cube \" + cubeName + \" dosen't contain any READY segment\"); } final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING)); if (!cubingJobs.isEmpty()) { throw new JobException(\"Enable is not allowed with a running job.\"); } if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) { this.releaseAllSegments(cube); } cube.setStatus(RealizationStatusEnum.READY); try { return getCubeManager().updateCube(cube); } catch (IOException e) { cube.setStatus(ostatus); throw e; } }","old_code_raw":"    @PreAuthorize(Constant.ACCESS_HAS_ROLE_ADMIN + \" or hasPermission(#cube, 'ADMINISTRATION') or hasPermission(#cube, 'OPERATION')  or hasPermission(#cube, 'MANAGEMENT')\")\n    public CubeInstance enableCube(CubeInstance cube) throws IOException, JobException {\n        String cubeName = cube.getName();\n\n        RealizationStatusEnum ostatus = cube.getStatus();\n        if (!cube.getStatus().equals(RealizationStatusEnum.DISABLED)) {\n            throw new InternalErrorException(\"Only disabled cube can be enabled, status of \" + cubeName + \" is \" + ostatus);\n        }\n\n        if (cube.getSegments(SegmentStatusEnum.READY).size() == 0) {\n            throw new InternalErrorException(\"Cube \" + cubeName + \" dosen't contain any READY segment\");\n        }\n\n        final List<CubingJob> cubingJobs = listAllCubingJobs(cube.getName(), null, EnumSet.of(ExecutableState.READY, ExecutableState.RUNNING));\n        if (!cubingJobs.isEmpty()) {\n            throw new JobException(\"Enable is not allowed with a running job.\");\n        }\n        if (!cube.getDescriptor().calculateSignature().equals(cube.getDescriptor().getSignature())) {\n            cube = this.releaseAllSegments(cube);\n        }\n\n        try {\n            return getCubeManager().updateCube(cube, null, null, null, RealizationStatusEnum.READY);\n        } catch (IOException e) {\n            cube.setStatus(ostatus);\n            throw e;\n        }\n    }\n","new_comment_raw":"Update a cube status from disable to ready.","old_comment_raw":"Update a cube status from disable to ready.","label":0,"pre_label":1,"AST_level":10,"line_counts":30,"new_code_token_num":256},{"new_code_raw":"public static ScannableTable generate(int width, int height, int seed) { return new MazeTable(width, height, seed, false); }","old_code_raw":"  public static ScannableTable generate(int width, int height, int seed) {\n    return new MazeTable(width, height, seed);\n  }\n","new_comment_raw":"Table function that generates a maze.","old_comment_raw":"Called by reflection based on the definition of the user-defined function in the schema.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"private byte[] read(InputStream in, int length) throws IOException { byte[] buffer = new byte[length]; int bytesRead = 0; do { bytesRead += in.read(buffer); } while (length != bytesRead); int freeSpace = currentFrame.capacity() - currentFrame.position(); if (freeSpace < bytesRead) { currentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead); } \/\/ add bytes to current frame and reset to be able to read again currentFrame.put(buffer); return buffer; }","old_code_raw":"\t\tprivate ByteBuffer read(SocketChannel channel, int length) throws IOException {\n\t\t\tByteBuffer buffer = ByteBuffer.allocate(length);\n\t\t\t\n\t\t\tint bytesRead = 0;\n\t\t\tdo {\n\t\t\t\tbytesRead += channel.read(buffer);\n\t\t\t} while (length != bytesRead);\n\t\t\t\n\t\t\tbuffer.flip();\n\t\t\t\n\t\t\tint freeSpace = currentFrame.capacity() - currentFrame.position();\n\t\t\tif (freeSpace < bytesRead) {\n\t\t\t\tcurrentFrame = reallocate(currentFrame, currentFrame.position() + bytesRead);\n\t\t\t}\n\n\t\t\t\/\/ add bytes to current frame and reset to be able to read again\n\t\t\tcurrentFrame.put(buffer);\n\t\t\tbuffer.rewind();\n\t\t\t\n\t\t\treturn buffer;\n\t\t}\n","new_comment_raw":"Reads given length from the given stream.","old_comment_raw":"Reads given length from the channel.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":104},{"new_code_raw":"protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return MicroTime.toMicroOfDay(data, adjuster); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L; \/\/ return epoch\n        }\n        try {\n            return MicroTime.toMicroOfDay(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#TIME to  MicroTime values, or microseconds past midnight.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#TIME to MicroTime values, or microseconds past midnight.","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":84},{"new_code_raw":"public boolean scrollDownList(int index) { return scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.DOWN); }","old_code_raw":"\tpublic boolean scrollDownList(int index) {\n\t\treturn scroller.scrollList(ListView.class, waiter.waitForAndGetView(index, ListView.class), Scroller.DOWN, null);\n\t}\n","new_comment_raw":"Scrolls down a list with a given index.","old_comment_raw":"Scrolls down a list with a given index.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"protected String[] convert(Path<?> leftHandSide, Object rightHandSide) { String str = rightHandSide.toString(); if (lowerCase){ str = str.toLowerCase(); } if (splitTerms) { if (str.equals(\"\")) { return new String[] { str }; } else { return StringUtils.split(str); } } else { return new String[] { str }; } }","old_code_raw":"    protected String convert(Path<?> path, Object value){\n        return value.toString();\n    }\n","new_comment_raw":"template method","old_comment_raw":"Template method, override to customize.","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":82},{"new_code_raw":"protected int getInSubqueryThreshold() { return config.getInSubqueryThreshold(); }","old_code_raw":"  protected int getInSubqueryThreshold() {\n    return IN_SUBQUERY_THRESHOLD;\n  }\n","new_comment_raw":"Gets the list size threshold under which  #convertInToOr is used.","old_comment_raw":"Gets the list size threshold under which #convertInToOr is used.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public static GitlabRepositoryName create(final String url) { LOGGER.log(Level.FINE, \"Constructing from URL {0}\", url); for (Pattern p : URL_PATTERNS) { Matcher m = p.matcher(url.trim()); if (m.matches()) { LOGGER.log(Level.FINE, \"URL matches {0}\", m); GitlabRepositoryName ret = new GitlabRepositoryName(m.group(1), m.group(2), m.group(3)); LOGGER.log(Level.FINE, \"Object is {0}\", ret); return ret; } } LOGGER.log(Level.WARNING, \"Could not match URL {0}\", url); return null; }","old_code_raw":"    public static GitHubRepositoryName create(final String url) {\n        LOGGER.log(Level.FINE, \"Constructing from URL {0}\", url);\n        for (Pattern p : URL_PATTERNS) {\n            Matcher m = p.matcher(url.trim());\n            if (m.matches()) {\n                LOGGER.log(Level.FINE, \"URL matches {0}\", m);\n                GitHubRepositoryName ret = new GitHubRepositoryName(m.group(1), m.group(2),\n                        m.group(3));\n                LOGGER.log(Level.FINE, \"Object is {0}\", ret);\n                return ret;\n            }\n        }\n        LOGGER.log(Level.WARNING, \"Could not match URL {0}\", url);\n        return null;\n    }\n","new_comment_raw":"Create  GitlabRepositoryName from URL","old_comment_raw":"Create GitHubRepositoryName from URL","label":1,"pre_label":0,"AST_level":11,"line_counts":17,"new_code_token_num":141},{"new_code_raw":"static protected float getFloatWithUnit(XML element, String attribute, float relativeTo) { String val = element.getString(attribute); return (val == null) ? 0 : parseUnitSize(val, relativeTo); }","old_code_raw":"  static protected float getFloatWithUnit(XML element, String attribute) {\n    String val = element.getString(attribute);\n    return (val == null) ? 0 : parseUnitSize(val);\n  }\n","new_comment_raw":"Used in place of element.getFloatAttribute(a) because we can have a unit suffix (length or coordinate).","old_comment_raw":"Used in place of element.getFloatAttribute(a) because we can have a unit suffix (length or coordinate).","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":39},{"new_code_raw":"public String toString() { return \"-P: \" + this.directory_prefix; }","old_code_raw":"    public String toString() {\n        return \"-P: \" + directory_prefix;\n    }\n","new_comment_raw":"Returns the directory prefix","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public static DateTimeFormatter time() { return Constants.t; }","old_code_raw":"    public static DateTimeFormatter time() {\n        if (t == null) {\n            t = new DateTimeFormatterBuilder()\n                .append(hourMinuteSecondFraction())\n                .append(offsetElement())\n                .toFormatter();\n        }\n        return t;\n    }\n","new_comment_raw":"Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit fraction of second, and time zone offset (HH:mm:ss.SSSZZ).","old_comment_raw":"Returns a formatter for a two digit hour of day, two digit minute of hour, two digit second of minute, three digit fraction of second, and time zone offset (HH:mm:ss.SSSZZ).","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public List getImageSrcs(boolean duplicate) { if (duplicate) { return this.htmlHandler.getAllImageSrcs(); } return this.htmlHandler.getImageSrcs(); }","old_code_raw":"    public List getImageSrcs(boolean duplicate) {\n        if (duplicate) {\n            return htmlHandler.getAllImageSrcs();\n        } else {\n            return htmlHandler.getImageSrcs();\n        }\n    }\n","new_comment_raw":"Get Image src attributes","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":29},{"new_code_raw":"public static GridRole find(String[] args) { if (args == null) { return NOT_GRID; } for (int i = 0; i < args.length; i++) { if (\"-role\".equals(args[i])) { if (i == args.length - 1) { return null; } else { String role = args[i + 1].toLowerCase(); if (nodeAliases.contains(role)) { return NODE; } else if (\"hub\".equals(role)) { return HUB; } else if (\"standalone\".equals(role)) { return NOT_GRID; } else { return null; } } } } return NOT_GRID; }","old_code_raw":"  public static GridRole find(String[] args) {\n    if (args == null) {\n      return NOT_GRID;\n    }\n    for (int i = 0; i < args.length; i++) {\n      if (\"-role\".equals(args[i])) {\n        if (i == args.length - 1) {\n          throw new GridConfigurationException(\n              \"-role needs to be followed by the role of this component in the grid.\");\n        } else {\n          String role = args[i + 1].toLowerCase();\n          if (nodeAliases.contains(role)) {\n            return NODE;\n          } else if (\"hub\".equals(role)) {\n            return HUB;\n          } else if (\"standalone\".equals(role)) {\n            return NOT_GRID;\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n    return NOT_GRID;\n  }\n","new_comment_raw":"finds the requested role from the parameters.","old_comment_raw":"finds the requested role from the parameters.","label":0,"pre_label":1,"AST_level":14,"line_counts":25,"new_code_token_num":136},{"new_code_raw":"public static String getDependencyIssue(AddOn.BaseRunRequirements requirements) { if (!requirements.hasDependencyIssue()) { return null; } List<Object> issueDetails = requirements.getDependencyIssueDetails(); switch (requirements.getDependencyIssue()) { case CYCLIC: return \"Cyclic dependency with: \" + issueDetails.get(0); case OLDER_VERSION: return \"Older version still installed: \" + issueDetails.get(0); case MISSING: String addOnId = (String) issueDetails.get(0); return MessageFormat.format(\"Add-On with ID \\\"{0}\\\"\", addOnId); case VERSION: AddOn addOn = (AddOn) issueDetails.get(0); return MessageFormat.format( \"Add-on \\\"{0}\\\" with version matching {1} (found version {2})\", addOn.getName(), issueDetails.get(1), addOn.getVersion()); default: LOGGER.warn(\"Failed to handle dependency issue with name \\\"\" + requirements.getDependencyIssue().name() + \"\\\" and details: \" + issueDetails); return null; } }","old_code_raw":"    public static String getDependencyIssue(AddOn.BaseRunRequirements requirements) {\n        if (!requirements.hasDependencyIssue()) {\n            return null;\n        }\n\n        List<Object> issueDetails = requirements.getDependencyIssueDetails();\n        switch (requirements.getDependencyIssue()) {\n        case CYCLIC:\n            return \"Cyclic dependency with: \" + issueDetails.get(0);\n        case OLDER_VERSION:\n            return \"Older version still installed: \" + issueDetails.get(0);\n        case MISSING:\n            String addOnId = (String) issueDetails.get(0);\n            return MessageFormat.format(\"Add-On with ID \\\"{0}\\\"\", addOnId);\n        case PACKAGE_VERSION_NOT_BEFORE:\n            AddOn addOn = (AddOn) issueDetails.get(0);\n            return MessageFormat.format(\n                    \"Add-on \\\"{0}\\\" with version not before {1} (found version {2})\",\n                    addOn.getName(),\n                    issueDetails.get(1),\n                    Integer.valueOf(addOn.getFileVersion()));\n        case PACKAGE_VERSION_NOT_FROM:\n            addOn = (AddOn) issueDetails.get(0);\n            return MessageFormat.format(\n                    \"Add-on \\\"{0}\\\" with version not after {1} (found version {2})\",\n                    addOn.getName(),\n                    issueDetails.get(1),\n                    Integer.valueOf(addOn.getFileVersion()));\n        case VERSION:\n            addOn = (AddOn) issueDetails.get(0);\n            if (addOn.getVersion() == null) {\n                return MessageFormat.format(\n                        \"Add-on \\\"{0}\\\" with semantic version >= {1} (found no semantic version)\",\n                        addOn.getName(),\n                        issueDetails.get(1));\n            }\n            return MessageFormat.format(\n                    \"Add-on \\\"{0}\\\" with semantic version >= {1} (found version {2})\",\n                    addOn.getName(),\n                    issueDetails.get(1),\n                    addOn.getVersion());\n        default:\n            LOGGER.warn(\"Failed to handle dependency issue with name \\\"\" + requirements.getDependencyIssue().name()\n                    + \"\\\" and details: \" + issueDetails);\n            return null;\n        }\n    }\n","new_comment_raw":"Returns the textual representation of the issue that prevents the add-on or extension from being run, if any.","old_comment_raw":"Returns the textual representation of the issue that prevents the add-on or extension from being run, if any.","label":0,"pre_label":1,"AST_level":11,"line_counts":28,"new_code_token_num":212},{"new_code_raw":"static Object wrapArgumentForScriptExecution(Object argument) { JSONObject wrappedArgument = new JSONObject(); try { if (argument instanceof String) { wrappedArgument.put(\"type\", \"STRING\"); wrappedArgument.put(\"value\", argument); } else if (argument instanceof Boolean) { wrappedArgument.put(\"type\", \"BOOLEAN\"); wrappedArgument.put(\"value\", argument); } else if (argument instanceof Number) { wrappedArgument.put(\"type\", \"NUMBER\"); wrappedArgument.put(\"value\", argument); } else if (argument instanceof ChromeWebElement) { wrappedArgument.put(\"type\", \"ELEMENT\"); wrappedArgument.put(\"value\", ((ChromeWebElement)argument).getElementId()); } else if (argument instanceof Collection<?>) { JSONArray array = new JSONArray(); for (Object o : (Collection<?>)argument) { array.put(wrapArgumentForScriptExecution(o)); } return array; } else { throw new IllegalArgumentException(\"Could not wrap up \" + \"javascript parameter \" + argument + \"(class: \" + argument.getClass() + \")\"); } } catch (JSONException e) { throw new WebDriverException(e); } return wrappedArgument; }","old_code_raw":"    static JSONObject wrapArgumentForScriptExecution(Object argument) {\n      JSONObject wrappedArgument = new JSONObject();\n      try {\n        if (argument instanceof String) {\n          wrappedArgument.put(\"type\", \"STRING\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof Boolean) {\n          wrappedArgument.put(\"type\", \"BOOLEAN\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof Number) {\n          wrappedArgument.put(\"type\", \"NUMBER\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof ChromeWebElement) {\n          wrappedArgument.put(\"type\", \"ELEMENT\");\n          wrappedArgument.put(\"value\", ((ChromeWebElement)argument).getElementId());\n        } else {\n          throw new IllegalArgumentException(\"Could not wrap up \" +\n                \"javascript parameter \" + argument +\n                \"(class: \" + argument.getClass() + \")\");\n        }\n      } catch (JSONException e) {\n        throw new WebDriverException(e);\n      }\n      return wrappedArgument;\n    }\n","new_comment_raw":"Wraps up values as type: some_type, value: some_value objects","old_comment_raw":"Wraps up values as type: some_type, value: some_value objects","label":0,"pre_label":1,"AST_level":17,"line_counts":32,"new_code_token_num":246},{"new_code_raw":"protected EngineParameterMetaData getParameterMetaData() throws SQLException { if (stmtPmeta != null) return stmtPmeta; stmtPmeta = ((EnginePreparedStatement)ps).getEmbedParameterSetMetaData(); return stmtPmeta; }","old_code_raw":"\tprotected EmbedParameterSetMetaData getParameterMetaData() throws SQLException\n\t{\n\t\tif (stmtPmeta != null)\n\t\t\treturn stmtPmeta;\n\n\t\tEmbedParameterSetMetaData pmeta = null;\n\t\tClass[] getParameterMetaDataParam = {};\n\t\ttry {\n\t\t\tMethod sh =\n\t\t\t\tgetPreparedStatement().getClass().getMethod(\"getEmbedParameterSetMetaData\", getParameterMetaDataParam);\n\t\t\tpmeta = (EmbedParameterSetMetaData)\n\t\t\t\tsh.invoke(getPreparedStatement(),null);\n\t\t\tstmtPmeta = pmeta;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\thandleReflectionException(e);\n\t\t}\n\t\treturn stmtPmeta;\n\t}\n","new_comment_raw":"Retrieve the ParameterMetaData for the prepared statement.","old_comment_raw":"Get parameter metadata from EmbedPreparedStatement or","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":32},{"new_code_raw":"public SqlTester getTester() { return new SqlTesterImpl(new AdvisorTesterFactory()); }","old_code_raw":"  public Tester getTester(SqlConformance conformance) {\n    return new AdvisorTestImpl(conformance);\n  }\n","new_comment_raw":"Converts a list to a string, one item per line.","old_comment_raw":"Converts a list to a string, one item per line.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"protected static CodecFactory getCompressionCodec(TaskAttemptContext context) { if (FileOutputFormat.getCompressOutput(context)) { \/\/ Default to deflate compression. int deflateLevel = context.getConfiguration().getInt( org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY, CodecFactory.DEFAULT_DEFLATE_LEVEL); int xzLevel = context.getConfiguration().getInt( org.apache.avro.mapred.AvroOutputFormat.XZ_LEVEL_KEY, CodecFactory.DEFAULT_XZ_LEVEL); String outputCodec = context.getConfiguration() .get(AvroJob.CONF_OUTPUT_CODEC); if (outputCodec == null) { String compressionCodec = context.getConfiguration().get(\"mapred.output.compression.codec\"); String avroCodecName = HadoopCodecFactory.getAvroCodecName(compressionCodec); if ( avroCodecName != null){ context.getConfiguration().set(AvroJob.CONF_OUTPUT_CODEC, avroCodecName); return HadoopCodecFactory.fromHadoopString(compressionCodec); } else { return CodecFactory.deflateCodec(deflateLevel); } } else if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) { return CodecFactory.deflateCodec(deflateLevel); } else if (DataFileConstants.XZ_CODEC.equals(outputCodec)) { return CodecFactory.xzCodec(xzLevel); } else { return CodecFactory.fromString(outputCodec); } } \/\/ No compression. return CodecFactory.nullCodec(); }","old_code_raw":"  protected static CodecFactory getCompressionCodec(TaskAttemptContext context) {\n    if (FileOutputFormat.getCompressOutput(context)) {\n      \/\/ Default to deflate compression.\n      int compressionLevel = context.getConfiguration().getInt(\n          org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY,\n          org.apache.avro.mapred.AvroOutputFormat.DEFAULT_DEFLATE_LEVEL);\n      \n      String outputCodec = context.getConfiguration()\n        .get(AvroJob.CONF_OUTPUT_CODEC);\n\n      if (outputCodec == null) {\n        String compressionCodec = context.getConfiguration().get(\"mapred.output.compression.codec\");\n        String avroCodecName = HadoopCodecFactory.getAvroCodecName(compressionCodec);\n        if ( avroCodecName != null){\n          context.getConfiguration().set(AvroJob.CONF_OUTPUT_CODEC, avroCodecName);\n          return HadoopCodecFactory.fromHadoopString(compressionCodec);\n        } else {\n          return CodecFactory.deflateCodec(compressionLevel);\n        }\n      } else if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) {\n          return CodecFactory.deflateCodec(compressionLevel);\n        } else {\n          return CodecFactory.fromString(outputCodec);\n        }\n      \n      }\n\n    \/\/ No compression.\n    return CodecFactory.nullCodec();\n  }\n","new_comment_raw":"Gets the configured compression codec from the task context.","old_comment_raw":"Gets the configured compression codec from the task context.","label":0,"pre_label":1,"AST_level":12,"line_counts":36,"new_code_token_num":202},{"new_code_raw":"public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(\"petId\", petId); String path = apiClient.expandPath(\"\/fake\/{petId}\/uploadImageWithRequiredFile\", uriVariables); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) formParams.add(\"requiredFile\", new FileSystemResource(requiredFile)); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"multipart\/form-data\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"petstore_auth\" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {\n        Object postBody = null;\n        \n        \/\/ verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        \/\/ verify the required parameter 'requiredFile' is set\n        if (requiredFile == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n        }\n        \n        \/\/ create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = apiClient.expandPath(\"\/fake\/{petId}\/uploadImageWithRequiredFile\", uriVariables);\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (requiredFile != null)\n            formParams.add(\"requiredFile\", new FileSystemResource(requiredFile));\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart\/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"uploads an image (required) 200 - successful operation","old_comment_raw":"uploads an image (required) 200 - successful operation","label":0,"pre_label":1,"AST_level":8,"line_counts":43,"new_code_token_num":336},{"new_code_raw":"public TimeOnly roundHalfCeilingCopy() { TimeOnly instant = iInstant; return (TimeOnly)instant.withMillis(iField.roundHalfCeiling(instant.getMillis())); }","old_code_raw":"    public TimeOnly roundHalfCeilingCopy() {\n        TimeOnly instant = iInstant;\n        return (TimeOnly)instant.toCopy(iField.roundHalfCeiling(instant.getMillis()));\n    }\n","new_comment_raw":"Rounds to the nearest whole unit of this field on a copy of this TimeOnly, favoring the ceiling if halfway.","old_comment_raw":"Rounds to the nearest whole unit of this field on a copy of this TimeOnly, favoring the ceiling if halfway.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"public Method getWriteMethod(String name) { return writeMethods.get(name); }","old_code_raw":"    public Method getWriteMethod(String name) {\n        return (Method) writeMethods.get(name);\n    }\n","new_comment_raw":"Returns the mutator for the property with the given name.","old_comment_raw":"Returns the mutator for the property with the given name.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"protected Control initControl(boolean ignoreProxyError) { if (!Control.initSingletonWithoutView(getControlOverrides()) && ! ignoreProxyError) { return null; } return Control.getSingleton(); }","old_code_raw":"    protected Control initControl() {\n        Control.initSingletonWithoutViewAndProxy(getControlOverrides());\n        return Control.getSingleton();\n    }\n","new_comment_raw":"Initialises the  Control singleton without view.","old_comment_raw":"Initialises the Control singleton without view and proxy.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"public ApiResponse<Void> createUsersWithListInputWithHttpInfo(List<User> body) throws ApiException { okhttp3.Call localVarCall = createUsersWithListInputValidateBeforeCall(body, null, null); return localVarApiClient.execute(localVarCall); }","old_code_raw":"    public ApiResponse<Void> createUsersWithListInputWithHttpInfo(List<User> body) throws ApiException {\n        okhttp3.Call call = createUsersWithListInputValidateBeforeCall(body, null, null);\n        return apiClient.execute(call);\n    }\n","new_comment_raw":"Creates list of users with given input array","old_comment_raw":"Creates list of users with given input array","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public boolean evaluate(S object) { return ev.<Boolean>evaluate(object); }","old_code_raw":"            public boolean evaluate(S object) {\n                return QueryIteratorUtils.<Boolean>evaluate(ev, object);\n            }            \n","new_comment_raw":"filter the given iterator using the given expressionevaluator that evaluates to true \/ false","old_comment_raw":"filter the given iterator using the given expressionevaluator that evaluates to true \/ false","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public double getContentPosition() { return mBundle.getDouble(KEY_CONTENT_POSITION, -1); }","old_code_raw":"    public long getContentPosition() {\n        return mBundle.getLong(KEY_CONTENT_POSITION, -1);\n    }\n","new_comment_raw":"Gets the content playback position as a floating point number of seconds from the beginning of the content.","old_comment_raw":"Gets the content playback position as a long integer number of milliseconds from the beginning of the content.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public ArchiveEntry findMostRecentArchive(Connection con, int indexId, int archiveId) { return con.createQuery(\"select archive.id, archive.archiveId, archive.nameHash,\" + \" archive.crc, archive.revision, archive.hash from archive \" + \"join index_archive on index_archive.archive = archive.id \" + \"join `index` on index.id = index_archive.index \" + \"where index.indexId = :indexId and archive.archiveId = :archiveId \" + \"group by archive.id \" + \"order by archive.revision desc \" + \"limit 1\") .addParameter(\"indexId\", indexId) .addParameter(\"archiveId\", archiveId) .executeAndFetchFirst(ArchiveEntry.class); }","old_code_raw":"\tpublic ArchiveEntry findMostRecentArchive(Connection con, int indexId, int archiveId)\n\t{\n\t\treturn con.createQuery(\"select archive.id, archive.archiveId, archive.nameHash, archive.revision from archive \"\n\t\t\t+ \"join index_archive on index_archive.archive = archive.id \"\n\t\t\t+ \"join `index` on index.id = index_archive.index \"\n\t\t\t+ \"where index.indexId = :indexId and archive.archiveId = :archiveId \"\n\t\t\t+ \"group by archive.id \"\n\t\t\t+ \"order by archive.revision desc \"\n\t\t\t+ \"limit 1\")\n\t\t\t.addParameter(\"indexId\", indexId)\n\t\t\t.addParameter(\"archiveId\", archiveId)\n\t\t\t.executeAndFetchFirst(ArchiveEntry.class);\n\t}\n","new_comment_raw":"Finds the most recent archive for the given indexId\/archiveId","old_comment_raw":"Finds the most recent archive for the given indexId\/archiveId","label":0,"pre_label":1,"AST_level":12,"line_counts":15,"new_code_token_num":120},{"new_code_raw":"public Task<EncodedImage> get(CacheKey key, AtomicBoolean isCancelled) { final EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { return foundPinnedImage(key, pinnedImage); } return getAsync(key, isCancelled); }","old_code_raw":"  public Task<EncodedImage> get(List<CacheKey> keys, final AtomicBoolean isCancelled) {\n    Preconditions.checkArgument(!keys.isEmpty());\n\n    for (CacheKey key : keys) {\n      final EncodedImage pinnedImage = mStagingArea.get(key);\n      if (pinnedImage != null) {\n        return foundPinnedImage(key, pinnedImage);\n      }\n    }\n\n    Task<EncodedImage> masterTask = getAsync(keys.get(0), isCancelled);\n    if (keys.size() == 1) {\n      return masterTask;\n    }\n    for (final CacheKey key : keys.subList(1, keys.size())) {\n      masterTask = masterTask.continueWithTask(\n          new Continuation<EncodedImage, Task<EncodedImage>>() {\n            @Override\n            public Task<EncodedImage> then(Task<EncodedImage> previousTask) throws Exception {\n              \/\/ If we've got a hit, stop. If this is cancelled, stop. Otherwise, keep going.\n              if (previousTask.isCancelled() || previousTask.getResult() != null) {\n                return previousTask;\n              }\n              return getAsync(key, isCancelled);\n            }\n          },\n          mReadExecutor);\n    }\n    return masterTask;\n  }\n","new_comment_raw":"Performs key-value look up in disk cache.","old_comment_raw":"Performs lookup of a series of disk cache keys in a single thread.","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":46},{"new_code_raw":"public String getConnectedServer(AccessToken accessToken, String node) { AgentMgtDao agentMgtDao = new AgentMgtDao(); return agentMgtDao.getConnectedServer(accessToken.getId(), node); }","old_code_raw":"    public String getConnectedServer(AccessToken accessToken) {\n        AgentMgtDao agentMgtDao = new AgentMgtDao();\n        return agentMgtDao.getConnectedServer(accessToken.getId());\n    }\n","new_comment_raw":"Get server ip connected with the given node.","old_comment_raw":"Get node ip connected to the access token","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":31},{"new_code_raw":"public int getMinimumValue() { return DateTimeConstants.MONDAY; }","old_code_raw":"    public int getMinimumValue() {\n        return MIN;\n    }\n","new_comment_raw":"Get the minimum value that this field can have.","old_comment_raw":"Get the minimum value that this field can have.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception { return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>()); }","old_code_raw":"    public synchronized final List<String> getDependentModulesRecursively(final String id) throws Exception {\r\n        final List<String> res = new ArrayList<String>();\r\n        for (final String depModule : getDependentModules(id)) {\r\n            res.add(depModule);\r\n            \/\/ the graph has no cycle, so we don't need to protected against infinite loop\r\n\r\n            res.addAll(this.getDependentModulesRecursively(depModule));\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n","new_comment_raw":"The list of installed modules depending on the passed one.","old_comment_raw":"The list of modules depending on the passed one.","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":26},{"new_code_raw":"public CommonCardView getCardView() { return mCardView; }","old_code_raw":"    public CardView getCardView() {\n        return mCardView;\n    }\n","new_comment_raw":"This method returns the complete View used","old_comment_raw":"This method returns the complete View used","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public static InboundContext getActiveSessionAndProducer() { return threadLocal.get(); }","old_code_raw":"    public static InboundContext getActiveSessionAndProducer() {\n        return (InboundContext) threadLocal.get();\n    }\n","new_comment_raw":"Returns the current  InboundContext used by the current thread which is processing a message.","old_comment_raw":"Returns the current InboundContext used by the current thread which is processing a message.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public <T extends Server> Server getServer(Class<T> clazz, String name) { for (Server server : getServers()){ if (server.isValid() && server.getLabel().getName().equals(name)){ return server.getAdapter(clazz); } } log.info(\"Requested server '\" + name + \"' was not found on Servers view\"); log.info(\"Available servers are: \" + LoggingUtils.format(getServersNames())); throw new EclipseLayerException(\"There is no server with name \" + name); }","old_code_raw":"\tpublic <T extends Server> T getServer(Class<T> clazz, String name) {\n\t\tfor (Server server : getServers()){\n\t\t\tif (server.isValid() && server.getLabel().getName().equals(name)){\n\t\t\t\treturn server.getAdapter(clazz);\n\t\t\t}\n\t\t}\n\t\tlog.info(\"Requested server '\" + name + \"' was not found on Servers view\");\n\t\tlog.info(\"Available servers are: \" + LoggingUtils.format(getServersNames()));\n\t\tthrow new EclipseLayerException(\"There is no server with name \" + name);\n\t}\n","new_comment_raw":"Gets a server of specified type with a given name","old_comment_raw":"Gets a server of specified type with the given name.","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":113},{"new_code_raw":"public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) { int columnType = (int) datumMessage.getColumnType(); switch (columnType) { case PgOid.BOOL: return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null; case PgOid.INT2: case PgOid.INT4: return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null; case PgOid.INT8: case PgOid.OID: case PgOid.MONEY: return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null; case PgOid.FLOAT4: return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null; case PgOid.FLOAT8: return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; case PgOid.NUMERIC: if (datumMessage.hasDatumDouble()) { \/\/ For backwards compatibility only to enable independent upgrade of Postgres plug-in return datumMessage.getDatumDouble(); } else if (datumMessage.hasDatumString()) { final String s = datumMessage.getDatumString(); return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s))); } return null; case PgOid.CHAR: case PgOid.VARCHAR: case PgOid.BPCHAR: case PgOid.TEXT: case PgOid.JSON: case PgOid.JSONB_OID: case PgOid.XML: case PgOid.UUID: case PgOid.BIT: case PgOid.VARBIT: case PgOid.INET_OID: case PgOid.CIDR_OID: case PgOid.MACADDR_OID: case PgOid.MACADDR8_OID: return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null; case PgOid.DATE: return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null; case PgOid.TIMESTAMP: if (!datumMessage.hasDatumInt64()) { return null; } \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()); case PgOid.TIMESTAMPTZ: if (!datumMessage.hasDatumInt64()) { return null; } \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch return Conversions.toInstantFromMicros(datumMessage.getDatumInt64()).atOffset(ZoneOffset.UTC); case PgOid.TIME: if (!datumMessage.hasDatumInt64()) { return null; } \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch return Duration.of(datumMessage.getDatumInt64(), ChronoUnit.MICROS); case PgOid.TIMETZ: if (!datumMessage.hasDatumDouble()) { return null; } \/\/ the value is sent as a double microseconds return Conversions.toInstantFromMicros((long) datumMessage.getDatumDouble()) .atOffset(ZoneOffset.UTC) .toOffsetTime(); case PgOid.INTERVAL: \/\/ these are sent as doubles by the plugin since their storage is larger than 8 bytes return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; \/\/ the plugin will send back a TZ formatted string case PgOid.BYTEA: return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null; case PgOid.POINT: { PgProto.Point datumPoint = datumMessage.getDatumPoint(); return new PGpoint(datumPoint.getX(), datumPoint.getY()); } case PgOid.TSRANGE_OID: case PgOid.TSTZRANGE_OID: case PgOid.DATERANGE_OID: case PgOid.INT4RANGE_OID: case PgOid.NUM_RANGE_OID: case PgOid.INT8RANGE_OID: return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(\"UTF-8\")) : null; case PgOid.INT2_ARRAY: case PgOid.INT4_ARRAY: case PgOid.INT8_ARRAY: case PgOid.TEXT_ARRAY: case PgOid.NUMERIC_ARRAY: case PgOid.FLOAT4_ARRAY: case PgOid.FLOAT8_ARRAY: case PgOid.BOOL_ARRAY: case PgOid.DATE_ARRAY: case PgOid.TIME_ARRAY: case PgOid.TIMETZ_ARRAY: case PgOid.TIMESTAMP_ARRAY: case PgOid.TIMESTAMPTZ_ARRAY: case PgOid.BYTEA_ARRAY: case PgOid.VARCHAR_ARRAY: case PgOid.OID_ARRAY: case PgOid.BPCHAR_ARRAY: case PgOid.MONEY_ARRAY: case PgOid.NAME_ARRAY: case PgOid.INTERVAL_ARRAY: case PgOid.CHAR_ARRAY: case PgOid.VARBIT_ARRAY: case PgOid.UUID_ARRAY: case PgOid.XML_ARRAY: case PgOid.POINT_ARRAY: case PgOid.JSONB_ARRAY: case PgOid.JSON_ARRAY: case PgOid.REF_CURSOR_ARRAY: case PgOid.INET_ARRAY: case PgOid.CIDR_ARRAY: case PgOid.MACADDR_ARRAY: case PgOid.MACADDR8_ARRAY: case PgOid.TSRANGE_ARRAY: case PgOid.TSTZRANGE_ARRAY: case PgOid.DATERANGE_ARRAY: case PgOid.INT4RANGE_ARRAY: case PgOid.NUM_RANGE_ARRAY: case PgOid.INT8RANGE_ARRAY: return getArray(datumMessage, connection, columnType); case PgOid.UNSPECIFIED: return null; default: PostgresType type = typeRegistry.get(columnType); if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) { return datumMessage.getDatumBytes().toByteArray(); } if(type.getOid() == typeRegistry.hstoreOid()) { return datumMessage.getDatumBytes().toByteArray(); } if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() || type.getOid() == typeRegistry.citextArrayOid() || type.getOid() == typeRegistry.hstoreArrayOid()) { return getArray(datumMessage, connection, columnType); } \/\/ unknown data type is sent by decoder as binary value if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) { return datumMessage.getDatumBytes().toByteArray(); } return null; } }","old_code_raw":"    public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n        int columnType = (int) datumMessage.getColumnType();\n        switch (columnType) {\n            case PgOid.BOOL:\n                return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null;\n            case PgOid.INT2:\n            case PgOid.INT4:\n                return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null;\n            case PgOid.INT8:\n            case PgOid.OID:\n            case PgOid.MONEY:\n                return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null;\n            case PgOid.FLOAT4:\n                return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null;\n            case PgOid.FLOAT8:\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            case PgOid.NUMERIC:\n                if (datumMessage.hasDatumDouble()) {\n                    \/\/ For backwards compatibility only to enable independent upgrade of Postgres plug-in\n                    return datumMessage.getDatumDouble();\n                }\n                else if (datumMessage.hasDatumString()) {\n                    final String s = datumMessage.getDatumString();\n                    return PostgresValueConverter.toSpecialValue(s).orElseGet(() -> new SpecialValueDecimal(new BigDecimal(s)));\n                }\n                return null;\n            case PgOid.CHAR:\n            case PgOid.VARCHAR:\n            case PgOid.BPCHAR:\n            case PgOid.TEXT:\n            case PgOid.JSON:\n            case PgOid.JSONB_OID:\n            case PgOid.XML:\n            case PgOid.UUID:\n            case PgOid.BIT:\n            case PgOid.VARBIT:\n            case PgOid.INET_OID:\n            case PgOid.CIDR_OID:\n            case PgOid.MACADDR_OID:\n            case PgOid.MACADDR8_OID:\n                return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null;\n            case PgOid.DATE:\n                return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null;\n            case PgOid.TIMESTAMP:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                \/\/ but we'll convert them to nanos which is the smallest unit\n                final LocalDateTime serverLocal = Conversions.toLocalDateTimeUTC(datumMessage.getDatumInt64());\n                return Conversions.toEpochNanos(serverLocal.toInstant(ZoneOffset.UTC));\n            case PgOid.TIMESTAMPTZ:\n            case PgOid.TIME:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                \/\/ but we'll convert them to nanos which is the smallest unit\n                return TimeUnit.NANOSECONDS.convert(datumMessage.getDatumInt64(), TimeUnit.MICROSECONDS);\n            case PgOid.TIMETZ:\n                if (!datumMessage.hasDatumDouble()) {\n                    return null;\n                }\n                \/\/ the value is sent as a double microseconds, convert to nano\n                return BigDecimal.valueOf(datumMessage.getDatumDouble() * 1000).longValue();\n            case PgOid.INTERVAL:\n                \/\/ these are sent as doubles by the plugin since their storage is larger than 8 bytes\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            \/\/ the plugin will send back a TZ formatted string\n            case PgOid.BYTEA:\n                return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null;\n            case PgOid.POINT: {\n                PgProto.Point datumPoint = datumMessage.getDatumPoint();\n                return new PGpoint(datumPoint.getX(), datumPoint.getY());\n            }\n            case PgOid.TSRANGE_OID:\n            case PgOid.TSTZRANGE_OID:\n            case PgOid.DATERANGE_OID:\n            case PgOid.INT4RANGE_OID:\n            case PgOid.NUM_RANGE_OID:\n            case PgOid.INT8RANGE_OID:\n                return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(\"UTF-8\")) : null;\n            case PgOid.INT2_ARRAY:\n            case PgOid.INT4_ARRAY:\n            case PgOid.INT8_ARRAY:\n            case PgOid.TEXT_ARRAY:\n            case PgOid.NUMERIC_ARRAY:\n            case PgOid.FLOAT4_ARRAY:\n            case PgOid.FLOAT8_ARRAY:\n            case PgOid.BOOL_ARRAY:\n            case PgOid.DATE_ARRAY:\n            case PgOid.TIME_ARRAY:\n            case PgOid.TIMETZ_ARRAY:\n            case PgOid.TIMESTAMP_ARRAY:\n            case PgOid.TIMESTAMPTZ_ARRAY:\n            case PgOid.BYTEA_ARRAY:\n            case PgOid.VARCHAR_ARRAY:\n            case PgOid.OID_ARRAY:\n            case PgOid.BPCHAR_ARRAY:\n            case PgOid.MONEY_ARRAY:\n            case PgOid.NAME_ARRAY:\n            case PgOid.INTERVAL_ARRAY:\n            case PgOid.CHAR_ARRAY:\n            case PgOid.VARBIT_ARRAY:\n            case PgOid.UUID_ARRAY:\n            case PgOid.XML_ARRAY:\n            case PgOid.POINT_ARRAY:\n            case PgOid.JSONB_ARRAY:\n            case PgOid.JSON_ARRAY:\n            case PgOid.REF_CURSOR_ARRAY:\n            case PgOid.INET_ARRAY:\n            case PgOid.CIDR_ARRAY:\n            case PgOid.MACADDR_ARRAY:\n            case PgOid.MACADDR8_ARRAY:\n            case PgOid.TSRANGE_ARRAY:\n            case PgOid.TSTZRANGE_ARRAY:\n            case PgOid.DATERANGE_ARRAY:\n            case PgOid.INT4RANGE_ARRAY:\n            case PgOid.NUM_RANGE_ARRAY:\n            case PgOid.INT8RANGE_ARRAY:\n            return getArray(datumMessage, connection, columnType);\n\n            case PgOid.UNSPECIFIED:\n                return null;\n\n            default:\n                PostgresType type = typeRegistry.get(columnType);\n                if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() || type.getOid() == typeRegistry.citextOid() ) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if(type.getOid() == typeRegistry.hstoreOid()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if (type.getOid() == typeRegistry.geometryArrayOid() ||\n                        type.getOid() == typeRegistry.geographyArrayOid() ||\n                        type.getOid() == typeRegistry.citextArrayOid() ||\n                        type.getOid() == typeRegistry.hstoreArrayOid()) {\n                    return getArray(datumMessage, connection, columnType);\n                }\n                \/\/ unknown data type is sent by decoder as binary value\n                if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n\n                return null;\n        }\n    }\n","new_comment_raw":"Converts the Protobuf value for a  io.debezium.connector.postgresql.proto.PgProto.DatumMessage plugin message to a Java value based on the type of the column from the message.","old_comment_raw":"Converts the Protobuf value for a io.debezium.connector.postgresql.proto.PgProto.DatumMessage plugin message to a Java value based on the type of the column from the message.","label":0,"pre_label":1,"AST_level":14,"line_counts":153,"new_code_token_num":961},{"new_code_raw":"public final Job<?, ?> getProject() { return job; }","old_code_raw":"    public final AbstractProject<?, ?> getProject() {\r\n        return project;\r\n    }\r\n","new_comment_raw":"Returns the job this action belongs to.","old_comment_raw":"Returns the project this action belongs to.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"protected final Enumeration elements() { return _contents.elements(); }","old_code_raw":"    protected final Iterator<SyntaxTreeNode> elements() {\n        return _contents.iterator();\n    }\n","new_comment_raw":"Returns an Enumeration of all child nodes of this node.","old_comment_raw":"Returns an Iterator of all child nodes of this node.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"public IntegrationFlow fromFile() { return IntegrationFlows.from( Files.inboundAdapter(new File(\"\/tmp\/in\")) .preventDuplicates(false) .patternFilter(\"*.txt\"), e -> e.poller(Pollers.fixedDelay(5000) .errorChannel(\"tfrErrors.input\"))) .handle(Files.splitter(true, true)) .<Object, Class<?>>route(Object::getClass, m -> m .channelMapping(FileSplitter.FileMarker.class, \"markers.input\") .channelMapping(String.class, \"lines.input\")) .get(); }","old_code_raw":"\tpublic IntegrationFlow fromFile() {\n\t\treturn IntegrationFlows.from(Files.inboundAdapter(new File(\"\/tmp\/in\"))\n\t\t\t\t\t.preventDuplicates(false)\n\t\t\t\t\t.patternFilter(\"*.txt\"), e -> e.poller(Pollers.fixedDelay(5000).errorChannel(tfrErrorChannel())))\n\t\t\t\t.handle(Files.splitter(true, true))\n\t\t\t\t.<Object, Class<?>>route(Object::getClass, m -> m\n\t\t\t\t\t\t.channelMapping(FileSplitter.FileMarker.class, \"markers.input\")\n\t\t\t\t\t\t.channelMapping(String.class, \"lines.input\"))\n\t\t\t\t.get();\n\t}\n","new_comment_raw":"Poll for files, add an error channel, split into lines route the start\/end markers to  #markers() and the lines to  #lines().","old_comment_raw":"Poll for files, add an error channel, split into lines route the start\/end markers to #markers() and the lines to #lines().","label":0,"pre_label":1,"AST_level":10,"line_counts":13,"new_code_token_num":106},{"new_code_raw":"public InetAddress getNumericalAddress() { return address; }","old_code_raw":"\tpublic long getNumericalAddress() {\r\n\t\treturn address;\r\n\t}\r\n","new_comment_raw":"Returns the address of the sender","old_comment_raw":"Returns the address of the sender as a long.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public SchemaPath getUnIndexed() { return new SchemaPath(getUnIndexedNameSegment(rootSegment, null)); }","old_code_raw":"  public SchemaPath getUnIndexed() {\n    NameSegment nameSegment = getUnIndexedNameSegment(rootSegment, null);\n    return new SchemaPath(nameSegment);\n  }\n","new_comment_raw":"Returns schema path with for arrays without index.","old_comment_raw":"Returns schema path with for arrays without index.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public VariationService createVariationService() { return createVariationService(defaultEndpointUrl); }","old_code_raw":"    public VariationService createVariationService() {\n        return createVariationService(defaultServerUrl);\n    }\n","new_comment_raw":"Create and return a new variation service with the default endpoint URL.","old_comment_raw":"Create and return a new variation service with the default server URL.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"public TimeOfDay setCopy(String text) { return setCopy(text, null); }","old_code_raw":"        public TimeOfDay setCopy(int value) {\n            int[] newValues = getField().set(iInstant, iFieldIndex, value);\n            return new TimeOfDay(iInstant, newValues);\n        }\n","new_comment_raw":"Sets this field in a copy of the TimeOfDay to a parsed text value.","old_comment_raw":"Sets this field in a copy of the TimeOfDay.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) { assert clazz != null; return getAnnotationMirror( element, clazz.getName() ); }","old_code_raw":"\tpublic static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) {\n\t\tassert element != null;\n\t\tassert clazz != null;\n\n\t\tAnnotationMirror mirror = null;\n\t\tfor ( AnnotationMirror am : element.getAnnotationMirrors() ) {\n\t\t\tif ( isAnnotationMirrorOfType( am, clazz ) ) {\n\t\t\t\tmirror = am;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn mirror;\n\t}\n","new_comment_raw":"Checks whether the  Element hosts an annotation of the specified class.","old_comment_raw":"Returns the annotation mirror for the specified annotation class from the Element.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public Element getElementByPath(String path) { \/* * Path is of type \"targetWidgetPath#componentPart\" or * \"targetWidgetPath\". *\/ String parts[] = path.split(SUBPART_SEPARATOR, 2); String widgetPath = parts[0]; Widget w = getWidgetFromPath(widgetPath); if (w == null) { return null; } if (parts.length == 1) { int pos = widgetPath.indexOf(\"domChild\"); if (pos == -1) { return w.getElement(); } \/\/ Contains dom reference to a sub element of the widget String subPath = widgetPath.substring(pos); return getElementByDOMPath(w.getElement(), subPath); } else if (parts.length == 2) { if (w instanceof SubPartAware) { return ((SubPartAware) w).getSubPartElement(parts[1]); } } return null; }","old_code_raw":"    public Element getElementByPath(String path) {\n        \/\/ ApplicationConnection.getConsole()\n        \/\/ .log(\"getElementByPath(\" + path + \")\");\n\n        \/\/ Path is of type \"PID\/componentPart\"\n        String parts[] = path.split(SUBPART_SEPARATOR, 2);\n        String widgetPath = parts[0];\n        Widget w = getWidgetFromPath(widgetPath);\n        if (w == null) {\n            return null;\n        }\n\n        if (parts.length == 1) {\n            int pos = widgetPath.indexOf(\"domChild\");\n            if (pos == -1) {\n                return w.getElement();\n            }\n\n            \/\/ Contains dom reference to a sub element of the widget\n            String subPath = widgetPath.substring(pos);\n            return getElementByDOMPath(w.getElement(), subPath);\n        } else if (parts.length == 2) {\n            if (w instanceof SubPartAware) {\n                \/\/ ApplicationConnection.getConsole().log(\n                \/\/ \"subPartAware: \" + parts[1]);\n                return ((SubPartAware) w).getSubPartElement(parts[1]);\n            } else {\n                \/\/ ApplicationConnection.getConsole().error(\n                \/\/ \"getElementByPath failed because \"\n                \/\/ + Util.getSimpleName(w)\n                \/\/ + \" is not SubPartAware\");\n                return null;\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"Locates an element using a String locator (path) which identifies a DOM element.","old_comment_raw":"EXPERIMENTAL.","label":1,"pre_label":0,"AST_level":10,"line_counts":31,"new_code_token_num":162},{"new_code_raw":"public ProjectRel createNewProject(RelNode projChild, int[] adjustments) { List<Pair<RexNode, String>> projects = new ArrayList<Pair<RexNode, String>>(); if (origProj != null) { for (Pair<RexNode, String> p : origProj.getNamedProjects()) { projects.add( Pair.of( convertRefsAndExprs( p.left, projChild.getRowType().getFieldList(), adjustments), p.right)); } } else { for (Ord<RelDataTypeField> field : Ord.zip(childFields)) { projects.add( Pair.of( (RexNode) rexBuilder.makeInputRef( field.e.getType(), field.i), field.e.getName())); } } return (ProjectRel) CalcRel.createProject( projChild, Pair.left(projects), Pair.right(projects), true \/* optimize to avoid trivial projections, as per javadoc *\/); }","old_code_raw":"  public ProjectRel createNewProject(RelNode projChild, int[] adjustments) {\n    List<Pair<RexNode, String>> projects =\n        new ArrayList<Pair<RexNode, String>>();\n\n    if (origProj != null) {\n      for (Pair<RexNode, String> p : origProj.getNamedProjects()) {\n        projects.add(\n            Pair.of(\n                convertRefsAndExprs(\n                    p.left,\n                    projChild.getRowType().getFieldList(),\n                    adjustments),\n                p.right));\n      }\n    } else {\n      for (Ord<RelDataTypeField> field : Ord.zip(childFields)) {\n        projects.add(\n            Pair.of(\n                (RexNode) rexBuilder.makeInputRef(\n                    field.e.getType(), field.i), field.e.getName()));\n      }\n    }\n    return (ProjectRel) CalcRel.createProject(\n        projChild,\n        Pair.left(projects),\n        Pair.right(projects));\n  }\n","new_comment_raw":"Creates a new projection based on the original projection, adjusting all input refs using an adjustment array passed in.","old_comment_raw":"Creates a new projection based on the original projection, adjusting all input refs using an adjustment array passed in.","label":0,"pre_label":1,"AST_level":12,"line_counts":29,"new_code_token_num":163},{"new_code_raw":"private boolean searchForButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class); if(matches == 0) matches = 1; for(Button button : buttonList){ matcher = p.matcher(button.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches = 0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForButton(regex, matches); } else { if (countMatches > 0) Log.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex); countMatches = 0; return false; } }","old_code_raw":"\tprivate boolean searchForButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(Button button : buttonList){\n\t\t\tmatcher = p.matcher(button.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches = 0;\n\t\t\t\treturn true;\n\t\t\t} \t\n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForButton(search, matches);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\n\t}\n","new_comment_raw":"Searches for a button with the given regex string and returns true if the searched button is found a given number of times","old_comment_raw":"Searches for a button with the given search string and returns true if the searched button is found a given number of times","label":1,"pre_label":0,"AST_level":11,"line_counts":31,"new_code_token_num":154},{"new_code_raw":"public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory); req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments); req.setAttribute(BROADCASTER_CLASS, broadcasterClassName); req.setAttribute(ATMOSPHERE_CONFIG, config); AtmosphereRequest r = null; Action a = null; try { if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null && (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null) && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) { Map<String, String> headers = configureQueryStringAsRequest(req); String body = headers.remove(ATMOSPHERE_POST_BODY); if (body != null && body.isEmpty()) { body = null; } r = new AtmosphereRequest.Builder() .headers(headers) .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod()) .body(body) .request(req).build(); a = cometSupport.service(r, res); } else { if (AtmosphereRequest.class.isAssignableFrom(req.getClass())) { return cometSupport.service(req, res); } else { return cometSupport.service(AtmosphereRequest.wrap(req), res); } } } catch (IllegalStateException ex) { if (ex.getMessage() != null && ex.getMessage().startsWith(\"Tomcat failed\")) { if (!isFilter) { logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(), ex.getMessage()); logger.warn(\"Using BlockingIOCometSupport.\"); } logger.trace(ex.getMessage(), ex); cometSupport = new BlockingIOCometSupport(config); doCometSupport(req, res); } else { logger.error(\"AtmosphereServlet exception\", ex); throw ex; } } finally { if (r != null && a != null && a.type != Action.TYPE.SUSPEND) { r.destroy(); } } return null; }","old_code_raw":"    public Action doCometSupport(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(ATMOSPHERE_CONFIG, config);\n\n        AtmosphereRequest r = null;\n        Action a = null;\n        try {\n            if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null\n                    && (isIECandidate(req) || req.getParameter(HeaderConfig.JSONP_CALLBACK_NAME) != null)\n                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {\n\n                Map<String, String> headers = configureQueryStringAsRequest(req);\n                String body = headers.remove(ATMOSPHERE_POST_BODY);\n                if (body != null && body.isEmpty()) {\n                    body = null;\n                }\n\n                r = new AtmosphereRequest.Builder()\n                        .headers(headers)\n                        .method(body != null && req.getMethod().equalsIgnoreCase(\"GET\") ? \"POST\" : req.getMethod())\n                        .body(body)\n                        .request(req).build();\n\n                a = cometSupport.service(r, res);\n            } else {\n                return cometSupport.service(AtmosphereRequest.wrap(req), res);\n            }\n        } catch (IllegalStateException ex) {\n            if (ex.getMessage() != null && ex.getMessage().startsWith(\"Tomcat failed\")) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n                logger.trace(ex.getMessage(), ex);\n\n                cometSupport = new BlockingIOCometSupport(config);\n                doCometSupport(req, res);\n            } else {\n                logger.error(\"AtmosphereServlet exception\", ex);\n                throw ex;\n            }\n        } finally {\n            if (r != null && a != null && a.type != Action.TYPE.SUSPEND) {\n                r.destroy();\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"Invoke the proprietary  CometSupport","old_comment_raw":"Invoke the proprietary CometSupport","label":0,"pre_label":1,"AST_level":14,"line_counts":56,"new_code_token_num":394},{"new_code_raw":"public int headOfSpan(Span tokenSpan) { \/\/ Error checks if (tokenSpan.size() == 0) { throw new IllegalArgumentException(\"Cannot find head word of empty span!\"); } \/\/ Find where to start searching up the dependency tree int candidateStart = tokenSpan.end() - 1; Optional<Integer> parent; while ( !(parent = sentence.governor(candidateStart)).isPresent() ) { candidateStart -= 1; if (candidateStart < tokenSpan.start()) { \/\/ Case: nothing in this span has a head. Default to right-most element. return tokenSpan.end() - 1; } } int candidate = candidateStart; \/\/ Search up the dependency tree while (parent.isPresent() && parent.get() >= tokenSpan.start() && parent.get() < tokenSpan.end()) { candidate = parent.get(); parent = sentence.governor(candidate); } \/\/ Return return candidate; }","old_code_raw":"  public int headOfSpan(Span tokenSpan) {\n    \/\/ Error checks\n    if (tokenSpan.size() == 0) {\n      throw new IllegalArgumentException(\"Cannot find head word of empty span!\");\n    }\n    List<Optional<Integer>> governors = sentence.governors();\n    if (tokenSpan.start() >= governors.size()) {\n      throw new IllegalArgumentException(\"Span is out of range: \" + tokenSpan + \"; sentence: \" + sentence);\n    }\n    if (tokenSpan.end() > governors.size()) {\n      throw new IllegalArgumentException(\"Span is out of range: \" + tokenSpan + \"; sentence: \" + sentence);\n    }\n\n    \/\/ Find where to start searching up the dependency tree\n    int candidateStart = tokenSpan.end() - 1;\n    Optional<Integer> parent;\n    while ( !(parent = governors.get(candidateStart)).isPresent() ) {\n      candidateStart -= 1;\n      if (candidateStart < tokenSpan.start()) {\n        \/\/ Case: nothing in this span has a head. Default to right-most element.\n        return tokenSpan.end() - 1;\n      }\n    }\n    int candidate = candidateStart;\n\n    \/\/ Search up the dependency tree\n    Set<Integer> seen = new HashSet<>();\n    while (parent.isPresent() && parent.get() >= tokenSpan.start() && parent.get() < tokenSpan.end()) {\n      candidate = parent.get();\n      if (seen.contains(candidate)) {\n        return candidate;\n      }\n      seen.add(candidate);\n      parent = governors.get(candidate);\n    }\n\n    \/\/ Return\n    return candidate;\n  }\n","new_comment_raw":"Get the index of the head word for a given span, based off of the dependency parse.","old_comment_raw":"Get the index of the head word for a given span, based off of the dependency parse.","label":0,"pre_label":1,"AST_level":9,"line_counts":28,"new_code_token_num":178},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class) @Paged public PagingDelegate<CalendarList> getCalendarList( final @Optional @Default(\"false\") boolean showHidden, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<CalendarList>() { @Override public List<CalendarList> doGetPage() throws IOException { com.google.api.services.calendar.Calendar.CalendarList.List calendars = client.calendarList().list(); com.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(pagingConfiguration.getFetchSize()) .setPageToken(this.getPageToken()) .setShowHidden(showHidden) .execute(); setPageToken(list.getNextPageToken()); return CalendarList.valueOf(list.getItems(), CalendarList.class); } }; }","old_code_raw":"    @Processor\n    @Inject\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n    public List<CalendarList> getCalendarList(\n    \t\tMuleMessage message,\n    \t\t@Optional @Default(\"100\") int maxResults,\n    \t\t@Optional String pageToken,\n    \t\t@Optional @Default(\"false\") boolean showHidden) throws IOException {\n\n    \tcom.google.api.services.calendar.Calendar.CalendarList.List calendars = this.client.calendarList().list();\n    \tcom.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(maxResults)\n    \t\t.setPageToken(pageToken)\n    \t\t.setShowHidden(showHidden)\n    \t\t.execute();\n    \t\n    \tthis.saveNextPageToken(list, message);\n    \treturn CalendarList.valueOf(list.getItems(), CalendarList.class);\n    }\n","new_comment_raw":"Returns a paginated iterator with instances of  org.mule.module.google.calendar.model.CalendarList listing the calendars of the user that owns the OAuth access token.","old_comment_raw":"Returns an instance of org.mule.module.google.calendar.model.CalendarList listing the calendars of the user that owns the OAuth access token.","label":1,"pre_label":0,"AST_level":14,"line_counts":25,"new_code_token_num":129},{"new_code_raw":"public Mono<Order> getOrderById(Long orderId) throws RestClientException { Object postBody = null; \/\/ verify the required parameter 'orderId' is set if (orderId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'orderId' when calling getOrderById\"); } \/\/ create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(\"order_id\", orderId); String path = UriComponentsBuilder.fromPath(\"\/store\/order\/{order_id}\").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/xml\", \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {}; return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<Order> getOrderById(Long orderId) throws RestClientException {\n        Object postBody = null;\n        \n        \/\/ verify the required parameter 'orderId' is set\n        if (orderId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'orderId' when calling getOrderById\");\n        }\n        \n        \/\/ create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"order_id\", orderId);\n        String path = UriComponentsBuilder.fromPath(\"\/store\/order\/{order_id}\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/xml\", \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};\n        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"Find purchase order by ID","old_comment_raw":"Find purchase order by ID","label":0,"pre_label":1,"AST_level":8,"line_counts":31,"new_code_token_num":256},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class) @Paged public PagingDelegate<File> listFiles( final @Optional @Default(\"100\") int maxResults, final @Optional String query, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<File>() { @Override public List<File> doGetPage() throws IOException { FileList response = client.files().list() .setMaxResults(maxResults) .setPageToken(this.getPageToken()) .setQ(query) .execute(); this.setPageToken(response.getNextPageToken()); return File.valueOf(response.getItems(), File.class); } }; }","old_code_raw":"\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Inject\n\tpublic List<File> listFiles(\n\t\t\tMuleMessage message,\n\t\t\t@Optional @Default(\"100\") int maxResults,\n\t\t\t@Optional String query,\n    \t\t@Optional @Default(\"#[flowVars['GoogleDrive_NEXT_PAGE_TOKEN']]\") String pageToken) throws IOException {\n\t\t\n\t\tFileList response = this.client.files().list()\n\t\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t\t.setPageToken(pageToken)\n\t\t\t\t\t\t\t.setQ(query)\n\t\t\t\t\t\t\t.execute();\n\t\t\n\t\tPaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n\t\treturn File.valueOf(response.getItems(), File.class);\n\t}\n","new_comment_raw":"Returns a paginated  Iterator with the user's  org.mule.module.google.drive.model.Files.","old_comment_raw":"Lists the user's files.","label":1,"pre_label":0,"AST_level":11,"line_counts":27,"new_code_token_num":116},{"new_code_raw":"public static TimestampedEntry parseTimestampedEntry(InputStream in) { TimestampedEntry timestampedEntry = new TimestampedEntry(); timestampedEntry.timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH); int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH); timestampedEntry.entryType = Ct.LogEntryType.valueOf(entryType); Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder(); if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) { int length = (int) readNumber(in, 3); ByteString x509 = ByteString.copyFrom(readFixedLength(in, length)); signedEntryBuilder.setX509(x509); } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) { Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder(); byte[] arr = readFixedLength(in, 32); preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr)); \/\/ set tbs certificate arr = readFixedLength(in, 2); int length = (int) readNumber(in, 2); preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length))); preCertBuilder.build(); signedEntryBuilder.setPrecert(preCertBuilder); } else { throw new SerializationException(String.format(\"Unknown entry type: %d\", entryType)); } timestampedEntry.signedEntry = signedEntryBuilder.build(); return timestampedEntry; }","old_code_raw":"  public static Ct.TimestampedEntry parseTimestampedEntry(InputStream in) {\n    Ct.TimestampedEntry.Builder timestampedEntry = Ct.TimestampedEntry.newBuilder();\n\n    long timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH);\n    timestampedEntry.setTimestamp(timestamp);\n\n    int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH);\n    timestampedEntry.setEntryType(Ct.LogEntryType.valueOf(entryType));\n\n    Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder();\n    if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) {\n\n      int length = (int) readNumber(in, 3);\n      ByteString x509 = ByteString.copyFrom(readFixedLength(in, length));\n      signedEntryBuilder.setX509(x509);\n\n    } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) {\n      Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder();\n\n      byte[] arr = readFixedLength(in, 32);\n      preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr));\n\n      \/\/ set tbs certificate\n      arr = readFixedLength(in, 2);\n      int length = (int) readNumber(in, 2);\n\n      preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length)));\n      preCertBuilder.build();\n\n      signedEntryBuilder.setPrecert(preCertBuilder);\n    } else {\n      throw new SerializationException(String.format(\"Unknown entry type: %d\", entryType));\n    }\n    signedEntryBuilder.build();\n    timestampedEntry.setSignedEntry(signedEntryBuilder);\n\n    return timestampedEntry.build();\n  }\n","new_comment_raw":"Parses a  TimestampedEntry from binary encoding.","old_comment_raw":"Parses a Ct.TimestampedEntry from binary encoding.","label":1,"pre_label":0,"AST_level":10,"line_counts":38,"new_code_token_num":224},{"new_code_raw":"synchronized public Value put(Transaction tx, Key key, Value value) throws IOException { Value oldValue = null; if (lastGetNodeCache != null) { if(lastGetEntryCache.getKey().equals(key)) { oldValue = lastGetEntryCache.setValue(value); lastGetEntryCache.setValue(value); lastGetNodeCache.storeUpdate(tx); return oldValue; } \/\/ This searches from the last location of a call to get for the element to replace \/\/ all the way to the end of the ListIndex. Iterator<Map.Entry<Key, Value>> iterator = lastGetNodeCache.iterator(tx); while (iterator.hasNext()) { Map.Entry<Key, Value> entry = iterator.next(); if (entry.getKey().equals(key)) { oldValue = entry.setValue(value); ((ListIterator) iterator).getCurrent().storeUpdate(tx); return oldValue; } } } \/\/ Not found because the cache wasn't set or its not at the end of the list so we \/\/ start from the beginning and go to the cached location or the end, then we do \/\/ an add if its not found. Iterator<Map.Entry<Key, Value>> iterator = iterator(tx); while (iterator.hasNext() && ((ListIterator) iterator).getCurrent() != lastGetNodeCache) { Map.Entry<Key, Value> entry = iterator.next(); if (entry.getKey().equals(key)) { oldValue = entry.setValue(value); ((ListIterator) iterator).getCurrent().storeUpdate(tx); return oldValue; } } \/\/ Not found so add it last. return add(tx, key, value); }","old_code_raw":"    synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {\n        return add(tx, key, value);\n    }\n","new_comment_raw":"Update the value of the item with the given key in the list if ot exists, otherwise it appends the value to the end of the list.","old_comment_raw":"appends to the list","label":1,"pre_label":0,"AST_level":12,"line_counts":43,"new_code_token_num":313},{"new_code_raw":"public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false; } return isSupported(type.getDurationType()); }","old_code_raw":"    public boolean isSupported(DateTimeFieldType type) {\n        if (type == null) {\n            return false;\n        }\n        DateTimeField field = type.getField(getChronology());\n        if (DATE_DURATION_TYPES.contains(type.getDurationType()) ||\n            field.getDurationField().getUnitMillis() >= getChronology().days().getUnitMillis()) {\n            return field.isSupported();\n        }\n        return false;\n    }\n","new_comment_raw":"Checks if the field type specified is supported by this local date and chronology.","old_comment_raw":"Checks if the field type specified is supported by this local datetime and chronology.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":28},{"new_code_raw":"public String executeAs(Function<Response, Response> handler) { Type type = new TypeToken<String>(){}.getType(); return execute(handler).as(type); }","old_code_raw":"        public String executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<String>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n","new_comment_raw":"POST \/fake\/outer\/string","old_comment_raw":"POST \/fake\/outer\/string","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"protected Object convertTimestampToEpochMillis(Column column, Field fieldDefn, Object data) { \/\/ epoch is the fallback value return convertValue(column, fieldDefn, data, 0L, (r) -> { try { r.deliver(Timestamp.toEpochMillis(data, adjuster)); } catch (IllegalArgumentException e) { } }); }","old_code_raw":"    protected Object convertTimestampToEpochMillis(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L; \/\/ return epoch\n        }\n        try {\n            return Timestamp.toEpochMillis(data, adjuster);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#TIMESTAMP to  Timestamp values, or milliseconds past epoch.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#TIMESTAMP to Timestamp values, or milliseconds past epoch.","label":0,"pre_label":1,"AST_level":10,"line_counts":10,"new_code_token_num":63},{"new_code_raw":"public QName getPortTypeName() { return portTypeName == null ? new QName(\"\") : portTypeName; }","old_code_raw":"    public QName getPortTypeName() {\n        return portName == null ? new QName(\"\") : portName;\n    }\n","new_comment_raw":"Returns the fully qualified name of the port type for this Call object (if there is one).","old_comment_raw":"Returns the fully qualified name of the port for this Call object (if there is one).","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class) @Paged public PagingDelegate<CommentReply> listCommentReplies( final String fileId, final String commentId, final @Optional @Default(\"false\") boolean includeDeleted, final @Optional @Default(\"100\") int maxResults, final PagingConfiguration pagingConfiguration ) throws IOException { return new TokenBasedPagingDelegate<CommentReply>() { @Override protected List<CommentReply> doGetPage() throws IOException { CommentReplyList response = client.replies().list(fileId, commentId) .setIncludeDeleted(includeDeleted) .setMaxResults(maxResults) .setPageToken(this.getPageToken()) .execute(); this.setPageToken(response.getNextPageToken()); return CommentReply.valueOf(response.getItems(), CommentReply.class); } }; }","old_code_raw":"\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Inject\n\tpublic List<CommentReply> listCommentReplies(\n\t\t\tMuleMessage message,\n\t\t\tString fileId,\n\t\t\tString commentId, \n\t\t\t@Optional @Default(\"false\") boolean includeDeleted,\n\t\t\t@Optional @Default(\"100\") int maxResults,\n\t\t\t@Optional @Default(\"#[flowVars['GoogleDrive_NEXT_PAGE_TOKEN']]\") String pageToken\n\t\t\t) throws IOException {\n\t\t\n\t\tCommentReplyList response = this.client.replies().list(fileId, commentId)\n\t\t\t\t\t\t\t\t\t\t.setIncludeDeleted(includeDeleted)\n\t\t\t\t\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t\t\t\t\t.setPageToken(pageToken)\n\t\t\t\t\t\t\t\t\t\t.execute();\n\t\t\n\n\t\tPaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n\t\treturn CommentReply.valueOf(response.getItems(), CommentReply.class);\n\t}\n","new_comment_raw":"Returns a paginated  Iterator with all the  org.mule.module.google.drive.model.CommentReply for a given comment @sample.xml ..\/..\/..\/doc\/GoogleDriveConnector.xml.sample google-drive:list-comment-replies","old_comment_raw":"Lists all replies for a given comment @sample.xml ..\/..\/..\/doc\/GoogleDriveConnector.xml.sample google-drive:list-comment-replies","label":1,"pre_label":0,"AST_level":11,"line_counts":29,"new_code_token_num":134},{"new_code_raw":"public static TimeExtractionFunction createDefault(String timeZone) { return new TimeExtractionFunction(ISO_TIME_FORMAT, null, timeZone, null); }","old_code_raw":"  public static TimeExtractionFunction createDefault() {\n    return new TimeExtractionFunction(ISO_TIME_FORMAT, null, \"UTC\", null);\n  }\n","new_comment_raw":"Creates the default time format extraction function.","old_comment_raw":"Creates the default time format extraction function.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public JobInstance cancel(@PathVariable String jobId) { try { final JobInstance jobInstance = jobService.getJobInstance(jobId); jobService.cancelJob(jobInstance); return jobService.getJobInstance(jobId); } catch (Exception e) { logger.error(e.getLocalizedMessage(), e); throw new InternalErrorException(e); } }","old_code_raw":"    public JobInstance cancel(@PathVariable String jobId) {\n\n        try {\n            final JobInstance jobInstance = jobService.getJobInstance(jobId);\n            return jobService.cancelJob(jobInstance);\n        } catch (Exception e) {\n            logger.error(e.getLocalizedMessage(), e);\n            throw new InternalErrorException(e);\n        }\n    }\n","new_comment_raw":"Cancel\/discard a job","old_comment_raw":"Cancel\/discard a job","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":61},{"new_code_raw":"public URL getRoot() { return rootUrl; }","old_code_raw":"\tpublic IPath getRoot() {\n\t\treturn root;\n\t}\n","new_comment_raw":"Method getRoot.","old_comment_raw":"Gets the root.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public static ExpectedCondition<Boolean> and(final ExpectedCondition<?>... conditions) { return new ExpectedCondition<Boolean>() { @Override public Boolean apply(WebDriver driver) { for (ExpectedCondition<?> condition : conditions) { Object result = condition.apply(driver); if (result instanceof Boolean) { if (Boolean.FALSE.equals(result)) { return false; } } if (result == null) { return false; } } return true; } @Override public String toString() { StringBuilder message = new StringBuilder(\"all conditions to be valid: \"); Joiner.on(\" && \").appendTo(message, conditions); return message.toString(); } }; }","old_code_raw":"  public static ExpectedCondition<Boolean> and(final ExpectedCondition<?>... conditions) {\n    return new ExpectedCondition<Boolean>() {\n      @Override\n      public Boolean apply(WebDriver driver) {\n        for (ExpectedCondition<?> condition : conditions) {\n          try {\n            Object result = condition.apply(driver);\n            if (result == null) {\n              return Boolean.FALSE;\n            } else if (result instanceof Boolean) {\n              if (!(Boolean) result) {\n                return Boolean.FALSE;\n              }\n            }\n          } catch (Exception e) {\n            return Boolean.FALSE;\n          }\n        }\n        return Boolean.TRUE;\n      }\n\n      @Override\n      public String toString() {\n        String message = \"all conditions to be valid: \";\n        for (ExpectedCondition<?> condition : conditions) {\n          message += condition.toString();\n        }\n        return message;\n      }\n    };\n  }\n","new_comment_raw":"An expectation with the logical and condition of the given list of conditions.","old_comment_raw":"An expectation with the logical and condition of the given list of conditions.","label":0,"pre_label":1,"AST_level":13,"line_counts":29,"new_code_token_num":131},{"new_code_raw":"protected PingResult parse(int exitValue, List<String> outLines,List<String> errLines) { PingResult info = new PingResult(); Pattern roundTripTimePat = Pattern.compile(RTT_REG_EX); Pattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX); Pattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX); Pattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX); info.setHost(getHost()); \/\/ Parse the output based on exit value of ping switch (exitValue) { \/\/ Clean exit case 0: \/\/ Extract the RTT times for (String line : outLines) { Matcher matcher = roundTripTimePat.matcher(line); if (matcher.find()) { info.setRTTMin(Double.parseDouble(matcher.group(1))); info.setRTTAvg(Double.parseDouble(matcher.group(2))); info.setRTTMax(Double.parseDouble(matcher.group(3))); info.setRTTMDev(Double.parseDouble(matcher.group(4))); } } \/\/ Extract the transmit and received counts for (String line : outLines) { Matcher matcher = transmitReceivePat.matcher(line); if (matcher.find()) { info.setTransmitted(Integer.parseInt(matcher.group(1))); info.setReceived(Integer.parseInt(matcher.group(2))); } } \/\/ If no ICMP packages are returned then consider the test failed if (info.getReceived() == 0) { info.setStatus(ServiceStatus.FAIL); } else { info.setStatus(ServiceStatus.SUCCESS); } break; \/\/ Error case: 1) Unable to resolve host ; 2) Host unreachable case 1: case 2: case 68: for (String line : outLines) { Matcher matcher = transmitReceivePat.matcher(line); if (matcher.find()) { info.setTransmitted(Integer.parseInt(matcher.group(1))); info.setReceived(Integer.parseInt(matcher.group(2))); } } for (String line: errLines) { Matcher matcher = unknownHostPat.matcher(line); if (matcher.find()) { info.setMessage(matcher.group(1)); } } info.setStatus(ServiceStatus.FAIL); break; default: assert false: \"Unknown exit code\"; } return info; }","old_code_raw":"\tprotected PingInfo parse(int exitValue, List<String> outLines,List<String> errLines) {\n\t\tPingInfo info = new PingInfo();\n\t\tPattern roundTripTimePat = Pattern.compile(RTT_REG_EX);\n\t\tPattern transmitReceivePat = Pattern.compile(TRANSMITTED_RECEIVED_REG_EX);\n\t\tPattern noRouteToHostPat = Pattern.compile(NO_ROUTE_TO_HOST_REG_EX);\n\t\tPattern unknownHostPat = Pattern.compile(UNKNOWN_HOST_REG_EX);\n\n\t\tinfo.setHost(getHost());\n\n\t\t\/\/ Parse the output based on exit value of ping\n\t\tswitch (exitValue) {\n\n\t\t\/\/ Clean exit\n\t\tcase 0:\n\t\t\t\/\/ Extract the RTT times\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = roundTripTimePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setRTTMin(Double.parseDouble(matcher.group(1)));\n\t\t\t\t\tinfo.setRTTAvg(Double.parseDouble(matcher.group(2)));\n\t\t\t\t\tinfo.setRTTMax(Double.parseDouble(matcher.group(3)));\n\t\t\t\t\tinfo.setRTTMDev(Double.parseDouble(matcher.group(4)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ Extract the transmit and received counts\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = transmitReceivePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setTransmitted(Integer.parseInt(matcher.group(1)));\n\t\t\t\t\tinfo.setReceived(Integer.parseInt(matcher.group(2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\/\/ If no ICMP packages are returned then consider the test failed\n\t\t\tif (info.getReceived() == 0) {\n\t\t\t\tinfo.setStatus(ServiceStatus.FAIL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinfo.setStatus(ServiceStatus.SUCCESS);\n\t\t\t}\n\t\t\tbreak;\n\t\t\/\/ Error case: 1) Unable to resolve host ; 2) Host unreachable\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 68:\n\t\t\tfor (String line : outLines) {\n\t\t\t\tMatcher matcher = transmitReceivePat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setTransmitted(Integer.parseInt(matcher.group(1)));\n\t\t\t\t\tinfo.setReceived(Integer.parseInt(matcher.group(2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (String line: errLines) {\n\t\t\t\tMatcher matcher = unknownHostPat.matcher(line);\n\t\t\t\tif (matcher.find()) {\n\t\t\t\t\tinfo.setMessage(matcher.group(1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tinfo.setStatus(ServiceStatus.FAIL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert false: \"Unknown exit code\";\n\t\t}\n\n\t\treturn info;\n\t}\n","new_comment_raw":"Parses the output of ping and populates a instance of  PingResult","old_comment_raw":"Parses the output of ping and populates a instance of PingInfo","label":1,"pre_label":0,"AST_level":13,"line_counts":70,"new_code_token_num":418},{"new_code_raw":"protected Object convertBits(Column column, Field fieldDefn, Object data, int numBytes) { return convertValue(column, fieldDefn, data, new byte[0], (r) -> { if (data instanceof Boolean) { Boolean value = (Boolean) data; r.deliver(new byte[] { value.booleanValue() ? (byte) 1 : (byte) 0 }); } else if (data instanceof Short) { Short value = (Short) data; ByteBuffer buffer = ByteBuffer.allocate(Short.BYTES); buffer.order(ByteOrder.LITTLE_ENDIAN); buffer.putShort(value.shortValue()); r.deliver(buffer.array()); } else if (data instanceof Integer) { Integer value = (Integer) data; ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES); buffer.order(ByteOrder.LITTLE_ENDIAN); buffer.putInt(value.intValue()); r.deliver(buffer.array()); } else if (data instanceof Long) { Long value = (Long) data; ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES); buffer.order(ByteOrder.LITTLE_ENDIAN); buffer.putLong(value.longValue()); r.deliver(buffer.array()); } else if (data instanceof byte[]) { byte[] bytes = (byte[]) data; if (bytes.length == 1) { r.deliver(bytes); } if (byteOrderOfBitType() == ByteOrder.BIG_ENDIAN) { \/\/ Reverse it to little endian ... int i = 0; int j = bytes.length - 1; byte tmp; while (j > i) { tmp = bytes[j]; bytes[j] = bytes[i]; bytes[i] = tmp; ++i; --j; } } r.deliver(padLittleEndian(numBytes, bytes)); } else if (data instanceof BitSet) { byte[] bytes = ((BitSet) data).toByteArray(); r.deliver(padLittleEndian(numBytes, bytes)); } }); }","old_code_raw":"    protected Object convertBits(Column column, Field fieldDefn, Object data, int numBytes) {\n        return convertValue(column, fieldDefn, data, false, (r) -> {\n            if (data instanceof Boolean) {\n                Boolean value = (Boolean) data;\n                r.deliver(new byte[] { value.booleanValue() ? (byte) 1 : (byte) 0 });\n            }\n            else if (data instanceof Short) {\n                Short value = (Short) data;\n                ByteBuffer buffer = ByteBuffer.allocate(Short.BYTES);\n                buffer.order(ByteOrder.LITTLE_ENDIAN);\n                buffer.putShort(value.shortValue());\n                r.deliver(buffer.array());\n            }\n            else if (data instanceof Integer) {\n                Integer value = (Integer) data;\n                ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES);\n                buffer.order(ByteOrder.LITTLE_ENDIAN);\n                buffer.putInt(value.intValue());\n                r.deliver(buffer.array());\n            }\n            else if (data instanceof Long) {\n                Long value = (Long) data;\n                ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);\n                buffer.order(ByteOrder.LITTLE_ENDIAN);\n                buffer.putLong(value.longValue());\n                r.deliver(buffer.array());\n            }\n            else if (data instanceof byte[]) {\n                byte[] bytes = (byte[]) data;\n                if (bytes.length == 1) {\n                    r.deliver(bytes);\n                }\n                if (byteOrderOfBitType() == ByteOrder.BIG_ENDIAN) {\n                    \/\/ Reverse it to little endian ...\n                    int i = 0;\n                    int j = bytes.length - 1;\n                    byte tmp;\n                    while (j > i) {\n                        tmp = bytes[j];\n                        bytes[j] = bytes[i];\n                        bytes[i] = tmp;\n                        ++i;\n                        --j;\n                    }\n                }\n                r.deliver(padLittleEndian(numBytes, bytes));\n            }\n            else if (data instanceof BitSet) {\n                byte[] bytes = ((BitSet) data).toByteArray();\n                r.deliver(padLittleEndian(numBytes, bytes));\n            }\n        });\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#BIT of length 2+.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#BIT of length 2+.","label":0,"pre_label":1,"AST_level":20,"line_counts":54,"new_code_token_num":379},{"new_code_raw":"public static AccessType fromExternalName(String externalName) { if ( externalName == null ) { return null; } for ( AccessType accessType : AccessType.values() ) { if ( accessType.getExternalName().equals( externalName ) ) { return accessType; } } \/\/ Check to see if making upper-case matches an enum name. try { return AccessType.valueOf( externalName.toUpperCase( Locale.ROOT) ); } catch ( IllegalArgumentException e ) { throw new UnknownAccessTypeException( externalName ); } }","old_code_raw":"\tpublic static AccessType fromExternalName(String externalName) {\n\t\tif ( externalName == null ) {\n\t\t\treturn null;\n\t\t}\n\t\tfor ( AccessType accessType : AccessType.values() ) {\n\t\t\tif ( accessType.getExternalName().equals( externalName ) ) {\n\t\t\t\treturn accessType;\n\t\t\t}\n\t\t}\n\t\tthrow new UnknownAccessTypeException( externalName );\n\t}\n","new_comment_raw":"Resolve an AccessType from its external name.","old_comment_raw":"Resolve an AccessType from its external name.","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":91},{"new_code_raw":"public static Bind parse(String serialized) { try { String[] parts = serialized.split(\":\"); switch (parts.length) { case 2: { return new Bind(parts[0], Volume.parse(parts[1])); } case 3: { AccessMode accessMode = AccessMode.valueOf(parts[2].toLowerCase()); return new Bind(parts[0], Volume.parse(parts[1]), accessMode); } default: { throw new IllegalArgumentException(); } } } catch (Exception e) { throw new IllegalArgumentException(\"Error parsing Bind '\" + serialized + \"'\"); } }","old_code_raw":"\tpublic static Bind parse(String serialized) {\n\t\ttry {\n\t\t\tString[] parts = serialized.split(\":\");\n\t\t\tswitch (parts.length) {\n\t\t\tcase 2: {\n\t\t\t\treturn new Bind(parts[0], Volume.parse(parts[1]));\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tif (\"rw\".equals(parts[2].toLowerCase()))\n\t\t\t\t\treturn new Bind(parts[0], Volume.parse(parts[1]), false);\n\t\t\t\telse if (\"ro\".equals(parts[2].toLowerCase()))\n\t\t\t\t\treturn new Bind(parts[0], Volume.parse(parts[1]), true);\n\t\t\t\telse\n\t\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tthrow new IllegalArgumentException(\"Error parsing Bind '\" + serialized\n\t\t\t\t\t+ \"'\");\n\t\t}\n\t}\n","new_comment_raw":"Parses a bind mount specification to a  Bind.","old_comment_raw":"Parses a bind mount specification to a Bind.","label":0,"pre_label":1,"AST_level":12,"line_counts":21,"new_code_token_num":131},{"new_code_raw":"public static String getLastBaselineBuild(String date) { if (BUILDS == null) { queryAllVariations(\"%\"); \/\/$NON-NLS-1$ } if (date == null) return LAST_BASELINE_BUILD; String lastBaselineBuild = null; for (int i=0; i<BUILDS_LENGTH; i++) { String build = BUILDS[i]; if (build.startsWith(AbstractResults.VERSION_REF)) { String buildDate = build.substring(build.indexOf('_')+1); if (buildDate.compareTo(date) < 0) { if (lastBaselineBuild == null || build.compareTo(lastBaselineBuild) > 0) { lastBaselineBuild = build; } } } } return lastBaselineBuild; }","old_code_raw":"public static String getLastBaselineBuild() {\n\tif (BUILDS == null) {\n\t\tqueryAllVariations(\"%\"); \/\/$NON-NLS-1$\n\t}\n\treturn LAST_BASELINE_BUILD;\n}\n","new_comment_raw":"Return the ID of the last baseline build before the given date.","old_comment_raw":"Return the ID of the last baseline build.","label":1,"pre_label":0,"AST_level":13,"line_counts":21,"new_code_token_num":126},{"new_code_raw":"protected boolean parse(String data) throws Exception { if(data == null || data.isEmpty()) { return true; } \/\/ ZAP: Replace all \"\\n\" with \"\\r\\n\" to parse correctly String newData = data.replaceAll(\"(?<!\\r)\\n\", CRLF); \/\/ ZAP: always use CRLF to comply with HTTP specification \/\/ even if the data it's not directly used. mLineDelimiter = CRLF; String[] split = patternCRLF.split(newData); mStartLine = split[0]; String token = null, name = null, value = null; int pos = 0; StringBuilder sb = new StringBuilder(2048); for (int i=1; i<split.length; i++) { token = split[i]; if (token.equals(\"\")) { continue; } if((pos = token.indexOf(\":\")) < 0) { mMalformedHeader = true; return false; } name = token.substring(0, pos).trim(); value = token.substring(pos +1).trim(); if(name.equalsIgnoreCase(CONTENT_LENGTH)) { try { mContentLength = Integer.parseInt(value); } catch (NumberFormatException nfe){} } \/* if (name.equalsIgnoreCase(PROXY_CONNECTION)) { sb.append(name + \": \" + _CLOSE + mLineDelimiter); } else if (name.equalsIgnoreCase(CONNECTION)) { sb.append(name + \": \" + _CLOSE + mLineDelimiter); } else { *\/ sb.append(name + \": \" + value + mLineDelimiter); \/\/} addInternalHeaderFields(name, value); } mMsgHeader = sb.toString(); return true; }","old_code_raw":"    protected boolean parse(String data) throws Exception {\n\n        String \ttoken = null,\n\t\t\t\tname = null,\n\t\t\t\tvalue = null;\n        int pos = 0;\n        Pattern pattern = null;\n\n        if(data == null || data.equals(\"\")) {\n            return true;\n        }\n\n        if ((pos = data.indexOf(CRLF)) < 0) {\n        \tif ((pos = data.indexOf(LF)) < 0) {\n        \t\treturn false;\n        \t} else {\n        \t\tmLineDelimiter = LF;\n        \t\tpattern = patternLF;\n        \t}\n        } else {\n        \tmLineDelimiter = CRLF;\n        \tpattern = patternCRLF;\n        }\n        \n\t\tString[] split = pattern.split(data);\n\t\tmStartLine = split[0];\n\n\t\tStringBuffer sb = new StringBuffer(2048);\n\t\tfor (int i=1; i<split.length; i++)\n\t\t{\n\t\t\ttoken = split[i];\n\t\t\tif (token.equals(\"\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n            if((pos = token.indexOf(\":\")) < 0) {\n\t\t\t\tmMalformedHeader = true;\n                return false;\n            }\n            name  = token.substring(0, pos).trim();\n            value = token.substring(pos +1).trim();\n\n            if(name.equalsIgnoreCase(CONTENT_LENGTH)) {\n            \ttry {\n                \tmContentLength = Integer.parseInt(value);\n            \t} catch (NumberFormatException nfe){}\n            }\n\t\t\t\n            \/*\n            if (name.equalsIgnoreCase(PROXY_CONNECTION)) {\n            \tsb.append(name + \": \" + _CLOSE + mLineDelimiter);\n            } else if (name.equalsIgnoreCase(CONNECTION)) {\n            \tsb.append(name + \": \" + _CLOSE + mLineDelimiter);\n            } else {\n            *\/\n\t\t\tsb.append(name + \": \" + value + mLineDelimiter);\n\t\t\t\/\/}\n\t\t\t\n\t\t\taddInternalHeaderFields(name, value);\n\t\t}\n\n        mMsgHeader = sb.toString();\n\t\treturn true;\n\t}\n","new_comment_raw":"Parse this Http header using the String given.","old_comment_raw":"Parse this Http header using the String given.","label":0,"pre_label":1,"AST_level":11,"line_counts":57,"new_code_token_num":327},{"new_code_raw":"public MainWindowBase getSleakWindow() { \/\/<DEBUG to find undisposed system resources> DeviceData data = new DeviceData(); data.tracking = true; Display display = new Display(data); Sleak sleak = new Sleak(); sleak.open(); Shell shell = new Shell(display); window = new MainWindowBase(shell); return window; \/\/<\/DEBUG> }","old_code_raw":"\tpublic MainWindow getSleakWindow() {\n\t\t\/\/<DEBUG to find undisposed system resources>\n\t\tDeviceData data = new DeviceData();\n\t\tdata.tracking = true;\n\t\tDisplay display = new Display(data);\n\t\tSleak sleak = new Sleak();\n\t\tsleak.open();\n\t\t\n\t\tShell shell = new Shell(display);\n\t\twindow = new MainWindow(shell);\n\t\treturn window;\n\t\t\/\/<\/DEBUG>\n\t}\n","new_comment_raw":"Initiates an instance of  MainWindowBase that is monitored by Sleak.java, to monitor what handles (to OS device context) are in use.","old_comment_raw":"Initiates an instance of MainWindow that is monitored by Sleak.java, to monitor what handles (to OS device context) are in use.","label":1,"pre_label":0,"AST_level":6,"line_counts":15,"new_code_token_num":68},{"new_code_raw":"public DateTimeField yearOfEra() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfEra(), years()); }","old_code_raw":"    public DateTimeField yearOfEra() {\n        return UnsupportedDateTimeField.getInstance(\"yearOfEra\", years());\n    }\n","new_comment_raw":"Get the year of era field for this chronology.","old_comment_raw":"Get the year of era field for this chronology.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public Map<String,InternalPortletPreference> getStoredPreferences( PortletWindow portletWindow, PortletRequest request) throws PortletContainerException { String key = getFormattedKey(portletWindow, request); Map<String,InternalPortletPreference> preferences = storage.get(key); if (preferences == null) { if (LOG.isDebugEnabled()) { LOG.debug(\"No portlet preferences found for: \" + key); } return Collections.emptyMap(); } else { if (LOG.isDebugEnabled()) { LOG.debug(\"Got \" + preferences.size() + \" stored preferences.\"); } return clonePreferences(preferences); } }","old_code_raw":"\tpublic InternalPortletPreference[] getStoredPreferences(\n\t\t\tPortletWindow portletWindow,\n\t\t\tPortletRequest request)\n\tthrows PortletContainerException {\n        String key = getFormattedKey(portletWindow, request);\n        InternalPortletPreference[] preferences = storage.get(key);\n        if (preferences == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No portlet preferences found for: \" + key);\n            }\n            return new InternalPortletPreference[0];\n        } else {\n        \tif (LOG.isDebugEnabled()) {\n        \t\tLOG.debug(\"Got \" + preferences.length + \" stored preferences.\");\n        \t}\n        \treturn clonePreferences(preferences);\n        }\n    }\n","new_comment_raw":"Returns the stored portlet preferences map.","old_comment_raw":"Returns the stored portlet preferences array.","label":1,"pre_label":0,"AST_level":11,"line_counts":20,"new_code_token_num":110},{"new_code_raw":"File getBaseDir(final File file1, final File file2) { if (file1 == null || file2 == null) { return null; } final Iterator file1Parents = getParents(file1).iterator(); final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator(); File result = null; while (file1Parents.hasNext() && file2Parents.hasNext()) { File next = (File) file1Parents.next(); if (next.equals(file2Parents.next())) { result = next; } else { break; } } return result; }","old_code_raw":"    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n","new_comment_raw":"Returns the common base directory between the passed file1 and file2.","old_comment_raw":"Returns the common base directory between a current base directory and a given file.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":105},{"new_code_raw":"private FileSelection expandIfNecessary(FileSelection selection) throws IOException { if (selection.isExpandedFully()) { return selection; } \/\/ use the cacheFileRoot if provided (e.g after partition pruning) Path metaFilePath = new Path(cacheFileRoot != null ? cacheFileRoot : selectionRoot, Metadata.METADATA_FILENAME); if (!fs.exists(metaFilePath)) { \/\/ no metadata cache if (selection.isExpandedPartial()) { logger.error(\"'{}' metadata file does not exist, but metadata directories cache file is present\", metaFilePath); metaContext.setMetadataCacheCorrupted(true); } return selection; } return expandSelectionFromMetadataCache(selection, metaFilePath); }","old_code_raw":"  private FileSelection expandIfNecessary(FileSelection selection) throws IOException {\n    if (selection.isExpandedFully()) {\n      return selection;\n    }\n\n    \/\/ use the cacheFileRoot if provided (e.g after partition pruning)\n    Path metaFilePath = new Path(cacheFileRoot != null ? cacheFileRoot : selectionRoot, Metadata.METADATA_FILENAME);\n    if (!fs.exists(metaFilePath)) { \/\/ no metadata cache\n      return selection;\n    }\n\n    FileSelection expandedSelection = initFromMetadataCache(selection, metaFilePath);\n    return expandedSelection;\n  }\n","new_comment_raw":"expands the selection's folders if metadata cache is found for the selection root.","old_comment_raw":"expands the selection's folders if metadata cache is found for the selection root.","label":0,"pre_label":1,"AST_level":9,"line_counts":19,"new_code_token_num":122},{"new_code_raw":"public Tree transformTree(Tree t) { if (VERBOSE) { System.err.println(\"Input to CoordinationTransformer: \" + t); } Tree tx = tn.transformTree(t); if (VERBOSE) { System.err.println(\"After DependencyTreeTransformer: \" + tx); } if (tx == null) { return tx; } Tree tt = UCPtransform(tx); if (VERBOSE) { System.err.println(\"After UCPTransformer: \" + tt); } Tree ttt = CCtransform(tt); if (VERBOSE) { System.err.println(\"After CCTransformer: \" + ttt); } Tree tttt = qp.transformTree(ttt); if (VERBOSE) { System.err.println(\"After QPTreeTransformer: \" + tttt); } Tree flatSQ = SQflatten(tttt); if (VERBOSE) { System.err.println(\"After SQ flattening: \" + flatSQ); } Tree fixedDates = dates.transformTree(flatSQ); if (VERBOSE) { System.err.println(\"After DateTreeTransformer: \" + fixedDates); } Tree removedXX = removeXOverX(fixedDates); if (VERBOSE) { System.err.println(\"After removeXoverX: \" + removedXX); } Tree conjp = combineConjp(removedXX); if (VERBOSE) { System.err.println(\"After combineConjp: \" + conjp); } return conjp; }","old_code_raw":"  public Tree transformTree(Tree t) {\n    if (VERBOSE) {\n      System.err.println(\"Input to CoordinationTransformer: \" + t);\n    }\n    Tree tx = tn.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DependencyTreeTransformer:  \" + tx);\n    }\n    if (tx == null) {\n      return tx;\n    }\n    Tree tt = UCPtransform(tx);\n    if (VERBOSE) {\n      System.err.println(\"After UCPTransformer:             \" + tt);\n    }\n    Tree ttt = CCtransform(tt);\n    if (VERBOSE) {\n      System.err.println(\"After CCTransformer:              \" + ttt);\n    }\n    Tree tttt = qp.transformTree(ttt);\n    if (VERBOSE) {\n      System.err.println(\"After QPTreeTransformer:          \" + tttt);\n    }\n    Tree flatSQ = SQflatten(tttt);\n    if (VERBOSE) {\n      System.err.println(\"After SQ flattening:              \" + flatSQ);\n    }\n    Tree fixedDates = dates.transformTree(flatSQ);\n    if (VERBOSE) {\n      System.err.println(\"After DateTreeTransformer:        \" + fixedDates);\n    }\n    Tree ret = removeXOverX(fixedDates);\n    if (VERBOSE) {\n      System.err.println(\"After removeXoverX:               \" + ret);\n    }\n    return ret;\n  }\n","new_comment_raw":"Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).","old_comment_raw":"Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).","label":0,"pre_label":1,"AST_level":8,"line_counts":42,"new_code_token_num":254},{"new_code_raw":"public static boolean checkAlreadyExist(AccountDatabase.AccountName s) { Realm realm = Realm.getDefaultInstance(); \/\/ Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); \/\/ Checking if string equals to is exist or not query.equalTo(\"name\", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); \/\/ Here checking if count of that values is greater than zero return (result1.size() > 0); }","old_code_raw":"    public static boolean checkAlreadyExist(AccountDatabase.AccountName s) {\n        Realm realm = Realm.getDefaultInstance();\n        \/\/ Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        \/\/ Checking if string equals to is exist or not\n        query.equalTo(\"name\", s.toString());\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        \/\/ Here checking if count of that values is greater than zero\n        return (result1.size() > 0) ? true : false;\n    }\n","new_comment_raw":"This function check if the selected account is already existed.","old_comment_raw":"This function check if the selected account is already existed.","label":0,"pre_label":1,"AST_level":7,"line_counts":13,"new_code_token_num":89},{"new_code_raw":"public Float getBottomValue() { return bottomValue; }","old_code_raw":"        public float getBottomValue() {\n            return bottomValue == null ? 0 : bottomValue.floatValue();\n        }\n","new_comment_raw":"Gets the 'bottom' attributes value using current units.","old_comment_raw":"Gets the 'bottom' CSS-attributes value in specified units.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public Builder argument(GraphQLArgument.Builder builder) { return argument(builder.build()); }","old_code_raw":"        public Builder argument(GraphQLArgument.Builder builder) {\n            this.arguments.add(builder.build());\n            return this;\n        }\n","new_comment_raw":"Same effect as the argument(GraphQLArgument).","old_comment_raw":"Same effect as the argument(GraphQLArgument).","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public ArrayList getAllAHRefs() { return this.a_href_all; }","old_code_raw":"    public ArrayList getAllAHRefs() {\n        return a_href_all;\n    }\n","new_comment_raw":"Get a list of all a href=","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public DateTimeFormatterBuilder appendHourOfDay(int minDigits) { return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2); }","old_code_raw":"    public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {\n        return appendDecimal(iChronoUTC.hourOfDay(), minDigits, 2);\n    }\n","new_comment_raw":"Instructs the printer to emit a numeric hourOfDay field.","old_comment_raw":"Instructs the printer to emit a numeric hourOfDay field.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public String getAsText(long instant, Locale locale) { return getAsText(get(instant)); }","old_code_raw":"    public String getAsText(long instant, Locale locale) {\n        return Integer.toString(get(instant));\n    }\n","new_comment_raw":"Get the human-readable, text value of this field from the milliseconds.","old_comment_raw":"Get the human-readable, text value of this field from the milliseconds.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"private String buildRemoveVideoSdpProposal() { if (logger.isActivated()) { logger.debug(\"Build SDP proposal to remove video stream from the session\"); } try { \/\/ Build SDP part String ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis()); String ipAddress = getDialogPath().getSipStack().getLocalIpAddress(); getAudioPlayer().getLocalRtpPort(); String audioSdp = AudioSdpBuilder.buildSdpOffer(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort()); return \"v=0\" + SipUtils.CRLF + \"o=- \" + ntpTime + \" \" + ntpTime + \" \" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + \"s=-\" + SipUtils.CRLF + \"c=\" + SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF + \"t=0 0\" + SipUtils.CRLF + audioSdp + \"a=sendrcv\" + SipUtils.CRLF; } catch (RemoteException e) { if (logger.isActivated()) { logger.error(\"Remove video has failed\", e); } \/\/ Unexpected error handleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION, e.getMessage())); return null; } }","old_code_raw":"\tprivate String buildRemoveVideoSdpProposal() {\n\t\tif (logger.isActivated()) {\n\t\t\tlogger.info(\"buildRemoveVideoSdpProposal()\");\n\t\t}\n\n\t\t\/\/ Build SDP part\n\t\tString sdp = \"\";\n\t\tString ntpTime = SipUtils.constructNTPtime(System.currentTimeMillis());\n\t\tString ipAddress = getDialogPath().getSipStack().getLocalIpAddress();\n\n\t\t\n\t\ttry {\n\t\t\tlogger.warn(\"Build audio sdp\");\n\t\t\tgetAudioPlayer().getLocalRtpPort();\t\t\t\n\t\t\tString audioSdp = AudioSdpBuilder.buildSdp(getAudioPlayer().getSupportedAudioCodecs(), getAudioPlayer().getLocalRtpPort());\n\t\t\t\n\t\t\tsdp = \"v=0\" + SipUtils.CRLF + \"o=- \" + ntpTime + \" \" + ntpTime\n\t\t\t\t\t+ \" \" + SdpUtils.formatAddressType(ipAddress)\n\t\t\t\t\t+ SipUtils.CRLF + \"s=-\" + SipUtils.CRLF + \"c=\"\n\t\t\t\t\t+ SdpUtils.formatAddressType(ipAddress) + SipUtils.CRLF\n\t\t\t\t\t+ \"t=0 0\" + SipUtils.CRLF + audioSdp + \"a=sendrcv\"\n\t\t\t\t\t+ SipUtils.CRLF;\n\t\t} catch (RemoteException e) {\n\t\t\tif (logger.isActivated()) {\n\t\t\t\tlogger.error(\"Remove Video has failed\", e);\n\t\t\t}\n\n\t\t\t\/\/ Unexpected error\n\t\t\thandleError(new IPCallError(IPCallError.UNEXPECTED_EXCEPTION,\n\t\t\t\t\te.getMessage()));\n\t\t}\n\t\treturn sdp;\n\t}\n","new_comment_raw":"Build SDP proposal to remove video stream from the session","old_comment_raw":"Build sdp proposal for removeVideo","label":1,"pre_label":0,"AST_level":23,"line_counts":31,"new_code_token_num":215},{"new_code_raw":"public String getMergePolicy() { return mergePolicy; }","old_code_raw":"    public String getMergePolicy() {\n        return mergePolicyConfig.getPolicy();\n    }\n","new_comment_raw":"Gets the map merge policy  com.hazelcast.map.merge.MapMergePolicy","old_comment_raw":"Gets the merge policy.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public int destroy() { ExecuteWatchdog watchdog = executor.getWatchdog(); while (!watchdog.isWatching()){ try { Thread.sleep(50); } catch (InterruptedException e) { throw new WebDriverException(e); } } watchdog.destroyProcess(); if (handler.hasResult()) { return getExitCode(); } log.info(\"Process destruction entered a last-ditch phase that shouldn't happen. File an issue if you see this message\"); \/\/ Give the process a chance to die naturally. quiesceFor(3, SECONDS); if (!handler.hasResult()) { log.info( \"Command failed to close cleanly. Destroying forcefully. \" + this); ProcessUtils.killProcess(snitch.getProcess()); quiesceFor(1, SECONDS); } int exitCode; if (!handler.hasResult()) { log.severe(String.format( \"Unable to kill process with PID %s: %s\", snitch.getProcess(), this)); exitCode = -1; executor.setExitValue(exitCode); } else { exitCode = getExitCode(); } postRunCleanup(); return exitCode; }","old_code_raw":"  public int destroy() {\n    ExecuteWatchdog watchdog = executor.getWatchdog();\n    if (watchdog != null) {\n      watchdog.destroyProcess();\n    }\n\n    \/\/ Give the process a chance to die naturally.\n    quiesceFor(3, SECONDS);\n\n    if (!handler.hasResult()) {\n      log.info(\n          \"Command failed to close cleanly. Destroying forcefully. \" + this);\n      ProcessUtils.killProcess(snitch.getProcess());\n      quiesceFor(1, SECONDS);\n    }\n\n    int exitCode;\n    if (!handler.hasResult()) {\n      log.severe(String.format(\n          \"Unable to kill process with PID %s: %s\", snitch.getProcess(), this));\n      exitCode = -1;\n      executor.setExitValue(exitCode);\n    } else {\n      exitCode = getExitCode();\n    }\n\n    postRunCleanup();\n    return exitCode;\n  }\n","new_comment_raw":"Destroy the current command.","old_comment_raw":"Destroy the current command.","label":0,"pre_label":1,"AST_level":9,"line_counts":40,"new_code_token_num":220},{"new_code_raw":"private static Gobbling gobble( Treepath< SyntacticTree > gobbleStart, int indentation ) { Preconditions.checkArgument( gobbleStart.getTreeAtEnd().isOneOf( _PLACEHOLDER_ ) ) ; Treepath< SyntacticTree > start = gobbleStart ; do { if( TreepathTools.hasNextSibling( start ) ) { final Treepath< SyntacticTree > next = TreepathTools.getNextSibling( start ) ; if( isRawItem( next ) ) { final Treepath< SyntacticTree > minusNext = TreepathTools.removeNextSibling( start ) ; return new Gobbling( minusNext, makeEmbeddedListItem( next ), indentation ) ; } else { final SyntacticTree nextTree = next.getTreeAtEnd() ; if( nextTree.isOneOf( WHITESPACE_, LINE_BREAK_ ) ) { start = TreepathTools.removeNextSibling( start ) ; if( nextTree.isOneOf( WHITESPACE_ ) ) { indentation = getWhitespaceLength( next ) ; } continue ; } } } \/\/ If no next sibling at all, or no useful next sibling, then return. return new Gobbling( start ) ; } while( true ) ; }","old_code_raw":"  private static Gobbling gobble( Treepath< SyntacticTree > gobbleStart ) {\n    if( null == gobbleStart ) {\n      return null ;\n    }\n    Preconditions.checkArgument( gobbleStart.getTreeAtEnd().isOneOf( _PLACEHOLDER_ ) ) ;\n    gobbleStart = TreepathTools.getNextSibling( gobbleStart ) ;\n    \n    do {\n      if( isRawItem( gobbleStart ) ) {\n        if( TreepathTools.hasNextSibling( gobbleStart ) ) {\n          final Treepath< SyntacticTree > nextStart = TreepathTools.getNextSibling( gobbleStart ) ;\n          final Treepath< SyntacticTree > nextStartMinusPrevious =\n              TreepathTools.removePreviousSibling( nextStart ) ;\n          return new Gobbling( nextStartMinusPrevious, makeEmbeddedListItem( gobbleStart ), true ) ;\n        } else {\n          final Treepath< SyntacticTree > minusPrevious = TreepathTools.removeEnd( gobbleStart ) ;\n          return new Gobbling( minusPrevious, makeEmbeddedListItem( gobbleStart ), false ) ;\n        }\n      } else if( gobbleStart.getTreeAtEnd().isOneOf( WHITESPACE_, LINE_BREAK_ ) ) {\n        if( TreepathTools.hasNextSibling( gobbleStart ) ) {\n          gobbleStart = TreepathTools.getNextSibling( gobbleStart ) ;\n        }\n      } else {\n        return null ;\n      }\n    } while( true ) ;\n  }\n","new_comment_raw":"Gobbles one item node if possible.","old_comment_raw":"Gobble one item node if possible.","label":1,"pre_label":0,"AST_level":16,"line_counts":28,"new_code_token_num":165},{"new_code_raw":"private List<WorkerInfo> checkWorkers() { boolean failJob = true; int pollAttempt = 0; List<WorkerInfo> healthyWorkerInfoList = new ArrayList<WorkerInfo>(); List<WorkerInfo> unhealthyWorkerInfoList = new ArrayList<WorkerInfo>(); int totalResponses = -1; while (pollAttempt < maxPollAttempts) { getAllWorkerInfos( getSuperstep(), healthyWorkerInfoList, unhealthyWorkerInfoList); totalResponses = healthyWorkerInfoList.size() + unhealthyWorkerInfoList.size(); if ((totalResponses * 100.0f \/ maxWorkers) >= minPercentResponded) { failJob = false; break; } getContext().setStatus(getGraphMapper().getMapFunctions() + \" \" + \"checkWorkers: Only found \" + totalResponses + \" responses of \" + maxWorkers + \" needed to start superstep \" + getSuperstep()); if (getWorkerHealthRegistrationChangedEvent().waitMsecs( msecsPollPeriod)) { if (LOG.isDebugEnabled()) { LOG.debug(\"checkWorkers: Got event that health \" + \"registration changed, not using poll attempt\"); } getWorkerHealthRegistrationChangedEvent().reset(); continue; } if (LOG.isInfoEnabled()) { LOG.info(\"checkWorkers: Only found \" + totalResponses + \" responses of \" + maxWorkers + \" needed to start superstep \" + getSuperstep() + \". Sleeping for \" + msecsPollPeriod + \" msecs and used \" + pollAttempt + \" of \" + maxPollAttempts + \" attempts.\"); \/\/ Find the missing workers if there are only a few if ((maxWorkers - totalResponses) <= partitionLongTailMinPrint) { Set<Integer> partitionSet = new TreeSet<Integer>(); for (WorkerInfo workerInfo : healthyWorkerInfoList) { partitionSet.add(workerInfo.getPartitionId()); } for (WorkerInfo workerInfo : unhealthyWorkerInfoList) { partitionSet.add(workerInfo.getPartitionId()); } for (int i = 1; i <= maxWorkers; ++i) { if (partitionSet.contains(new Integer(i))) { continue; } else if (i == getTaskPartition()) { continue; } else { LOG.info(\"checkWorkers: No response from \"+ \"partition \" + i + \" (could be master)\"); } } } } ++pollAttempt; } if (failJob) { LOG.error(\"checkWorkers: Did not receive enough processes in \" + \"time (only \" + totalResponses + \" of \" + minWorkers + \" required). This occurs if you do not \" + \"have enough map tasks available simultaneously on \" + \"your Hadoop instance to fulfill the number of \" + \"requested workers.\"); return null; } if (healthyWorkerInfoList.size() < minWorkers) { LOG.error(\"checkWorkers: Only \" + healthyWorkerInfoList.size() + \" available when \" + minWorkers + \" are required.\"); return null; } return healthyWorkerInfoList; }","old_code_raw":"    private Map<String, JSONArray> checkWorkers() {\n        boolean failJob = true;\n        int pollAttempt = 0;\n        List<String> healthyWorkerList = new ArrayList<String>();\n        List<String> unhealthyWorkerList = new ArrayList<String>();\n        int totalResponses = -1;\n        while (pollAttempt < maxPollAttempts) {\n            getWorkers(\n                getSuperstep(), healthyWorkerList, unhealthyWorkerList);\n            totalResponses = healthyWorkerList.size() +\n                unhealthyWorkerList.size();\n            if ((totalResponses * 100.0f \/ maxWorkers) >=\n                    minPercentResponded) {\n                failJob = false;\n                break;\n            }\n            getContext().setStatus(getGraphMapper().getMapFunctions() + \" \" +\n                                   \"checkWorkers: Only found \" +\n                                   totalResponses +\n                                   \" responses of \" + maxWorkers +\n                                   \" needed to start superstep \" +\n                                   getSuperstep());\n            if (getWorkerHealthRegistrationChangedEvent().waitMsecs(\n                    msecsPollPeriod)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"checkWorkers: Got event that health \" +\n                              \"registration changed, not using poll attempt\");\n                }\n                getWorkerHealthRegistrationChangedEvent().reset();\n                continue;\n            }\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"checkWorkers: Only found \" + totalResponses +\n                         \" responses of \" + maxWorkers +\n                         \" needed to start superstep \" +\n                         getSuperstep() + \".  Sleeping for \" +\n                         msecsPollPeriod + \" msecs and used \" + pollAttempt +\n                         \" of \" + maxPollAttempts + \" attempts.\");\n                \/\/ Find the missing workers if there are only a few\n                if ((maxWorkers - totalResponses) <= partitionLongTailMinPrint) {\n                    Set<Integer> partitionSet = new TreeSet<Integer>();\n                    for (String hostnamePartitionId : healthyWorkerList) {\n                        int lastIndex = hostnamePartitionId.lastIndexOf(\"_\");\n                        Integer partition = Integer.parseInt(\n                            hostnamePartitionId.substring(lastIndex + 1));\n                        partitionSet.add(partition);\n                    }\n                    for (String hostnamePartitionId : unhealthyWorkerList) {\n                        int lastIndex = hostnamePartitionId.lastIndexOf(\"_\");\n                        Integer partition = Integer.parseInt(\n                            hostnamePartitionId.substring(lastIndex + 1));\n                        partitionSet.add(partition);\n                    }\n                    for (int i = 1; i <= maxWorkers; ++i) {\n                        if (partitionSet.contains(new Integer(i))) {\n                            continue;\n                        } else if (i == getTaskPartition()) {\n                            continue;\n                        } else {\n                            LOG.info(\"checkWorkers: No response from \"+\n                                     \"partition \" + i + \" (could be master)\");\n                        }\n                    }\n                }\n            }\n            ++pollAttempt;\n        }\n        if (failJob) {\n            LOG.error(\"checkWorkers: Did not receive enough processes in \" +\n                      \"time (only \" + totalResponses + \" of \" +\n                      minWorkers + \" required).  This occurs if you do not \" +\n                      \"have enough map tasks available simultaneously on \" +\n                      \"your Hadoop instance to fulfill the number of \" +\n                      \"requested workers.\");\n            return null;\n        }\n\n        if (healthyWorkerList.size() < minWorkers) {\n            LOG.error(\"checkWorkers: Only \" + healthyWorkerList.size() +\n                      \" available when \" + minWorkers + \" are required.\");\n            return null;\n        }\n\n        Map<String, JSONArray> workerHostnamePortMap =\n            new HashMap<String, JSONArray>();\n        for (String healthyWorker: healthyWorkerList) {\n            String healthyWorkerPath = null;\n            try {\n                healthyWorkerPath =\n                    getWorkerHealthyPath(getApplicationAttempt(),\n                                         getSuperstep()) + \"\/\" +  healthyWorker;\n                JSONArray hostnamePortArray =\n                    new JSONArray(\n                        new String(getZkExt().getData(healthyWorkerPath,\n                                                      false,\n                                                      null)));\n                workerHostnamePortMap.put(healthyWorker, hostnamePortArray);\n            } catch (JSONException e) {\n                throw new RuntimeException(\n                    \"checkWorkers: Problem fetching hostname and port for \" +\n                    healthyWorker + \" in \" + healthyWorkerPath);\n            } catch (KeeperException e) {\n                throw new IllegalStateException(\n                    \"checkWorkers: KeeperException\", e);\n            } catch (InterruptedException e) {\n                throw new IllegalStateException(\n                    \"checkWorkers: IllegalStateException\", e);\n            }\n        }\n\n        return workerHostnamePortMap;\n    }\n","new_comment_raw":"Check all the  WorkerInfo objects to ensure that a minimum number of good workers exists out of the total that have reported.","old_comment_raw":"Check the workers to ensure that a minimum number of good workers exists out of the total that have reported.","label":1,"pre_label":0,"AST_level":21,"line_counts":82,"new_code_token_num":510},{"new_code_raw":"protected DateTimeField getField(int index, Chronology chrono) { switch (index) { case YEAR: return chrono.year(); case MONTH_OF_YEAR: return chrono.monthOfYear(); case DAY_OF_MONTH: return chrono.dayOfMonth(); case MILLIS_OF_DAY: return chrono.millisOfDay(); default: throw new IndexOutOfBoundsException(\"Invalid index: \" + index); } }","old_code_raw":"    protected DateTimeField getField(int index, Chronology chrono) {\n        switch (index) {\n            case YEAR:\n                return chrono.year();\n            case DAY_OF_YEAR:\n                return chrono.dayOfYear();\n            case MILLIS_OF_DAY:\n                return chrono.millisOfDay();\n            default:\n                throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n        }\n    }\n","new_comment_raw":"Gets the field for a specific index in the chronology specified.","old_comment_raw":"Gets the field for a specific index in the chronology specified.","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":69},{"new_code_raw":"private ZapTextField getTxtProxyPort() { if (txtProxyPort == null) { txtProxyPort = new ZapTextField(); } return txtProxyPort; }","old_code_raw":"\tprivate JTextField getTxtProxyPort() {\n\t\tif (txtProxyPort == null) {\n\t\t\ttxtProxyPort = new JTextField();\n\t\t}\n\t\treturn txtProxyPort;\n\t}\n","new_comment_raw":"This method initializes txtProxyPort","old_comment_raw":"This method initializes txtProxyPort","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"private static Consumer<List> mongoChecker(final String... expected) { return actual -> { if (expected == null) { Assert.assertThat(\"null mongo Query\", actual, CoreMatchers.nullValue()); return; } if (expected.length == 0) { CalciteAssert.assertArrayEqual(\"empty Mongo query\", expected, actual.toArray(new Object[0])); return; } final BsonDocument expectedBson = BsonDocument.parse(String.join(\",\", expected)); final BsonDocument actualBson = BsonDocument.parse(((List<?>) actual.get(0)) .stream() .map(Objects::toString) .collect(Collectors.joining(\"\\n\"))); \/\/ compare Bson (not string) representation if (!expectedBson.equals(actualBson)) { final JsonWriterSettings settings = JsonWriterSettings.builder().indent(true).build(); \/\/ used to pretty print Assertion error Assert.assertEquals(\"expected and actual Mongo queries do not match\", expectedBson.toJson(settings), actualBson.toJson(settings)); Assert.fail(\"Should have failed previously because (expected != actual) is already known\"); } }; }","old_code_raw":"  private static Consumer<List> mongoChecker(final String... strings) {\n    return actual -> {\n      Object[] actualArray =\n          actual == null || actual.isEmpty()\n              ? null\n              : ((List) actual.get(0)).toArray();\n      CalciteAssert.assertArrayEqual(\"expected MongoDB query not found\",\n          strings, actualArray);\n    };\n  }\n","new_comment_raw":"Returns a function that checks that a particular MongoDB query has been called.","old_comment_raw":"Returns a function that checks that a particular MongoDB pipeline is generated to implement a query.","label":1,"pre_label":0,"AST_level":11,"line_counts":31,"new_code_token_num":223},{"new_code_raw":"public TopicPublisher createPublisher(Topic topic) throws JMSException { checkClosed(); if (topic instanceof CustomDestination) { CustomDestination customDestination = (CustomDestination) topic; return customDestination.createPublisher(this); } return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic)); }","old_code_raw":"    public TopicPublisher createPublisher(Topic topic) throws JMSException {\n        checkClosed();\n        return new ActiveMQTopicPublisher(this, ActiveMQMessageTransformation.transformDestination(topic));\n    }\n","new_comment_raw":"Creates a publisher for the specified topic.","old_comment_raw":"Creates a publisher for the specified topic.","label":0,"pre_label":1,"AST_level":8,"line_counts":10,"new_code_token_num":50},{"new_code_raw":"public int getBuffer(int k) { return (k >= 0 && k < getBufferSize()) ? buffer.get(k) : Config.NONEXIST; }","old_code_raw":"  public int getBuffer(int k) {\n    return (k >= 0 && k < getBufferSize()) ? buffer.get(k) : CONST.NONEXIST;\n  }\n","new_comment_raw":"Get the sentence index of the kth word on the buffer.","old_comment_raw":"Get the sentence index of the kth word on the buffer.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public Component[] getChildren() { ensureZOrder(); Component[] c = new Component[children.size()]; return (Component[])children.toArray(c); }","old_code_raw":"    public SuiComponent[] getChildren() {\r\n        ensureZOrder();\r\n        SuiComponent[] c = new SuiComponent[children.size()];\r\n        return (SuiComponent[])children.toArray(c);\r\n    }\r\n","new_comment_raw":"Returns an array of this Container's children.","old_comment_raw":"Returns an array of this SuiContainer's children.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":38},{"new_code_raw":"public final boolean hasValidResults() { return getLastAction() != null; }","old_code_raw":"    public final boolean hasValidResults() {\r\n        AbstractBuild<?, ?> build = getLastFinishedBuild();\r\n        if (build != null) {\r\n            BuildHistory history = new BuildHistory(build, resultActionType);\r\n\r\n            return history.hasPreviousResult();\r\n        }\r\n        return false;\r\n    }\r\n","new_comment_raw":"Returns whether this project has a valid result action attached.","old_comment_raw":"Returns whether we have enough valid results in order to draw a meaningful graph.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":15},{"new_code_raw":"public EntityMode guessEntityMode(Object object) { for ( Map.Entry<EntityMode, Tuplizer> entityModeTuplizerEntry : tuplizers.entrySet() ) { if ( entityModeTuplizerEntry.getValue().isInstance( object ) ) { return entityModeTuplizerEntry.getKey(); } } return null; }","old_code_raw":"\tpublic EntityMode guessEntityMode(Object object) {\n\t\tIterator itr = tuplizers.entrySet().iterator();\n\t\twhile( itr.hasNext() ) {\n\t\t\tMap.Entry entry = ( Map.Entry ) itr.next();\n\t\t\tTuplizer tuplizer = ( Tuplizer ) entry.getValue();\n\t\t\tif ( tuplizer.isInstance( object ) ) {\n\t\t\t\treturn ( EntityMode ) entry.getKey();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n","new_comment_raw":"Given a supposed instance of an entity\/component, guess its entity mode.","old_comment_raw":"Given a supposed instance of an entity\/component, guess its entity mode.","label":0,"pre_label":1,"AST_level":9,"line_counts":9,"new_code_token_num":47},{"new_code_raw":"protected String getExample(Schema schema) { if (schema.getExample() != null) { return schema.getExample().toString(); } else if (ModelUtils.isDateTimeSchema(schema)) { return \"2000-01-23T04:56:07.000Z\"; } else if (ModelUtils.isDateSchema(schema)) { return \"2000-01-23\"; } else if (ModelUtils.isBooleanSchema(schema)) { return \"true\"; } else if (ModelUtils.isNumberSchema(schema)) { if (ModelUtils.isFloatSchema(schema)) { \/\/ float return \"1.3579\"; } else { \/\/ double return \"3.149\"; } } else if (ModelUtils.isPasswordSchema(schema)) { return \"********\"; } else if (ModelUtils.isUUIDSchema(schema)) { return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\"; \/\/ do these last in case the specific types above are derived from these classes } else if (ModelUtils.isStringSchema(schema)) { return \"aeiou\"; } else if (ModelUtils.isIntegerSchema(schema)) { if (ModelUtils.isLongSchema(schema)) { \/\/ long return \"123456789\"; } else { \/\/integer return \"123\"; } } else { LOGGER.debug(\"default example value not implemented for {}. Default to UNDEFINED_EXAMPLE_VALUE\", schema); return \"UNDEFINED_EXAMPLE_VALUE\"; } }","old_code_raw":"    protected String getExample(Property property) {\n        if (property.getExample() != null) {\n            return property.getExample().toString();\n        } else if (property instanceof DateTimeProperty) {\n            return \"2000-01-23T04:56:07.000Z\";\n        } else if (property instanceof DateProperty) {\n            return \"2000-01-23\";\n        } else if (property instanceof BooleanProperty) {\n            return \"true\";\n        } else if (property instanceof LongProperty) {\n            return \"123456789\";\n        } else if (property instanceof DoubleProperty) { \/\/ derived from DecimalProperty so make sure this is first\n            return \"3.149\";\n        }  else if (property instanceof DecimalProperty) {\n            return \"1.3579\";\n        } else if (property instanceof PasswordProperty) {\n            return \"********\";\n        } else if (property instanceof UUIDProperty) {\n            return \"046b6c7f-0b8a-43b9-b35d-6489e6daee91\";\n        \/\/ do these last in case the specific types above are derived from these classes\n        } else if (property instanceof StringProperty) {\n            return \"aeiou\";\n        } else if (property instanceof BaseIntegerProperty) {\n            return \"123\";\n        } else if (property instanceof AbstractNumericProperty) {\n            return \"1.23\";\n        }\n        LOGGER.warn(\"default example value not implemented for \" + property);\n        return \"\";\n    }\n","new_comment_raw":"Get the example string value for the given schema.","old_comment_raw":"Get the example string value for the given Property.","label":1,"pre_label":0,"AST_level":16,"line_counts":34,"new_code_token_num":279},{"new_code_raw":"public static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationBindingContext context) { ClassLoaderService classLoaderService = context.classLoaderService(); Map<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>(); for ( ClassInfo info : context.getIndex().getKnownClasses() ) { if ( !isEntityClass( info ) ) { continue; } if ( processedClassInfos.containsKey( info ) ) { continue; } List<ClassInfo> configuredClassList = new ArrayList<ClassInfo>(); ClassInfo tmpClassInfo = info; Class<?> clazz = classLoaderService.classForName( tmpClassInfo.toString() ); while ( clazz != null && !clazz.equals( Object.class ) ) { tmpClassInfo = context.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) ); clazz = clazz.getSuperclass(); if ( tmpClassInfo == null ) { continue; } if ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) { List<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo ); for ( ClassInfo tmpInfo : configuredClassList ) { classInfoList.add( tmpInfo ); processedClassInfos.put( tmpInfo, classInfoList ); } break; } else { configuredClassList.add( 0, tmpClassInfo ); processedClassInfos.put( tmpClassInfo, configuredClassList ); } } } Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>(); List<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>(); for ( List<ClassInfo> classInfoList : processedClassInfos.values() ) { if ( !processedList.contains( classInfoList ) ) { hierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, context ) ); processedList.add( classInfoList ); } } return hierarchies; }","old_code_raw":"\tpublic static Set<ConfiguredClassHierarchy> createEntityHierarchies(Index index, ServiceRegistry serviceRegistry) {\n\t\tClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : index.getKnownClasses() ) {\n\t\t\tif ( !isConfiguredClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = classLoaderService.classForName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = index.getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tAnnotationBindingContext context = new AnnotationBindingContext( index, serviceRegistry );\n\t\tSet<ConfiguredClassHierarchy> hierarchies = new HashSet<ConfiguredClassHierarchy>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();\n\t\tfor ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {\n\t\t\tif ( !processedList.contains( classInfoList ) ) {\n\t\t\t\thierarchies.add( ConfiguredClassHierarchy.create( classInfoList, context ) );\n\t\t\t\tprocessedList.add( classInfoList );\n\t\t\t}\n\t\t}\n\n\t\treturn hierarchies;\n\t}\n","new_comment_raw":"Pre-processes the annotated entities from the index and put them into a structure which can bound to the Hibernate metamodel.","old_comment_raw":"This methods pre-processes the annotated entities from the index and put them into a structure which can bound to the Hibernate metamodel.","label":1,"pre_label":0,"AST_level":13,"line_counts":50,"new_code_token_num":278},{"new_code_raw":"public String toEnumVarName(String value, String datatype) { String modified; if (value.length() == 0) { modified = \"EMPTY\"; } else { modified = value; modified = sanitizeKotlinSpecificNames(modified); } switch (getEnumPropertyNaming()) { case original: \/\/ NOTE: This is provided as a last-case allowance, but will still result in reserved words being escaped. modified = value; break; case camelCase: \/\/ NOTE: Removes hyphens and underscores modified = camelize(modified, true); break; case PascalCase: \/\/ NOTE: Removes hyphens and underscores String result = camelize(modified); modified = titleCase(result); break; case snake_case: \/\/ NOTE: Removes hyphens modified = underscore(modified); break; case UPPERCASE: modified = modified.toUpperCase(); break; } if (reservedWords.contains(modified)) { return escapeReservedWord(modified); } return modified; }","old_code_raw":"    public String toEnumVarName(String value, String datatype) {\n        String modified;\n        if (value.length() == 0) {\n            modified = \"EMPTY\";\n        } else {\n            modified = value;\n\n            for (Map.Entry<String, String> specialCharacters : specialCharReplacements.entrySet()) {\n                \/\/ Underscore is the only special character we'll allow\n                if (!specialCharacters.getKey().equals(\"_\")) {\n                    modified = modified.replaceAll(\"\\\\Q\" + specialCharacters.getKey() + \"\\\\E\", specialCharacters.getValue());\n                }\n            }\n\n            \/\/ Fallback, replace unknowns with underscore.\n            modified = modified.replaceAll(\"\\\\W+\", \"_\");\n            if (modified.matches(\"\\\\d.*\")) {\n                modified = \"_\" + modified;\n            }\n\n            \/\/ _, __, and ___ are reserved in Kotlin. Treat all names with only underscores consistently, regardless of count.\n            if (modified.matches(\"^_*$\")) {\n                modified = modified.replaceAll(\"\\\\Q_\\\\E\", \"Underscore\");\n            }\n        }\n\n        switch (getEnumPropertyNaming()) {\n            case original:\n                \/\/ NOTE: This is provided as a last-case allowance, but will still result in reserved words being escaped.\n                modified =  value;\n                break;\n            case camelCase:\n                \/\/ NOTE: Removes hyphens and underscores\n                modified =  camelize(modified, true);\n                break;\n            case PascalCase:\n                \/\/ NOTE: Removes hyphens and underscores\n                String result = camelize(modified);\n                modified =  result.substring(0, 1).toUpperCase() + result.substring(1);\n                break;\n            case snake_case:\n                \/\/ NOTE: Removes hyphens\n                modified = underscore(modified);\n                break;\n            case UPPERCASE:\n                modified = modified.toUpperCase();\n                break;\n        }\n\n        if (reservedWords.contains(modified)) {\n            \/\/ TODO: Allow enum escaping as an option (e.g. backticks vs append\/prepend underscore vs match model property escaping).\n            return String.format(\"`%s`\", modified);\n        }\n\n        return modified;\n    }\n","new_comment_raw":"Return the sanitized variable name for enum","old_comment_raw":"Return the sanitized variable name for enum","label":0,"pre_label":1,"AST_level":8,"line_counts":39,"new_code_token_num":175},{"new_code_raw":"public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations) { ActiveMQConnectionFactory factory = null; if (jmsFactoryType.equals(JMSFactoryType.CF)) { factory = new ActiveMQJMSConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) { factory = new ActiveMQQueueConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) { factory = new ActiveMQTopicConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) { factory = new ActiveMQXAConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) { factory = new ActiveMQXAQueueConnectionFactory(false, transportConfigurations); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) { factory = new ActiveMQXATopicConnectionFactory(false, transportConfigurations); } return factory; }","old_code_raw":"   public static HornetQConnectionFactory createConnectionFactoryWithoutHA(JMSFactoryType jmsFactoryType, final TransportConfiguration... transportConfigurations)\n   {\n      HornetQConnectionFactory factory = null;\n      if (jmsFactoryType.equals(JMSFactoryType.CF))\n      {\n         factory = new HornetQJMSConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF))\n      {\n         factory = new HornetQQueueConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF))\n      {\n         factory = new HornetQTopicConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.XA_CF))\n      {\n         factory = new HornetQXAConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF))\n      {\n         factory = new HornetQXAQueueConnectionFactory(false, transportConfigurations);\n      }\n      else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF))\n      {\n         factory = new HornetQXATopicConnectionFactory(false, transportConfigurations);\n      }\n\n      return factory;\n   }\n","new_comment_raw":"Create a ActiveMQConnectionFactory which creates session factories using a static list of transportConfigurations.","old_comment_raw":"Create a HornetQConnectionFactory which creates session factories using a static list of transportConfigurations.","label":1,"pre_label":0,"AST_level":13,"line_counts":32,"new_code_token_num":146},{"new_code_raw":"public static W3CWidget getWidget(String metadata, String shindig) throws Exception{ JSONObject gadget = null; JSONObject response = new JSONObject(metadata); JSONArray gadgets = response.getJSONArray(\"gadgets\"); if (gadgets.length()==0) return null; gadget = gadgets.getJSONObject(0); return new GadgetAdapter(gadget, shindig); }","old_code_raw":"\tpublic static Widget getWidget(String metadata, String shindig) throws Exception{\n\t\tJSONObject gadget = null;\n\t\tWidget widget = null;\n\t\tJSONObject response = new JSONObject(metadata);\n\t\tJSONArray gadgets = response.getJSONArray(\"gadgets\");\n\t\tif (gadgets.length() > 0){\n\t\t\tgadget = gadgets.getJSONObject(0);\n\t\t\tif (gadget.has(\"errors\")) throw new Exception(\"Invalid gadget - Shindig error\");\n\t\t\t\n\t\t\twidget = new Widget();\n\t\t\t\/\/ Defaults\n\t\t\tString title = \"Untitled Gadget\";\n\t\t\tint height = 200;\n\t\t\tint width = 320;\n\t\t\tString author = \"Unknown Author\";\n\t\t\tString description = \"Google Gadget\";\n\t\t\tString icon = DEFAULT_ICON;\n\n\t\t\tif (!gadget.has(\"url\")) throw new Exception(\"Invalid gadget - URL missing\");\n\t\t\tif (gadget.getString(\"url\") == null || gadget.getString(\"url\").equals(\"\")) throw new Exception(\"Invalid gadget - Invalid URL\");\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tURL url = new URL(gadget.getString(\"url\"));\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new Exception(\"Invalid gadget - invalid URL\");\n\t\t\t}\n\n\t\t\t\/\/ Use the URL as the GUID\n\t\t\twidget.setGuid(gadget.getString(\"url\"));\n\n\t\t\t\/\/ We should be able to use the \"iframeUrl\" property here, but\n\t\t\t\/\/ it isn't very reliable at generating a usable value, so we construct\n\t\t\t\/\/ a very basic URL instead\n\t\t\tStartFile sf = new StartFile();\n\t\t\tsf.setWidget(widget);\n\t\t\t\/\/ FIXME we need to use real locales in these URLs\n\t\t\tsf.setUrl(shindig+\"\/gadgets\/ifr?url=\"+gadget.getString(\"url\")+\"&amp;lang=en&amp;country=UK\");\n\t\t\t\n\t\t\tif (gadget.has(\"height\")) if (gadget.getInt(\"height\") != 0) height = gadget.getInt(\"height\");\n\t\t\tif (gadget.has(\"width\")) if (gadget.getInt(\"width\") != 0) width = gadget.getInt(\"width\");\n\n\t\t\tif (gadget.has(\"author\")){\n\t\t\t\tif (gadget.getString(\"author\")!=null){\n\t\t\t\t\tif (!(gadget.getString(\"author\").trim()).equals(\"\")){\n\t\t\t\t\t\tauthor = gadget.getString(\"author\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (gadget.has(\"title\")){\n\t\t\t\tif (gadget.getString(\"title\")!=null){\n\t\t\t\t\tif (!(gadget.getString(\"title\").trim()).equals(\"\")){\n\t\t\t\t\t\ttitle = gadget.getString(\"title\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ Override the title with directory title if present (this is intended for gallery use)\n\t\t\tif (gadget.has(\"directory_title\")){\n\t\t\t\tif (gadget.getString(\"directory_title\")!=null){\n\t\t\t\t\tif (!(gadget.getString(\"directory_title\").trim()).equals(\"\")){\n\t\t\t\t\t\ttitle = gadget.getString(\"directory_title\");\n\t\t\t\t\t}    \t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (gadget.has(\"description\")){\n\t\t\t\tif (gadget.getString(\"description\")!=null){\n\t\t\t\t\tif (!(gadget.getString(\"description\").trim()).equals(\"\")){\n\t\t\t\t\t\ttitle = gadget.getString(\"description\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (gadget.has(\"thumbnail\")){\n\t\t\t\tif (gadget.getString(\"thumbnail\")!=null){\n\t\t\t\t\tif (!(gadget.getString(\"thumbnail\").trim()).equals(\"\")){\n\t\t\t\t\t\ticon = gadget.getString(\"thumbnail\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twidget.setMaximize(false);\n\t\t\twidget.setHeight(height);\n\t\t\twidget.setWidth(width);\n\t\t\tName name = new Name();\n\t\t\tname.setWidget(widget);\n\t\t\tname.setName(title);\n\t\t\tDescription desc = new Description();\n\t\t\tdesc.setWidget(widget);\n\t\t\tdesc.setContent(description);\n\t\t\tWidgetIcon wicon = new WidgetIcon();\n\t\t\twicon.setSrc(icon);\n\t\t\twicon.setWidget(widget);\n\t\t\twidget.setWidgetAuthor(author);\n\t\t\t\n\t\t\twidget.save();\n\t\t\tsf.save();\n\t\t\tname.save();\n\t\t\twicon.save();\n\t\t\tdesc.save();\n\t\t\t\n\t\t}\n\t\treturn widget;\n\t}\n","new_comment_raw":"Marshall JSON metadata into a new W3CWidget instance","old_comment_raw":"Marshall JSON metadata into a new Widget instance","label":1,"pre_label":0,"AST_level":6,"line_counts":10,"new_code_token_num":64},{"new_code_raw":"public static boolean isSameScriptEngine(String name, String engineName, String engineLanguage) { if (name == null) { return false; } \/\/ In the configs we just use the engine name, in the UI we use the language name as well if (name.indexOf(LANG_ENGINE_SEP) > 0) { if (name.equals(engineLanguage + LANG_ENGINE_SEP + engineName)) { return true; } return false; } return name.equals(engineName); }","old_code_raw":"\tpublic static boolean isSameScriptEngine(String name, String engineName, String engineLanguage) {\n\t\tif (name == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t\/\/ In the configs we just use the engine name, in the UI we use the language name as well\n\t\tif (name.indexOf(LANG_ENGINE_SEP) > 0) {\n\t\t\tif (name.equals(engineLanguage + LANG_ENGINE_SEP + engineName)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (name.equals(engineName)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t\/\/ Nasty, but sometime the engine names are reported differently, eg 'Mozilla Rhino' vs 'Rhino'\n\t\tif (name.endsWith(engineName)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (engineName.endsWith(name)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"Tells whether or not the given  name matches the given  engineName and  engineLanguage.","old_comment_raw":"Tells whether or not the given name matches the given engineName and engineLanguage.","label":0,"pre_label":1,"AST_level":9,"line_counts":16,"new_code_token_num":86},{"new_code_raw":"public static int getPrecision(MajorType majorType) { if (majorType.hasPrecision()) { return majorType.getPrecision(); } return isScalarStringType(majorType) ? MAX_VARCHAR_LENGTH : UNDEFINED; }","old_code_raw":"  public static int getPrecision(MajorType majorType) {\n    MinorType type = majorType.getMinorType();\n\n    if (type == MinorType.VARBINARY || type == MinorType.VARCHAR) {\n      return 65536;\n    }\n\n    if (majorType.hasPrecision()) {\n      return majorType.getPrecision();\n    }\n\n    return 0;\n  }\n","new_comment_raw":"Get the precision of given type.","old_comment_raw":"Get the precision of given type.","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"private Object createConversationID() { if (getConversationID() != null) { return getConversationID(); } else { return UUID.randomUUID().toString(); } }","old_code_raw":"    private Object createConversationID() {\n        if (conversationID == null) {\n            return UUID.randomUUID().toString();\n        }\n        return conversationID;\n    }\n","new_comment_raw":"Creates a new conversation id","old_comment_raw":"Creates a new conversational id","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":34},{"new_code_raw":"public boolean addFile(File sourceFile) { String filename = sourceFile.getName(); File destFile = null; String codeExtension = null; boolean replacement = false; \/\/ if the file appears to be code related, drop it \/\/ into the code folder, instead of the data folder if (filename.toLowerCase().endsWith(\".class\") || filename.toLowerCase().endsWith(\".jar\") || filename.toLowerCase().endsWith(\".dll\") || filename.toLowerCase().endsWith(\".jnilib\") || filename.toLowerCase().endsWith(\".so\")) { \/\/if (!codeFolder.exists()) codeFolder.mkdirs(); prepareCodeFolder(); destFile = new File(codeFolder, filename); } else { for (String extension : mode.getExtensions()) { String lower = filename.toLowerCase(); if (lower.endsWith(\".\" + extension)) { destFile = new File(this.folder, filename); codeExtension = extension; } } if (codeExtension == null) { prepareDataFolder(); destFile = new File(dataFolder, filename); } } \/\/ check whether this file already exists if (destFile.exists()) { Object[] options = { Language.text(\"prompt.ok\"), Language.text(\"prompt.cancel\") }; String prompt = \"Replace the existing version of \" + filename + \"?\"; int result = JOptionPane.showOptionDialog(editor, prompt, \"Replace\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (result == JOptionPane.YES_OPTION) { replacement = true; } else { return false; } } \/\/ If it's a replacement, delete the old file first, \/\/ otherwise case changes will not be preserved. \/\/ http:\/\/dev.processing.org\/bugs\/show_bug.cgi?id=969 if (replacement) { boolean muchSuccess = destFile.delete(); if (!muchSuccess) { Base.showWarning(\"Error adding file\", \"Could not delete the existing '\" + filename + \"' file.\", null); return false; } } \/\/ make sure they aren't the same file if ((codeExtension == null) && sourceFile.equals(destFile)) { Base.showWarning(\"You can't fool me\", \"This file has already been copied to the\\n\" + \"location from which where you're trying to add it.\\n\" + \"I ain't not doin nuthin'.\", null); return false; } \/\/ Handles \"Add File\" when a .pde is used. For beta 1, this no longer runs \/\/ on a separate thread because it's totally unnecessary (a .pde file is \/\/ not going to be so large that it's ever required) and otherwise we have \/\/ to introduce a threading block here. \/\/ https:\/\/github.com\/processing\/processing\/issues\/3383 if (!sourceFile.equals(destFile)) { try { Base.copyFile(sourceFile, destFile); } catch (IOException e) { Base.showWarning(\"Error adding file\", \"Could not add '\" + filename + \"' to the sketch.\", e); return false; } } if (codeExtension != null) { SketchCode newCode = new SketchCode(destFile, codeExtension); if (replacement) { replaceCode(newCode); } else { insertCode(newCode); sortCode(); } setCurrentCode(filename); editor.header.repaint(); if (isUntitled()) { \/\/ TODO probably not necessary? problematic? \/\/ Mark the new code as modified so that the sketch is saved current.setModified(true); } } else { if (isUntitled()) { \/\/ TODO probably not necessary? problematic? \/\/ If a file has been added, mark the main code as modified so \/\/ that the sketch is properly saved. code[0].setModified(true); } } return true; }","old_code_raw":"  public boolean addFile(File sourceFile) {\n    String filename = sourceFile.getName();\n    File destFile = null;\n    String codeExtension = null;\n    boolean replacement = false;\n\n    \/\/ if the file appears to be code related, drop it\n    \/\/ into the code folder, instead of the data folder\n    if (filename.toLowerCase().endsWith(\".class\") ||\n        filename.toLowerCase().endsWith(\".jar\") ||\n        filename.toLowerCase().endsWith(\".dll\") ||\n        filename.toLowerCase().endsWith(\".jnilib\") ||\n        filename.toLowerCase().endsWith(\".so\")) {\n\n      \/\/if (!codeFolder.exists()) codeFolder.mkdirs();\n      prepareCodeFolder();\n      destFile = new File(codeFolder, filename);\n\n    } else {\n      for (String extension : mode.getExtensions()) {\n        String lower = filename.toLowerCase();\n        if (lower.endsWith(\".\" + extension)) {\n          destFile = new File(this.folder, filename);\n          codeExtension = extension;\n        }\n      }\n      if (codeExtension == null) {\n        prepareDataFolder();\n        destFile = new File(dataFolder, filename);\n      }\n    }\n\n    \/\/ check whether this file already exists\n    if (destFile.exists()) {\n      Object[] options = { Language.text(\"prompt.ok\"), Language.text(\"prompt.cancel\") };\n      String prompt = \"Replace the existing version of \" + filename + \"?\";\n      int result = JOptionPane.showOptionDialog(editor,\n                                                prompt,\n                                                \"Replace\",\n                                                JOptionPane.YES_NO_OPTION,\n                                                JOptionPane.QUESTION_MESSAGE,\n                                                null,\n                                                options,\n                                                options[0]);\n      if (result == JOptionPane.YES_OPTION) {\n        replacement = true;\n      } else {\n        return false;\n      }\n    }\n\n    \/\/ If it's a replacement, delete the old file first,\n    \/\/ otherwise case changes will not be preserved.\n    \/\/ http:\/\/dev.processing.org\/bugs\/show_bug.cgi?id=969\n    if (replacement) {\n      boolean muchSuccess = destFile.delete();\n      if (!muchSuccess) {\n        Base.showWarning(\"Error adding file\",\n                         \"Could not delete the existing '\" +\n                         filename + \"' file.\", null);\n        return false;\n      }\n    }\n\n    \/\/ make sure they aren't the same file\n    if ((codeExtension == null) && sourceFile.equals(destFile)) {\n      Base.showWarning(\"You can't fool me\",\n                       \"This file has already been copied to the\\n\" +\n                       \"location from which where you're trying to add it.\\n\" +\n                       \"I ain't not doin nuthin'.\", null);\n      return false;\n    }\n\n    \/\/ in case the user is \"adding\" the code in an attempt\n    \/\/ to update the sketch's tabs\n\tif (!sourceFile.equals(destFile)) {\n\t\tfinal File sourceFile2 = sourceFile;\n\t\tfinal File destFile2 = destFile;\n\t    \/\/ Create a new event dispatch thread- to display ProgressBar\n\t    \/\/ while Saving As\n    javax.swing.SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        new ProgressFrame(sourceFile2, destFile2, editor);\n      }\n    });\n\t}\n\n    if (codeExtension != null) {\n      SketchCode newCode = new SketchCode(destFile, codeExtension);\n\n      if (replacement) {\n        replaceCode(newCode);\n\n      } else {\n        insertCode(newCode);\n        sortCode();\n      }\n      setCurrentCode(filename);\n      editor.header.repaint();\n      if (isUntitled()) {  \/\/ TODO probably not necessary? problematic?\n        \/\/ Mark the new code as modified so that the sketch is saved\n        current.setModified(true);\n      }\n\n    } else {\n      if (isUntitled()) {  \/\/ TODO probably not necessary? problematic?\n        \/\/ If a file has been added, mark the main code as modified so\n        \/\/ that the sketch is properly saved.\n        code[0].setModified(true);\n      }\n    }\n    return true;\n  }\n","new_comment_raw":"Add a file to the sketch.","old_comment_raw":"Add a file to the sketch.","label":0,"pre_label":1,"AST_level":13,"line_counts":116,"new_code_token_num":777},{"new_code_raw":"public Node parseXML(String text, Document doc) { return null; }","old_code_raw":"        public DocumentFragment parseXML(String text, Document doc) {\n            return null;\n        }\n","new_comment_raw":"Parses the given XML string into a DocumentFragment of the given document or a new document if 'doc' is null.","old_comment_raw":"Parses the given XML string into a DocumentFragment of the given document.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":15},{"new_code_raw":"public ParameterList getQueryStringParams() { try { ParameterList result = new ParameterList(); String queryString = new URL(url).getQuery(); result.addQuerystring(queryString); result.addAll(querystringParams); return result; } catch (MalformedURLException mue) { throw new OAuthException(\"Malformed URL\", mue); } }","old_code_raw":"  public Map<String, String> getQueryStringParams()\n  {\n    try\n    {\n      Map<String, String> params = new HashMap<String, String>();\n      String queryString = new URL(url).getQuery();\n      params.putAll(MapUtils.queryStringToMap(queryString));\n      params.putAll(this.querystringParams);\n      return params;\n    }\n    catch (MalformedURLException mue)\n    {\n      throw new OAuthException(\"Malformed URL\", mue);\n    }\n  }\n","new_comment_raw":"Get a  ParameterList with the query string parameters.","old_comment_raw":"Get a Map of the query string parameters.","label":1,"pre_label":0,"AST_level":7,"line_counts":17,"new_code_token_num":62},{"new_code_raw":"private Bitmap getWidgetPreview(AppWidgetProviderInfo info) { final PackageManager packageManager = mPackageManager; String packageName = info.provider.getPackageName(); Drawable drawable = null; if (info.previewImage != 0) { drawable = packageManager.getDrawable(packageName, info.previewImage, null); if (drawable == null) { Log.w(TAG, \"Can't load icon drawable 0x\" + Integer.toHexString(info.icon) + \" for provider: \" + info.provider); } } \/\/ If we don't have a preview image, create a default one if (drawable == null) { Resources resources = mLauncher.getResources(); \/\/ Create a new bitmap to hold the widget preview int width = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minWidth)) * sScaleFactor); int height = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minHeight)) * sScaleFactor); final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); final Drawable background = resources.getDrawable(R.drawable.default_widget_preview); renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f); \/\/ Draw the icon flush left try { Drawable icon = null; if (info.icon > 0) { icon = packageManager.getDrawable(packageName, info.icon, null); } if (icon == null) { icon = resources.getDrawable(R.drawable.ic_launcher_application); } final int iconSize = mMinWidgetPreviewDim \/ 2; final int offset = iconSize \/ 4; renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f); } catch (Resources.NotFoundException e) { \/\/ if we can't find the icon, then just don't draw it } return bitmap; } else { \/\/ Scale down the preview if necessary final float imageWidth = drawable.getIntrinsicWidth(); final float imageHeight = drawable.getIntrinsicHeight(); final float aspect = (float) imageWidth \/ imageHeight; final int scaledWidth = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageWidth)) * sScaleFactor); final int scaledHeight = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageHeight)) * sScaleFactor); int width; int height; if (aspect >= 1.0f) { width = scaledWidth; height = (int) (((float) scaledWidth \/ imageWidth) * imageHeight); } else { height = scaledHeight; width = (int) (((float) scaledHeight \/ imageHeight) * imageWidth); } final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f); return bitmap; } }","old_code_raw":"    private FastBitmapDrawable getWidgetPreview(AppWidgetProviderInfo info) {\n        final PackageManager packageManager = mPackageManager;\n        String packageName = info.provider.getPackageName();\n        Drawable drawable = null;\n        FastBitmapDrawable newDrawable = null;\n        if (info.previewImage != 0) {\n            drawable = packageManager.getDrawable(packageName, info.previewImage, null);\n            if (drawable == null) {\n                Log.w(TAG, \"Can't load icon drawable 0x\" + Integer.toHexString(info.icon)\n                        + \" for provider: \" + info.provider);\n            }\n        }\n\n        \/\/ If we don't have a preview image, create a default one\n        final int minDim = mWorkspaceWidgetLayout.estimateCellWidth(1);\n        final int maxDim = mWorkspaceWidgetLayout.estimateCellWidth(3);\n        if (drawable == null) {\n            Resources resources = mLauncher.getResources();\n\n            \/\/ Create a new bitmap to hold the widget preview\n            int width = (int) (Math.max(minDim, Math.min(maxDim, info.minWidth)) * sScaleFactor);\n            int height = (int) (Math.max(minDim, Math.min(maxDim, info.minHeight)) * sScaleFactor);\n            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n            final Drawable background = resources.getDrawable(R.drawable.default_widget_preview);\n            renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f);\n\n            \/\/ Draw the icon flush left\n            try {\n                Drawable icon = null;\n                if (info.icon > 0) {\n                    icon = packageManager.getDrawable(packageName, info.icon, null);\n                }\n                if (icon == null) {\n                    icon = resources.getDrawable(R.drawable.ic_launcher_application);\n                }\n\n                final int iconSize = minDim \/ 2;\n                final int offset = iconSize \/ 4;\n                renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f);\n            } catch (Resources.NotFoundException e) {\n                \/\/ if we can't find the icon, then just don't draw it\n            }\n\n            newDrawable = new FastBitmapDrawable(bitmap);\n        } else {\n            \/\/ Scale down the preview if necessary\n            final float imageWidth = drawable.getIntrinsicWidth();\n            final float imageHeight = drawable.getIntrinsicHeight();\n            final float aspect = (float) imageWidth \/ imageHeight;\n            final int scaledWidth =\n                (int) (Math.max(minDim, Math.min(maxDim, imageWidth)) * sScaleFactor);\n            final int scaledHeight =\n                (int) (Math.max(minDim, Math.min(maxDim, imageHeight)) * sScaleFactor);\n            int width;\n            int height;\n            if (aspect >= 1.0f) {\n                width = scaledWidth;\n                height = (int) (((float) scaledWidth \/ imageWidth) * imageHeight);\n            } else {\n                height = scaledHeight;\n                width = (int) (((float) scaledHeight \/ imageHeight) * imageWidth);\n            }\n\n            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n            renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f);\n\n            newDrawable = new FastBitmapDrawable(bitmap);\n        }\n        newDrawable.setBounds(0, 0, newDrawable.getIntrinsicWidth(),\n                newDrawable.getIntrinsicHeight());\n        return newDrawable;\n    }\n","new_comment_raw":"This method will extract the preview image specified by the widget developer (if it exists), otherwise, it will try to generate a default image preview with the widget's package icon.","old_comment_raw":"This method will extract the preview image specified by the widget developer (if it exists), otherwise, it will try to generate a default image preview with the widget's package icon.","label":0,"pre_label":1,"AST_level":13,"line_counts":69,"new_code_token_num":515},{"new_code_raw":"public final int getBeginColumn() { return this.bufcolumn[this.tokenBegin]; }","old_code_raw":"    public final int getBeginColumn() {\n        return bufcolumn[tokenBegin];\n    }\n","new_comment_raw":"Get the column begin","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"private static String stringify(Object obj) { if (obj instanceof DERString) { return escapeHtml(((DERString) obj).getString()); } \/\/ TODO: why not DERInteger as number? else if (obj instanceof DERInteger || obj instanceof byte[]) { return convertToHexString(obj); } else if (obj instanceof ASN1TaggedObject) { ASN1TaggedObject tagObj = (ASN1TaggedObject) obj; \/\/ Note: \"[\", _not_ '[' ... return \"[\" + tagObj.getTagNo() + \"] \" + stringify(tagObj.getObject()); } else if (obj instanceof ASN1Sequence) { ASN1Sequence aObj = (ASN1Sequence) obj; StringBuilder tmp = new StringBuilder(\"[\"); for (int i = 0, len = aObj.size(); i < len; i++) { tmp.append(stringify(aObj.getObjectAt(i))); if (i != len - 1) { tmp.append(\", \"); } } return tmp.append(\"]\").toString(); } else { String hex = null; try { Method method = obj.getClass().getMethod(\"getOctets\", (Class[]) null); hex = convertToHexString(method.invoke(obj, (Object[]) null)); } catch (Exception e) { \/\/ Ignore } if (hex == null && obj != null) { hex = escapeHtml(obj.toString()); } return hex; } }","old_code_raw":"\tprivate static String stringify(Object obj)\n\t{\n\t\tif (obj instanceof DERString)\n\t\t{\n\t\t\treturn ((DERString) obj).getString();\n\t\t}\n\t\telse if (obj instanceof DERInteger || obj instanceof byte[])\n\t\t{\n\t\t\treturn convertToHexString(obj);\n\t\t}\n\t\telse if (obj instanceof ASN1TaggedObject)\n\t\t{\n\t\t\tASN1TaggedObject tagObj = (ASN1TaggedObject) obj;\n\t\t\t\/\/ Note: \"[\", _not_ '[' ...\n\t\t\treturn \"[\" + tagObj.getTagNo() + \"] \" + stringify(tagObj.getObject());\n\t\t}\n\t\telse if (obj instanceof ASN1Sequence)\n\t\t{\n\t\t\tASN1Sequence aObj = (ASN1Sequence) obj;\n\t\t\tStringBuilder tmp = new StringBuilder(\"[\");\n\t\t\tfor (int i = 0, len = aObj.size(); i < len; i++)\n\t\t\t{\n\t\t\t\ttmp.append(stringify(aObj.getObjectAt(i)));\n\t\t\t\tif (i != len - 1)\n\t\t\t\t{\n\t\t\t\t\ttmp.append(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tmp.append(\"]\").toString();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tString hex = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tMethod method = obj.getClass().getMethod(\"getOctets\", (Class[]) null);\n\t\t\t\thex = convertToHexString(method.invoke(obj, (Object[]) null));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t\/\/ Ignore\n\t\t\t}\n\t\t\tif (hex == null && obj != null)\n\t\t\t{\n\t\t\t\thex = obj.toString();\n\t\t\t}\n\t\t\treturn hex;\n\t\t}\n\t}\n","new_comment_raw":"Gets a HTML escaped string representation of the given object.","old_comment_raw":"Gets a string representation of the given object.","label":1,"pre_label":0,"AST_level":14,"line_counts":52,"new_code_token_num":285},{"new_code_raw":"public WireType getWireType() { return queue.wireType(); }","old_code_raw":"\tpublic WireType getWireType() {\n\t\treturn wireType;\n\t}\n","new_comment_raw":"Returns the queue wire type","old_comment_raw":"Returns","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"public Job<?, ?> getOwner() { return job; }","old_code_raw":"    public AbstractProject<?, ?> getOwner() {\n        return project;\n    }\n","new_comment_raw":"Returns the job.","old_comment_raw":"Returns the project.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"public Integer[] getVersions() { return vers; }","old_code_raw":"    public Integer[] getVersions() {\n        return versions.keySet().toArray(new Integer[versions.keySet().size()]);\n    }\n","new_comment_raw":"Get an array for all available versions (sorted)","old_comment_raw":"Get an iterator for all available versions","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":12},{"new_code_raw":"private IDKey getIdentityKey(Object value) { return new IDKey(value); }","old_code_raw":"    private String getIdentityKey(Object value) {\n        return \"\" + System.identityHashCode(value);\n    }\n","new_comment_raw":"Get an IDKey that represents the unique identity of the object.","old_comment_raw":"Get a String representation of the identity hashCode for a given","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public static Log forSlf4jLogger(org.slf4j.Logger logger) { return new Log((Logger) logger); }","old_code_raw":"    public static Log forSlf4jLogger(org.slf4j.Logger logger) {\n        return named(logger.getName());\n    }\n","new_comment_raw":"Returns a  Log instance with the same name as the given slf4j  org.slf4j.Logger instance.","old_comment_raw":"Returns a Log instance with the same name as the given slf4j org.slf4j.Logger instance.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public static MemberID parse(String memberID, boolean isClassMember) { return parse(memberID, isClassMember, null); }","old_code_raw":"    public static MemberID parse(String signature, boolean isClassMember) {\n        return parse(signature, isClassMember, null);\n    }\n","new_comment_raw":"Parse a member ID, with or without classname, with or without descriptor.","old_comment_raw":"Parse a signature, with or without classname, with or without descriptor.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":23},{"new_code_raw":"public static MailboxMessage<HBaseId> messageMetaFromResult(Configuration conf, Result result) { HBaseMailboxMessage message = null; Flags flags = new Flags(); List<Property> propList = new ArrayList<Property>(); KeyValue[] keys = result.raw(); String mediaType = null, subType = null; Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null; Date internalDate = null; int i = 0; \/** it is VERY IMPORTANT that the byte arrays are kept ascending *\/ if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) { bodyOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) { contentOctets = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) { internalDate = new Date(Bytes.toLong(keys[i].getValue())); i++; } \/\/ may be null so it will probably skip if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) { textualLineCount = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) { modSeq = Bytes.toLong(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) { mediaType = Bytes.toString(keys[i].getValue()); i++; } if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) { subType = Bytes.toString(keys[i].getValue()); i++; } \/\/ only TEXT_LINE_COUNT can be missing if message is binary if (i < 5) { throw new RuntimeException(\"HBase message column names not sorted.\"); } while (i < keys.length) { \/\/get message properties if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) { propList.add(getProperty(keys[i].getValue())); } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) { \/\/ get system flags, stored as qualifiers if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) { flags.add(systemFlagFromBytes(keys[i].getQualifier())); } } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) { \/\/ get user flags, stored as value qualifier flags.add(userFlagFromBytes(keys[i].getQualifier())); } i++; } HBaseId uuid = HBaseIdFromRowKey(result.getRow()); uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), 16); PropertyBuilder props = new PropertyBuilder(propList); props.setMediaType(mediaType); props.setSubType(subType); message = new HBaseMailboxMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props); message.setUid(uid); message.setModSeq(modSeq); message.setTextualLineCount(textualLineCount); return message; }","old_code_raw":"    public static Message<HBaseId> messageMetaFromResult(Configuration conf, Result result) {\n        HBaseMessage message = null;\n        Flags flags = new Flags();\n        List<Property> propList = new ArrayList<Property>();\n        KeyValue[] keys = result.raw();\n        String mediaType = null, subType = null;\n        Long modSeq = null, uid, bodyOctets = null, contentOctets = null, textualLineCount = null;\n        Date internalDate = null;\n\n        int i = 0;\n        \/** it is VERY IMPORTANT that the byte arrays are kept ascending *\/\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_BODY_OCTETS)) {\n            bodyOctets = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_CONTENT_OCTETS)) {\n            contentOctets = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_INTERNALDATE)) {\n            internalDate = new Date(Bytes.toLong(keys[i].getValue()));\n            i++;\n        }\n        \/\/ may be null so it will probably skip\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_TEXT_LINE_COUNT)) {\n            textualLineCount = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MODSEQ)) {\n            modSeq = Bytes.toLong(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_MEDIA_TYPE)) {\n            mediaType = Bytes.toString(keys[i].getValue());\n            i++;\n        }\n        if (Bytes.equals(keys[i].getQualifier(), MESSAGE_SUB_TYPE)) {\n            subType = Bytes.toString(keys[i].getValue());\n            i++;\n        }\n        \/\/ only TEXT_LINE_COUNT can be missing if message is binary\n        if (i < 5) {\n            throw new RuntimeException(\"HBase message column names not sorted.\");\n        }\n        while (i < keys.length) {\n            \/\/get message properties\n            if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_PROP_B)) {\n                propList.add(getProperty(keys[i].getValue()));\n            } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_SFLAGS_B)) {\n                \/\/ get system flags, stored as qualifiers\n                if (Bytes.equals(MARKER_PRESENT, keys[i].getValue())) {\n                    flags.add(systemFlagFromBytes(keys[i].getQualifier()));\n                }\n            } else if (Bytes.startsWith(keys[i].getQualifier(), PREFIX_UFLAGS_B)) {\n                \/\/ get user flags, stored as value qualifier\n                flags.add(userFlagFromBytes(keys[i].getQualifier()));\n            }\n            i++;\n        }\n        HBaseId uuid = HBaseIdFromRowKey(result.getRow());\n        uid = Long.MAX_VALUE - Bytes.toLong(result.getRow(), 16);\n        PropertyBuilder props = new PropertyBuilder(propList);\n        props.setMediaType(mediaType);\n        props.setSubType(subType);\n        message = new HBaseMessage(conf, uuid, internalDate, flags, contentOctets, (int) (contentOctets - bodyOctets), props);\n        message.setUid(uid);\n        message.setModSeq(modSeq);\n        message.setTextualLineCount(textualLineCount);\n        return message;\n    }\n","new_comment_raw":"Creates a HBaseMailboxMessage from a Result object.","old_comment_raw":"Creates a HBaseMessage from a Result object.","label":1,"pre_label":0,"AST_level":15,"line_counts":73,"new_code_token_num":627},{"new_code_raw":"public static SchemaBuilder builder() { return SchemaBuilder.int64() .name(SCHEMA_NAME) .version(1); }","old_code_raw":"    public static SchemaBuilder builder() {\n        return SchemaBuilder.float64()\n                            .name(SCHEMA_NAME)\n                            .version(1);\n    }\n","new_comment_raw":"Returns a  SchemaBuilder for a  MicroDuration.","old_comment_raw":"Returns a SchemaBuilder for a MicroDuration.","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":22},{"new_code_raw":"private int invoke_calculateBufferSize(int tdsVersion, int packetSize) { Class[] classes = new Class[]{int.class, int.class}; Object[] objects = new Object[]{new Integer(tdsVersion), new Integer(packetSize)}; return ((Integer) invokeStaticMethod(Support.class, \"calculateNamedPipeBufferSize\", classes, objects)).intValue(); }","old_code_raw":"    private int invoke_calculateBufferSize(int tdsVersion, int packetSize) {\n        Class[] classes = new Class[]{int.class, int.class};\n        Object[] objects = new Object[]{new Integer(tdsVersion), new Integer(packetSize)};\n\n        return ((Integer) invokeStaticMethod(SharedNamedPipe.class,\n                \"calculateBufferSize\", classes, objects)).intValue();\n    }\n","new_comment_raw":"Helper method to invoke  Support#calculateNamedPipeBufferSize(int, int) using reflection.","old_comment_raw":"Helper method to invoke SharedNamedPipe#calculateBufferSize(int, int) using reflection.","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":73},{"new_code_raw":"private void getAndStoreFullRegistry() throws Throwable { long currentUpdateGeneration = fetchRegistryGeneration.get(); logger.info(\"Getting all instance registry info from the eureka server\"); Applications apps = null; if (shouldUseExperimentalTransport()) { EurekaHttpResponse<Applications> httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == null ? eurekaHttpClient.getApplications() : eurekaHttpClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress()); if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) { apps = httpResponse.getEntity(); } logger.info(\"The response status is {}\", httpResponse.getStatusCode()); } else { ClientResponse response = makeRemoteCall(Action.Refresh); try { if (response.getStatus() == Status.OK.getStatusCode()) { apps = response.getEntity(Applications.class); } logger.info(\"The response status is {}\", response.getStatus()); } finally { closeResponse(response); } } if (apps == null) { logger.error(\"The application is null for some reason. Not storing this information\"); } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) { localRegionApps.set(this.filterAndShuffle(apps)); logger.debug(\"Got full registry with apps hashcode {}\", apps.getAppsHashCode()); } else { logger.warn(\"Not updating applications as another thread is updating it already\"); } }","old_code_raw":"    private ClientResponse getAndStoreFullRegistry() throws Throwable {\n        long currentUpdateGeneration = fetchRegistryGeneration.get();\n        ClientResponse response = makeRemoteCall(Action.Refresh);\n        logger.info(\"Getting all instance registry info from the eureka server\");\n\n        Applications apps = null;\n        if (response.getStatus() == Status.OK.getStatusCode()) {\n            apps = response.getEntity(Applications.class);\n        }\n\n        if (apps == null) {\n            logger.error(\"The application is null for some reason. Not storing this information\");\n        } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {\n            localRegionApps.set(this.filterAndShuffle(apps));\n            logger.debug(\"Got full registry with apps hashcode {}\", apps.getAppsHashCode());\n        } else {\n            logger.warn(\"Not updating applications as another thread is updating it already\");\n        }\n        logger.info(\"The response status is {}\", response.getStatus());\n        return response;\n    }\n","new_comment_raw":"Gets the full registry information from the eureka server and stores it locally.","old_comment_raw":"Gets the full registry information from the eureka server and stores it locally.","label":0,"pre_label":1,"AST_level":12,"line_counts":36,"new_code_token_num":257},{"new_code_raw":"private boolean shouldRegister(InstanceInfo myInfo) { if (!clientConfig.shouldRegisterWithEureka()) { return false; } else if ((myInfo != null) && (myInfo.getDataCenterInfo() .equals(DataCenterInfo.Name.Amazon))) { return true; } return true; }","old_code_raw":"    private boolean shouldRegister(InstanceInfo myInfo) {\n        if (!clientConfig.shouldRegisterWithEureka()) {\n            return false;\n        }\n\n        return true;\n    }\n","new_comment_raw":"Checks to see if the eureka client registration is enabled.","old_comment_raw":"Checks to see if the eureka client registration is enabled.","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"public boolean get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public boolean get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"Extracts the attribute map from the specified  WithAttributes and returns the value of this attribute from the map.","old_comment_raw":"Analogous to #get(WithAttributes) except returning a primitive boolean.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public Builder setHostName(String hostName) { if (hostName == null || hostName.isEmpty()) { logger.warn(\"Passed in hostname is blank, not setting it\"); return this; } String existingHostName = result.hostName; result.hostName = hostName; if ((existingHostName != null) && !(hostName.equals(existingHostName))) { refreshStatusPageUrl().refreshHealthCheckUrl() .refreshVIPAddress().refreshSecureVIPAddress(); } return this; }","old_code_raw":"        public Builder setHostName(String hostName) {\n            String existingHostName = result.hostName;\n            result.hostName = hostName;\n            if ((existingHostName != null)\n                    && !(hostName.equals(existingHostName))) {\n                refreshStatusPageUrl().refreshHealthCheckUrl()\n                        .refreshVIPAddress().refreshSecureVIPAddress();\n            }\n            return this;\n        }\n","new_comment_raw":"Sets the fully qualified hostname of this running instance.This is mostly used in constructing the  java.net.URL for communicating with the instance.","old_comment_raw":"Sets the fully qualified hostname of this running instance.This is mostly used in constructing the java.net.URL for communicating with the instance.","label":0,"pre_label":1,"AST_level":7,"line_counts":16,"new_code_token_num":86},{"new_code_raw":"protected Object convertSmallInt(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, SHORT_FALSE, (r) -> { if (data instanceof Short) { r.deliver(data); } else if (data instanceof Number) { Number value = (Number) data; r.deliver(new Short(value.shortValue())); } else if (data instanceof Boolean) { r.deliver(NumberConversions.getShort((Boolean)data)); } else if (data instanceof String) { r.deliver(Short.parseShort((String)data)); } }); }","old_code_raw":"    protected Object convertSmallInt(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return SHORT_FALSE;\n        }\n        if (data instanceof Short) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Short(value.shortValue());\n        }\n        if (data instanceof Boolean) {\n            return NumberConversions.getShort((Boolean) data);\n        }\n        if (data instanceof String) {\n            return Short.parseShort((String) data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"Converts a value object for an expected JDBC type of  Types#SMALLINT.","old_comment_raw":"Converts a value object for an expected JDBC type of Types#SMALLINT.","label":0,"pre_label":1,"AST_level":15,"line_counts":18,"new_code_token_num":121},{"new_code_raw":"public Float getLeftValue() { return leftValue; }","old_code_raw":"        public float getLeftValue() {\n            return leftValue == null ? 0 : leftValue.floatValue();\n        }\n","new_comment_raw":"Gets the 'left' attributes value using current units.","old_comment_raw":"Gets the 'left' CSS-attributes value in specified units.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"private synchronized static Supplier<Annotator> getOrCreate(AnnotatorFactory factory) { return () -> { Annotator rtn = customAnnotators.get(factory.signature()); if (rtn == null) { \/\/ Create the annotator rtn = factory.create(); \/\/ Register the annotator customAnnotators.put(factory.signature(), factory.create()); \/\/ Clean up memory if needed while (customAnnotators.size() > 10) { customAnnotators.keySet().iterator().remove(); } } return rtn; }; }","old_code_raw":"  private synchronized static Supplier<Annotator> getOrCreate(String name, Properties props, Supplier<Annotator> annotator) {\n    StanfordCoreNLP.AnnotatorSignature key = new StanfordCoreNLP.AnnotatorSignature(name, PropertiesUtils.getSignature(name, props));\n    customAnnotators.register(name, props, StanfordCoreNLP.GLOBAL_ANNOTATOR_CACHE.computeIfAbsent(key, (sig) -> Lazy.cache(annotator)));\n    return () -> customAnnotators.get(name);\n  }\n","new_comment_raw":"Either get a custom annotator which was recently defined, or create it if it has never been defined.","old_comment_raw":"Either get a custom annotator which was recently defined, or create it if it has never been defined.","label":0,"pre_label":1,"AST_level":11,"line_counts":17,"new_code_token_num":98},{"new_code_raw":"public synchronized VisualItem getItem(String itemClass, Entity entity, boolean create) { ItemEntry entry = (ItemEntry)m_entryMap.get(itemClass); if ( entry != null ) { VisualItem item = (VisualItem)entry.itemMap.get(entity); if ( !create ) { return item; } else if ( item == null ) { item = m_ifactory.getItem(itemClass); item.init(this, itemClass, entity); addItem(entry, entity, item); } if ( item instanceof NodeItem ) ((NodeItem)item).removeAllNeighbors(); item.setDirty(0); item.setVisible(true); return item; } else { throw new IllegalArgumentException(\"The input string must be a\" + \" recognized item class!\"); } } \/\/","old_code_raw":"\tpublic synchronized GraphItem getItem(String itemClass, Entity entity, boolean create) {\n\t\tItemEntry entry = (ItemEntry)m_entryMap.get(itemClass);\n\t\tif ( entry != null ) {\n\t\t\tGraphItem item = (GraphItem)entry.itemMap.get(entity);\n\t\t\tif ( !create ) {\n\t\t\t\treturn item;\n\t\t\t} else if ( item == null ) {\n\t\t\t\titem = m_ifactory.getItem(itemClass);\n\t\t\t\titem.init(this, itemClass, entity);\n\t\t\t\taddItem(entry, entity, item);\n\t\t\t}\n            if ( item instanceof NodeItem )\n                ((NodeItem)item).removeAllNeighbors();\n            item.setDirty(0);\n            item.setVisible(true);\n\t\t\treturn item;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"The input string must be a\"\n\t\t\t\t\t\t+ \" recognized item class!\");\n\t\t}\t\t\n\t} \/\/\n","new_comment_raw":"Requests a VisualItem of the specified item class corresponding to a given Entity, optionally creating the VisualItem if it doesn't already exist.","old_comment_raw":"Requests a GraphItem of the specified item class corresponding to a given Entity, optionally creating the GraphItem if it doesn't already exist.","label":1,"pre_label":0,"AST_level":11,"line_counts":23,"new_code_token_num":148},{"new_code_raw":"public Iterator<PersistentClass> getClassMappings() { return classes.values().iterator(); }","old_code_raw":"\tpublic Iterator getClassMappings() {\n\t\treturn classes.values().iterator();\n\t}\n","new_comment_raw":"Iterate the entity mappings","old_comment_raw":"Iterate the entity mappings","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public EurekaClient getEurekaClient() { return eurekaClient; }","old_code_raw":"    public EurekaClient getEurekaClient() {\n        return discoveryClient;\n    }\n","new_comment_raw":"Get the  EurekaClient implementation.","old_comment_raw":"Get the EurekaClient implementation.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public LookupService createLookupService() { return createLookupService(defaultEndpointUrl); }","old_code_raw":"    public LookupService createLookupService() {\n        return createLookupService(defaultServerUrl);\n    }\n","new_comment_raw":"C6reate and return a new lookup service with the default endpoint URL.","old_comment_raw":"C6reate and return a new lookup service with the default server URL.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":13},{"new_code_raw":"public static void to2D(double[] weights, List<Index<CRFLabel>> labelIndices, int[] map, double[][] newWeights) { int index = 0; for (int i = 0; i < map.length; i++) { int labelSize = labelIndices.get(map[i]).size(); System.arraycopy(weights, index, newWeights[i], 0, labelSize); index += labelSize; } }","old_code_raw":"  public static double[][] to2D(double[] weights, List<Index<CRFLabel>> labelIndices, int[] map) {\n    double[][] newWeights = new double[map.length][];\n    int index = 0;\n    for (int i = 0; i < map.length; i++) {\n      int labelSize = labelIndices.get(map[i]).size();\n      newWeights[i] = new double[labelSize];\n      try {\n        System.arraycopy(weights, index, newWeights[i], 0, labelSize);\n      } catch (Exception ex) {\n        log.info(\"weights: \" + Arrays.toString(weights));\n        log.info(\"newWeights[\"+i+\"]: \" + Arrays.toString(newWeights[i]));\n        throw new RuntimeException(ex);\n      }\n      index += labelSize;\n    }\n    return newWeights;\n  }\n","new_comment_raw":"Takes a double array of weights and populates a 2D array where: the first element is the mapped index of the clique size (e.g., node-0, edge-1) matching featuresIndex i the second element is the number of output classes for that clique size","old_comment_raw":"Takes a double array of weights and creates a 2D array where: the first element is the mapped index of the clique size (e.g., node-0, edge-1) matching featuresIndex i the second element is the number of output classes for that clique size","label":1,"pre_label":0,"AST_level":10,"line_counts":9,"new_code_token_num":84},{"new_code_raw":"public SessionFactory buildSessionFactory() throws HibernateException { log.debug( \"Preparing to build session factory with filters : \" + filterDefinitions ); secondPassCompile(); if ( ! metadataSourceQueue.isEmpty() ) { log.warn( \"mapping metadata cache was not completely processed\" ); } enableLegacyHibernateValidator(); enableBeanValidation(); enableHibernateSearch(); validate(); Environment.verifyProperties( properties ); Properties copy = new Properties(); copy.putAll( properties ); ConfigurationHelper.resolvePlaceHolders( copy ); Settings settings = buildSettings( copy ); return new SessionFactoryImpl( this, mapping, settings, getInitializedEventListeners(), sessionFactoryObserver ); }","old_code_raw":"\tpublic SessionFactory buildSessionFactory(ServicesRegistry serviceRegistry) throws HibernateException {\n\t\tlog.debug( \"Preparing to build session factory with filters : \" + filterDefinitions );\n\n\t\tsecondPassCompile();\n\t\tif ( ! metadataSourceQueue.isEmpty() ) {\n\t\t\tlog.warn( \"mapping metadata cache was not completely processed\" );\n\t\t}\n\n\t\tenableLegacyHibernateValidator();\n\t\tenableBeanValidation();\n\t\tenableHibernateSearch();\n\n\t\tvalidate();\n\t\tEnvironment.verifyProperties( properties );\n\t\tProperties copy = new Properties();\n\t\tcopy.putAll( properties );\n\t\tConfigurationHelper.resolvePlaceHolders( copy );\n\t\tSettings settings = buildSettings( copy, serviceRegistry.getService( JdbcServices.class ) );\n\n\t\treturn new SessionFactoryImpl(\n\t\t\t\tthis,\n\t\t\t\tmapping,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\tgetInitializedEventListeners(),\n\t\t\t\tsessionFactoryObserver\n\t\t\t);\n\t}\n","new_comment_raw":"Create a  SessionFactory using the properties and mappings in this configuration.","old_comment_raw":"Create a SessionFactory using the properties and mappings in this configuration.","label":0,"pre_label":1,"AST_level":7,"line_counts":28,"new_code_token_num":119},{"new_code_raw":"public String getName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getName(locale, iID, nameKey); if (name != null) { return name; } return offsetFormatter().print(instant, this); }","old_code_raw":"    public String getName(long millis, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(millis);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(millis, this);\n    }\n","new_comment_raw":"Gets the long name of this datetime zone suitable for display using the specified locale.","old_comment_raw":"Gets the long name of this datetime zone suitable for display using the specified locale.","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":76},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 55: break; case 2: { return getNext(\"<\", yytext()); } case 56: break; case 3: { return getNext(); } case 57: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 58: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 59: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 60: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 61: break; case 8: { return handleQuotes(yytext(), false); } case 62: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 63: break; case 10: { return getNext(\">\", yytext()); } case 64: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 65: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 66: break; case 13: { return handleEllipsis(yytext()); } case 67: break; case 14: { return normalizeFractions(yytext()); } case 68: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 69: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 70: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 71: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 72: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 73: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 74: break; case 21: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 75: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 76: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 77: break; case 24: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 78: break; case 25: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 79: break; case 26: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 80: break; case 27: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 81: break; case 28: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 82: break; case 29: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 83: break; case 30: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 84: break; case 31: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 85: break; case 32: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 86: break; case 33: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 87: break; case 34: \/\/ lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 88: break; case 35: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 89: break; case 36: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 90: break; case 37: { return getNormalizedAmpNext(); } case 91: break; case 38: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 92: break; case 39: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 93: break; case 40: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 94: break; case 41: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 16; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 17; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 95: break; case 42: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 96: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 97: break; case 44: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } return getNext(); } case 98: break; case 45: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 99: break; case 46: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 100: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } String s; if (yylength() == 2) { \/\/ \"I.\", etc. yypushback(1); \/\/ return a period next time; s = yytext(); \/\/ return the word without the final period } else if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); \/\/ return the word without the final period } else { s = yytext(); \/\/ return the word WITH the final period yypushback(1); \/\/ (redpulication:) also return a period for next time } return getNext(s, yytext()); } case 101: break; case 48: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 102: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 103: break; case 50: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 104: break; case 51: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 105: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 106: break; case 53: \/\/ lookahead expression with fixed lookahead length yypushback(4); { return getNext(); } case 107: break; case 54: { String txt = yytext(); if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 108: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 55: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 56: break;\n        case 3: \n          { return getNext();\n          }\n        case 57: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 58: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 59: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 60: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 61: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 62: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 63: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 64: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 65: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 66: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 67: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 68: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 69: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 70: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 71: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 72: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 73: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 74: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 75: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 76: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 77: break;\n        case 24: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 78: break;\n        case 25: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 79: break;\n        case 26: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 80: break;\n        case 27: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 81: break;\n        case 28: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 82: break;\n        case 29: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 83: break;\n        case 30: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 84: break;\n        case 31: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 85: break;\n        case 32: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 86: break;\n        case 33: \n          { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 87: break;\n        case 34: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 88: break;\n        case 35: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n          }\n        case 89: break;\n        case 36: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 90: break;\n        case 37: \n          { return getNormalizedAmpNext();\n          }\n        case 91: break;\n        case 38: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 92: break;\n        case 39: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 93: break;\n        case 40: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 94: break;\n        case 41: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 16;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 17;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 95: break;\n        case 42: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 96: break;\n        case 43: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n\t\t\t  return getNext();\n          }\n        case 97: break;\n        case 44: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 98: break;\n        case 45: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 99: break;\n        case 46: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          String s;\n\t\t\t  if (yylength() == 2) { \/\/ \"I.\", etc.\n\t\t\t    yypushback(1); \/\/ return a period next time;\n\t\t\t    s = yytext(); \/\/ return the word without the final period\n                          } else if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext(); \/\/ return the word without the final period\n                          } else {\n                            s = yytext(); \/\/ return the word WITH the final period\n                            yypushback(1); \/\/ (redpulication:) also return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 100: break;\n        case 47: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 101: break;\n        case 48: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 102: break;\n        case 49: \n          { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 103: break;\n        case 50: \n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 104: break;\n        case 51: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 105: break;\n        case 52: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 106: break;\n        case 53: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 107: break;\n        case 54: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 108: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","old_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","label":0,"pre_label":1,"AST_level":17,"line_counts":739,"new_code_token_num":4512},{"new_code_raw":"public Task<EncodedImage> get(List<CacheKey> keys, final AtomicBoolean isCancelled) { Preconditions.checkArgument(!keys.isEmpty()); for (CacheKey key : keys) { final EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { return foundPinnedImage(key, pinnedImage); } } Task<EncodedImage> masterTask = getAsync(keys.get(0), isCancelled); if (keys.size() == 1) { return masterTask; } for (final CacheKey key : keys.subList(1, keys.size())) { masterTask = masterTask.continueWithTask( new Continuation<EncodedImage, Task<EncodedImage>>() { @Override public Task<EncodedImage> then(Task<EncodedImage> previousTask) throws Exception { \/\/ If we've got a hit, stop. If this is cancelled, stop. Otherwise, keep going. if (previousTask.isCancelled() || previousTask.getResult() != null) { return previousTask; } return getAsync(key, isCancelled); } }, mReadExecutor); } return masterTask; }","old_code_raw":"  public Task<EncodedImage> get(final CacheKey key, final AtomicBoolean isCancelled) {\n    Preconditions.checkNotNull(key);\n    Preconditions.checkNotNull(isCancelled);\n\n    final EncodedImage pinnedImage = mStagingArea.get(key);\n    if (pinnedImage != null) {\n      FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n      mImageCacheStatsTracker.onStagingAreaHit();\n      return Task.forResult(pinnedImage);\n    }\n\n    try {\n      return Task.call(\n          new Callable<EncodedImage>() {\n            @Override\n            public EncodedImage call()\n                throws Exception {\n              if (isCancelled.get()) {\n                throw new CancellationException();\n              }\n              EncodedImage result = mStagingArea.get(key);\n              if (result != null) {\n                FLog.v(TAG, \"Found image for %s in staging area\", key.toString());\n                mImageCacheStatsTracker.onStagingAreaHit();\n              } else {\n                FLog.v(TAG, \"Did not find image for %s in staging area\", key.toString());\n                mImageCacheStatsTracker.onStagingAreaMiss();\n\n                try {\n                  final PooledByteBuffer buffer = readFromDiskCache(key);\n                  CloseableReference<PooledByteBuffer> ref = CloseableReference.of(buffer);\n                  try {\n                    result = new EncodedImage(ref);\n                  } finally {\n                    CloseableReference.closeSafely(ref);\n                  }\n                } catch (Exception exception) {\n                  return null;\n                }\n              }\n\n              if (Thread.interrupted()) {\n                FLog.v(TAG, \"Host thread was interrupted, decreasing reference count\");\n                if (result != null) {\n                  result.close();\n                }\n                throw new InterruptedException();\n              } else {\n                return result;\n              }\n            }\n          },\n          mReadExecutor);\n    } catch (Exception exception) {\n      \/\/ Log failure\n      \/\/ TODO: 3697790\n      FLog.w(\n          TAG,\n          exception,\n          \"Failed to schedule disk-cache read for %s\",\n          key.toString());\n      return Task.forError(exception);\n    }\n  }\n","new_comment_raw":"Performs lookup of a series of disk cache keys in a single thread.","old_comment_raw":"Performs key-value look up in disk cache.","label":1,"pre_label":0,"AST_level":13,"line_counts":31,"new_code_token_num":190},{"new_code_raw":"public Constructor[] getConstructors() throws SecurityException { \/\/ BEGIN android-note \/\/ trying to get closer to the RI which returns a raw constructor array. \/\/ copied from newer version of harmony \/\/ END android-note checkPublicMemberAccess(); return getDeclaredConstructors(this, true); }","old_code_raw":"    public Constructor<T>[] getConstructors() throws SecurityException {\n        checkPublicMemberAccess();\n        return getDeclaredConstructors(this, true);\n    }\n","new_comment_raw":"Returns an array containing  Constructor objects for all public constructors for the class represented by this  Class.","old_comment_raw":"Returns an array containing Constructor objects describing all constructors which are visible from the current execution context.","label":1,"pre_label":0,"AST_level":5,"line_counts":10,"new_code_token_num":58},{"new_code_raw":"public boolean checkAlreadyExist(AccountDatabase.AccountName s) { \/\/ Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); \/\/ Checking if string equals to is exist or not query.equalTo(\"name\", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); \/\/ Here checking if count of that values is greater than zero return result1.size() > 0; }","old_code_raw":"    public boolean checkAlreadyExist(AccountDatabase.AccountName s) {\n\n        \/\/ Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        \/\/ Checking if string equals to is exist or not\n        query.equalTo(\"name\", s.toString());\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        \/\/ Here checking if count of that values is greater than zero\n        return (result1.size() > 0) ? true : false;\n    }\n","new_comment_raw":"This function check if the selected account is already existed.","old_comment_raw":"This function check if the selected account is already existed.","label":0,"pre_label":1,"AST_level":7,"line_counts":13,"new_code_token_num":79},{"new_code_raw":"private ASN1Object toASN1Object( X509Certificate cert) throws CertificateEncodingException { try { return new ASN1InputStream(cert.getEncoded()).readObject(); } catch (Exception e) { throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString()); } }","old_code_raw":"    private DERObject toASN1Object(\n        X509Certificate cert)\n        throws CertificateEncodingException\n    {\n        try\n        {\n            return new ASN1InputStream(cert.getEncoded()).readObject();\n        }\n        catch (Exception e)\n        {\n            throw new CertificateEncodingException(\"Exception while encoding certificate: \" + e.toString());\n        }\n    }\n","new_comment_raw":"Return a ASN1Object containing the encoded certificate.","old_comment_raw":"Return a DERObject containing the encoded certificate.","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":52},{"new_code_raw":"private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) { if (expr instanceof RexInputRef) { final int index = ((RexInputRef) expr).getIndex(); Expression x = inputGetter.field(list, index); return list.append( \"v\", nullAs.handle( list.append(\"v\", x))); } if (expr instanceof RexLocalRef) { return translate( program.getExprList().get(((RexLocalRef) expr).getIndex()), nullAs); } if (expr instanceof RexLiteral) { return translateLiteral( expr, typeFactory.createTypeWithNullability( expr.getType(), isNullable(expr) && nullAs != RexImpTable.NullAs.NOT_POSSIBLE), typeFactory, nullAs); } if (expr instanceof RexCall) { final RexCall call = (RexCall) expr; final SqlOperator operator = call.getOperator(); RexImpTable.CallImplementor implementor = RexImpTable.INSTANCE.get(operator); if (implementor != null) { return implementor.implement(this, call, nullAs); } } switch (expr.getKind()) { default: throw new RuntimeException( \"cannot translate expression \" + expr); } }","old_code_raw":"    private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) {\n        if (expr instanceof RexInputRef) {\n            final int index = ((RexInputRef) expr).getIndex();\n            Expression x = inputGetter.field(list, index);\n            return nullAs.handle(list.append(\"v\", x));\n        }\n        if (expr instanceof RexLocalRef) {\n            return translate(\n                program.getExprList().get(((RexLocalRef) expr).getIndex()),\n                nullAs);\n        }\n        if (expr instanceof RexLiteral) {\n            return translateLiteral(\n                expr,\n                typeFactory.createTypeWithNullability(\n                    expr.getType(),\n                    isNullable(expr)\n                    && nullAs != RexImpTable.NullAs.NOT_POSSIBLE),\n                typeFactory,\n                nullAs);\n        }\n        if (expr instanceof RexCall) {\n            final RexCall call = (RexCall) expr;\n            final SqlOperator operator = call.getOperator();\n            RexImpTable.CallImplementor implementor =\n                RexImpTable.INSTANCE.get(operator);\n            if (implementor != null) {\n                return implementor.implement(this, call, nullAs);\n            }\n        }\n        switch (expr.getKind()) {\n        default:\n            throw new RuntimeException(\n                \"cannot translate expression \" + expr);\n        }\n    }\n","new_comment_raw":"Translates an expression that is not in the cache.","old_comment_raw":"Translates an expression that is not in the cache.","label":0,"pre_label":1,"AST_level":10,"line_counts":40,"new_code_token_num":214},{"new_code_raw":"public static String jenkinsJobName(BuildConfig bc) { String namespace = bc.getMetadata().getNamespace(); String name = bc.getMetadata().getName(); return jenkinsJobName(namespace, name); }","old_code_raw":"  public static String jenkinsJobName(BuildConfig bc, String defaultNamespace) {\n    String namespace = bc.getMetadata().getNamespace();\n    String name = bc.getMetadata().getName();\n    return jenkinsJobName(namespace, name, defaultNamespace);\n  }\n","new_comment_raw":"Finds the Jenkins job name for the given  BuildConfig.","old_comment_raw":"Finds the Jenkins job for the given BuildConfig and defaultNamespace","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":38},{"new_code_raw":"public TregexMatcher matcher(Tree t, HeadFinder headFinder) { return matcher(t, t, null, ArrayMap.newArrayMap(), new VariableStrings(), headFinder); }","old_code_raw":"  public TregexMatcher matcher(Tree t, HeadFinder headFinder) {\n    return matcher(t, t, null, ArrayMap.<String, Tree>newArrayMap(), new VariableStrings(), headFinder);\n  }\n","new_comment_raw":"Get a  TregexMatcher for this pattern on this tree.","old_comment_raw":"Get a TregexMatcher for this pattern on this tree.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"private ConnectionJDBC getConnection() throws SQLException { return (ConnectionJDBC) statement.getConnection(); }","old_code_raw":"    private ConnectionJDBC2 getConnection() throws SQLException {\n        return (ConnectionJDBC2) statement.getConnection();\n    }\n","new_comment_raw":"Returns the  ConnectionJDBC object referenced by the  #statement instance variable.","old_comment_raw":"Returns the ConnectionJDBC2 object referenced by the #statement instance variable.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"static String substituteParamMarkers(String sql, ParamInfo[] list) { \/\/ A parameter can have at most 8 characters: \" @P\" plus at most 4 \/\/ digits plus \" \". We substract the \"?\" placeholder, that's at most \/\/ 7 extra characters needed for each parameter. char[] buf = new char[sql.length() + list.length * 7]; int bufferPtr = 0; \/\/ Output buffer pointer int start = 0; \/\/ Input string pointer for (int i = 0; i < list.length; i++) { int pos = list[i].markerPos; if (pos > 0) { sql.getChars(start, pos, buf, bufferPtr); bufferPtr += (pos - start); start = pos + 1; \/\/ Append \" @P\" buf[bufferPtr++] = ' '; buf[bufferPtr++] = '@'; buf[bufferPtr++] = 'P'; \/\/ Append parameter number String number = String.valueOf(i); number.getChars(0, number.length(), buf, bufferPtr); bufferPtr += number.length(); \/\/ Append \" \" buf[bufferPtr++] = ' '; } } if (start < sql.length()) { sql.getChars(start, sql.length(), buf, bufferPtr); bufferPtr += (sql.length() - start); } return new String(buf, 0, bufferPtr); }","old_code_raw":"    static String substituteParamMarkers(String sql, ParamInfo[] list){\n        StringBuffer buf = new StringBuffer(sql.length() + list.length * 6);\n        int start = 0;\n\n        for (int i = 0; i < list.length; i++) {\n            int pos = list[i].markerPos;\n\n            if (pos > 0) {\n                buf.append(sql.substring(start, list[i].markerPos));\n                start = pos + 1;\n                buf.append(\" @P\").append(i).append(' ');\n            }\n        }\n\n        if (start < sql.length()) {\n            buf.append(sql.substring(start));\n        }\n\n        return buf.toString();\n    }\n","new_comment_raw":"Update the SQL string and replace the ? markers with parameter names eg @P0, @P1 etc.","old_comment_raw":"Update the SQL string and replace the &#63; markers with parameter names eg @P0, @P1 etc.","label":1,"pre_label":0,"AST_level":11,"line_counts":40,"new_code_token_num":285},{"new_code_raw":"public List<List<CoreLabel>> toStatement(List<CoreLabel> question) { TokenSequenceMatcher matcher; if ((matcher = triggerWhatIsThere.matcher(question)).matches()) { \/\/ must come before triggerWhatIs return postProcess(question, processWhatIsThere(matcher)); } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) { \/\/ must come before triggerWhatIs return postProcess(question, processWhNNIs(matcher)); } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) { \/\/ must come before triggerWhatHave return postProcess(question, processWhNNHaveIs(matcher)); } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) { \/\/ must come before triggerWhatHave return postProcess(question, processWhNNHaveNN(matcher)); } else if ((matcher = triggerWhatIs.matcher(question)).matches()) { return postProcess(question, processWhatIs(matcher)); } else if ((matcher = triggerWhatHave.matcher(question)).matches()) { return postProcess(question, processWhatHave(matcher)); } else if ((matcher = triggerWhereDo.matcher(question)).matches()) { return postProcess(question, processWhereDo(matcher, question)); } else if ((matcher = triggerWhereIs.matcher(question)).matches()) { return postProcess(question, processWhereIs(matcher)); } else if ((matcher = triggerWhoIs.matcher(question)).matches()) { return postProcess(question, processWhoIs(matcher)); } else if ((matcher = triggerWhoDid.matcher(question)).matches()) { return postProcess(question, processWhoDid(matcher)); } else if ((matcher = triggerWhatDo.matcher(question)).matches()) { return postProcess(question, processWhatDo(matcher)); } else if ((matcher = triggerWhenDo.matcher(question)).matches()) { return postProcess(question, processWhenDo(matcher)); } else if ((matcher = triggerHow.matcher(question)).matches()) { return postProcess(question, processHow(matcher)); } else { return Collections.emptyList(); } }","old_code_raw":"  public List<List<CoreLabel>> toStatement(List<CoreLabel> question) {\n    TokenSequenceMatcher matcher;\n    if ((matcher = triggerWhatIsThere.matcher(question)).matches()) {  \/\/ must come before triggerWhatIs\n      return postProcess(question, processWhatIsThere(matcher));\n    } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) {  \/\/ must come before triggerWhatIs\n      return postProcess(question, processWhNNIs(matcher));\n    } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) {  \/\/ must come before triggerWhatHave\n      return postProcess(question, processWhNNHave(matcher));\n    } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) {  \/\/ must come before triggerWhatHave\n      return postProcess(question, processWhNNHaveNN(matcher));\n    } else if ((matcher = triggerWhatIs.matcher(question)).matches()) {\n      return postProcess(question, processWhatIs(matcher));\n    } else if ((matcher = triggerWhatHave.matcher(question)).matches()) {\n      return postProcess(question, processWhatHave(matcher));\n    } else if ((matcher = triggerWhereDo.matcher(question)).matches()) {\n      return postProcess(question, processWhereDo(matcher));\n    } else if ((matcher = triggerWhereIs.matcher(question)).matches()) {\n      return postProcess(question, processWhereIs(matcher));\n    } else if ((matcher = triggerWhoIs.matcher(question)).matches()) {\n      return postProcess(question, processWhoIs(matcher));\n    } else if ((matcher = triggerWhoDid.matcher(question)).matches()) {\n      return postProcess(question, processWhoDid(matcher));\n    } else if ((matcher = triggerWhatDo.matcher(question)).matches()) {\n      return postProcess(question, processWhatDo(matcher));\n    } else if ((matcher = triggerWhenDo.matcher(question)).matches()) {\n      return postProcess(question, processWhenDo(matcher));\n    } else {\n      return Collections.emptyList();\n    }\n  }\n","new_comment_raw":"Convert a question to a statement, if possible.","old_comment_raw":"Convert a question to a statement, if possible.","label":0,"pre_label":1,"AST_level":20,"line_counts":33,"new_code_token_num":413},{"new_code_raw":"public static TokenSequencePattern compile(SequencePattern.PatternExpr nodeSequencePattern) { return new TokenSequencePattern(null, nodeSequencePattern); }","old_code_raw":"  public static TokenSequencePattern compile(Env env, String... strings)\n  {\n    try {\n      List<SequencePattern.PatternExpr> patterns = new ArrayList<SequencePattern.PatternExpr>();\n      for (String string:strings) {\n        \/\/ TODO: Check token sequence parser?\n        SequencePattern.PatternExpr pattern = env.parser.parseSequence(env, string);\n        patterns.add(pattern);\n      }\n      SequencePattern.PatternExpr nodeSequencePattern = new SequencePattern.SequencePatternExpr(patterns);\n      return new TokenSequencePattern(StringUtils.join(strings), nodeSequencePattern);\n    } catch (Exception ex) {\n      throw new RuntimeException(ex);\n    }\n  }\n","new_comment_raw":"Compiles a PatternExpr into a TokenSequencePattern.","old_comment_raw":"Compiles a sequence of regular expression a TokenSequencePattern using the specified environment.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"private boolean isBreakOnOpcode(Integer opcode) { boolean shouldBreak = false; if (config.isBreakOnPingPong()) { \/\/ break on every message type shouldBreak = true; } else { \/\/ break only on non-ping\/pong boolean isPing = opcode.equals(WebSocketMessage.OPCODE_PING); boolean isPong = opcode.equals(WebSocketMessage.OPCODE_PONG); if (!isPing && !isPong) { shouldBreak = true; } } return shouldBreak; }","old_code_raw":"\tprivate boolean isBreakOnOpcode(Integer opcode) {\n\t\tif (config.isBreakOnPingPong()) {\n\t\t\t\/\/ break on every message type\n\t\t\treturn true;\n\t\t} else {\n\t\t\t\/\/ break only on non-ping\/pong\n\t\t\tboolean isPing = opcode.equals(WebSocketMessage.OPCODE_PING);\n\t\t\tboolean isPong = opcode.equals(WebSocketMessage.OPCODE_PONG);\n\t\t\t\n\t\t\tif (!isPing && !isPong) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"Check out if breakpoint should be applied on given  WebSocketMessageDTO#opcode.","old_comment_raw":"Check out if breakpoint should be applied on given WebSocketMessageDTO#opcode.","label":0,"pre_label":1,"AST_level":9,"line_counts":17,"new_code_token_num":80},{"new_code_raw":"public static RelNode createDistinctRel(RelNode rel) { return LogicalAggregate.create(rel, ImmutableBitSet.range(rel.getRowType().getFieldCount()), null, ImmutableList.of()); }","old_code_raw":"  public static RelNode createDistinctRel(RelNode rel) {\n    return LogicalAggregate.create(rel,\n        ImmutableBitSet.range(rel.getRowType().getFieldCount()), null,\n        ImmutableList.<AggregateCall>of());\n  }\n","new_comment_raw":"Creates a LogicalAggregate that removes all duplicates from the result of an underlying relational expression.","old_comment_raw":"Creates a LogicalAggregate that removes all duplicates from the result of an underlying relational expression.","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"public static EString substring(Expr<String> left, int right) { return factory.createString(Ops.SUBSTR1ARG, left, factory.createConstant(right)); }","old_code_raw":"    public static EString substring(Expr<String> left, int right) {\n        return createString(Ops.SUBSTR1ARG, left, createConstant(right));\n    }\n","new_comment_raw":"Expr : left.substring(right)","old_comment_raw":"Expr : left.substring(right)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public boolean isEmpty() { return this.tags.isEmpty(); }","old_code_raw":"        public boolean isEmpty() {\n            return tags.isEmpty();\n        }\n","new_comment_raw":"Checks if the tag stack is empty","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"public static EDateTime<Date> currentTimestamp() { return currentTimestamp(Date.class); }","old_code_raw":"    public static EDateTime<Date> currentTimestamp() {\n        return ODateTime.create(Date.class, Ops.DateTimeOps.CURRENT_TIMESTAMP);\n    }\n","new_comment_raw":"Get an expression representing the current time instant as a EDateTime instance","old_comment_raw":"Get an expression representing the current time instant as a EDateTime instance","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"private static long toEpochNanos(LocalDate date) { long epochDay = date.toEpochDay(); return epochDay * Conversions.NANOSECONDS_PER_DAY; }","old_code_raw":"    public static long toEpochNanos(Object value, TemporalAdjuster adjuster) {\n        LocalDateTime dateTime = Conversions.toLocalDateTime(value);\n        if ( adjuster != null) {\n            dateTime = dateTime.with(adjuster);\n        }\n        return Conversions.toEpochNanos(dateTime);\n    }\n","new_comment_raw":"Get the number of nanoseconds past epoch of the given  LocalDate.","old_comment_raw":"Get the number of nanoseconds past epoch of the given java.time.LocalDateTime, java.time.LocalDate, java.time.LocalTime, java.util.Date, java.sql.Date, java.sql.Time, or java.sql.Timestamp.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":23},{"new_code_raw":"public String toHexString(final int start, final int length) { Preconditions.checkArgument(start >= 0); final StringBuilder sb = new StringBuilder(\"buffer byte dump\"); final int end = Math.min(length, this.length - start); for (int i = 0; i < end; i++) { if (i % LOG_BYTES_PER_ROW == 0) { sb.append(String.format(\"%n [%05d-%05d]\", i + start, Math.min(i + LOG_BYTES_PER_ROW - 1, end - 1) + start)); } byte b = _getByte(i + start); sb.append(\" 0x\").append(HEX_CHAR[b >> 4]).append(HEX_CHAR[b & 0x0F]); } if (length > end) { sb.append(String.format(\"%n [%05d-%05d] <ioob>\", start + end, start + length)); } return sb.append(System.lineSeparator()).toString(); }","old_code_raw":"  public String toHexString(final int start, final int length) {\n    final int roundedStart = (start \/ LOG_BYTES_PER_ROW) * LOG_BYTES_PER_ROW;\n\n    final StringBuilder sb = new StringBuilder(\"buffer byte dump\\n\");\n    int index = roundedStart;\n    for (int nLogged = 0; nLogged < length; nLogged += LOG_BYTES_PER_ROW) {\n      sb.append(String.format(\" [%05d-%05d]\", index, index + LOG_BYTES_PER_ROW - 1));\n      for (int i = 0; i < LOG_BYTES_PER_ROW; ++i) {\n        try {\n          final byte b = getByte(index++);\n          sb.append(String.format(\" 0x%02x\", b));\n        } catch (IndexOutOfBoundsException ioob) {\n          sb.append(\" <ioob>\");\n        }\n      }\n      sb.append('\\n');\n    }\n    return sb.toString();\n  }\n","new_comment_raw":"Return the buffer's byte contents in the form of a hex dump.","old_comment_raw":"Return the buffer's byte contents in the form of a hex dump.","label":0,"pre_label":1,"AST_level":14,"line_counts":17,"new_code_token_num":195},{"new_code_raw":"public int yylex() throws java.io.IOException { int yy_input; int yy_action; \/\/ cached fields: int yy_currentPos_l; int yy_startRead_l; int yy_markedPos_l; int yy_endRead_l = yy_endRead; char[] yy_buffer_l = yy_buffer; char[] yycmap_l = yycmap; int[] yytrans_l = yytrans; int[] yy_rowMap_l = yy_rowMap; byte[] yy_attr_l = YY_ATTRIBUTE; while (true) { yy_markedPos_l = yy_markedPos; yy_action = -1; yy_startRead_l = yy_currentPos_l = yy_currentPos = yy_startRead = yy_markedPos_l; yy_state = yy_lexical_state; yy_forAction: { while (true) { if (yy_currentPos_l < yy_endRead_l) { yy_input = yy_buffer_l[yy_currentPos_l++]; } else if (yy_atEOF) { yy_input = YYEOF; break yy_forAction; } else { \/\/ store back cached positions yy_currentPos = yy_currentPos_l; yy_markedPos = yy_markedPos_l; boolean eof = yy_refill(); \/\/ get translated positions and possibly new buffer yy_currentPos_l = yy_currentPos; yy_markedPos_l = yy_markedPos; yy_buffer_l = yy_buffer; yy_endRead_l = yy_endRead; if (eof) { yy_input = YYEOF; break yy_forAction; } else { yy_input = yy_buffer_l[yy_currentPos_l++]; } } int yy_next = yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]]; if (yy_next == -1) { break yy_forAction; } yy_state = yy_next; int yy_attributes = yy_attr_l[yy_state]; if ((yy_attributes & 1) == 1) { yy_action = yy_state; yy_markedPos_l = yy_currentPos_l; if ((yy_attributes & 8) == 8) { break yy_forAction; } } } } \/\/ store back cached position yy_markedPos = yy_markedPos_l; switch (yy_action) { case 4: case 9: case 10: case 13: { return ACCEPT; } case 19: break; case 5: case 6: case 7: { return IGNORE; } case 20: break; case 2: { return IGNORE; } case 21: break; case 15: { yybegin(SENTENCE); \/* System.out.println(\"Beginning of sentence\"); *\/ return ACCEPT; } case 22: break; case 3: { System.out.print(yytext()); } case 23: break; case 16: case 17: { yybegin(YYINITIAL); \/* System.out.println(\"End of sentence\"); *\/ return ACCEPT; } case 24: break; default: if (yy_input == YYEOF && yy_startRead == yy_currentPos) { yy_atEOF = true; return YYEOF; } else { yy_ScanError(YY_NO_MATCH); } } } }","old_code_raw":"  public int yylex() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 5: \n          { yybegin(YYINITIAL);\n                     \/* System.out.println(\"End of sentence\"); *\/\n                            return ACCEPT;\n          }\n        case 6: break;\n        case 3: \n          { return ACCEPT;\n          }\n        case 7: break;\n        case 4: \n          { yybegin(SENTENCE);\n\t\t\t  \/* System.out.println(\"Beginning of sentence\"); *\/\n\t\t\t  return ACCEPT;\n          }\n        case 8: break;\n        case 2: \n          { System.out.print(yytext());\n          }\n        case 9: break;\n        case 1: \n          { return IGNORE;\n          }\n        case 10: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            return YYEOF;\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","old_comment_raw":"Resumes scanning until the next regular expression is matched, the end of input is encountered or an I\/O-Error occurs.","label":0,"pre_label":1,"AST_level":17,"line_counts":131,"new_code_token_num":441},{"new_code_raw":"protected TokenResponse executeRefreshToken() throws IOException { if (refreshToken == null) { return null; } return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl), refreshToken).setClientAuthentication(clientAuthentication) .setRequestInitializer(requestInitializer).execute(); }","old_code_raw":"  protected TokenResponse executeRefreshToken() throws IOException {\n    return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl),\n        refreshToken).setClientAuthentication(clientAuthentication)\n        .setRequestInitializer(requestInitializer).execute();\n  }\n","new_comment_raw":"Executes a request for new credentials from the token server.","old_comment_raw":"Executes the request for a new refresh token from the authorization endpoint from #refreshToken().","label":1,"pre_label":0,"AST_level":6,"line_counts":10,"new_code_token_num":47},{"new_code_raw":"public boolean equals(Object obj) { return this == obj || (obj instanceof Pair) && Util.equal(this.left, ((Pair) obj).left) && Util.equal(this.right, ((Pair) obj).right); }","old_code_raw":"    public boolean equals(Object obj)\n    {\n        return (obj instanceof Pair)\n            && Util.equal(this.left, ((Pair) obj).left)\n            && Util.equal(this.right, ((Pair) obj).right);\n    }\n","new_comment_raw":"Creates a Pair of appropriate type.","old_comment_raw":"Creates a Pair of appropriate type.","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":52},{"new_code_raw":"public List<Pet> findPetsByTags(List<String> tags) throws ApiException { ApiResponse<List<Pet>> localVarResp = findPetsByTagsWithHttpInfo(tags); return localVarResp.getData(); }","old_code_raw":"    public List<Pet> findPetsByTags(List<String> tags) throws ApiException {\n        ApiResponse<List<Pet>> resp = findPetsByTagsWithHttpInfo(tags);\n        return resp.getData();\n    }\n","new_comment_raw":"Finds Pets by tags","old_comment_raw":"Finds Pets by tags","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"public Q addFetchGroup(String fetchGroupName) { fetchGroups.add(fetchGroupName); return queryMixin.getSelf(); }","old_code_raw":"    public Q addFetchGroup(String fetchGroupName) {\n        fetchGroups.add(fetchGroupName);\n        return (Q) this;\n    }\n","new_comment_raw":"Add the fetch group to the set of active fetch groups.","old_comment_raw":"Add the fetch group to the set of active fetch groups.","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":21},{"new_code_raw":"public boolean hasParams() { return !cookieParams.isEmpty() || !urlParams.isEmpty() || !formParams.isEmpty() || !headerParams.isEmpty(); }","old_code_raw":"\tpublic boolean hasParams() {\n\t\treturn !cookieParams.isEmpty() || !urlParams.isEmpty() || !formParams.isEmpty();\n\t}\n","new_comment_raw":"Tells whether or not this site has any parameters (cookies, query, form parameters, or response header fields).","old_comment_raw":"Tells whether or not this site has any parameters (cookies, query or form parameters).","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":35},{"new_code_raw":"public static DateTimeFormatter dateTimeNoMillis() { return Constants.dtx; }","old_code_raw":"    public static DateTimeFormatter dateTimeNoMillis() {\n        if (dtx == null) {\n            dtx = new DateTimeFormatterBuilder()\n                .append(date())\n                .append(tTimeNoMillis())\n                .toFormatter();\n        }\n        return dtx;\n    }\n","new_comment_raw":"Returns a formatter that combines a full date and time without millis, separated by a 'T' (yyyy-MM-dd'T'HH:mm:ssZZ).","old_comment_raw":"Returns a formatter that combines a full date and time without millis, separated by a 'T' (yyyy-MM-dd'T'HH:mm:ssZZ).","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public Future<HttpResponse> executeAsync(Executor executor) { FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() { public HttpResponse call() throws Exception { return execute(); } }); executor.execute(future); return future; }","old_code_raw":"  public Future<HttpResponse> executeAsync(Executor exec) {\n    final SettableFuture<HttpResponse> future = SettableFuture.create();\n    exec.execute(new Runnable() {\n      public void run() {\n        try {\n          future.set(execute());\n        } catch (IOException ex) {\n          future.setException(ex);\n        }\n      }\n    });\n    return future;\n  }\n","new_comment_raw":"Executes this request asynchronously in a single separate thread using the supplied executor.","old_comment_raw":"Executes this request asynchronously using #executeAsync(Executor) in a single separate thread using the supplied Executor.","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":49},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class) @Paged public PagingDelegate<Change> listChanges( final @Optional @Default(\"true\") boolean includeDeleted, final @Optional @Default(\"true\") boolean includeSubscribed, final @Optional @Default(\"100\") int maxResults, final @Optional Long startChangeId, final PagingConfiguration pagingConfiguration ) throws IOException { return new TokenBasedPagingDelegate<Change>() { @Override protected List<Change> doGetPage() throws IOException { ChangeList response = client.changes().list() .setIncludeDeleted(includeDeleted) .setIncludeSubscribed(includeSubscribed) .setMaxResults(maxResults) .setPageToken(this.getPageToken()) .setStartChangeId(startChangeId) .execute(); this.setPageToken(response.getNextPageToken()); return Change.valueOf(response.getItems(), Change.class); } }; }","old_code_raw":"\t@Processor\n    @OAuthProtected\n\t@OAuthInvalidateAccessTokenOn(exception=OAuthTokenExpiredException.class)\n\t@Inject\n\tpublic List<Change> listChanges(\n\t\t\tMuleMessage message,\n\t\t\t@Optional @Default(\"true\") boolean includeDeleted,\n\t\t\t@Optional @Default(\"true\") boolean includeSubscribed,\n\t\t\t@Optional @Default(\"100\") int maxResults,\n\t\t\t@Optional @Default(\"#[flowVars['GoogleDrive_NEXT_PAGE_TOKEN']]\") String pageToken,\n\t\t\t@Optional Long startChangeId\n\t\t\t) throws IOException {\n\t\t\n\t\tChangeList response = this.client.changes().list()\n\t\t\t\t\t\t\t\t\t.setIncludeDeleted(includeDeleted)\n\t\t\t\t\t\t\t\t\t.setIncludeSubscribed(includeSubscribed)\n\t\t\t\t\t\t\t\t\t.setMaxResults(maxResults)\n\t\t\t\t\t\t\t\t\t.setPageToken(pageToken)\n\t\t\t\t\t\t\t\t\t.setStartChangeId(startChangeId)\n\t\t\t\t\t\t\t\t\t.execute();\n\t\t\n\t\tPaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n\t\t\n\t\treturn Change.valueOf(response.getItems(), Change.class);\n\t}\n","new_comment_raw":"Returns a paginated  Iterator with the  org.mule.module.google.drive.model.Change objects for a user @sample.xml ..\/..\/..\/doc\/GoogleDriveConnector.xml.sample google-drive:list-changes","old_comment_raw":"Lists the changes for a user @sample.xml ..\/..\/..\/doc\/GoogleDriveConnector.xml.sample google-drive:list-changes","label":1,"pre_label":0,"AST_level":11,"line_counts":31,"new_code_token_num":150},{"new_code_raw":"public ArrayList<Activity> getAllOpenedActivities() { ArrayList<Activity> activities = new ArrayList<Activity>(); Iterator<WeakReference<Activity>> activityStackIterator = activityStack.iterator(); while(activityStackIterator.hasNext()){ Activity activity = activityStackIterator.next().get(); if(activity!=null) activities.add(activity); } return activities; }","old_code_raw":"\tpublic ArrayList<Activity> getAllOpenedActivities()\n\t{\n\t\treturn new ArrayList<Activity>(activityStack);\n\t}\n","new_comment_raw":"Returns a  List of all the opened\/active activities.","old_comment_raw":"Returns a List of all the opened\/active activities.","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":60},{"new_code_raw":"public AtmosphereRequest getRequest() { return atmosphereRequest; }","old_code_raw":"    public HttpServletRequest getRequest() {\n        return atmosphereRequest;\n    }\n","new_comment_raw":"Return the associated  AtmosphereRequest","old_comment_raw":"Return the associated HttpServletRequest","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public View getActiveDecorView() { final View [] views = getWindowDecorViews(); final Activity activity = activityUtils.getCurrentActivity(false); if(views !=null && views.length > 0) { int length = views.length; for(int i = length - 1; i >= 0; i--){ if(activity.hasWindowFocus() && getCurrentViews(TextView.class,(ViewGroup) views[i]).size()==1) { return views[i]; } else if(activity.hasWindowFocus() && activity.getWindow().getDecorView().equals(views[i])){ return views[i]; } else if(!activity.hasWindowFocus() && !activity.getWindow().getDecorView().equals(views[i])){ return views[i]; } } return views[views.length-1]; } else return null; }","old_code_raw":"\tpublic View getActiveDecorView()\n\t{\n\t\tView [] views = getWindowDecorViews();\n\t\tActivity activity = activityUtils.getCurrentActivity(false);\n\t\tif(views !=null && views.length > 0)\n\t\t{\n\t\t\tint length = views.length;\n\t\t\tfor(int i = length - 1; i >= 0; i--){\n\t\t\t\tif(activity.hasWindowFocus() && activity.getWindow().getDecorView().equals(views[i])){\n\t\t\t\t\treturn views[i];\n\t\t\t\t}\n\t\t\t\telse if(!activity.hasWindowFocus() && !activity.getWindow().getDecorView().equals(views[i])){ \n\t\t\t\t\treturn views[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn views[views.length-1];\n\t\t}\n\t\telse\n\t\t\treturn null;\n\t}\n","new_comment_raw":"Returns the active DecorView.","old_comment_raw":"Returns the active DecorView.","label":0,"pre_label":1,"AST_level":15,"line_counts":25,"new_code_token_num":173},{"new_code_raw":"public ClusterSummary getClusterInfo() throws TException { long start = System.nanoTime(); try { StormClusterState stormClusterState = data.getStormClusterState(); Map<String, Assignment> assignments = new HashMap<String, Assignment>(); \/\/ get TopologySummary List<TopologySummary> topologySummaries = NimbusUtils.getTopologySummary(stormClusterState, assignments); \/\/ all supervisors Map<String, SupervisorInfo> supervisorInfos = Cluster.get_all_SupervisorInfo(stormClusterState, null); \/\/ generate SupervisorSummaries List<SupervisorSummary> supervisorSummaries = NimbusUtils.mkSupervisorSummaries(supervisorInfos, assignments); NimbusSummary nimbusSummary = NimbusUtils.getNimbusSummary(stormClusterState, supervisorSummaries, data); return new ClusterSummary(nimbusSummary, supervisorSummaries, topologySummaries); } catch (TException e) { LOG.info(\"Failed to get ClusterSummary \", e); throw e; } catch (Exception e) { LOG.info(\"Failed to get ClusterSummary \", e); throw new TException(e); } finally { long end = System.nanoTime(); SimpleJStormMetric.updateNimbusHistogram(\"getClusterInfo\", (end - start) \/ TimeUtils.NS_PER_US); } }","old_code_raw":"    public ClusterSummary getClusterInfo() throws TException {\n        long start = System.nanoTime();\n        try {\n\n            StormClusterState stormClusterState = data.getStormClusterState();\n\n            Map<String, Assignment> assignments =\n                    new HashMap<String, Assignment>();\n\n            \/\/ get TopologySummary\n            List<TopologySummary> topologySummaries =\n                    NimbusUtils.getTopologySummary(stormClusterState,\n                            assignments);\n\n            \/\/ all supervisors\n            Map<String, SupervisorInfo> supervisorInfos =\n                    Cluster.get_all_SupervisorInfo(stormClusterState, null);\n\n            \/\/ generate SupervisorSummaries\n            List<SupervisorSummary> supervisorSummaries =\n                    NimbusUtils.mkSupervisorSummaries(supervisorInfos,\n                            assignments);\n\n            NimbusSummary nimbusSummary =\n                    NimbusUtils.getNimbusSummary(stormClusterState,\n                            supervisorSummaries, data);\n\n            ClusterSummary ret =\n                    new ClusterSummary(nimbusSummary, supervisorSummaries,\n                            topologySummaries);\n\n            return ret;\n\n        } catch (TException e) {\n            LOG.info(\"Failed to get ClusterSummary \", e);\n            throw e;\n        } catch (Exception e) {\n            LOG.info(\"Failed to get ClusterSummary \", e);\n            throw new TException(e);\n        }finally {\n            double spend = (System.nanoTime() - start)\/1000000.0d;\n            SimpleJStormMetric.updateHistorgram(\"getClusterInfo\", spend);\n            LOG.info(\"getClusterInfo spend {}ms\", spend);\n        }\n    }\n","new_comment_raw":"get cluster's summary, it will contain SupervisorSummary and TopologySummary","old_comment_raw":"get cluster's summary, it will contain SupervisorSummary and","label":1,"pre_label":0,"AST_level":9,"line_counts":31,"new_code_token_num":186},{"new_code_raw":"public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException { Object postBody = body; String path = UriComponentsBuilder.fromPath(\"\/fake\/outer\/number\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"*\/*\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<BigDecimal> fakeOuterNumberSerialize(BigDecimal body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake\/outer\/number\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*\/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"Test serialization of outer number types 200 - Output number","old_comment_raw":"Test serialization of outer number types 200 - Output number","label":0,"pre_label":1,"AST_level":8,"line_counts":23,"new_code_token_num":177},{"new_code_raw":"public boolean isResolvable(PicoContainer container, ComponentAdapter adapter, Class expectedType) { final Class collectionType = getCollectionType(expectedType); return collectionType != null && (emptyCollection || getResolvingAdapters(container, adapter, expectedType).length > 0); }","old_code_raw":"    public boolean isResolvable(PicoContainer container, ComponentAdapter adapter, Class expectedType) {\n        final Class collectionType = getCollectionType(expectedType);\n        if (collectionType != null) {\n            return emptyCollection\n                    || !getMatchingComponentAdapters(container, adapter, componentKeyType, getValueType(expectedType)).isEmpty();\n        }\n        return false;\n    }\n","new_comment_raw":"Check for a successful dependency resolution of the parameter for the expected type.","old_comment_raw":"Test for dependency resolution of the parameter for the expected type.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":45},{"new_code_raw":"public List<Library> getImportedLibraries() { return importedLibraries; }","old_code_raw":"  public ArrayList<Library> getImportedLibraries() {\n    return importedLibraries;\n  }\n","new_comment_raw":"Get the list of imported libraries.","old_comment_raw":"Get the list of imported libraries.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public OracleQuery clone(Connection conn){ return new OracleQuery(conn, getTemplates(), getMetadata().clone()); }","old_code_raw":"    public OracleQuery clone(Connection conn){\n        return new OracleQuery(conn, templates, getMetadata().clone());   \n    }\n","new_comment_raw":"Clone the state of this query to a new SQLQueryImpl instance with the given Connection","old_comment_raw":"Clone the state of this query to a new SQLQueryImpl instance with the given Connection","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public ResultSet executeQuery(String sql) throws SQLException { if( type==ResultSet.TYPE_FORWARD_ONLY && concurrency==ResultSet.CONCUR_READ_ONLY ) { ResultSet rs = internalExecuteQuery( sql ); if( rs != null ) return rs; else throw new SQLException(\"No ResultSet was produced.\"); } else return new freetds.CursorResultSet(this, sql); }","old_code_raw":"   public ResultSet executeQuery(String sql) throws SQLException\n   {\n        if ( type == ResultSet.TYPE_FORWARD_ONLY\n                && concurrency == ResultSet.CONCUR_READ_ONLY ) {\n            return internalExecuteQuery( getTds(sql), sql );\n        }\n        else {\n            return new freetds.CursorResultSet( this, sql );\n        }\n   }\n","new_comment_raw":"Execute an SQL statement that returns a single ResultSet.","old_comment_raw":"Execute a SQL statement that retruns a single ResultSet","label":1,"pre_label":0,"AST_level":8,"line_counts":17,"new_code_token_num":64},{"new_code_raw":"public static String removeTags(String str) { return TAG_REGEXP.matcher(str).replaceAll(\"\"); }","old_code_raw":"\tpublic static String removeTags(String str)\n\t{\n\t\tStringBuilder builder = new StringBuilder(str.length());\n\t\tboolean inTag = false;\n\n\t\tfor (int i = 0; i < str.length(); i++)\n\t\t{\n\t\t\tchar currentChar = str.charAt(i);\n\n\t\t\tif (currentChar == '<')\n\t\t\t{\n\t\t\t\tinTag = true;\n\t\t\t}\n\t\t\telse if (currentChar == '>')\n\t\t\t{\n\t\t\t\tinTag = false;\n\t\t\t}\n\t\t\telse if (!inTag)\n\t\t\t{\n\t\t\t\tbuilder.append(currentChar);\n\t\t\t}\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n","new_comment_raw":"Removes all tags from the given `str`.","old_comment_raw":"Removes all tags from the given `str`.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":22},{"new_code_raw":"public Tree transformTree(Tree t) { if (VERBOSE) { System.err.println(\"Input to CoordinationTransformer: \" + t); } Tree tx = tn.transformTree(t); if (VERBOSE) { System.err.println(\"After DependencyTreeTransformer: \" + tx); } if (tx == null) { return tx; } Tree tt = UCPtransform(tx); if (VERBOSE) { System.err.println(\"After UCPTransformer: \" + t); } Tree ttt = CCtransform(tt); if (VERBOSE) { System.err.println(\"After CCTransformer: \" + t); } Tree tttt = qp.transformTree(ttt); if (VERBOSE) { System.err.println(\"After QPTreeTransformer: \" + t); } Tree ret = dates.transformTree(tttt); if (VERBOSE) { System.err.println(\"After DateTreeTransformer: \" + t); } return ret; }","old_code_raw":"  public Tree transformTree(Tree t) {\n    if (VERBOSE) {\n      System.err.println(\"Input to CoordinationTransformer: \" + t);\n    }\n    t = tn.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DependencyTreeTransformer:  \" + t);\n    }\n    if (t == null) {\n      return t;\n    }\n\n    if (performMWETransformation) {\n      t = MWETransform(t);\n      if (VERBOSE) {\n        System.err.println(\"After MWETransform:               \" + t);\n      }\n\n      t = prepCCTransform(t);\n      if (VERBOSE) {\n        System.err.println(\"After prepCCTransform:               \" + t);\n      }\n    }\n\n    t = UCPtransform(t);\n    if (VERBOSE) {\n      System.err.println(\"After UCPTransformer:             \" + t);\n    }\n    t = CCtransform(t);\n    if (VERBOSE) {\n      System.err.println(\"After CCTransformer:              \" + t);\n    }\n    t = qp.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After QPTreeTransformer:          \" + t);\n    }\n    t = SQflatten(t);\n    if (VERBOSE) {\n      System.err.println(\"After SQ flattening:              \" + t);\n    }\n    t = dates.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DateTreeTransformer:        \" + t);\n    }\n    t = removeXOverX(t);\n    if (VERBOSE) {\n      System.err.println(\"After removeXoverX:               \" + t);\n    }\n    t = combineConjp(t);\n    if (VERBOSE) {\n      System.err.println(\"After combineConjp:               \" + t);\n    }\n    t = moveRB(t);\n    if (VERBOSE) {\n      System.err.println(\"After moveRB:                     \" + t);\n    }\n    t = changeSbarToPP(t);\n    if (VERBOSE) {\n      System.err.println(\"After changeSbarToPP:             \" + t);\n    }\n    t = rearrangeNowThat(t);\n    if (VERBOSE) {\n      System.err.println(\"After rearrangeNowThat:           \" + t);\n    }\n\n    return t;\n  }\n","new_comment_raw":"Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).","old_comment_raw":"Transforms t if it contains a coordination in a flat structure (CCtransform) and transforms UCP (UCPtransform).","label":0,"pre_label":1,"AST_level":8,"line_counts":30,"new_code_token_num":175},{"new_code_raw":"public Iterator<Component> getComponentIterator() { return Collections.unmodifiableList(components).iterator(); }","old_code_raw":"    public Iterator<Component> getComponentIterator() {\n        return java.util.Collections.unmodifiableList(components).iterator();\n    }\n","new_comment_raw":"Gets the component container iterator for going through all the components (tab contents).","old_comment_raw":"Gets the component container iterator for going trough all the components in the container.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"public ApiResponse<Void> logoutUserWithHttpInfo() throws ApiException { okhttp3.Call localVarCall = logoutUserValidateBeforeCall(null, null); return localVarApiClient.execute(localVarCall); }","old_code_raw":"    public ApiResponse<Void> logoutUserWithHttpInfo() throws ApiException {\n        okhttp3.Call call = logoutUserValidateBeforeCall(null, null);\n        return apiClient.execute(call);\n    }\n","new_comment_raw":"Logs out current logged in user session","old_comment_raw":"Logs out current logged in user session","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":27},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(String type, StructuredTextEnvironment environment) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$ return getStatefulExpert(handler, environment); }","old_code_raw":"\tstatic public ISTextExpert getStatefulExpert(String type, STextEnvironment environment) {\n\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n","new_comment_raw":"Obtains a IStructuredTextExpert instance for processing structured text with the specified type handler and the specified environment.","old_comment_raw":"Obtains a ISTextExpert instance for processing structured text with the specified type handler and the specified environment.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"public String getVerboseMessage() { return getVerboseMessage(true); }","old_code_raw":"  public String getVerboseMessage() {\n    return generateMessage() + \"\\n\\n\" + ErrorHelper.buildCausesMessage(getCause());\n  }\n","new_comment_raw":"generates the message that will be displayed to the client.","old_comment_raw":"generates the message that will be displayed to the client.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"private static X509ExtendedTrustManager findFirstX509TrustManager(TrustManager[] tms) throws KeyManagementException { for (TrustManager tm : tms) { if (tm instanceof X509ExtendedTrustManager) { return (X509ExtendedTrustManager) tm; } if (tm instanceof X509TrustManager) { return new X509ExtendedTrustManagerWrapper((X509TrustManager) tm); } } return null; }","old_code_raw":"    private static X509TrustManager findFirstX509TrustManager(TrustManager[] tms) {\n        for (TrustManager tm : tms) {\n            if (tm instanceof X509TrustManager) {\n                return (X509TrustManager)tm;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"Finds the first  X509ExtendedTrustManager or  X509TrustManager element in the provided array.","old_comment_raw":"Finds the first X509TrustManager element in the provided array.","label":1,"pre_label":0,"AST_level":10,"line_counts":14,"new_code_token_num":58},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException { Object localVarPostBody = body; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/boolean\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/boolean\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"Test serialization of outer boolean types","old_comment_raw":"Test serialization of outer boolean types","label":0,"pre_label":1,"AST_level":8,"line_counts":31,"new_code_token_num":166},{"new_code_raw":"public Interval gap(ReadableInterval interval) { interval = DateTimeUtils.getReadableInterval(interval); if (overlaps(interval) || abuts(interval)) { return null; } long otherStart = interval.getStartMillis(); long otherEnd = interval.getEndMillis(); long thisStart = getStartMillis(); long thisEnd = getEndMillis(); if (thisStart >= otherEnd) { return new Interval(otherEnd, thisStart, getChronology()); } else { return new Interval(thisEnd, otherStart, getChronology()); } }","old_code_raw":"    public Interval gap(ReadableInterval interval) {\n        interval = DateTimeUtils.getReadableInterval(interval);\n        if (overlaps(interval) || abuts(interval)) {\n            return null;\n        }\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        long thisStart = getStartMillis();\n        long thisEnd = getEndMillis();\n        if (thisStart >= otherEnd) {\n            return new Interval(otherEnd, thisStart);\n        } else {\n            return new Interval(thisEnd, otherStart);\n        }\n    }\n","new_comment_raw":"Gets the gap between this interval and another interval.","old_comment_raw":"Gets the gap between this interval and that specified.","label":1,"pre_label":0,"AST_level":7,"line_counts":16,"new_code_token_num":96},{"new_code_raw":"public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) { return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize); }","old_code_raw":"    public static RequestQueue newRequestQueue(ImplRestConnection implRestConnection, int threadPoolSize) {\n        return newRequestQueue(HttpRestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n","new_comment_raw":"Create a new request queue, using NoHttp default request executor  RestProtocol and default response parser  RestParser.","old_comment_raw":"Create a new request queue, using NoHttp default request executor HttpRestConnection and default response parser HttpRestParser.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public static String deprocess(String str, STextProcessor processor) { if ((str == null) || (str.length() <= 1)) return str; \/\/ make sure that LRE\/PDF are added around the string STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; return STextEngine.fullToLeanText(processor, env, str, null); }","old_code_raw":"\tpublic static String deprocess(String str, STextProcessor processor) {\n\t\tif ((str == null) || (str.length() <= 1) || !isProcessingNeeded())\n\t\t\treturn str;\n\n\t\t\/\/ make sure that LRE\/PDF are added around the string\n\t\tSTextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN);\n\t\treturn STextEngine.fullToLeanText(processor, env, str, null);\n\t}\n","new_comment_raw":"Removes directional formatting characters in the given string.","old_comment_raw":"Remove directional formatting characters in the given string that were inserted by the #processTyped processTyped method.","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":82},{"new_code_raw":"public static String quote(String name) { if ( name == null || name.length() == 0 || isQuoted( name ) ) { return name; } else { return new StringBuffer( name.length() + 2 ).append('`').append( name ).append( '`' ).toString(); } }","old_code_raw":"\tpublic static String quote(String name) {\n\t\tif ( name == null || name.length() == 0 || isQuoted( name ) ) {\n\t\t\treturn name;\n\t\t}\n\t\telse {\n\t\t\treturn new StringBuilder( name.length() + 2 ).append('`').append( name ).append( '`' ).toString();\n\t\t}\n\t}\n","new_comment_raw":"Return a representation of the given name ensuring quoting (wrapped with '`' characters).","old_comment_raw":"Return a representation of the given name ensuring quoting (wrapped with '`' characters).","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":65},{"new_code_raw":"public static EString substring(Expr<String> left, int beginIndex, int endIndex) { return operationFactory.createString(Ops.SUBSTR2ARGS, left, exprFactory.createConstant(beginIndex), exprFactory.createConstant(endIndex)); }","old_code_raw":"    public static EString substring(Expr<String> left, int beginIndex, int endIndex) {\n        return factory.createString(Ops.SUBSTR2ARGS, left, factory.createConstant(beginIndex), factory.createConstant(endIndex));\n    }\n","new_comment_raw":"Expr : left.substring(beginIndex, endIndex)","old_comment_raw":"Expr : left.substring(beginIndex, endIndex)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":39},{"new_code_raw":"public static List getEditorSearchPath() { \/\/ grrrr, Arrays.asList() returns a readonly List item, which makes it difficult \/\/ to append additional items. This means we have to do this manually. \/\/ start by getting the list from the editor manager, which is returned as an \/\/ array of Strings. String[] paths = PropertyEditorManager.getEditorSearchPath(); \/\/ get a list matching the initial size...we don't always request this with the intend to append. List pathList = new ArrayList(paths.length); \/\/ now MANUALLY add each of the items in the array. for (int i = 0; i < paths.length; i++) { pathList.add(paths[i]); } return pathList; }","old_code_raw":"    public static List getEditorSearchPath()\n    {\n        String[] path = PropertyEditorManager.getEditorSearchPath();\n\n        List list = new ArrayList(path.length);\n        for (int i=0; i<path.length; i++) {\n            list.add(path[i]);\n        }\n\n        return list;\n    }\n","new_comment_raw":"Get a list containing all of the packages in the editor search path.","old_comment_raw":"Gets the package names that will be searched for property editors.","label":1,"pre_label":0,"AST_level":9,"line_counts":20,"new_code_token_num":141},{"new_code_raw":"public BigDecimal executeAs(Function<Response, Response> handler) { Type type = new TypeToken<BigDecimal>(){}.getType(); return execute(handler).as(type); }","old_code_raw":"        public BigDecimal executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<BigDecimal>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n","new_comment_raw":"POST \/fake\/outer\/number","old_comment_raw":"POST \/fake\/outer\/number","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public ResultSetMetaData getMetaData() throws SQLException { try { debugCodeCall(\"getMetaData\"); checkClosed(); ResultInterface result = command.getMetaData(); if(result == null) { return null; } int id = getNextId(TraceObject.RESULT_SET_META_DATA); if(debug()) { debugCodeAssign(\"ResultSetMetaData\", TraceObject.RESULT_SET_META_DATA, id); debugCodeCall(\"getMetaData\"); } JdbcResultSetMetaData meta = new JdbcResultSetMetaData(null, this, result, session.getTrace(), id); return meta; } catch(Throwable e) { throw logAndConvert(e); } }","old_code_raw":"    public ResultSetMetaData getMetaData() throws SQLException {\r\n        try {\r\n            debugCodeCall(\"getMetaData\");\r\n            checkClosed();\r\n            return null;\r\n        } catch(Throwable e) {\r\n            throw logAndConvert(e);\r\n        }\r\n    }\r\n","new_comment_raw":"Gets the result set metadata of the query returned when the statement is executed.","old_comment_raw":"[Not supported] Gets the result set metadata of the query returned when the statement is executed.","label":1,"pre_label":0,"AST_level":8,"line_counts":21,"new_code_token_num":110},{"new_code_raw":"public static Set<BitSet> getUniqueKeys(RelNode rel, boolean ignoreNulls) { final BuiltInMetadata.UniqueKeys metadata = rel.metadata(BuiltInMetadata.UniqueKeys.class); return metadata.getUniqueKeys(ignoreNulls); }","old_code_raw":"  public static Set<BitSet> getUniqueKeys(RelNode rel, boolean ignoreNulls) {\n    return (Set<BitSet>) rel.getCluster().getMetadataProvider()\n        .getRelMetadata(\n            rel,\n            \"getUniqueKeys\",\n            new Object[]{ignoreNulls});\n  }\n","new_comment_raw":"Returns the  BuiltInMetadata.UniqueKeys#getUniqueKeys(boolean) statistic.","old_comment_raw":"Determines the set of unique minimal keys for this expression, optionally ignoring nulls in the columns in the expression.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":33},{"new_code_raw":"public DateTime roundHalfEvenCopy() { DateTime instant = iInstant; return (DateTime)instant.withMillis(iField.roundHalfEven(instant.getMillis())); }","old_code_raw":"    public DateTime roundHalfEvenCopy() {\n        DateTime instant = iInstant;\n        return (DateTime)instant.toCopy(iField.roundHalfEven(instant.getMillis()));\n    }\n","new_comment_raw":"Rounds to the nearest whole unit of this field on a copy of this DateTime.","old_comment_raw":"Rounds to the nearest whole unit of this field on a copy of this DateTime.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"public Insets getBorderInsets(Component c) { return getBorderInsets(c, null); }","old_code_raw":"    public Insets getBorderInsets(Component c, Insets insets) {\n        if (this.insets != null) {\n            if (insets == null) {\n                insets = new Insets(this.insets.top, this.insets.left,\n                                  this.insets.bottom, this.insets.right);\n            }\n            else {\n                insets.top    = this.insets.top;\n                insets.bottom = this.insets.bottom;\n                insets.left   = this.insets.left;\n                insets.right  = this.insets.right;\n            }\n        }\n        else if (insets == null) {\n            insets = new Insets(0, 0, 0, 0);\n        }\n        else {\n            insets.top = insets.bottom = insets.left = insets.right = 0;\n        }\n        if (c instanceof JComponent) {\n            Region region = Region.getRegion((JComponent)c);\n            Insets margin = null;\n            if ((region == Region.ARROW_BUTTON || region == Region.BUTTON ||\n                 region == Region.CHECK_BOX ||\n                 region == Region.CHECK_BOX_MENU_ITEM ||\n                 region == Region.MENU || region == Region.MENU_ITEM ||\n                 region == Region.RADIO_BUTTON ||\n                 region == Region.RADIO_BUTTON_MENU_ITEM ||\n                 region == Region.TOGGLE_BUTTON) &&\n                       (c instanceof AbstractButton)) {\n                margin = ((AbstractButton)c).getMargin();\n            }\n            else if ((region == Region.EDITOR_PANE ||\n                      region == Region.FORMATTED_TEXT_FIELD ||\n                      region == Region.PASSWORD_FIELD ||\n                      region == Region.TEXT_AREA ||\n                      region == Region.TEXT_FIELD ||\n                      region == Region.TEXT_PANE) &&\n                        (c instanceof JTextComponent)) {\n                margin = ((JTextComponent)c).getMargin();\n            }\n            else if (region == Region.TOOL_BAR && (c instanceof JToolBar)) {\n                margin = ((JToolBar)c).getMargin();\n            }\n            else if (region == Region.MENU_BAR && (c instanceof JMenuBar)) {\n                margin = ((JMenuBar)c).getMargin();\n            }\n            if (margin != null) {\n                insets.top += margin.top;\n                insets.bottom += margin.bottom;\n                insets.left += margin.left;\n                insets.right += margin.right;\n            }\n        }\n        return insets;\n    }\n","new_comment_raw":"This default implementation returns a new Insets instance where the top, left, bottom, and right fields are set to 0.","old_comment_raw":"Reinitializes the insets parameter with this Border's current Insets.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public boolean scrollUpList(int index) { return scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.UP, false); }","old_code_raw":"\tpublic boolean scrollUpList(int index) {\n\t\treturn scroller.scrollList(waiter.waitForAndGetView(index, ListView.class), Scroller.UP);\n\t}\n","new_comment_raw":"Scrolls up a list with a given index.","old_comment_raw":"Scrolls up a list with a given index.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"private XmlAttributeNode getScriptSourcePath(XmlTagNode node) { for (XmlAttributeNode attribute : node.getAttributes()) { if (attribute.getName().getLexeme().equals(SRC)) { return attribute; } } return null; }","old_code_raw":"  private String getScriptSourcePath(XmlTagNode node) {\n    for (XmlAttributeNode attribute : node.getAttributes()) {\n      if (attribute.getName().getLexeme().equals(SRC)) {\n        String text = attribute.getText();\n        return text != null && text.length() > 0 ? text : null;\n      }\n    }\n    return null;\n  }\n","new_comment_raw":"Return the first source attribute for the given tag node, or  null if it does not exist.","old_comment_raw":"Return the value of the source attribute if it exists.","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":43},{"new_code_raw":"public String getSearchPath() { \/\/ Java Mode doesn't need any default external jars at the moment. \/\/ This is here for Android Mode so that it can add its android.jar file. return null; }","old_code_raw":"  public String getSearchPath() {\n    \/\/ Java Mode doesn't need any default external jars at the moment.\n    return \"\";\n  }\n","new_comment_raw":"Any modes that extend JavaMode can override this method to add additional","old_comment_raw":"Any modes that extend JavaMode can override this method to add additional jars to be included in the classpath for code completion and error checking","label":1,"pre_label":0,"AST_level":4,"line_counts":6,"new_code_token_num":42},{"new_code_raw":"public synchronized List<ColumnIdentifier> getColumns(TableIdentifier tbl) { String schema = getSchemaToUse(tbl.getSchema()); TableIdentifier toSearch = tbl.createCopy(); toSearch.adjustCase(dbConnection); if (toSearch.getSchema() == null) { toSearch.setSchema(schema); } List<ColumnIdentifier> cols = this.objects.get(toSearch); if (cols == null) { try { TableDefinition def = dbConnection.getMetadata().getTableDefinition(toSearch); addTable(def); } catch (SQLException sql) { LogMgr.logWarning(\"DbObjectCache.getColumns()\", \"Error retrieving table definition\", sql); return null; } } \/\/ To support Oracle public synonyms, try to find a table with that name but without a schema if (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null) { toSearch.setSchema(null); toSearch.setType(null); cols = this.objects.get(toSearch); if (cols == null) { \/\/ retrieve Oracle PUBLIC synonyms this.getTables(\"PUBLIC\"); cols = this.objects.get(toSearch); } } if (CollectionUtil.isEmpty(cols)) { TableIdentifier tblToUse = null; \/\/ use the stored key because that might carry the correct type attribute \/\/ TabelIdentifier.equals() doesn't compare the type, only the expression \/\/ so we'll get a containsKey() == true even if the type is different \/\/ (which is necessary because the TableIdentifier passed to this \/\/ method will never contain a type!) \/\/ only using objects.get() would not return anything! if (objects.containsKey(toSearch)) { \/\/ we have already retrieved the list of tables, but not the columns for this table \/\/ the table identifier in the object map contains correct type and schema information, so we need \/\/ to use that tblToUse = findEntry(toSearch); } else { \/\/ retrieve the real table identifier based on the table name tblToUse = this.dbConnection.getMetadata().findObject(toSearch); } try { cols = this.dbConnection.getMetadata().getTableColumns(tblToUse); } catch (Throwable e) { LogMgr.logError(\"DbObjectCache.getColumns\", \"Error retrieving columns for \" + tblToUse, e); cols = null; } if (tblToUse != null && CollectionUtil.isNonEmpty(cols)) { this.objects.put(tblToUse, cols); } } return Collections.unmodifiableList(cols); }","old_code_raw":"\tpublic List<ColumnIdentifier> getColumns(TableIdentifier tbl)\n\t{\n\t\tString schema = getSchemaToUse(tbl.getSchema());\n\n\t\tif (this.objects.size() == 0 || !schemasInCache.contains(schema == null ? NULL_SCHEMA : schema))\n\t\t{\n\t\t\tthis.getTables(schema);\n\t\t}\n\n\t\tTableIdentifier toSearch = tbl.createCopy();\n\t\ttoSearch.adjustCase(dbConnection);\n\t\tif (toSearch.getSchema() == null)\n\t\t{\n\t\t\ttoSearch.setSchema(schema);\n\t\t}\n\n\t\tList<ColumnIdentifier> cols = this.objects.get(toSearch);\n\n\t\t\/\/ To support Oracle public synonyms, try to find a table with that name but without a schema\n\t\tif (retrieveOraclePublicSynonyms && toSearch.getSchema() != null && cols == null)\n\t\t{\n\t\t\ttoSearch.setSchema(null);\n\t\t\ttoSearch.setType(null);\n\t\t\tcols = this.objects.get(toSearch);\n\t\t\tif (cols == null)\n\t\t\t{\n\t\t\t\t\/\/ retrieve Oracle PUBLIC synonyms\n\t\t\t\tthis.getTables(\"PUBLIC\");\n\t\t\t\tcols = this.objects.get(toSearch);\n\t\t\t}\n\t\t}\n\n\t\tif (CollectionUtil.isEmpty(cols))\n\t\t{\n\t\t\tTableIdentifier tblToUse = null;\n\n\t\t\t\/\/ use the stored key because that might carry the correct type attribute\n\t\t\t\/\/ TabelIdentifier.equals() doesn't compare the type, only the expression\n\t\t\t\/\/ so we'll get a containsKey() == true even if the type is different\n\t\t\t\/\/ (which is necessary because the TableIdentifier passed to this\n\t\t\t\/\/ method will never contain a type!)\n\t\t\t\/\/ only using objects.get() would not return anything!\n\t\t\tif (objects.containsKey(toSearch))\n\t\t\t{\n\t\t\t\t\/\/ we have already retrieved the list of tables, but not the columns for this table\n\t\t\t\t\/\/ the table identifier in the object map contains correct type and schema information, so we need\n\t\t\t\t\/\/ to use that\n\t\t\t\ttblToUse = findEntry(toSearch);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\/\/ retrieve the real table identifier based on the table name\n\t\t\t\ttblToUse = this.dbConnection.getMetadata().findObject(toSearch);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tcols = this.dbConnection.getMetadata().getTableColumns(tblToUse);\n\t\t\t}\n\t\t\tcatch (Throwable e)\n\t\t\t{\n\t\t\t\tLogMgr.logError(\"DbObjectCache.getColumns\", \"Error retrieving columns for \" + tblToUse, e);\n\t\t\t\tcols = null;\n\t\t\t}\n\n\t\t\tif (tblToUse != null && CollectionUtil.isNonEmpty(cols))\n\t\t\t{\n\t\t\t\tthis.objects.put(tblToUse, cols);\n\t\t\t}\n\n\t\t}\n\t\treturn Collections.unmodifiableList(cols);\n\t}\n","new_comment_raw":"Return the columns for the given table.","old_comment_raw":"Return the columns for the given table","label":1,"pre_label":0,"AST_level":11,"line_counts":83,"new_code_token_num":459},{"new_code_raw":"public static PsiFile findLayoutResource(PsiElement element) { if (element == null) { return null; \/\/ nothing to be used } if (!(element instanceof PsiIdentifier)) { return null; \/\/ nothing to be used } PsiElement layout = element.getParent().getFirstChild(); if (layout == null) { return null; \/\/ no file to process } if (!\"R.layout\".equals(layout.getText())) { return null; \/\/ not layout file } Project project = element.getProject(); String name = String.format(\"%s.xml\", element.getText()); return resolveLayoutResourceFile(element, project, name); }","old_code_raw":"    public static PsiFile findLayoutResource(PsiElement element) {\n        if (element == null) {\n            return null; \/\/ nothing to be used\n        }\n        if (!(element instanceof PsiIdentifier)) {\n            return null; \/\/ nothing to be used\n        }\n\n        PsiElement layout = element.getParent().getFirstChild();\n        if (layout == null) {\n            return null; \/\/ no file to process\n        }\n        if (!\"R.layout\".equals(layout.getText())) {\n            return null; \/\/ not layout file\n        }\n\n        Project project = element.getProject();\n        String name = String.format(\"%s.xml\", element.getText());\n\n        \/\/ restricting the search to the current module - searching the whole project could return wrong layouts\n        GlobalSearchScope moduleScope = ModuleUtil.findModuleForPsiElement(element).getModuleWithDependenciesAndLibrariesScope(false);\n        PsiFile[] files = FilenameIndex.getFilesByName(project, name, moduleScope);\n        if (files.length <= 0) {\n            return null; \/\/no matching files\n        }\n\n        \/\/ TODO - we have a problem here - we still can have multiple layouts (some coming from a dependency)\n        \/\/ we need to resolve R class properly and find the proper layout for the R class\n        return files[0];\n    }\n","new_comment_raw":"Try to find layout XML file in selected element","old_comment_raw":"Try to find layout XML file in selected element","label":0,"pre_label":1,"AST_level":6,"line_counts":23,"new_code_token_num":131},{"new_code_raw":"public Object getObject(String name) throws JMSException { initializeReading(); Object result = map.get(name); if (result instanceof UTF8Buffer) { result = result.toString(); } return result; }","old_code_raw":"    public Object getObject(String name) throws JMSException {\n        initializeReading();\n        return map.get(name);\n    }\n","new_comment_raw":"Returns the value of the object with the specified name.","old_comment_raw":"Returns the value of the object with the specified name.","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":40},{"new_code_raw":"public MenuItem addItem(SafeHtml html, ScheduledCommand cmd) { return addItem(new MenuItem(html, cmd)); }","old_code_raw":"  public MenuItem addItem(String text, boolean asHTML, Command cmd) {\n    return addItem(new MenuItem(text, asHTML, cmd));\n  }\n","new_comment_raw":"Adds a menu item to the bar containing SafeHtml, that will fire the given command when it is selected.","old_comment_raw":"Adds a menu item to the bar, that will fire the given command when it is selected.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public HBaseResponse getHTableInfo(String tableName) throws IOException, ExecutionException { return htableInfoCache.get(tableName); }","old_code_raw":"    public HBaseResponse getHTableInfo(String tableName) throws IOException {\n        if (htableInfoCache.containsKey(tableName)) {\n            return htableInfoCache.get(tableName);\n        }\n\n        HBaseResponse hr = new HBaseResponse();\n        if (\"hbase\".equals(getConfig().getMetadataUrl().getScheme())) {\n            try {\n                \/\/ use reflection to isolate NoClassDef errors when HBase is not available\n                hr = (HBaseResponse) Class.forName(\"org.apache.kylin.rest.service.HBaseInfoUtil\")\/\/\n                        .getMethod(\"getHBaseInfo\", new Class[] { String.class, String.class })\/\/\n                        .invoke(null, new Object[] { tableName, this.getConfig().getStorageUrl() });\n            } catch (Throwable e) {\n                throw new IOException(e);\n            }\n        }\n\n        htableInfoCache.put(tableName, hr);\n        return hr;\n    }\n","new_comment_raw":"Calculate size of each region for given table and other info of the table.","old_comment_raw":"Calculate size of each region for given table and other info of the table.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"private static ObjectName asObjectName(Object componentKey) throws MalformedObjectNameException { if (componentKey == null) { throw new NullPointerException(\"componentKey cannot be null\"); } if (componentKey instanceof ObjectName) { return (ObjectName) componentKey; } if (componentKey instanceof Class) { Class clazz = (Class) componentKey; return new ObjectName(\"picomx:type=\" + clazz.getName()); } else { String text = componentKey.toString(); \/\/ Fix, so it works under WebSphere ver. 5 if (text.indexOf(':') == -1) { text = \"picomx:type=\" + text; } return new ObjectName(text); } }","old_code_raw":"    public static ObjectName asObjectName(Object key) throws MalformedObjectNameException {\n        if (key == null) {\n            throw new NullPointerException(\"key cannot be null\");\n        }\n        if (key instanceof ObjectName) {\n            return (ObjectName) key;\n        }\n        if (key instanceof Class) {\n            Class clazz = (Class) key;\n            return new ObjectName(\"nanomx:type=\" + clazz.getName());\n        } else {\n            String text = key.toString();\n            \/\/ Fix, so it works under WebSphere ver. 5\n            if (text.indexOf(':') == -1) {\n                text = \"nanomx:type=\" + text;\n            }\n            return new ObjectName(text);\n        }\n    }\n","new_comment_raw":"Ensures that the given componentKey is converted to a JMX ObjectName","old_comment_raw":"Ensures that the given key is converted to a JMX ObjectName","label":1,"pre_label":0,"AST_level":10,"line_counts":21,"new_code_token_num":127},{"new_code_raw":"public ConcurrentEntityStatisticsImpl getEntityStatistics(String entityName) { ConcurrentEntityStatisticsImpl es = entityStatistics.get( entityName ); if ( es == null ) { es = new ConcurrentEntityStatisticsImpl( entityName ); ConcurrentEntityStatisticsImpl previous; if ( ( previous = entityStatistics.putIfAbsent( entityName, es ) ) != null ) { es = previous; } } return es; }","old_code_raw":"\tpublic EntityStatistics getEntityStatistics(String entityName) {\n\t\tConcurrentEntityStatisticsImpl es = (ConcurrentEntityStatisticsImpl) entityStatistics.get( entityName );\n\t\tif ( es == null ) {\n\t\t\tes = new ConcurrentEntityStatisticsImpl( entityName );\n\t\t\tConcurrentEntityStatisticsImpl previous;\n\t\t\tif ( ( previous = (ConcurrentEntityStatisticsImpl) entityStatistics.putIfAbsent(\n\t\t\t\t\tentityName, es\n\t\t\t) ) != null ) {\n\t\t\t\tes = previous;\n\t\t\t}\n\t\t}\n\t\treturn es;\n\t}\n","new_comment_raw":"find entity statistics per name","old_comment_raw":"find entity statistics per name","label":0,"pre_label":1,"AST_level":9,"line_counts":12,"new_code_token_num":57},{"new_code_raw":"public <V extends Visitor<? super X>> V visit(V visitor) { for (X x : this) { visitor.visit(x); } return visitor; }","old_code_raw":"    public <P extends Visitor<? super X>> P visit(P predicate)\n    {\n        for (X x : this) {\n            predicate.visit(x);\n        }\n\n        return predicate;\n    }\n","new_comment_raw":"Applies  visitor to each item","old_comment_raw":"Applies predicate to each item","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":33},{"new_code_raw":"public RepositoryMetadata lookupComponent(Class<?> repositoryClass) { if (repositoriesMetadata.containsKey(repositoryClass)) { return repositoriesMetadata.get(repositoryClass); } throw new RuntimeException(\"Unknown Repository class \" + repositoryClass.getName()); }","old_code_raw":"    public RepositoryMetadata lookupComponent(Class<?> repoClass)\r\n    {\r\n        if (repositoriesMetadata.containsKey(repoClass))\r\n        {\r\n            return repositoriesMetadata.get(repoClass);\r\n        }\r\n        throw new RuntimeException(\"Unknown Repository class \" + repoClass.getName());\r\n    }\r\n","new_comment_raw":"Lookup the  RepositoryMetadata for a specific Repository class.","old_comment_raw":"Repository access - lookup the Repository component meta data for a specific Repository class.","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":43},{"new_code_raw":"public RequestBody serialize(Object obj, String contentType) throws ApiException { if (obj instanceof byte[]) { \/\/ Binary (byte array) body parameter support. return RequestBody.create(MediaType.parse(contentType), (byte[]) obj); } else if (obj instanceof File) { \/\/ File body parameter support. return RequestBody.create(MediaType.parse(contentType), (File) obj); } else if (isJsonMime(contentType)) { String content; if (obj != null) { content = json.serialize(obj); } else { content = null; } return RequestBody.create(MediaType.parse(contentType), content); } else { throw new ApiException(\"Content type \\\"\" + contentType + \"\\\" is not supported\"); } }","old_code_raw":"  public String serialize(Object obj, String contentType) throws ApiException {\n    if (isJsonMime(contentType)) {\n      if (obj != null)\n        return json.serialize(obj);\n      else\n        return null;\n    } else {\n      throw new ApiException(\"Content type \\\"\" + contentType + \"\\\" is not supported\");\n    }\n  }\n","new_comment_raw":"Serialize the given Java object into request body according to the object's class and the request Content-Type.","old_comment_raw":"Serialize the given Java object into request body string, according to the request Content-Type.","label":1,"pre_label":0,"AST_level":12,"line_counts":20,"new_code_token_num":155},{"new_code_raw":"public VideoCallProvider getVideoCallProvider() { return mVideoCallProvider; }","old_code_raw":"    public ConnectionService.VideoCallProvider getVideoCallProvider() {\n        return mVideoCallProvider;\n    }\n","new_comment_raw":"Returns the  VideoCallProvider for the connection.","old_comment_raw":"Returns the ConnectionService.VideoCallProvider for the connection.","label":1,"pre_label":0,"AST_level":4,"line_counts":5,"new_code_token_num":10},{"new_code_raw":"public String[] checkAllWords(String words) { List<String> misspelledWords = new ArrayList<String>(); StringWordTokenizer tokenizer = new StringWordTokenizer(words); while (tokenizer.hasMoreWords()) { String word = tokenizer.nextWord(); if (!isWordCorrect(word, tokenizer.isNewSentence())) { misspelledWords.add(word); } } return misspelledWords.toArray(new String[0]); }","old_code_raw":"    public String[] checkAllWords(String words) {\n        List<String> misspeltWords = new ArrayList<String>();\n        StringWordTokenizer tokenizer = new StringWordTokenizer(words);\n\n        while (tokenizer.hasMoreWords()) {\n            String word = tokenizer.nextWord();\n            if (!isWordCorrect(word, tokenizer.isNewSentence())) {\n                misspeltWords.add(word);\n            }\n        }\n        return misspeltWords.toArray(new String[0]);\n    }\n","new_comment_raw":"Spell checks all words in the input string and returns an array of misspelled words.","old_comment_raw":"Spell checks all words in the input string and returns an array of misspelt words.","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":76},{"new_code_raw":"public static String getMessageId(SipRequest request) { String result = null; try { \/\/ Read ID from multipart content String content = request.getContent(); int index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID); if (index != -1) { index = index+ImdnUtils.HEADER_IMDN_MSG_ID.length()+1; String part = content.substring(index); String msgId = part.substring(0, part.indexOf(CRLF)); result = msgId.trim(); } } catch(Exception e) { } return result; }","old_code_raw":"\tpublic static String getMessageId(SipRequest request) {\r\n\t\t\/\/ Read ID from Message-Id header\r\n\t\tExtensionHeader messageIdHeader = (ExtensionHeader)request.getHeader(ImdnUtils.HEADER_IMDN_MSG_ID);\r\n\t\tif (messageIdHeader != null) {\r\n\t\t\treturn messageIdHeader.getValue();\r\n\t\t} \r\n\t\t\r\n\t\t\/\/ Read ID from multipart content\r\n\t\ttry {\r\n\t\t    String content = request.getContent();\r\n\t\t\tint index = content.indexOf(ImdnUtils.HEADER_IMDN_MSG_ID);\r\n\t\t\tif (index != -1) {\r\n\t\t\t\tindex = index+ImdnUtils.HEADER_IMDN_MSG_ID.length()+1;\r\n\t\t\t\tString part = content.substring(index);\r\n\t\t\t\tString msgId = part.substring(0, part.indexOf(SipUtils.CRLF));\r\n\t\t\t\treturn msgId.trim();\r\n\t\t\t}\r\n\t\t} catch(Exception e) {\r\n\t\t}\r\n\t\t\r\n\t\t\/\/ No message id\r\n\t\treturn null;\r\n\t}\r\n","new_comment_raw":"Returns the message ID from a SIP request","old_comment_raw":"Returns the message id header value of a SIP request","label":1,"pre_label":0,"AST_level":10,"line_counts":18,"new_code_token_num":98},{"new_code_raw":"public TupleFilter flatFilter(int maxFlatChildrenSize) { return flattenInternal(this, maxFlatChildrenSize); }","old_code_raw":"    public TupleFilter flatFilter() {\n        return flattenInternal(this);\n    }\n","new_comment_raw":"throws IllegalStateException when the flat children exceed the maxFlatChildrenSize","old_comment_raw":"flatten to OR-AND filter, (A AND B AND ..) OR (C AND D AND ..) OR ..","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public static EBoolean startsWith(Expr<String> left, Expr<String> right) { return operationFactory.createBoolean(Ops.STARTSWITH, left, right); }","old_code_raw":"    public static EBoolean startsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return startsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.STARTSWITH_IC, left, right);\n        }\n    }\n","new_comment_raw":"Expr : left.startsWith(right)","old_comment_raw":"Expr : left.startsWith(right) (ignore case)","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public static DocumentFactory createDocumentFactory(ServiceManager manager, Session session) { DocumentFactory factory; DocumentManager docManager = null; try { docManager = (DocumentManager) manager.lookup(DocumentManager.ROLE); factory = docManager.createDocumentIdentityMap(session); } catch (ServiceException e) { throw new RuntimeException(e); } finally { if (docManager != null) { manager.release(docManager); } } return factory; }","old_code_raw":"    public static DocumentFactory createDocumentFactory(ServiceManager manager, Session session) {\n        DocumentFactory map;\n        DocumentManager docManager = null;\n        try {\n            docManager = (DocumentManager) manager.lookup(DocumentManager.ROLE);\n            map = docManager.createDocumentIdentityMap(session);\n        } catch (ServiceException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (docManager != null) {\n                manager.release(docManager);\n            }\n        }\n        return map;\n    }\n","new_comment_raw":"Creates a document factory.","old_comment_raw":"Creates a document identity map.","label":1,"pre_label":0,"AST_level":8,"line_counts":17,"new_code_token_num":75},{"new_code_raw":"public Menu getControlMenu(final Control c) { Menu controlMenu = ControlHandler.getInstance().getMenu(c); if(controlMenu == null) { throw new CoreLayerException(c.getClass() +\" Has no menu\"); } return controlMenu; }","old_code_raw":"\tpublic Menu getControlMenu(final Control c) {\n\n\t\tMenu menu = Display.syncExec(new ResultRunnable<Menu>() {\n\n\t\t\t@Override\n\t\t\tpublic Menu run() {\n\t\t\t\tMenu m = c.getMenu();\n\t\t\t\treturn m;\n\t\t\t}\n\t\t});\n\n\t\tif (menu == null) {\n\t\t\tthrow new CoreLayerException(\n\t\t\t\t\tc.getClass() +\" Has no menu\");\n\t\t}\n\n\t\treturn menu;\t\n\t}\n","new_comment_raw":"Returns menu of given control","old_comment_raw":"Gets Menu of specified control.","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":47},{"new_code_raw":"public String toDefaultValue(Schema p) { if (p instanceof StringSchema) { StringSchema dp = (StringSchema) p; if (dp.getDefault() != null) { return \"@\\\"\" + dp.getDefault() + \"\\\"\"; } } else if (p instanceof BooleanSchema) { BooleanSchema dp = (BooleanSchema) p; if (dp.getDefault() != null) { if (dp.getDefault().toString().equalsIgnoreCase(\"false\")) return \"@(NO)\"; else return \"@(YES)\"; } } else if (p instanceof DateSchema) { \/\/ TODO } else if (p instanceof DateTimeSchema) { \/\/ TODO } else if (p instanceof NumberSchema) { NumberSchema dp = (NumberSchema) p; if (dp.getDefault() != null) { return \"@\" + dp.getDefault().toString(); } } else if (p instanceof IntegerSchema) { IntegerSchema dp = (IntegerSchema) p; if (dp.getDefault() != null) { return \"@\" + dp.getDefault().toString(); } } return null; }","old_code_raw":"    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateProperty) {\n            \/\/ TODO\n        } else if (p instanceof DateTimeProperty) {\n            \/\/ TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"Return the default value of the schema","old_comment_raw":"Return the default value of the property","label":1,"pre_label":0,"AST_level":15,"line_counts":33,"new_code_token_num":219},{"new_code_raw":"@Transactional(readOnly = true) @Override public int getAllCount(final String currentUser, final Set<String> userRoles, EphesoftUser ephesoftUser) { return batchInstanceDao.getAllCount(currentUser, userRoles, ephesoftUser); }","old_code_raw":"\t@Transactional(readOnly = true)\n\t@Override\n\tpublic int getAllCount(final String currentUser, final Set<String> currentRole) {\n\t\treturn batchInstanceDao.getAllCount(currentUser, currentRole);\n\t}\n","new_comment_raw":"An api to return total count of batches from the batch instance table having access by the user roles on the basis of ephesoft user.","old_comment_raw":"An api to return total count of batches in the batch instance table.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":37},{"new_code_raw":"public String toDefaultValue(Schema p) { if (ModelUtils.isDateSchema(p)) { \/\/ TODO } else if (ModelUtils.isDateTimeSchema(p)) { \/\/ TODO } else if (ModelUtils.isNumberSchema(p)) { if (p.getDefault() != null) { return \"@\" + p.getDefault().toString(); } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getDefault() != null) { return \"@\" + p.getDefault().toString(); } } else if (ModelUtils.isStringSchema(p)) { if (p.getDefault() != null) { return \"@\\\"\" + (String) p.getDefault() + \"\\\"\"; } } else if (ModelUtils.isBooleanSchema(p)) { if (p.getDefault() != null) { if (p.getDefault().toString().equalsIgnoreCase(\"false\")) return \"@(NO)\"; else return \"@(YES)\"; } } return null; }","old_code_raw":"    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateProperty) {\n            \/\/ TODO\n        } else if (p instanceof DateTimeProperty) {\n            \/\/ TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"Return the default value of the schema","old_comment_raw":"Return the default value of the property","label":1,"pre_label":0,"AST_level":15,"line_counts":29,"new_code_token_num":206},{"new_code_raw":"public static Parameter getReferencedParameter(OpenAPI openAPI, Parameter parameter) { if (parameter != null && StringUtils.isNotEmpty(parameter.get$ref())) { String name = getSimpleRef(parameter.get$ref()); Parameter referencedParameter = getParameter(openAPI, name); if(referencedParameter != null) { return referencedParameter; } } return parameter; }","old_code_raw":"    public static Parameter getReferencedParameter(OpenAPI openAPI, Parameter parameter) {\n        if (parameter != null && StringUtils.isNotEmpty(parameter.get$ref())) {\n            String name = getSimpleRef(parameter.get$ref());\n            return getParameter(openAPI, name);\n        }\n        return parameter;\n    }\n","new_comment_raw":"If a Parameter contains a reference to an other Parameter with '$ref', returns the referenced Parameter if it is found or the actual Parameter in the other cases.","old_comment_raw":"If a Parameter contains a reference to an other Parameter with '$ref', returns the referenced Parameter or the actual Parameter in the other cases.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); \/\/System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); } } return nodeList; }","old_code_raw":"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"Given a Tree node t, attempts to return a list of nodes to which node t has this grammatical relation.","old_comment_raw":"Given a Tree node t, attempts to return a list of nodes to which node t has this grammatical relation, with t as the governor.","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":151},{"new_code_raw":"public IncidentsTask createReportsTask() { return new IncidentsTask(url); }","old_code_raw":"\tpublic ReportsTask createReportsTask() {\n\t\treturn new ReportsTask(url);\n\t}\n","new_comment_raw":"Create incidents task object","old_comment_raw":"Create report task object","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"public NVP<Long, Double> reset(final long newStartMs, final long newCount) { final long[] priorWindow = TIME_WINDOW_UPDATER.getAndSet(this, windowRangeFromMs(newStartMs, windowWidth)); final long priorCount = count; count = newCount; return new NVP<Long, Double>(priorWindow[1], calcRate(priorCount, windowWidth)); }","old_code_raw":"\tpublic long reset() {\n\t\tfinal long priorCount = count;\n\t\tcount = 0;\n\t\treturn priorCount;\n\t}\n","new_comment_raw":"Resets the count to zero and sets the time window according to the passed ms timestamp","old_comment_raw":"Resets the count to zero","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":63},{"new_code_raw":"private int[] getEnteredTime(Boolean[] enteredZeros) { int amOrPm = -1; int startIndex = 1; if (!mIs24HourMode && isTypedTimeFullyLegal()) { int keyCode = mTypedTimes.get(mTypedTimes.size() - 1); if (keyCode == getAmOrPmKeyCode(AM)) { amOrPm = AM; } else if (keyCode == getAmOrPmKeyCode(PM)){ amOrPm = PM; } startIndex = 2; } int minute = -1; int hour = -1; int second = 0; int shift = mEnableSeconds ? 2 : 0; for (int i = startIndex; i <= mTypedTimes.size(); i++) { int val = getValFromKeyCode(mTypedTimes.get(mTypedTimes.size() - i)); if (mEnableSeconds) { if (i == startIndex) { second = val; } else if (i == startIndex + 1) { second += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[2] = true; } } } if (i == startIndex + shift) { minute = val; } else if (i == startIndex + shift + 1) { minute += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[1] = true; } } else if (i == startIndex + shift + 2) { hour = val; } else if (i == startIndex + shift + 3) { hour += 10*val; if (enteredZeros != null && val == 0) { enteredZeros[0] = true; } } } return new int[] {hour, minute, second, amOrPm}; }","old_code_raw":"    private int[] getEnteredTime(Boolean[] enteredZeros) {\n        int amOrPm = -1;\n        int startIndex = 1;\n        if (!mIs24HourMode && isTypedTimeFullyLegal()) {\n            int keyCode = mTypedTimes.get(mTypedTimes.size() - 1);\n            if (keyCode == getAmOrPmKeyCode(AM)) {\n                amOrPm = AM;\n            } else if (keyCode == getAmOrPmKeyCode(PM)){\n                amOrPm = PM;\n            }\n            startIndex = 2;\n        }\n        int minute = -1;\n        int hour = -1;\n        for (int i = startIndex; i <= mTypedTimes.size(); i++) {\n            int val = getValFromKeyCode(mTypedTimes.get(mTypedTimes.size() - i));\n            if (i == startIndex) {\n                minute = val;\n            } else if (i == startIndex+1) {\n                minute += 10*val;\n                if (enteredZeros != null && val == 0) {\n                    enteredZeros[1] = true;\n                }\n            } else if (i == startIndex+2) {\n                hour = val;\n            } else if (i == startIndex+3) {\n                hour += 10*val;\n                if (enteredZeros != null && val == 0) {\n                    enteredZeros[0] = true;\n                }\n            }\n        }\n\n        return new int[] {hour, minute, amOrPm};\n    }\n","new_comment_raw":"Get the currently-entered time, as integer values of the hours, minutes and seconds typed.","old_comment_raw":"Get the currently-entered time, as integer values of the hours and minutes typed.","label":1,"pre_label":0,"AST_level":16,"line_counts":48,"new_code_token_num":297},{"new_code_raw":"final public Token getNextToken() { if (this.token.next != null) { this.token = this.token.next; } else { this.token = this.token.next = this.token_source.getNextToken(); } this.jj_ntk = -1; this.jj_gen++; return this.token; }","old_code_raw":"    final public Token getNextToken() {\n        if (token.next != null) {\n            token = token.next;\n        } else {\n            token = token.next = token_source.getNextToken();\n        }\n\n        jj_ntk = -1;\n        jj_gen++;\n\n        return token;\n    }\n","new_comment_raw":"Get the next token","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":52},{"new_code_raw":"public static String deprocess(String str) { if ((str == null) || (str.length() <= 1)) return str; STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; StringBuffer buf = new StringBuffer(); int strLen = str.length(); for (int i = 0; i < strLen; i++) { char c = str.charAt(i); switch (c) { case LRM : continue; case LRE : continue; case PDF : continue; default : buf.append(c); } } return buf.toString(); }","old_code_raw":"\tpublic static String deprocess(String str) {\n\t\tif ((str == null) || (str.length() <= 1) || !isProcessingNeeded())\n\t\t\treturn str;\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tint strLen = str.length();\n\t\tfor (int i = 0; i < strLen; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tswitch (c) {\n\t\t\t\tcase LRM :\n\t\t\t\t\tcontinue;\n\t\t\t\tcase LRE :\n\t\t\t\t\tcontinue;\n\t\t\t\tcase PDF :\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault :\n\t\t\t\t\tbuf.append(c);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}\n","new_comment_raw":"Removes directional formatting characters in the given string.","old_comment_raw":"Remove directional formatting characters in the given string that were inserted by one of the #process process methods.","label":1,"pre_label":0,"AST_level":9,"line_counts":26,"new_code_token_num":125},{"new_code_raw":"public boolean isBoolean() { return raw.equals(\"true\") || raw.equals(\"false\"); }","old_code_raw":"    public boolean isBoolean() {\n        return arg.equals(\"true\") || arg.equals(\"false\");\n    }\n","new_comment_raw":"Checks whether this ChatSection's value can be parsed as a boolean","old_comment_raw":"Checks whether this ChatSection's argument can be parsed as a boolean","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public Material asMaterialFromName() { return Material.getMaterial(raw.toUpperCase()); }","old_code_raw":"    public Material asMaterialFromName() {\n        return Material.getMaterial(arg.toUpperCase());\n    }\n","new_comment_raw":"Gets the material whose name is the same as the raw value (ignores case)","old_comment_raw":"Gets the material whose name is the same as the raw arg (ignores case)","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public ArrayList getAllImageSrcs() { return this.img_src_all; }","old_code_raw":"    public ArrayList getAllImageSrcs() {\n        return img_src_all;\n    }\n","new_comment_raw":"Get the list of src attributes for all images","old_comment_raw":"DOCUMENT ME!","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":11},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } \/\/ Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\"); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\"); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    \/\/ Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n","new_comment_raw":"Find the dependency path between two words in a sentence.","old_comment_raw":"Select the most common element of the given type in the given span.","label":1,"pre_label":0,"AST_level":11,"line_counts":64,"new_code_token_num":555},{"new_code_raw":"public static char[] union(char[]... list) { StringBuilder sb = new StringBuilder(); for (char[] characters : list) { for (int i = 0; i < list.length; i++) { if (!contains(sb, characters[i])) sb.append(list[i]); } } char[] toReturn = new char[sb.length()]; sb.getChars(0, sb.length(), toReturn, 0); Arrays.sort(toReturn); return toReturn; }","old_code_raw":"    public static char[] union(char[] c1, char[] c2) {\r\n    \tStringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < c1.length; i++) {\r\n            if (!contains(sb, c1[i]))\r\n                sb.append(c1[i]);\r\n        }\r\n        for (int i = 0; i < c2.length; i++) {\r\n            if (!contains(sb, c2[i]))\r\n                sb.append(c2[i]);\r\n        }\r\n        char[] c3 = new char[sb.length()];\r\n        sb.getChars(0, sb.length(), c3, 0);\r\n        Arrays.sort(c3);\r\n        return c3;\r\n    }\r\n","new_comment_raw":"Union multiple character arrays.","old_comment_raw":"Union two character arrays.","label":1,"pre_label":0,"AST_level":12,"line_counts":17,"new_code_token_num":107},{"new_code_raw":"public String getSourceTableName() { return ((source != null) ? source.getTableName() : null); }","old_code_raw":"\n\tpublic String getSourceTableName()\n\t{\n\t\treturn ( ( tableName != null) ? tableName.getTableName() : \n\t\t\t\t\t((source != null) ? source.getTableName() : null));\n\t}\n","new_comment_raw":"Get the name of the underlying(base) table this column comes from, if any.","old_comment_raw":"Get the name of the table this column comes from.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public ScheduledReporter build() { ScheduledReporter reporter; switch (influxdbVersion) { case V08: Influxdb influxdb = buildInfluxdb(); reporter = (executor == null) ? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics) : new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor) ; break; default: Sender s = buildSender(); reporter = executor == null ? new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer) : new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer, executor) ; } return reporter; }","old_code_raw":"\t\tpublic ScheduledReporter build(Influxdb influxdb) {\n\t\t\treturn executor == null\n\t\t\t\t\t? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics)\n\t\t\t\t\t: new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor)\n\t\t\t\t\t;\n\t\t}\n","new_comment_raw":"Builds a  ScheduledReporter with the given properties, sending metrics using the given InfluxDB.","old_comment_raw":"Builds a InfluxdbReporter with the given properties, sending metrics using the given Influxdb client.","label":1,"pre_label":0,"AST_level":9,"line_counts":22,"new_code_token_num":132},{"new_code_raw":"private PartitionTemplate assembleSar( final String name, final Configuration config, final Configuration assembly ) throws LoomException { final Configuration[] blockConfig = assembly.getChildren( \"block\" ); final ComponentTemplate[] blocks = buildBlocks( blockConfig, config ); final PartitionTemplate blockPartition = new PartitionTemplate( ContainerConstants.BLOCK_PARTITION, new String[]{ContainerConstants.LISTENER_PARTITION}, PartitionTemplate.EMPTY_SET, blocks ); final Configuration[] listenerConfig = assembly.getChildren( \"listener\" ); final ComponentTemplate[] listeners = buildBlockListeners( listenerConfig, config ); final PartitionTemplate listenerPartition = new PartitionTemplate( ContainerConstants.LISTENER_PARTITION, new String[ 0 ], PartitionTemplate.EMPTY_SET, listeners ); final PartitionTemplate[] partitions = new PartitionTemplate[]{blockPartition, listenerPartition}; return new PartitionTemplate( name, new String[ 0 ], partitions, ComponentTemplate.EMPTY_SET ); }","old_code_raw":"    private PartitionMetaData assembleSar( final String name,\n                                           final Configuration config,\n                                           final Configuration assembly )\n        throws LoomException\n    {\n        final Configuration[] blockConfig = assembly.getChildren( \"block\" );\n        final ComponentMetaData[] blocks = buildBlocks( blockConfig, config );\n        final PartitionMetaData blockPartition =\n            new PartitionMetaData( ContainerConstants.BLOCK_PARTITION,\n                                   new String[]{ContainerConstants.LISTENER_PARTITION},\n                                   PartitionMetaData.EMPTY_SET,\n                                   blocks );\n\n        final Configuration[] listenerConfig = assembly.getChildren( \"listener\" );\n        final ComponentMetaData[] listeners = buildBlockListeners( listenerConfig, config );\n        final PartitionMetaData listenerPartition =\n            new PartitionMetaData( ContainerConstants.LISTENER_PARTITION,\n                                   new String[ 0 ],\n                                   PartitionMetaData.EMPTY_SET,\n                                   listeners );\n\n        final PartitionMetaData[] partitions =\n            new PartitionMetaData[]{blockPartition, listenerPartition};\n\n        return new PartitionMetaData( name,\n                                      new String[ 0 ],\n                                      partitions,\n                                      ComponentMetaData.EMPTY_SET );\n    }\n","new_comment_raw":"Create a  PartitionTemplate object based on specified name and assembly configuration.","old_comment_raw":"Create a PartitionMetaData object based on specified name and assembly configuration.","label":1,"pre_label":0,"AST_level":8,"line_counts":31,"new_code_token_num":148},{"new_code_raw":"public static final Weblogger getRoller() { if (rollerInstance == null) { throw new IllegalStateException(\"Roller Weblogger has not been bootstrapped yet\"); } return rollerInstance; }","old_code_raw":"    public static final Roller getRoller() {\n        if (rollerInstance == null) {\n            throw new IllegalStateException(\"Roller Weblogger has not been bootstrapped yet\");\n        }\n        \n        return rollerInstance;\n    }\n","new_comment_raw":"Accessor to the Weblogger Weblogger business tier.","old_comment_raw":"Accessor to the Roller Weblogger business tier.","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":34},{"new_code_raw":"public static EBoolean endsWith(Expr<String> left, Expr<String> right) { return operationFactory.createBoolean(Ops.ENDSWITH, left, right); }","old_code_raw":"    public static EBoolean endsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return endsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.ENDSWITH_IC, left, right);\n        }\n    }\n","new_comment_raw":"Expr : left.endsWith(right)","old_comment_raw":"Expr : left.endsWith(right) (ignore case)","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public static List<Vulnerability> getAllVulnerabilities() { initializeIfEmpty(); return Collections.unmodifiableList(vulnerabilitiesI18NMap.getVulnerabilityList(Constant.getLocale().toString())); }","old_code_raw":"\tpublic static List<Vulnerability> getAllVulnerabilities() {\n\t\tif (vulns == null) {\n\t\t\tinit();\n\t\t}\n\t\treturn vulns;\n\t}\n","new_comment_raw":"Gets an unmodifiable  List containing all the  Vulnerability for the current active Locale.","old_comment_raw":"Gets an unmodifiable List containing all the Vulnerability loaded from the path Constant.VULNS_CONFIG.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) { final Object optionalObject = queryParameters.getOptionalObject(); final Serializable optionalId = queryParameters.getOptionalId(); final String optionalEntityName = queryParameters.getOptionalEntityName(); if ( optionalObject != null && optionalEntityName != null ) { return session.generateEntityKey( optionalId, session.getEntityPersister( optionalEntityName, optionalObject ) ); } else { return null; } }","old_code_raw":"\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n","new_comment_raw":"@param resultSet The result set from which to do the load.","old_comment_raw":"@param resultSet The result set from which to do the load.","label":0,"pre_label":1,"AST_level":8,"line_counts":19,"new_code_token_num":71},{"new_code_raw":"public double distanceTo(double x, double y, double z) { final double a = this.x - x; final double b = this.y - y; final double c = this.z - z; return Math.sqrt(a * a + b * b + c * c); }","old_code_raw":"\tpublic float distanceTo(float x, float y, float z) {\n\t\tfinal float a = this.x - x;\n\t\tfinal float b = this.y - y;\n\t\tfinal float c = this.z - z;\n\t\treturn (float) Math.sqrt(a * a + b * b + c * c);\n\t}\n","new_comment_raw":"@param double x The point x coordinate.","old_comment_raw":"@param float x The point x coordinate.","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":56},{"new_code_raw":"public void updatePetWithForm (Long petId, String name, String status) throws ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\"); } \/\/ create path and map variables String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"application\/x-www-form-urlencoded\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); if (name != null) { builder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8); } if (status != null) { builder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8); } HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { \/\/ normal form params formParams.put(\"name\", ApiInvoker.parameterToString(name)); formParams.put(\"status\", ApiInvoker.parameterToString(status)); } try { String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public void  updatePetWithForm (String petId, String name, String status) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"application\/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (name != null) {\n        builder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (status != null) {\n        builder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param petId ID of pet that needs to be updated","old_comment_raw":"@param petId ID of pet that needs to be updated","label":0,"pre_label":1,"AST_level":10,"line_counts":63,"new_code_token_num":377},{"new_code_raw":"public static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY) { if (model == null) { return null; } List<Triangle> triangles = model.getTriangles().stream() .map(triangle -> triangle.rotate(orientation)) .collect(Collectors.toList()); List<Vertex> vertices = model.getVertices().stream() .map(v -> v.rotate(orientation)) .collect(Collectors.toList()); Area clickBox = get2DGeometry(client, triangles, orientation, localX, localY); Area visibleAABB = getAABB(client, vertices, orientation, localX, localY); if (visibleAABB == null || clickBox == null) { return null; } clickBox.intersect(visibleAABB); return clickBox; }","old_code_raw":"\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int tileX, int tileY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, tileX, tileY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, tileX, tileY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n","new_comment_raw":"@param localY the y-axis coordinate of the tile","old_comment_raw":"@param tileY the y-axis coordinate of the tile","label":1,"pre_label":0,"AST_level":9,"line_counts":27,"new_code_token_num":143},{"new_code_raw":"public MultiIterator init(IndexSupport indexSupport){ this.indexSupport = indexSupport; this.iterators = new Iterator<?>[sources.size()]; this.lastEntry = new boolean[iterators.length]; this.values = new Object[iterators.length]; return this; }","old_code_raw":"    public MultiIterator init(IteratorFactory iteratorFactory){\n        this.iteratorFactory = iteratorFactory;\n        this.iterators = new Iterator<?>[sources.size()];\n        this.lastEntry = new boolean[iterators.length];\n        this.values = new Object[iterators.length];\n        return this;\n    }\n","new_comment_raw":"@param indexSupport","old_comment_raw":"@param iteratorFactory","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":46},{"new_code_raw":"@Deprecated public Graph executeSparqlQuery(ConstructQuery query, TripleCollection defaultGraph) { return (Graph) executeSparqlQuery((Query) query, defaultGraph); }","old_code_raw":"    @Deprecated\n    public ImmutableGraph executeSparqlQuery(ConstructQuery query,\n            Graph defaultGraph) {\n        return (ImmutableGraph) executeSparqlQuery((Query) query, defaultGraph);\n    }\n","new_comment_raw":"@param defaultGraph the default graph against which to execute the query if not FROM clause is present","old_comment_raw":"@param defaultGraph the default ImmutableGraph against which to execute the query if not FROM clause is present","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":28},{"new_code_raw":"private static String toString(Collection<TypedDependency> dependencies, boolean extraSep) { StringBuilder buf = new StringBuilder(); if (extraSep) { List<TypedDependency> extraDeps = new ArrayList<TypedDependency>(); for (TypedDependency td : dependencies) { if (td.extra()) { extraDeps.add(td); } else { buf.append(td.toString()).append('\\n'); } } \/\/ now we print the separator for extra dependencies, and print these if there are some if (!extraDeps.isEmpty()) { buf.append(\"======\\n\"); for (TypedDependency td : extraDeps) { buf.append(td.toString()).append('\\n'); } } } else { for (TypedDependency td : dependencies) { buf.append(td.toString()).append('\\n'); } } return buf.toString(); }","old_code_raw":"  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep, boolean includeTags) {\n    CoreLabel.OutputFormat labelFormat = (includeTags) ? CoreLabel.OutputFormat.VALUE_TAG_INDEX : CoreLabel.OutputFormat.VALUE_INDEX;\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps = new ArrayList<>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        } else {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n      \/\/ now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString(labelFormat)).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n","new_comment_raw":"@param extraSep boolean indicating whether the extra dependencies have to be printed separately, after the basic ones","old_comment_raw":"@param extraSep boolean indicating whether the extra dependencies have to be printed separately, after the basic ones","label":0,"pre_label":1,"AST_level":12,"line_counts":27,"new_code_token_num":175},{"new_code_raw":"public int compareTo(BaseSingleFieldPeriod other) { if (other.getClass() != getClass()) { throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass()); } int otherValue = other.getValue(); int thisValue = getValue(); if (thisValue > otherValue) { return 1; } if (thisValue < otherValue) { return -1; } return 0; }","old_code_raw":"    public int compareTo(Object other) {\n        if (other.getClass() != getClass()) {\n            throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass());\n        }\n        int otherValue = ((BaseSingleFieldPeriod) other).getValue();\n        int thisValue = getValue();\n        if (thisValue > otherValue) {\n            return 1;\n        }\n        if (thisValue < otherValue) {\n            return -1;\n        }\n        return 0;\n    }\n","new_comment_raw":"@param other the other period, must not be null","old_comment_raw":"@param other the other period, must not be null","label":0,"pre_label":1,"AST_level":9,"line_counts":15,"new_code_token_num":80},{"new_code_raw":"public boolean supports(AuthenticationToken token) { if ( log.isInfoEnabled() ) { log.info( \"Received null AuthenticationToken. Returning false for supports(token) implementation (can't \" + \"process null tokens).\" ); } return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass()); }","old_code_raw":"    public boolean supports(Class tokenClass) {\n        return getAuthenticationTokenClass().isAssignableFrom( tokenClass );\n    }\n","new_comment_raw":"@param token the token being submitted for authentication.","old_comment_raw":"@param tokenClass the class of the authenticationToken being submitted for authentication.","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":64},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        \/\/ Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        \/\/ Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n","new_comment_raw":"@param preview bitmap that can be recycled","old_comment_raw":"@param preview bitmap that can be recycled","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":92},{"new_code_raw":"private static String toString(Collection<TypedDependency> dependencies, boolean extraSep, boolean includeTags) { String labelFormat = (includeTags) ? \"value-tag-index\" : \"value-index\"; StringBuilder buf = new StringBuilder(); if (extraSep) { List<TypedDependency> extraDeps = new ArrayList<TypedDependency>(); for (TypedDependency td : dependencies) { if (td.extra()) { extraDeps.add(td); } else { buf.append(td.toString(labelFormat)).append('\\n'); } } \/\/ now we print the separator for extra dependencies, and print these if there are some if (!extraDeps.isEmpty()) { buf.append(\"======\\n\"); for (TypedDependency td : extraDeps) { buf.append(td.toString(labelFormat)).append('\\n'); } } } else { for (TypedDependency td : dependencies) { buf.append(td.toString(labelFormat)).append('\\n'); } } return buf.toString(); }","old_code_raw":"  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep) {\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps =  new ArrayList<TypedDependency>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        } else {\n          buf.append(td.toString(\"value-tag-index\")).append('\\n');\n        }\n      }\n      \/\/ now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString(\"value-tag-index\")).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString(\"value-tag-index\")).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n","new_comment_raw":"@param dependencies The TypedDependencies to print","old_comment_raw":"@param dependencies The TypedDependencies to print","label":0,"pre_label":1,"AST_level":12,"line_counts":27,"new_code_token_num":201},{"new_code_raw":"private boolean paramAppend(StringBuilder sb, String name, String value, ParameterParser parser) { boolean isEdited = false; if (name != null) { sb.append(name); isEdited = true; } if (value != null) { sb.append(parser.getDefaultKeyValueSeparator()); sb.append(value); isEdited = true; } return isEdited; }","old_code_raw":"    private boolean paramAppend(StringBuilder sb, String name, String value) {\n        boolean isEdited = false;\n        \n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        \n        if (value != null) {\n            sb.append('=');\n            sb.append(value);\n            isEdited = true;\n        }\n        \n        return isEdited;\n    }\n","new_comment_raw":"@param name Null = not to append parameter.","old_comment_raw":"@param name Null = not to append parameter.","label":0,"pre_label":1,"AST_level":7,"line_counts":17,"new_code_token_num":68},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData(); }","old_code_raw":"  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    return uploadFileWithRequiredFileWithHttpInfo(petId, file, additionalMetadata).getData();\n      }\n","new_comment_raw":"@param requiredFile file to upload (required)","old_comment_raw":"@param file file to upload (required)","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public Optional<GraphQLError> add(SDLDefinition definition) { \/\/ extensions if (definition instanceof ObjectTypeExtensionDefinition) { ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition; return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName); } else if (definition instanceof InterfaceTypeExtensionDefinition) { InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition; return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName); } else if (definition instanceof UnionTypeExtensionDefinition) { UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition; return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName); } else if (definition instanceof EnumTypeExtensionDefinition) { EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition; return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName); } else if (definition instanceof ScalarTypeExtensionDefinition) { ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition; return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName); } else if (definition instanceof InputObjectTypeExtensionDefinition) { InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition; return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName); \/\/ \/\/ normal } else if (definition instanceof ScalarTypeDefinition) { ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition; return define(scalarTypes, scalarTypes, newEntry); } else if (definition instanceof TypeDefinition) { TypeDefinition newEntry = (TypeDefinition) definition; return define(types, types, newEntry); } else if (definition instanceof DirectiveDefinition) { DirectiveDefinition newEntry = (DirectiveDefinition) definition; return define(directiveDefinitions, directiveDefinitions, newEntry); } else if (definition instanceof SchemaDefinition) { SchemaDefinition newSchema = (SchemaDefinition) definition; if (schema != null) { return Optional.of(new SchemaRedefinitionError(this.schema, newSchema)); } else { schema = newSchema; } } else { return Assert.assertShouldNeverHappen(); } return Optional.empty(); }","old_code_raw":"    public Optional<GraphQLError> add(Definition definition) {\n        \/\/ extensions\n        if (definition instanceof ObjectTypeExtensionDefinition) {\n            ObjectTypeExtensionDefinition newEntry = (ObjectTypeExtensionDefinition) definition;\n            return defineExt(typeExtensions, newEntry, ObjectTypeExtensionDefinition::getName);\n        } else if (definition instanceof InterfaceTypeExtensionDefinition) {\n            InterfaceTypeExtensionDefinition newEntry = (InterfaceTypeExtensionDefinition) definition;\n            return defineExt(interfaceTypeExtensions, newEntry, InterfaceTypeExtensionDefinition::getName);\n        } else if (definition instanceof UnionTypeExtensionDefinition) {\n            UnionTypeExtensionDefinition newEntry = (UnionTypeExtensionDefinition) definition;\n            return defineExt(unionTypeExtensions, newEntry, UnionTypeExtensionDefinition::getName);\n        } else if (definition instanceof EnumTypeExtensionDefinition) {\n            EnumTypeExtensionDefinition newEntry = (EnumTypeExtensionDefinition) definition;\n            return defineExt(enumTypeExtensions, newEntry, EnumTypeExtensionDefinition::getName);\n        } else if (definition instanceof ScalarTypeExtensionDefinition) {\n            ScalarTypeExtensionDefinition newEntry = (ScalarTypeExtensionDefinition) definition;\n            return defineExt(scalarTypeExtensions, newEntry, ScalarTypeExtensionDefinition::getName);\n        } else if (definition instanceof InputObjectTypeExtensionDefinition) {\n            InputObjectTypeExtensionDefinition newEntry = (InputObjectTypeExtensionDefinition) definition;\n            return defineExt(inputObjectTypeExtensions, newEntry, InputObjectTypeExtensionDefinition::getName);\n            \/\/\n            \/\/ normal\n        } else if (definition instanceof ScalarTypeDefinition) {\n            ScalarTypeDefinition newEntry = (ScalarTypeDefinition) definition;\n            return define(scalarTypes, scalarTypes, newEntry);\n        } else if (definition instanceof TypeDefinition) {\n            TypeDefinition newEntry = (TypeDefinition) definition;\n            return define(types, types, newEntry);\n        } else if (definition instanceof DirectiveDefinition) {\n            DirectiveDefinition newEntry = (DirectiveDefinition) definition;\n            return define(directiveDefinitions, directiveDefinitions, newEntry);\n        } else if (definition instanceof SchemaDefinition) {\n            SchemaDefinition newSchema = (SchemaDefinition) definition;\n            if (schema != null) {\n                return Optional.of(new SchemaRedefinitionError(this.schema, newSchema));\n            } else {\n                schema = newSchema;\n            }\n        }\n        return Optional.empty();\n    }\n","new_comment_raw":"@param definition the definition to add","old_comment_raw":"@param definition the definition to add","label":0,"pre_label":1,"AST_level":20,"line_counts":44,"new_code_token_num":328},{"new_code_raw":"public Action timedout(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { AtmosphereResourceImpl re; long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { \/\/ The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); \/\/ Something went wrong. if (request == null || response == null) { logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response); return timedoutAction; } re = (AtmosphereResourceImpl) request.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE); if (re != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = re.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster)b).broadcastOnResume(re); } if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(re); } return timedoutAction; }","old_code_raw":"    public Action timedout(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl re;\n        long l = (Long) req.getAttribute(MAX_INACTIVE);\n        if (l == -1) {\n            \/\/ The closedDetector closed the connection.\n            return timedoutAction;            \n        }\n        req.setAttribute(MAX_INACTIVE, (long)-1);\n\n        \/\/ Something went wrong.\n        if (req == null || res == null) {\n            logger.warning(\"Invalid Request\/Response: \" + req + \"\/\" + res);\n            return timedoutAction;\n        }\n\n        re = (AtmosphereResourceImpl) req.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE);\n\n        if (re != null) {\n            re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n            Broadcaster b = re.getBroadcaster();\n            if (b instanceof DefaultBroadcaster) {\n                ((DefaultBroadcaster)b).broadcastOnResume(re);\n            }\n\n            if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) {\n                re.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                        (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT));\n            }\n            invokeAtmosphereHandler(re);\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"@param response the  HttpServletResponse","old_comment_raw":"@param res the HttpServletResponse","label":1,"pre_label":0,"AST_level":13,"line_counts":37,"new_code_token_num":198},{"new_code_raw":"public static int availablePort(int preferred) { int rtn = -1; try { rtn = tryPort(preferred); } catch (IOException ignored) { } return rtn; }","old_code_raw":"    public static int availablePort(int prefered) {\n        int rtn = -1;\n        try {\n            rtn = tryPort(prefered);\n        } catch (IOException e) {\n\n        }\n        return rtn;\n    }\n","new_comment_raw":"@param preferred preferred port","old_comment_raw":"@param prefered","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":34},{"new_code_raw":"public synchronized <T extends AbstractTypeServerPluginContainer> T getPluginContainerByPlugin(String pluginName) { for (AbstractTypeServerPluginContainer pc : this.pluginContainers.values()) { if (null != pc.getPluginManager().getPluginEnvironment(pluginName)) { return (T) pc; } } return null; }","old_code_raw":"    public synchronized <T extends AbstractTypeServerPluginContainer> T getPluginContainerByPlugin(PluginKey pluginKey) {\n        for (AbstractTypeServerPluginContainer pc : this.pluginContainers.values()) {\n            try {\n                if (pc.getSupportedServerPluginType().equals(new ServerPluginType(pluginKey.getPluginType()))) {\n                    if (null != pc.getPluginManager().getPluginEnvironment(pluginKey.getPluginName())) {\n                        return (T) pc;\n                    }\n                }\n            } catch (Exception skip) {\n                \/\/ should never really happen\n                log.error(\"Bad plugin key: \" + pluginKey);\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@param pluginName","old_comment_raw":"@param pluginKey","label":1,"pre_label":0,"AST_level":9,"line_counts":10,"new_code_token_num":50},{"new_code_raw":"private boolean paramAppend(StringBuilder sb, String name, String value) { boolean isEdited = false; if (name != null) { sb.append(name); isEdited = true; } if (value != null) { sb.append('='); sb.append(value); isEdited = true; } return isEdited; }","old_code_raw":"    private boolean paramAppend(StringBuffer sb, String name, String value) {\n        boolean isEdited = false;\n        if (name != null) {\n            sb.append(name);\n            isEdited = true;\n        }\n        if (value != null) {\n            sb.append('=');\n            sb.append(value);\n            isEdited = true;\n        }\n        return isEdited;\n    }\n","new_comment_raw":"@param sb","old_comment_raw":"@param sb","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":63},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(String type, StructuredTextEnvironment environment) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$ return getStatefulExpert(handler, environment); }","old_code_raw":"\tstatic public ISTextExpert getStatefulExpert(String type, STextEnvironment environment) {\n\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n","new_comment_raw":"@param type the identifier for the required type handler. This identifier may be one of those listed in  StructuredTextTypeHandlerFactory or it may be have been registered by a plug-in.","old_comment_raw":"@param type the identifier for the required type handler. This identifier may be one of those listed in STextTypeHandlerFactory or it may be have been registered by a plug-in.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"public Order placeOrder(Order order) throws ApiException { ApiResponse<Order> resp = placeOrderWithHttpInfo(order); return resp.getData(); }","old_code_raw":"    public Order placeOrder(Order body) throws ApiException {\n        ApiResponse<Order> resp = placeOrderWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"@param order order placed for purchasing the pet (required)","old_comment_raw":"@param body order placed for purchasing the pet (required)","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public FilterBuilder addFilter(Class<? extends Filter> klass, String urlPattern) { final FilterHolder holder = new FilterHolder(checkNotNull(klass)); final FilterBuilder filterConfig = new FilterBuilder(holder, handler); filterConfig.addUrlPattern(checkNotNull(urlPattern)); return filterConfig; }","old_code_raw":"    public FilterRegistration.Dynamic addFilter(String name, Class<? extends Filter> klass) {\n        final FilterHolder holder = new FilterHolder(checkNotNull(klass));\n        holder.setName(name);\n        handler.getServletHandler().addFilter(holder);\n        return holder.getRegistration();\n    }\n","new_comment_raw":"@param klass the filter class","old_comment_raw":"@param name the filter's name","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":50},{"new_code_raw":"public RuntimeException translate(String sql, List<Object> bindings, SQLException ex) { return exceptionTranslator.translate(sql, bindings, ex); }","old_code_raw":"    public RuntimeException translate(String sql, SQLException ex) {\n        return exceptionTranslator.translate(sql, ex);\n    }\n","new_comment_raw":"@param ex","old_comment_raw":"@param ex","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception { return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>()); }","old_code_raw":"    public synchronized final List<String> getDependentModulesRecursively(final String id) throws Exception {\r\n        final List<String> res = new ArrayList<String>();\r\n        for (final String depModule : getDependentModules(id)) {\r\n            res.add(depModule);\r\n            \/\/ the graph has no cycle, so we don't need to protected against infinite loop\r\n\r\n            res.addAll(this.getDependentModulesRecursively(depModule));\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n","new_comment_raw":"@param ref the module.","old_comment_raw":"@param id the module.","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":26},{"new_code_raw":"public String getTypeName(int code, long length, int precision, int scale) throws HibernateException { String result = typeNames.get( code, length, precision, scale ); if ( result == null ) { throw new HibernateException( \"No type mapping for java.sql.Types code: \" + code + \", length: \" + length ); } return result; }","old_code_raw":"\tpublic String getTypeName(int code, int length, int precision, int scale) throws HibernateException {\n\t\tString result = typeNames.get( code, length, precision, scale );\n\t\tif ( result == null ) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"No type mapping for java.sql.Types code: \" +\n\t\t\t\t\tcode +\n\t\t\t\t\t\", length: \" +\n\t\t\t\t\tlength\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n","new_comment_raw":"@param scale The datatype scale","old_comment_raw":"@param scale The datatype scale","label":0,"pre_label":1,"AST_level":10,"line_counts":13,"new_code_token_num":71},{"new_code_raw":"public PMetadata getCache(PGraphics renderer) { if (cacheMap == null) return null; return cacheMap.get(renderer); }","old_code_raw":"  public Object getCache(Object parent) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(parent);\n  }\n","new_comment_raw":"@param renderer The PGraphics renderer associated to the image","old_comment_raw":"@param parent The PGraphics object (or any object, really) associated","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) { final long endTime = System.currentTimeMillis() + timeout; while (true) { final boolean timedOut = System.currentTimeMillis() > endTime; if (timedOut){ return false; } sleeper.sleep(); final boolean foundAnyTextView = searcher.searchFor(TextView.class, text, expectedMinimumNumberOfMatches, scroll); if (foundAnyTextView){ return true; } final boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll); if (foundAnyEditText){ return true; } } }","old_code_raw":"\tpublic boolean waitForText(String text, int matches, long timeout, boolean scroll) {\n        final long endTime = System.currentTimeMillis() + timeout;\n\n\t\twhile (true) {\n\t\t\tfinal boolean timedOut = System.currentTimeMillis() > endTime;\n\t\t\tif (timedOut){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tsleeper.sleep();\n\n\t\t\tfinal boolean foundAnyTextView = searcher.searchFor(TextView.class, text, matches, scroll);\n\t\t\tif (foundAnyTextView){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfinal boolean foundAnyEditText = searcher.searchFor(EditText.class, text, 1, scroll);\n\t\t\tif (foundAnyEditText){\n\t\t\t\treturn true;\n\t\t\t}\n        }\n    }\n","new_comment_raw":"@param scroll  true if scrolling should be performed","old_comment_raw":"@param scroll true if scrolling should be performed","label":0,"pre_label":1,"AST_level":9,"line_counts":23,"new_code_token_num":107},{"new_code_raw":"public CodegenModel fromModel(String name, Schema model, Map<String, Schema> allDefinitions) { CodegenModel codegenModel = super.fromModel(name, model, allDefinitions); return codegenModel; }","old_code_raw":"    public CodegenModel fromModel(String name, Model model, Map<String, Model> allDefinitions) {\n        CodegenModel codegenModel = super.fromModel(name, model, allDefinitions);\n        return codegenModel;\n    }\n","new_comment_raw":"@param model OpenAPI Model object","old_comment_raw":"@param model Swagger Model object","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":33},{"new_code_raw":"private FileSelection expandSelectionFromMetadataCache(FileSelection selection, List<Path> metaFilePaths) throws IOException { \/\/ get the metadata for the root directory by reading the metadata file \/\/ parquetTableMetadata contains the metadata for all files in the selection root folder, but we need to make sure \/\/ we only select the files that are part of selection (by setting fileSet appropriately) \/\/ get (and set internal field) the metadata for the directory by reading the metadata file FileSystem processUserFileSystem = ImpersonationUtil.createFileSystem(ImpersonationUtil.getProcessUserName(), fs.getConf()); parquetTableMetadata = Metadata.readBlockMeta(processUserFileSystem, metaFilePaths, metaContext, readerConfig); if (ignoreExpandingSelection(parquetTableMetadata)) { return selection; } if (corruptDatesAutoCorrected) { ParquetReaderUtility.correctDatesInMetadataCache(this.parquetTableMetadata); } ParquetReaderUtility.transformBinaryInMetadataCache(parquetTableMetadata, readerConfig); List<FileStatus> fileStatuses = selection.getStatuses(fs); if (fileSet == null) { fileSet = new HashSet<>(); } final Path first = fileStatuses.get(0).getPath(); if (fileStatuses.size() == 1 && selection.getSelectionRoot().equals(first)) { \/\/ we are selecting all files from selection root. Expand the file list from the cache for (MetadataBase.ParquetFileMetadata file : parquetTableMetadata.getFiles()) { fileSet.add(file.getPath()); } } else if (selection.isExpandedPartial() && !selection.hadWildcard() && cacheFileRoot != null) { if (selection.wasAllPartitionsPruned()) { \/\/ if all partitions were previously pruned, we only need to read 1 file (for the schema) fileSet.add(this.parquetTableMetadata.getFiles().get(0).getPath()); } else { \/\/ we are here if the selection is in the expanded_partial state (i.e it has directories). We get the \/\/ list of files from the metadata cache file that is present in the cacheFileRoot directory and populate \/\/ the fileSet. However, this is *not* the final list of files that will be scanned in execution since the \/\/ second phase of partition pruning will apply on the files and modify the file selection appropriately. for (MetadataBase.ParquetFileMetadata file : this.parquetTableMetadata.getFiles()) { fileSet.add(file.getPath()); } } } else { \/\/ we need to expand the files from fileStatuses for (FileStatus status : fileStatuses) { Path currentCacheFileRoot = status.getPath(); if (status.isDirectory()) { \/\/ TODO [DRILL-4496] read the metadata cache files in parallel \/\/ Depending on the version of metadata this may represent more than 1 metadata file paths. List<Path> metaPaths = populateMetaPaths(currentCacheFileRoot, fs); MetadataBase.ParquetTableMetadataBase metadata = Metadata.readBlockMeta(processUserFileSystem, metaPaths, metaContext, readerConfig); if (ignoreExpandingSelection(metadata)) { return selection; } for (MetadataBase.ParquetFileMetadata file : metadata.getFiles()) { fileSet.add(file.getPath()); } } else { final Path path = Path.getPathWithoutSchemeAndAuthority(currentCacheFileRoot); fileSet.add(path); } } } if (fileSet.isEmpty()) { \/\/ no files were found, most likely we tried to query some empty sub folders logger.warn(\"The table is empty but with outdated invalid metadata cache files. Please, delete them.\"); return null; } List<Path> fileNames = new ArrayList<>(fileSet); \/\/ when creating the file selection, set the selection root without the URI prefix \/\/ The reason is that the file names above have been created in the form \/\/ \/a\/b\/c.parquet and the format of the selection root must match that of the file names \/\/ otherwise downstream operations such as partition pruning can break. Path metaRootPath = Path.getPathWithoutSchemeAndAuthority(selection.getSelectionRoot()); this.selectionRoot = metaRootPath; \/\/ Use the FileSelection constructor directly here instead of the FileSelection.create() method \/\/ because create() changes the root to include the scheme and authority; In future, if create() \/\/ is the preferred way to instantiate a file selection, we may need to do something different... \/\/ WARNING: file statuses and file names are inconsistent FileSelection newSelection = new FileSelection(selection.getStatuses(fs), fileNames, metaRootPath, cacheFileRoot, selection.wasAllPartitionsPruned()); newSelection.setExpandedFully(); newSelection.setMetaContext(metaContext); return newSelection; }","old_code_raw":"  private FileSelection expandSelectionFromMetadataCache(FileSelection selection, Path metaFilePath) throws IOException {\n    \/\/ get the metadata for the root directory by reading the metadata file\n    \/\/ parquetTableMetadata contains the metadata for all files in the selection root folder, but we need to make sure\n    \/\/ we only select the files that are part of selection (by setting fileSet appropriately)\n\n    \/\/ get (and set internal field) the metadata for the directory by reading the metadata file\n    FileSystem processUserFileSystem = ImpersonationUtil.createFileSystem(ImpersonationUtil.getProcessUserName(), fs.getConf());\n    parquetTableMetadata = Metadata.readBlockMeta(processUserFileSystem, metaFilePath, metaContext, readerConfig);\n    if (ignoreExpandingSelection(parquetTableMetadata)) {\n      return selection;\n    }\n    if (corruptDatesAutoCorrected) {\n      ParquetReaderUtility.correctDatesInMetadataCache(this.parquetTableMetadata);\n    }\n    ParquetReaderUtility.transformBinaryInMetadataCache(parquetTableMetadata, readerConfig);\n    List<FileStatus> fileStatuses = selection.getStatuses(fs);\n\n    if (fileSet == null) {\n      fileSet = new HashSet<>();\n    }\n\n    final Path first = fileStatuses.get(0).getPath();\n    if (fileStatuses.size() == 1 && selection.getSelectionRoot().equals(first)) {\n      \/\/ we are selecting all files from selection root. Expand the file list from the cache\n      for (MetadataBase.ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n        fileSet.add(file.getPath());\n      }\n\n    } else if (selection.isExpandedPartial() && !selection.hadWildcard() && cacheFileRoot != null) {\n      if (selection.wasAllPartitionsPruned()) {\n        \/\/ if all partitions were previously pruned, we only need to read 1 file (for the schema)\n        fileSet.add(this.parquetTableMetadata.getFiles().get(0).getPath());\n      } else {\n        \/\/ we are here if the selection is in the expanded_partial state (i.e it has directories).  We get the\n        \/\/ list of files from the metadata cache file that is present in the cacheFileRoot directory and populate\n        \/\/ the fileSet. However, this is *not* the final list of files that will be scanned in execution since the\n        \/\/ second phase of partition pruning will apply on the files and modify the file selection appropriately.\n        for (MetadataBase.ParquetFileMetadata file : this.parquetTableMetadata.getFiles()) {\n          fileSet.add(file.getPath());\n        }\n      }\n    } else {\n      \/\/ we need to expand the files from fileStatuses\n      for (FileStatus status : fileStatuses) {\n        Path currentCacheFileRoot = status.getPath();\n        if (status.isDirectory()) {\n          \/\/TODO [DRILL-4496] read the metadata cache files in parallel\n          Path metaPath = new Path(currentCacheFileRoot, Metadata.METADATA_FILENAME);\n          MetadataBase.ParquetTableMetadataBase metadata = Metadata.readBlockMeta(processUserFileSystem, metaPath, metaContext, readerConfig);\n          if (ignoreExpandingSelection(metadata)) {\n            return selection;\n          }\n          for (MetadataBase.ParquetFileMetadata file : metadata.getFiles()) {\n            fileSet.add(file.getPath());\n          }\n        } else {\n          final Path path = Path.getPathWithoutSchemeAndAuthority(currentCacheFileRoot);\n          fileSet.add(path);\n        }\n      }\n    }\n\n    if (fileSet.isEmpty()) {\n      \/\/ no files were found, most likely we tried to query some empty sub folders\n      logger.warn(\"The table is empty but with outdated invalid metadata cache files. Please, delete them.\");\n      return null;\n    }\n\n    List<Path> fileNames = new ArrayList<>(fileSet);\n\n    \/\/ when creating the file selection, set the selection root without the URI prefix\n    \/\/ The reason is that the file names above have been created in the form\n    \/\/ \/a\/b\/c.parquet and the format of the selection root must match that of the file names\n    \/\/ otherwise downstream operations such as partition pruning can break.\n    Path metaRootPath = Path.getPathWithoutSchemeAndAuthority(selection.getSelectionRoot());\n    this.selectionRoot = metaRootPath;\n\n    \/\/ Use the FileSelection constructor directly here instead of the FileSelection.create() method\n    \/\/ because create() changes the root to include the scheme and authority; In future, if create()\n    \/\/ is the preferred way to instantiate a file selection, we may need to do something different...\n    \/\/ WARNING: file statuses and file names are inconsistent\n    FileSelection newSelection = new FileSelection(selection.getStatuses(fs), fileNames, metaRootPath, cacheFileRoot,\n        selection.wasAllPartitionsPruned());\n\n    newSelection.setExpandedFully();\n    newSelection.setMetaContext(metaContext);\n    return newSelection;\n  }\n","new_comment_raw":"@param metaFilePaths metadata cache file path","old_comment_raw":"@param metaFilePath metadata cache file path","label":1,"pre_label":0,"AST_level":14,"line_counts":90,"new_code_token_num":815},{"new_code_raw":"public PumpEnactResult applyAPSRequest(APSResult request) { request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!isInitialized()) { result = new PumpEnactResult(); result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized); result.enacted = false; result.success = false; log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized)); return result; } if (isSuspended()) { result = new PumpEnactResult(); result.comment = MainApp.sResources.getString(R.string.pumpsuspended); result.enacted = false; result.success = false; log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended)); return result; } if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: \" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: cancelTempBasal()\"); result = cancelTempBasal(false); } else { result = new PumpEnactResult(); result.absolute = request.rate; result.duration = 0; result.enacted = false; result.comment = \"Basal set correctly\"; result.success = true; if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: Basal set correctly\"); } } else if (isTempBasalInProgress() && getTempBasalRemainingMinutesFromHistory() > 5 && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) { result = new PumpEnactResult(); result.absolute = getTempBasalAbsoluteRateHistory(); result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes(); result.enacted = false; result.comment = \"Temp basal set correctly\"; result.success = true; if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: Temp basal set correctly\"); } else { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: setTempBasalAbsolute()\"); result = setTempBasalAbsolute(request.rate, request.duration); } return result; }","old_code_raw":"    public boolean applyAPSRequest(APSResult request, Callback callback) {\n        PumpInterface pump = getActivePump();\n        request.rate = applyBasalConstraints(request.rate);\n\n        if (!pump.isInitialized()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (pump.isSuspended()) {\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            if (callback != null) {\n                callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run();\n            }\n            return false;\n        }\n\n        if (request.smb != 0) {\n            long lastSMBTime = getLastBolusTime();\n            if (lastSMBTime != 0 && lastSMBTime + 4.5 * 60 * 1000 > System.currentTimeMillis()) {\n                log.debug(\"SMB requsted but still in 5 min interval\");\n            } else {\n                DetailedBolusInfo detailedBolusInfo = new DetailedBolusInfo();\n                detailedBolusInfo.eventType = CareportalEvent.CORRECTIONBOLUS;\n                detailedBolusInfo.insulin = request.smb;\n                detailedBolusInfo.isSMB = true;\n                detailedBolusInfo.source = Source.USER;\n                getCommandQueue().bolus(detailedBolusInfo, callback);\n            }\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                getCommandQueue().cancelTempBasal(false, callback);\n                return true;\n            } else {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n                if (callback != null) {\n                    callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run();\n                }\n                return false;\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n            if (callback != null) {\n                callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run();\n            }\n            return false;\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback);\n            return true;\n        }\n    }\n","new_comment_raw":"@param request","old_comment_raw":"@param request","label":0,"pre_label":1,"AST_level":10,"line_counts":58,"new_code_token_num":385},{"new_code_raw":"protected AtmosphereHandlerWrapper map(AtmosphereRequest req) throws ServletException { String path; if (req.getPathInfo() != null) { path = req.getServletPath() + req.getPathInfo(); } else { path = req.getServletPath(); } if (path == null || path.length() <= 1) { path = \"\/all\"; } AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path); if (atmosphereHandlerWrapper == null) { atmosphereHandlerWrapper = map(\"\/all\"); } if (atmosphereHandlerWrapper == null) { throw new AtmosphereMappingException(\"No AtmosphereHandler maps request for \" + path); } config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster, atmosphereHandlerWrapper.broadcaster.getID()); return atmosphereHandlerWrapper; }","old_code_raw":"    protected AtmosphereHandlerWrapper map(HttpServletRequest req) throws ServletException {\n        String path;\n        if (req.getPathInfo() != null) {\n            path = req.getServletPath() + req.getPathInfo();\n        } else {\n            path = req.getServletPath();\n        }\n        if (path == null || path.length() <= 1) {\n            path = \"\/all\";\n        }\n\n        AtmosphereHandlerWrapper atmosphereHandlerWrapper = map(path);\n        if (atmosphereHandlerWrapper == null) {\n            atmosphereHandlerWrapper = map(\"\/all\");\n        }\n\n        if (atmosphereHandlerWrapper == null) {\n            throw new AtmosphereMappingException(\"No AtmosphereHandler maps request for \" + path);\n        }\n        config.getBroadcasterFactory().add(atmosphereHandlerWrapper.broadcaster,\n                atmosphereHandlerWrapper.broadcaster.getID());\n        return atmosphereHandlerWrapper;\n    }\n","new_comment_raw":"@param req the  AtmosphereResponse","old_comment_raw":"@param req the HttpServletResponse","label":1,"pre_label":0,"AST_level":8,"line_counts":24,"new_code_token_num":129},{"new_code_raw":"public static boolean simpleMatch(Collection<String> patterns, String str) { if (patterns != null) { for (String pattern : patterns) { if (simpleMatch(pattern, str)) { return true; } } } return false; }","old_code_raw":"    public static boolean simpleMatch(List<String> patterns, String str) {\n        if (patterns != null) {\n            for (String pattern : patterns) {\n                if (simpleMatch(pattern, str)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n","new_comment_raw":"@param str the String to match","old_comment_raw":"@param str the String to match","label":0,"pre_label":1,"AST_level":10,"line_counts":11,"new_code_token_num":48},{"new_code_raw":"private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) { \/\/ Pre-checks if (sessions.isEmpty()) { return null; } List<HttpSession> matchingSessions = new LinkedList<>(sessions); for (String token : tokens) { \/\/ Get the corresponding cookie from the cookies list HttpCookie matchingCookie = null; for (HttpCookie cookie : cookies) { if (cookie.getName().equals(token)) { matchingCookie = cookie; break; } } \/\/ Filter the sessions that do not match the cookie value Iterator<HttpSession> it = matchingSessions.iterator(); while (it.hasNext()) { if (!it.next().matchesToken(token, matchingCookie)) { it.remove(); } } } \/\/ Return the matching session if (matchingSessions.size() >= 1) { if (matchingSessions.size() > 1) { log.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite() + \". Using first one.\"); } return matchingSessions.get(0); } return null; }","old_code_raw":"\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\n\t\treturn CookieBasedSessionManagementHelper.getMatchingHttpSession(sessions, cookies, siteTokens);\n\t}\n","new_comment_raw":"@param cookies the cookies present in the request header of the message","old_comment_raw":"@param cookies the cookies present in the request header of the message","label":0,"pre_label":1,"AST_level":11,"line_counts":38,"new_code_token_num":204},{"new_code_raw":"public static BooleanOperation booleanOperation(Operator operator, Expression<?>... args) { return predicate(operator, args); }","old_code_raw":"    public static BooleanOperation booleanOperation(Operator operation, Expression<?>... args) {\n        return predicate(operation, args);\n    }\n","new_comment_raw":"@param operator operator","old_comment_raw":"@param operation","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) { return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld); }","old_code_raw":"    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFloder, String filename, boolean isRange, boolean isDeleteOld) {\n        return new RestDownloadRequestor(url, requestMethod, fileFloder, filename, isRange, isDeleteOld);\n    }\n","new_comment_raw":"@param filename Filename","old_comment_raw":"@param filename Filename","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":42},{"new_code_raw":"public int compareTo(Object reference) { ServiceReference other = (ServiceReference) reference; Long id = (Long) getProperty(Constants.SERVICE_ID); Long otherId = (Long) other.getProperty(Constants.SERVICE_ID); if (id.equals(otherId)) { return 0; \/\/ same service } Integer rank = (Integer) getProperty(Constants.SERVICE_RANKING); Integer otherRank = (Integer) other .getProperty(Constants.SERVICE_RANKING); \/\/ If no rank, then spec says it defaults to zero. rank = (rank == null) ? new Integer(0) : rank; otherRank = (otherRank == null) ? new Integer(0) : otherRank; \/\/ Sort by rank in ascending order. if (rank.compareTo(otherRank) < 0) { return -1; \/\/ lower rank } else if (rank.compareTo(otherRank) > 0) { return 1; \/\/ higher rank } \/\/ If ranks are equal, then sort by service id in descending order. return (id.compareTo(otherId) < 0) ? 1 : -1; }","old_code_raw":"    public int compareTo(Object arg0) {\r\n        throw new UnsupportedOperationException(\"This feature has not yet been implemented.\");\r\n\r\n    }\r\n","new_comment_raw":"@param reference the service reference","old_comment_raw":"@param arg0 the object","label":1,"pre_label":0,"AST_level":7,"line_counts":31,"new_code_token_num":196},{"new_code_raw":"protected boolean addCondition(StringBuilder buffer, String on) { if ( StringHelper.isNotEmpty( on ) ) { if ( !on.startsWith( \" and\" ) ) buffer.append( \" and \" ); buffer.append( on ); return true; } else { return false; } }","old_code_raw":"\tprotected boolean addCondition(StringBuffer buffer, String on) {\n\t\tif ( StringHelper.isNotEmpty( on ) ) {\n\t\t\tif ( !on.startsWith( \" and\" ) ) buffer.append( \" and \" );\n\t\t\tbuffer.append( on );\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n","new_comment_raw":"@param buffer The buffer to append the 'on' condition to.","old_comment_raw":"@param buffer The buffer to append the 'on' condition to.","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":56},{"new_code_raw":"public static SemgrexPattern compile(String semgrex) { \/\/ TODO: make this threadsafe by making SemgrexParser threadsafe. \/\/ TODO: make semgrex parser objects non-public try { SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\")); SemgrexPattern newPattern = parser.Root(); newPattern.setPatternString(semgrex); return newPattern; } catch (ParseException ex) { throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex); } catch (TokenMgrError er) { throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er); } }","old_code_raw":"  public static SemgrexPattern compile(String semgrex, Env env) {\n    try {\n      SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\"));\n      SemgrexPattern newPattern = parser.Root();\n      newPattern.setEnv(env);\n      newPattern.patternString = semgrex;\n      return newPattern;\n    } catch (ParseException ex) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex);\n    } catch (TokenMgrError er) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er);\n    }\n  }\n","new_comment_raw":"@param semgrex the pattern string","old_comment_raw":"@param semgrex the pattern string","label":0,"pre_label":1,"AST_level":9,"line_counts":15,"new_code_token_num":114},{"new_code_raw":"private static CoreLabel fromProto(CoreNLPProtos.Token proto) { CoreLabel word = new CoreLabel(); \/\/ Required fields word.setWord(proto.getWord()); \/\/ Optional fields if (proto.hasPos()) { word.setTag(proto.getPos()); } if (proto.hasValue()) { word.setValue(proto.getValue()); } if (proto.hasCategory()) { word.setCategory(proto.getCategory()); } if (proto.hasBefore()) { word.setBefore(proto.getBefore()); } if (proto.hasAfter()) { word.setAfter(proto.getAfter()); } if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); } if (proto.hasNer()) { word.setNER(proto.getNer()); } if (proto.hasLemma()) { word.setLemma(proto.getLemma()); } if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); } if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); } if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); } if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); } if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); } if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); } if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); } if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); } if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); } if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); } if (proto.getXmlContextCount() > 0) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); } if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); } \/\/ Non-default annotators if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); } if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); } if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); } \/\/ Return return word; }","old_code_raw":"  private static CoreLabel fromProto(CoreMapProtos.CoreLabel proto) {\n    CoreLabel word = new CoreLabel();\n    \/\/ Required fields\n    word.setWord(proto.getWord());\n    \/\/ Optional fields\n    if (proto.hasPos()) { word.setTag(proto.getPos()); }\n    if (proto.hasValue()) { word.setValue(proto.getValue()); }\n    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }\n    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }\n    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }\n    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }\n    if (proto.hasNer()) { word.setNER(proto.getNer()); }\n    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }\n    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }\n    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }\n    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }\n    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }\n    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }\n    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }\n    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }\n    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }\n    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }\n    \/\/ Return\n    return word;\n  }\n","new_comment_raw":"@param proto The serialized protobuf to read the CoreLabel from.","old_comment_raw":"@param proto The serialized protobuf to read the CoreLabel from.","label":0,"pre_label":1,"AST_level":8,"line_counts":33,"new_code_token_num":504},{"new_code_raw":"protected static TableId parse(String[] parts, int numParts, boolean useCatalogBeforeSchema) { if (numParts == 0) return null; if (numParts == 1) return new TableId(null, null, parts[0]); \/\/ table only if (numParts == 2) { if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); \/\/ catalog & table only return new TableId(null, parts[0], parts[1]); \/\/ catalog & table only } return new TableId(parts[0], parts[1], parts[2]); \/\/ catalog & table only }","old_code_raw":"    public static TableId parse(String str, char delimiter, boolean useCatalogBeforeSchema) {\n        String[] parts = str.split(\"[\\\\\" + delimiter + \"]\");\n        if (parts.length == 0) return null;\n        if (parts.length == 1) return new TableId(null, null, parts[0]); \/\/ table only\n        if (parts.length == 2) {\n            if (useCatalogBeforeSchema) return new TableId(parts[0], null, parts[1]); \/\/ catalog & table only\n            return new TableId(null, parts[0], parts[1]); \/\/ catalog & table only\n        }\n        return new TableId(parts[0], parts[1], parts[2]); \/\/ catalog & table only\n    }\n","new_comment_raw":"@param parts the parts of the identifier; may not be null","old_comment_raw":"@param str the input string","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":132},{"new_code_raw":"public Client testSpecialTags(Client client, Map<String, Object> params) throws IOException { HttpResponse response = testSpecialTagsForHttpResponse(client, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public Client testSpecialTags(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = testSpecialTagsForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param client client model","old_comment_raw":"@param body client model","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":51},{"new_code_raw":"public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException { Object localVarPostBody = body; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/composite\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"*\/*\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException {\n    Object localVarPostBody = outerComposite;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/composite\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*\/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param body Input composite as post body (optional)","old_comment_raw":"@param outerComposite Input composite as post body (optional)","label":1,"pre_label":0,"AST_level":8,"line_counts":30,"new_code_token_num":176},{"new_code_raw":"public static Iterable<ProviderMetadata<?, ?, ?, ?>> boundedByIso3166Code(String iso3166Code, ApiType type) { return filter(all(), Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates.type(type))); }","old_code_raw":"   public static Iterable<ProviderMetadata> boundedByIso3166Code(String iso3166Code,\n            TypeToken<? extends Wrapper> contextWrappableAs) {\n      return filter(all(), Predicates.and(ProviderPredicates.boundedByIso3166Code(iso3166Code), ProviderPredicates\n               .contextWrappableAs(contextWrappableAs)));\n   }\n","new_comment_raw":"@param type the type to filter providers by","old_comment_raw":"@param contextWrappableAs the contextWrappableAs to filter providers by","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":45},{"new_code_raw":"public static double length(double x, double y, double z) { return Math.sqrt(length2(x, y, z)); }","old_code_raw":"\tpublic static float length(float x, float y, float z) {\n\t\treturn (float) Math.sqrt(length2(x, y, z));\n\t}\n","new_comment_raw":"@param y double The y component.","old_comment_raw":"@param y float The y component.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"private long[][][] createGrid(int[][][] typeArray) throws Exception { long[][][] ids = new long[typeArray.length][][]; for (int i = 0; i < typeArray.length; i++) { \/\/ Add screen to DB long screenId = LauncherAppState.getLauncherProvider().generateNewScreenId(); ContentValues v = new ContentValues(); v.put(LauncherSettings.WorkspaceScreens._ID, screenId); v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i); getMockContentResolver().insert(LauncherSettings.WorkspaceScreens.CONTENT_URI, v); ids[i] = new long[typeArray[i].length][]; for (int y = 0; y < typeArray[i].length; y++) { ids[i][y] = new long[typeArray[i][y].length]; for (int x = 0; x < typeArray[i][y].length; x++) { if (typeArray[i][y][x] < 0) { \/\/ Empty cell ids[i][y][x] = -1; } else { ids[i][y][x] = addItem(typeArray[i][y][x], screenId, DESKTOP, x, y); } } } } return ids; }","old_code_raw":"    private long[][][] createGrid(int[][][] typeArray, long startScreen) throws Exception {\n        LauncherSettings.Settings.call(getMockContentResolver(),\n                LauncherSettings.Settings.METHOD_CREATE_EMPTY_DB);\n        long[][][] ids = new long[typeArray.length][][];\n\n        for (int i = 0; i < typeArray.length; i++) {\n            \/\/ Add screen to DB\n            long screenId = startScreen + i;\n\n            \/\/ Keep the screen id counter up to date\n            LauncherSettings.Settings.call(getMockContentResolver(),\n                    LauncherSettings.Settings.METHOD_NEW_SCREEN_ID);\n\n            ContentValues v = new ContentValues();\n            v.put(LauncherSettings.WorkspaceScreens._ID, screenId);\n            v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);\n            getMockContentResolver().insert(LauncherSettings.WorkspaceScreens.CONTENT_URI, v);\n\n            ids[i] = new long[typeArray[i].length][];\n            for (int y = 0; y < typeArray[i].length; y++) {\n                ids[i][y] = new long[typeArray[i][y].length];\n                for (int x = 0; x < typeArray[i][y].length; x++) {\n                    if (typeArray[i][y][x] < 0) {\n                        \/\/ Empty cell\n                        ids[i][y][x] = -1;\n                    } else {\n                        ids[i][y][x] = addItem(typeArray[i][y][x], screenId, DESKTOP, x, y);\n                    }\n                }\n            }\n        }\n        return ids;\n    }\n","new_comment_raw":"@param typeArray A 3d array of item types. @see #addItem(int, long, long, int, int) for type definitions. The first dimension represents the screens and the next two represent the workspace grid.","old_comment_raw":"@param typeArray A 3d array of item types. @see #addItem(int, long, long, int, int) for type definitions. The first dimension represents the screens and the next two represent the workspace grid.","label":0,"pre_label":1,"AST_level":16,"line_counts":27,"new_code_token_num":261},{"new_code_raw":"public Client testClientModel(Client client) throws ApiException { Object localVarPostBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, \"Missing the required parameter 'client' when calling testClientModel\"); } \/\/ create path and map variables String localVarPath = \"\/fake\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client testClientModel(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":36,"new_code_token_num":210},{"new_code_raw":"public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }","old_code_raw":"  public Call testEndpointParametersAsync(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n","new_comment_raw":"@param number None (required)","old_comment_raw":"@param number None (required)","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":187},{"new_code_raw":"public static boolean isValidTimeFloor(RexNode rexNode) { if (rexNode.getKind() != SqlKind.FLOOR) { return false; } final RexCall call = (RexCall) rexNode; if (call.operands.size() != 2) { return false; } final RexLiteral flag = (RexLiteral) call.operands.get(1); final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue(); return timeUnit != null && VALID_TIME_EXTRACT.contains(timeUnit); }","old_code_raw":"  public static boolean isValidTimeFloor(RexCall call) {\n    if (call.getKind() != SqlKind.FLOOR) {\n      return false;\n    }\n    final RexLiteral flag = (RexLiteral) call.operands.get(1);\n    final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue();\n    return timeUnit != null && VALID_TIME_EXTRACT.contains(timeUnit);\n  }\n","new_comment_raw":"@param rexNode Extract expression","old_comment_raw":"@param call Extract expression","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":84},{"new_code_raw":"public QuoteAnnotator(Properties props, boolean verbose) { USE_SINGLE = Boolean.parseBoolean(props.getProperty(\"singleQuotes\", \"false\")); MAX_LENGTH = Integer.parseInt(props.getProperty(\"maxLength\", \"-1\")); ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(\"asciiQuotes\", \"false\")); ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(\"allowEmbeddedSame\", \"false\")); SMART_QUOTES = Boolean.parseBoolean(props.getProperty(\"smartQuotes\", \"false\")); EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(\"extractUnclosedQuotes\", \"false\")); VERBOSE = verbose; Timing timer = null; if (VERBOSE) { timer = new Timing(); log.info(\"Preparing quote annotator...\"); } if (VERBOSE) { timer.stop(\"done.\"); } }","old_code_raw":"  public QuoteAnnotator(String name, Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + \".\" + \"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(name + \".\" + \"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + \".\" + \"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + \".\" + \"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n","new_comment_raw":"@param verbose whether or not to output verbose information.","old_comment_raw":"@param verbose whether or not to output verbose information.","label":0,"pre_label":1,"AST_level":8,"line_counts":20,"new_code_token_num":157},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) { rootToStart.addFirst(startAncestor); startAncestor = sentence.governor(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = start; while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) { rootToEnd.addFirst(endAncestor); endAncestor = sentence.governor(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node return null; \/\/ TODO(gabor) write me! }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    \/\/ Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n","new_comment_raw":"@param selector The property of the sentence we are getting the mode of. For example, Sentence::posTags","old_comment_raw":"@param selector The property of the sentence we are getting the mode of. For example, Sentence::posTags","label":0,"pre_label":1,"AST_level":8,"line_counts":27,"new_code_token_num":178},{"new_code_raw":"public boolean isSpinnerTextSelected(int index, String text) { return checker.isSpinnerTextSelected(index, text); }","old_code_raw":"\tpublic boolean isSpinnerTextSelected(int spinnerIndex, String text)\n\t{\n\t\treturn checker.isSpinnerTextSelected(spinnerIndex, text);\n\t}\n","new_comment_raw":"@param index the index of the spinner to check.  0 if only one spinner is available","old_comment_raw":"@param spinnerIndex the index of the spinner to check. 0 if only one spinner is available","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":21},{"new_code_raw":"private static ResultPoint[] findVertices180(BitMatrix matrix, boolean tryHarder) { int height = matrix.getHeight(); int width = matrix.getWidth(); int halfWidth = width >> 1; ResultPoint[] result = new ResultPoint[8]; boolean found = false; int[] counters = new int[START_PATTERN_REVERSE.length]; int rowStep = Math.max(1, height >> (tryHarder ? 9 : 7)); \/\/ Top Left for (int i = height - 1; i > 0; i -= rowStep) { int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE, counters); if (loc != null) { result[0] = new ResultPoint(loc[1], i); result[4] = new ResultPoint(loc[0], i); found = true; break; } } \/\/ Bottom Left if (found) { \/\/ Found the Top Left vertex found = false; for (int i = 0; i < height; i += rowStep) { int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE, counters); if (loc != null) { result[1] = new ResultPoint(loc[1], i); result[5] = new ResultPoint(loc[0], i); found = true; break; } } } counters = new int[STOP_PATTERN_REVERSE.length]; \/\/ Top Right if (found) { \/\/ Found the Bottom Left vertex found = false; for (int i = height - 1; i > 0; i -= rowStep) { int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE, counters); if (loc != null) { result[2] = new ResultPoint(loc[0], i); result[6] = new ResultPoint(loc[1], i); found = true; break; } } } \/\/ Bottom Right if (found) { \/\/ Found the Top Right vertex found = false; for (int i = 0; i < height; i += rowStep) { int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE, counters); if (loc != null) { result[3] = new ResultPoint(loc[0], i); result[7] = new ResultPoint(loc[1], i); found = true; break; } } } return found ? result : null; }","old_code_raw":"  private static ResultPoint[] findVertices180(BitMatrix matrix) {\n    int height = matrix.getHeight();\n    int width = matrix.getWidth();\n    int halfWidth = width >> 1;\n\n    ResultPoint[] result = new ResultPoint[8];\n    boolean found = false;\n\n    \/\/ Top Left\n    for (int i = height - 1; i > 0; i--) {\n      int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE);\n      if (loc != null) {\n        result[0] = new ResultPoint(loc[1], i);\n        result[4] = new ResultPoint(loc[0], i);\n        found = true;\n        break;\n      }\n    }\n    \/\/ Bottom Left\n    if (found) { \/\/ Found the Top Left vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        int[] loc = findGuardPattern(matrix, halfWidth, i, halfWidth, true, START_PATTERN_REVERSE);\n        if (loc != null) {\n          result[1] = new ResultPoint(loc[1], i);\n          result[5] = new ResultPoint(loc[0], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    \/\/ Top Right\n    if (found) { \/\/ Found the Bottom Left vertex\n      found = false;\n      for (int i = height - 1; i > 0; i--) {\n        int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE);\n        if (loc != null) {\n          result[2] = new ResultPoint(loc[0], i);\n          result[6] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    \/\/ Bottom Right\n    if (found) { \/\/ Found the Top Right vertex\n      found = false;\n      for (int i = 0; i < height; i++) {\n        int[] loc = findGuardPattern(matrix, 0, i, halfWidth, false, STOP_PATTERN_REVERSE);\n        if (loc != null) {\n          result[3] = new ResultPoint(loc[0], i);\n          result[7] = new ResultPoint(loc[1], i);\n          found = true;\n          break;\n        }\n      }\n    }\n    return found ? result : null;\n  }\n","new_comment_raw":"@param matrix the scanned barcode image.","old_comment_raw":"@param matrix the scanned barcode image.","label":0,"pre_label":1,"AST_level":14,"line_counts":67,"new_code_token_num":475},{"new_code_raw":"public String processCode(String code) { if (code == null || code.length() < 2) return null; if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm') return null; if (code.length() == 2) { clazzes_.clear(); \/\/ CSIm is equivalent to CSI0m, which is 'reset' return null; } int extendedColor = 0; boolean extendedMarkerSeen = false; boolean extendedRGBMarkerSeen = false; int extendedRGBColorsSeen = 0; String[] tokens = code.substring(2, code.length() - 1).split(\";\"); for (String token : tokens) { int codeVal = StringUtil.parseInt(token, -1); if (codeVal == -1) continue; if (extendedColor > 0) { if (!extendedMarkerSeen && !extendedRGBMarkerSeen) { if (codeVal == EXT_BY_INDEX) { extendedMarkerSeen = true; continue; } else if (codeVal == EXT_BY_RGB) { extendedRGBMarkerSeen = true; extendedRGBColorsSeen = 0; } else { \/\/ unknown extended color format; hard to recover so \/\/ just reset back to defaults and return clazzes_.clear(); return null; } } else { \/\/ We don't support colors specified via RGB, but parse the \/\/ sequence then ignore it in case there are supported \/\/ sequences after it if (extendedRGBMarkerSeen) { extendedRGBColorsSeen++; if (extendedRGBColorsSeen == 3 \/*red, green, blue*\/) { extendedColor = 0; extendedRGBMarkerSeen = false; extendedRGBColorsSeen = 0; } } else { if (extendedColor == FOREGROUND_EXT) { if (codeVal >= 0 && codeVal <= 255) { currentColor_.setExtended(codeVal); resetForeground(); clazzes_.add(Color.clazzForColorIndex(codeVal, false \/*background*\/)); } } else { if (codeVal >= 0 && codeVal <= 255) { currentBgColor_.setExtended(codeVal); resetBackground(); clazzes_.add(Color.clazzForColorIndex(codeVal, true \/*background*\/)); } } extendedColor = 0; extendedMarkerSeen = false; } } } else if (codeVal == RESET) { inverted_ = false; currentColor_.reset(); currentBgColor_.reset(); clazzes_.clear(); } else if (codeVal == BOLD) { clazzes_.add(BOLD_STYLE); } else if (codeVal == BLURRED) { \/\/ NYI clazzes_.add(BLURRED_STYLE); } else if (codeVal == BOLD_BLURRED_OFF) { clazzes_.remove(BOLD_STYLE); \/\/ NYI clazzes_.remove(BLURRED_STYLE); } else if (codeVal == ITALIC) { \/\/ NYI clazzes_.add(ITALIC_STYLE); } else if (codeVal == ITALIC_OFF) { \/\/ NYI clazzes_.remove(ITALIC_STYLE); } else if (codeVal == UNDERLINE) { clazzes_.add(UNDERLINE_STYLE); } else if (codeVal == UNDERLINE_OFF) { clazzes_.remove(UNDERLINE_STYLE); } else if (codeVal == BLINKSLOW || codeVal == BLINKFAST) { clazzes_.add(BLINK_STYLE); } else if (codeVal == BLINK_OFF) { clazzes_.remove(BLINK_STYLE); } else if (codeVal == INVERSE) { if (!inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = true; } } else if (codeVal == INVERSE_OFF) { if (inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = false; } } else if (codeVal == HIDDEN) { clazzes_.add(HIDDEN_STYLE); } else if (codeVal == HIDDEN_OFF) { clazzes_.remove(HIDDEN_STYLE); } else if (codeVal == STRIKETHROUGH) { \/\/ NYI clazzes_.add(STRIKETHROUGH_STYLE); } else if (codeVal == STRIKETHROUGH_OFF) { \/\/ NYI clazzes_.remove(STRIKETHROUGH_OFF); } else if (Color.isFgColorCode(codeVal)) { currentColor_.setCode(codeVal); resetForeground(); clazzes_.add(clazzForColor(codeVal)); } else if (Color.isBgColorCode(codeVal)) { currentBgColor_ = new Color(false, codeVal); resetBackground(); clazzes_.add(clazzForBgColor(codeVal)); } else if (codeVal == RESET_FOREGROUND) { currentColor_.reset(); resetForeground(); } else if (codeVal == RESET_BACKGROUND) { currentBgColor_.reset(); resetBackground(); } else if (codeVal == FOREGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == BACKGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else { \/\/ ignore all others } } return getStyle(); }","old_code_raw":"   public String processCode(String code, String baseClazz)\n   {\n      if (code == null || code.length() < 2)\n         return getStyle(baseClazz); \/\/ unrecognized sequence, ignore\n      if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm')\n         return getStyle(baseClazz); \/\/ unsupported sequence, ignore\n      if (code.length() == 2)\n      {\n         clazzes_.clear(); \/\/ CSIm is equivalent to CSI0m, which is 'reset'\n         return getStyle(baseClazz);\n      }\n      \n      int extendedColor = 0;\n      boolean extendedMarkerSeen = false;\n      boolean extendedRGBMarkerSeen = false;\n      int extendedRGBColorsSeen = 0;\n      \n      String[] tokens = code.substring(2, code.length() - 1).split(\";\");\n      for (String token : tokens)\n      {\n         int codeVal = StringUtil.parseInt(token,  -1);\n         if (codeVal == -1)\n            continue;\n\n         if (extendedColor > 0)\n         {\n            if (!extendedMarkerSeen && !extendedRGBMarkerSeen)\n            {\n               if (codeVal == EXT_BY_INDEX)\n               {\n                  extendedMarkerSeen = true;\n                  continue;\n               }\n               else if (codeVal == EXT_BY_RGB)\n               {\n                  extendedRGBMarkerSeen = true;\n                  extendedRGBColorsSeen = 0;\n               }\n               else\n               {\n                  \/\/ unknown extended color format; hard to recover so\n                  \/\/ just reset back to defaults and return\n                  clazzes_.clear();\n                  return getStyle(baseClazz);\n               }\n            }\n            else\n            {\n               \/\/ We don't support colors specified via RGB, but parse the\n               \/\/ sequence then ignore it in case there are supported \n               \/\/ sequences after it\n               if (extendedRGBMarkerSeen)\n               {\n                  extendedRGBColorsSeen++;\n                  if (extendedRGBColorsSeen == 3 \/*red, green, blue*\/)\n                  {\n                     extendedColor = 0;\n                     extendedRGBMarkerSeen = false;\n                     extendedRGBColorsSeen = 0;\n                  }\n               }\n               else \n               {\n                  if (extendedColor == FOREGROUND_EXT)\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentColor_.setExtended(codeVal);\n                        resetForeground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              false \/*background*\/));\n                     }\n                  }\n                  else\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentBgColor_.setExtended(codeVal);\n                        resetBackground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              true \/*background*\/));\n                     }\n                  }\n                  extendedColor = 0;\n                  extendedMarkerSeen = false;\n               }\n            }\n         }\n         else if (codeVal == RESET)\n         {\n            inverted_ = false;\n            currentColor_.reset();\n            currentBgColor_.reset();\n            clazzes_.clear();\n         }\n         else if (codeVal == BOLD)\n         {\n            clazzes_.add(BOLD_STYLE);\n         }\n         else if (codeVal == BLURRED)\n         {\n            \/\/ NYI clazzes_.add(BLURRED_STYLE);\n         }\n         else if (codeVal == BOLD_BLURRED_OFF)\n         {\n            clazzes_.remove(BOLD_STYLE);\n            \/\/ NYI clazzes_.remove(BLURRED_STYLE);\n         }\n         else if (codeVal == ITALIC)\n         {\n            \/\/ NYI clazzes_.add(ITALIC_STYLE);\n         }\n         else if (codeVal == ITALIC_OFF)\n         {\n            \/\/ NYI clazzes_.remove(ITALIC_STYLE);\n         }\n         else if (codeVal == UNDERLINE)\n         {\n            clazzes_.add(UNDERLINE_STYLE);\n         }\n         else if (codeVal == UNDERLINE_OFF)\n         {\n            clazzes_.remove(UNDERLINE_STYLE);\n         }\n         else if (codeVal == BLINKSLOW || codeVal == BLINKFAST)\n         {\n            clazzes_.add(BLINK_STYLE);\n         }\n         else if (codeVal == BLINK_OFF)\n         {\n            clazzes_.remove(BLINK_STYLE);\n         }\n         else if (codeVal == INVERSE)\n         {\n            if (!inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = true;\n            }\n         }\n         else if (codeVal == INVERSE_OFF)\n         {\n            if (inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = false;\n            }\n         }\n         else if (codeVal == HIDDEN)\n         {\n            clazzes_.add(HIDDEN_STYLE);\n         }\n         else if (codeVal == HIDDEN_OFF)\n         {\n            clazzes_.remove(HIDDEN_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH)\n         {\n            \/\/ NYI clazzes_.add(STRIKETHROUGH_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH_OFF)\n         {\n            \/\/ NYI clazzes_.remove(STRIKETHROUGH_OFF);\n         }\n         else if (Color.isFgColorCode(codeVal))\n         {\n            currentColor_.setCode(codeVal);\n            resetForeground();\n            clazzes_.add(clazzForColor(codeVal));\n         }\n         else if (Color.isBgColorCode(codeVal))\n         {\n            currentBgColor_ = new Color(false, codeVal);\n            resetBackground();\n            clazzes_.add(clazzForBgColor(codeVal));\n         }\n         else if (codeVal == RESET_FOREGROUND)\n         {\n            currentColor_.reset();\n            resetForeground();\n         }\n         else if (codeVal == RESET_BACKGROUND)\n         {\n            currentBgColor_.reset();\n            resetBackground();\n         }\n         else if (codeVal == FOREGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else if (codeVal == BACKGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else\n         {\n            \/\/ ignore all others\n         }\n      }\n      return getStyle(baseClazz);\n   }\n","new_comment_raw":"@param code escape sequence","old_comment_raw":"@param code escape sequence","label":0,"pre_label":1,"AST_level":31,"line_counts":214,"new_code_token_num":854},{"new_code_raw":"private boolean isCached(Serializable collectionKey, CollectionPersister persister) { if ( persister.hasCache() ) { CacheKey cacheKey = context.getSession().generateCacheKey( collectionKey, persister.getKeyType(), persister.getRole() ); return persister.getCacheAccessStrategy().get( cacheKey, context.getSession().getTimestamp() ) != null; } return false; }","old_code_raw":"\tprivate boolean isCached(EntityKey entityKey, EntityPersister persister) {\n\t\tif ( persister.hasCache() ) {\n\t\t\tCacheKey key = context.getSession().generateCacheKey(\n\t\t\t\t\tentityKey.getIdentifier(),\n\t\t\t\t\tpersister.getIdentifierType(),\n\t\t\t\t\tentityKey.getEntityName()\n\t\t\t);\n\t\t\treturn persister.getCacheAccessStrategy().get( key, context.getSession().getTimestamp() ) != null;\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@param id A key that must be included in the batch fetch","old_comment_raw":"@param id The identifier of the entity currently demanding load.","label":1,"pre_label":0,"AST_level":10,"line_counts":12,"new_code_token_num":65},{"new_code_raw":"private ColumnState buildPrimitive(ContainerState parent, ColumnMetadata columnSchema) { final ValueVector vector; if (parent.projection().isProjected(columnSchema) || allowCreation(parent)) { \/\/ Create the vector for the column. vector = parent.vectorCache().vectorFor(columnSchema.schema()); \/\/ In permissive mode, the mode or precision of the vector may differ \/\/ from that requested. Update the schema to match. if (parent.vectorCache().isPermissive() && !vector.getField().isEquivalent(columnSchema.schema())) { columnSchema = ((PrimitiveColumnMetadata) columnSchema).mergeWith(vector.getField()); } } else { \/\/ Column is not projected. No materialized backing for the column. vector = null; } \/\/ Create the writer. final AbstractObjectWriter colWriter = ColumnWriterFactory.buildColumnWriter(columnSchema, vector); \/\/ Build the vector state which manages the vector. VectorState vectorState; if (vector == null) { vectorState = new NullVectorState(); } else if (columnSchema.isArray()) { vectorState = new RepeatedVectorState(colWriter.array(), (RepeatedValueVector) vector); } else if (columnSchema.isNullable()) { vectorState = new NullableVectorState( colWriter, (NullableVector) vector); } else { vectorState = SimpleVectorState.vectorState(columnSchema, colWriter.events(), vector); } \/\/ Create the column state which binds the vector and writer together. return new PrimitiveColumnState(parent.loader(), colWriter, vectorState); }","old_code_raw":"  private ColumnState buildPrimitive(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    ValueVector vector;\n    if (!colProj.isProjected() && !allowCreation(parent)) {\n\n      \/\/ Column is not projected. No materialized backing for the column.\n\n      vector = null;\n    } else {\n\n      \/\/ Create the vector for the column.\n\n      vector = parent.vectorCache().addOrGet(columnSchema.schema());\n\n      \/\/ In permissive mode, the mode or precision of the vector may differ\n      \/\/ from that requested. Update the schema to match.\n\n      if (parent.vectorCache().isPermissive() && ! vector.getField().isEquivalent(columnSchema.schema())) {\n        columnSchema = ((PrimitiveColumnMetadata) columnSchema).mergeWith(vector.getField());\n      }\n    }\n\n    \/\/ Create the writer.\n\n    final AbstractObjectWriter colWriter = ColumnWriterFactory.buildColumnWriter(\n        columnSchema, colProj.conversionFactory(), vector);\n\n    \/\/ Build the vector state which manages the vector.\n\n    VectorState vectorState;\n    if (vector == null) {\n      vectorState = new NullVectorState();\n    } else if (columnSchema.isArray()) {\n      vectorState = new RepeatedVectorState(colWriter.array(), (RepeatedValueVector) vector);\n    } else if (columnSchema.isNullable()) {\n      vectorState = new NullableVectorState(\n          colWriter, (NullableVector) vector);\n    } else {\n      vectorState = SimpleVectorState.vectorState(columnSchema,\n            colWriter.events(), vector);\n    }\n\n    \/\/ Create the column state which binds the vector and writer together.\n\n    return new PrimitiveColumnState(parent.loader(), colWriter,\n        vectorState);\n  }\n","new_comment_raw":"@param colProj implied projection type for the column","old_comment_raw":"@param colProj implied projection type for the column","label":0,"pre_label":1,"AST_level":11,"line_counts":41,"new_code_token_num":273},{"new_code_raw":"protected boolean isDisconnectRequest(AtmosphereRequest request) { if (\"GET\".equals(request.getMethod())) { if (request.getParameterMap().containsKey(\"disconnect\")) { return true; } } else if (\"POST\".equals(request.getMethod())) { try { String data = decodePostData(request.getContentType(), extractString(request.getReader())); request.setAttribute(POST_MESSAGE_RECEIVED, data); if (data != null && data.length() > 0) { List<SocketIOPacketImpl> list = SocketIOPacketImpl.parse(data); if (!list.isEmpty()) { if (SocketIOPacketImpl.PacketType.DISCONNECT.equals(list.get(0).getFrameType())) { return true; } } } } catch (IOException e) { e.printStackTrace(); } } return false; }","old_code_raw":"    protected boolean isDisconnectRequest(HttpServletRequest request) {\n\n        if (\"GET\".equals(request.getMethod())) {\n\n            if (request.getParameterMap().containsKey(\"disconnect\")) {\n                return true;\n            }\n\n        } else if (\"POST\".equals(request.getMethod())) {\n            try {\n                String data = decodePostData(request.getContentType(), extractString(request.getReader()));\n                request.setAttribute(POST_MESSAGE_RECEIVED, data);\n                if (data != null && data.length() > 0) {\n                    List<SocketIOPacketImpl> list = SocketIOPacketImpl.parse(data);\n                    if (!list.isEmpty()) {\n                        if (SocketIOPacketImpl.PacketType.DISCONNECT.equals(list.get(0).getFrameType())) {\n                            return true;\n                        }\n                    }\n\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n        return false;\n    }\n","new_comment_raw":"@param request","old_comment_raw":"@param request","label":0,"pre_label":1,"AST_level":14,"line_counts":30,"new_code_token_num":158},{"new_code_raw":"public Client testSpecialTags(Client client) throws ApiException { ApiResponse<Client> resp = testSpecialTagsWithHttpInfo(client); return resp.getData(); }","old_code_raw":"    public Client testSpecialTags(Client body) throws ApiException {\n        ApiResponse<Client> resp = testSpecialTagsWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public int[] indices(Collection<E> elements) { int[] indices = new int[elements.size()]; int i = 0; for (E elem : elements) { indices[i++] = indexOf(elem); } return indices; }","old_code_raw":"  public int[] indices(Collection<E> elems) {\n    int[] indices = new int[elems.size()];\n    int i = 0;\n    for (E elem : elems) {\n      indices[i++] = indexOf(elem);\n    }\n    return indices;\n  }\n","new_comment_raw":"@param elements The list of items","old_comment_raw":"@param elems The list of items","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":52},{"new_code_raw":"public void updatePetWithForm (String petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling updatePetWithForm\", new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\")); } \/\/ create path and map variables String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"application\/x-www-form-urlencoded\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); if (name != null) { localVarBuilder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8); } if (status != null) { localVarBuilder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8); } HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params formParams.put(\"name\", ApiInvoker.parameterToString(name)); formParams.put(\"status\", ApiInvoker.parameterToString(status)); } String[] authNames = new String[] { \"petstore_auth\" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void updatePetWithForm (Long petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling updatePetWithForm\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application\/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (name != null) {\n        localVarBuilder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (status != null) {\n        localVarBuilder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param name Updated name of the pet","old_comment_raw":"@param name Updated name of the pet","label":0,"pre_label":1,"AST_level":11,"line_counts":65,"new_code_token_num":491},{"new_code_raw":"protected boolean processExtensionPopupChildren(PopupMenuUtils.PopupMenuInvokerWrapper invokerWrapper) { boolean childEnable = false; for (int index = 0; index < this.getItemCount(); index++) { JMenuItem item = this.getItem(index); if (isEnableForComponent(item, invokerWrapper)) { childEnable = true; } } return childEnable; }","old_code_raw":"\tprotected boolean processExtensionPopupChildren(Component invoker) {\n\t\tboolean childEnable = false;\n\t\tfor (int index = 0; index < this.getItemCount(); index++) {\n\t\t\tJMenuItem item = this.getItem(index);\n\t\t\tif (item instanceof PopupMenuHistoryReference) {\n\t\t\t\tPopupMenuHistoryReference itemRef=(PopupMenuHistoryReference) item;\n\t\t\t\tif (itemRef.isEnableForComponent(invoker)) {\n\t\t\t\t\tchildEnable = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn childEnable;\n\t}\n","new_comment_raw":"@param invokerWrapper the wrapped invoker","old_comment_raw":"@param invoker the component of the invoker","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":57},{"new_code_raw":"public static WebDavMount mount(URI uri) throws CommandFailedException { return chooseStrategy().mount(uri); }","old_code_raw":"\tpublic static WebDavMount mount(int localPort) throws CommandFailedException {\n\t\treturn chooseStrategy().mount(localPort);\n\t}\n","new_comment_raw":"@param uri URI of the webdav share","old_comment_raw":"@param localPort local TCP port of the webdav share","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public long set(long instant, int month) { Utils.verifyValueBounds(this, month, MIN, MAX); \/\/ int thisYear = iChronology.year().get(instant); \/\/ int thisDom = iChronology.getDayOfMonth(instant, thisYear); int maxDom = iChronology.getDaysInYearMonth(thisYear, month); if (thisDom > maxDom) { \/\/ Quietly force DOM to nearest sane value. thisDom = maxDom; } \/\/ Return newly calculated millis value return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) + iChronology.millisOfDay().get(instant); }","old_code_raw":"    public long set(long millis, int month) {\n        super.verifyValueBounds(month, MIN, MAX);\n        \/\/\n        int thisYear = iChronology.year().get(millis);\n        \/\/\n        int thisDom = iChronology.getDayOfMonth(millis, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            \/\/ Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        \/\/ Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.millisOfDay().get(millis);\n    }\n","new_comment_raw":"@param month the month (1,12) to update the time to.","old_comment_raw":"@param month the month (1,12) to update the time to.","label":0,"pre_label":1,"AST_level":7,"line_counts":16,"new_code_token_num":105},{"new_code_raw":"public List<WebElement> apply(WebDriver driver) { List<WebElement> allChildren = findElement(parent, driver).findElements(childLocator); return allChildren.isEmpty() ? null : allChildren; }","old_code_raw":"      public List<WebElement> apply(WebDriver webDriver) {\n        List<WebElement> elements = null;\n        try {\n          elements = webDriver.findElement(locator).findElements(sub_locator);\n        } catch (Exception e) {\/**\/}\n        if (elements != null && elements.size() > 0) {\n          return elements;\n        }\n        return null;\n      }\n","new_comment_raw":"@param childLocator used to find child element. For example td By.xpath(\".\/tr\/td\")","old_comment_raw":"@param sub_locator used to find child element. For example td By.xpath(\".\/tr\/td\")","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":34},{"new_code_raw":"private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) { \/\/ Pre-checks if (sessions.isEmpty()) { return null; } List<HttpSession> matchingSessions = new LinkedList<>(sessions); for (String token : siteTokens.getTokensSet()) { \/\/ Get the corresponding cookie from the cookies list HttpCookie matchingCookie = null; for (HttpCookie cookie : cookies) { if (cookie.getName().equals(token)) { matchingCookie = cookie; break; } } \/\/ Filter the sessions that do not match the cookie value Iterator<HttpSession> it = matchingSessions.iterator(); while (it.hasNext()) { if (!it.next().matchesToken(token, matchingCookie)) { it.remove(); } } } \/\/ Return the matching session if (matchingSessions.size() >= 1) { if (matchingSessions.size() > 1) { log.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite() + \". Using first one.\"); } return matchingSessions.get(0); } return null; }","old_code_raw":"\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) {\n\n\t\t\/\/ Pre-checks\n\t\tif (sessions.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tList<HttpSession> matchingSessions = new LinkedList<>(sessions);\n\t\tfor (String token : tokens) {\n\t\t\t\/\/ Get the corresponding cookie from the cookies list\n\t\t\tHttpCookie matchingCookie = null;\n\t\t\tfor (HttpCookie cookie : cookies) {\n\t\t\t\tif (cookie.getName().equals(token)) {\n\t\t\t\t\tmatchingCookie = cookie;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ Filter the sessions that do not match the cookie value\n\t\t\tIterator<HttpSession> it = matchingSessions.iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tif (!it.next().matchesToken(token, matchingCookie)) {\n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\/\/ Return the matching session\n\t\tif (matchingSessions.size() >= 1) {\n\t\t\tif (matchingSessions.size() > 1) {\n\t\t\t\tlog.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite()\n\t\t\t\t\t\t+ \". Using first one.\");\n\t\t\t}\n\t\t\treturn matchingSessions.get(0);\n\t\t}\n\t\treturn null;\n\n\t}\n","new_comment_raw":"@param siteTokens the tokens","old_comment_raw":"@param tokens the tokens","label":1,"pre_label":0,"AST_level":11,"line_counts":38,"new_code_token_num":206},{"new_code_raw":"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType) throws ApiException { Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(\"?\"); else b.append(\"&\"); b.append(escapeString(key)).append(\"=\").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String contentType) throws ApiException {\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder = client.resource(basePath + path + querystring).accept(\"application\/json\");\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param path The sub-path of the HTTP URL","old_comment_raw":"@param path The sub-path of the HTTP URL","label":0,"pre_label":1,"AST_level":16,"line_counts":109,"new_code_token_num":716},{"new_code_raw":"public static Annotation fromProto(CoreNLPProtos.Document proto) { \/\/ Set text Annotation ann = new Annotation(proto.getText()); \/\/ Add tokens List<CoreLabel> tokens = new ArrayList<CoreLabel>(proto.getTokenCount()); for (CoreNLPProtos.Token token : proto.getTokenList()) { CoreLabel coreLabel = fromProto(token); \/\/ Set docid if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); } tokens.add(coreLabel); } if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); } \/\/ Add sentences List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount()); for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) { CoreNLPProtos.Sentence sentence = proto.getSentence(sentIndex); CoreMap map = fromProto(sentence); if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) { \/\/ Set tokens for sentence map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd())); \/\/ Set sentence index + token index + paragraph index for (int i = sentence.getTokenOffsetBegin(); i < sentence.getTokenOffsetEnd(); ++i) { tokens.get(i).setSentIndex(sentIndex); tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1); if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); } } \/\/ Set text map.set(TextAnnotation.class, proto.getText().substring(sentence.getCharacterOffsetBegin(), sentence.getCharacterOffsetEnd())); } \/\/ End iteration sentences.add(map); } if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); } \/\/ Set DocID String docid = null; if (proto.hasDocID()) { docid = proto.getDocID(); ann.set(DocIDAnnotation.class, docid); } \/\/ Set coref chain Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>(); for (CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) { CorefChain chain = fromProto(chainProto, ann); corefChains.put(chain.getChainID(), chain); } if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); } \/\/ Set dependency graphs \/\/ We need to wait until here, since this is the first time we see tokens for (int i = 0; i < proto.getSentenceCount(); ++i) { CoreNLPProtos.Sentence sentence = proto.getSentenceList().get(i); CoreMap map = sentences.get(i); List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class); if (sentence.hasBasicDependencies()) { map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid)); } if (sentence.hasCollapsedDependencies()) { map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid)); } if (sentence.hasCollapsedCCProcessedDependencies()) { map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid)); } } \/\/ Redo some light annotation for (CoreMap sentence : sentences) { if (sentence.containsKey(TokensAnnotation.class)) { sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence)); } } \/\/ Return return ann; }","old_code_raw":"  public static Annotation fromProto(CoreMapProtos.Document proto) {\n    \/\/ Set text\n    Annotation ann = new Annotation(proto.getText());\n\n    \/\/ Add tokens\n    List<CoreLabel> tokens = new ArrayList<CoreLabel>(proto.getTokenCount());\n    for (CoreMapProtos.CoreLabel token : proto.getTokenList()) {\n      CoreLabel coreLabel = fromProto(token);\n      \/\/ Set docid\n      if (proto.hasDocID()) { coreLabel.setDocID(proto.getDocID()); }\n      tokens.add(coreLabel);\n    }\n    if (!tokens.isEmpty()) { ann.set(TokensAnnotation.class, tokens); }\n\n    \/\/ Add sentences\n    List<CoreMap> sentences = new ArrayList<CoreMap>(proto.getSentenceCount());\n    for (int sentIndex = 0; sentIndex < proto.getSentenceCount(); ++sentIndex) {\n      CoreMapProtos.Sentence sentence = proto.getSentence(sentIndex);\n      CoreMap map = fromProto(sentence);\n      if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {\n        \/\/ Set tokens for sentence\n        map.set(TokensAnnotation.class, tokens.subList(sentence.getTokenOffsetBegin(), sentence.getTokenOffsetEnd()));\n        \/\/ Set sentence index + token index + paragraph index\n        for (int i = sentence.getTokenOffsetBegin(); i < sentence.getTokenOffsetEnd(); ++i) {\n          tokens.get(i).setSentIndex(sentIndex);\n          tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);\n          if (sentence.hasParagraph()) { tokens.get(i).set(ParagraphAnnotation.class, sentence.getParagraph()); }\n        }\n        \/\/ Set text\n        map.set(TextAnnotation.class, proto.getText().substring(sentence.getCharacterOffsetBegin(), sentence.getCharacterOffsetEnd()));\n      }\n      \/\/ End iteration\n      sentences.add(map);\n    }\n    if (!sentences.isEmpty()) { ann.set(SentencesAnnotation.class, sentences); }\n\n    \/\/ Set DocID\n    String docid = null;\n    if (proto.hasDocID()) {\n      docid = proto.getDocID();\n      ann.set(DocIDAnnotation.class, docid);\n    }\n\n    \/\/ Set coref chain\n    Map<Integer, CorefChain> corefChains = new HashMap<Integer, CorefChain>();\n    for (CoreMapProtos.CorefChain chainProto : proto.getCorefChainList()) {\n      CorefChain chain = fromProto(chainProto, ann);\n      corefChains.put(chain.getChainID(), chain);\n    }\n    if (!corefChains.isEmpty()) { ann.set(CorefChainAnnotation.class, corefChains); }\n\n    \/\/ Set dependency graphs\n    \/\/ We need to wait until here, since this is the first time we see tokens\n    for (int i = 0; i < proto.getSentenceCount(); ++i) {\n      CoreMapProtos.Sentence sentence = proto.getSentenceList().get(i);\n      CoreMap map = sentences.get(i);\n      List<CoreLabel> sentenceTokens = map.get(TokensAnnotation.class);\n      if (sentence.hasBasicDependencies()) {\n        map.set(BasicDependenciesAnnotation.class, fromProto(sentence.getBasicDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedDependencies()) {\n        map.set(CollapsedDependenciesAnnotation.class, fromProto(sentence.getCollapsedDependencies(), sentenceTokens, docid));\n      }\n      if (sentence.hasCollapsedCCProcessedDependencies()) {\n        map.set(CollapsedCCProcessedDependenciesAnnotation.class, fromProto(sentence.getCollapsedCCProcessedDependencies(), sentenceTokens, docid));\n      }\n    }\n\n    \/\/ Redo some light annotation\n    for (CoreMap sentence : sentences) {\n      if (sentence.containsKey(TokensAnnotation.class)) {\n        sentence.set(NumerizedTokensAnnotation.class, NumberNormalizer.findAndMergeNumbers(sentence));\n      }\n    }\n\n    \/\/ Return\n    return ann;\n  }\n","new_comment_raw":"@param proto The protocol buffer to read the document from.","old_comment_raw":"@param proto The protocol buffer to read the document from.","label":0,"pre_label":1,"AST_level":15,"line_counts":79,"new_code_token_num":653},{"new_code_raw":"private SQLResponse execute(String correctedSql, SQLRequest sqlRequest, Connection conn) throws Exception { Statement stat = null; ResultSet resultSet = null; Boolean isPushDown = false; List<List<String>> results = Lists.newArrayList(); List<SelectedColumnMeta> columnMetas = Lists.newArrayList(); try { \/\/ special case for prepare query. if (BackdoorToggles.getPrepareOnly()) { return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas); } stat = conn.createStatement(); processStatementAttr(stat, sqlRequest); resultSet = stat.executeQuery(correctedSql); ResultSetMetaData metaData = resultSet.getMetaData(); int columnCount = metaData.getColumnCount(); \/\/ Fill in selected column meta for (int i = 1; i <= columnCount; ++i) { columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i), metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i), metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i), metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i), metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i), metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i), metaData.isDefinitelyWritable(i))); } \/\/ fill in results while (resultSet.next()) { List<String> oneRow = Lists.newArrayListWithCapacity(columnCount); for (int i = 0; i < columnCount; i++) { oneRow.add((resultSet.getString(i + 1))); } results.add(oneRow); } } catch (SQLException sqlException) { isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas, sqlException); if (!isPushDown) { throw sqlException; } } finally { close(resultSet, stat, null);\/\/conn is passed in, not my duty to close } return getSqlResponse(isPushDown, results, columnMetas); }","old_code_raw":"    private SQLResponse execute(String correctedSql, SQLRequest sqlRequest) throws Exception {\n        Connection conn = null;\n        Statement stat = null;\n        ResultSet resultSet = null;\n        Boolean isPushDown = false;\n\n        List<List<String>> results = Lists.newArrayList();\n        List<SelectedColumnMeta> columnMetas = Lists.newArrayList();\n\n        try {\n            conn = QueryConnection.getConnection(sqlRequest.getProject());\n\n            \/\/ special case for prepare query. \n            if (BackdoorToggles.getPrepareOnly()) {\n                return getPrepareOnlySqlResponse(correctedSql, conn, isPushDown, results, columnMetas);\n            }\n\n            stat = conn.createStatement();\n            processStatementAttr(stat, sqlRequest);\n            resultSet = stat.executeQuery(correctedSql);\n\n            ResultSetMetaData metaData = resultSet.getMetaData();\n            int columnCount = metaData.getColumnCount();\n\n            \/\/ Fill in selected column meta\n            for (int i = 1; i <= columnCount; ++i) {\n                columnMetas.add(new SelectedColumnMeta(metaData.isAutoIncrement(i), metaData.isCaseSensitive(i),\n                        metaData.isSearchable(i), metaData.isCurrency(i), metaData.isNullable(i), metaData.isSigned(i),\n                        metaData.getColumnDisplaySize(i), metaData.getColumnLabel(i), metaData.getColumnName(i),\n                        metaData.getSchemaName(i), metaData.getCatalogName(i), metaData.getTableName(i),\n                        metaData.getPrecision(i), metaData.getScale(i), metaData.getColumnType(i),\n                        metaData.getColumnTypeName(i), metaData.isReadOnly(i), metaData.isWritable(i),\n                        metaData.isDefinitelyWritable(i)));\n            }\n\n            \/\/ fill in results\n            while (resultSet.next()) {\n                List<String> oneRow = Lists.newArrayListWithCapacity(columnCount);\n                for (int i = 0; i < columnCount; i++) {\n                    oneRow.add((resultSet.getString(i + 1)));\n                }\n\n                results.add(oneRow);\n            }\n        } catch (SQLException sqlException) {\n            isPushDown = PushDownUtil.doPushDownQuery(sqlRequest.getProject(), correctedSql, conn.getSchema(), results, columnMetas,\n                    sqlException);\n            if (!isPushDown) {\n                throw sqlException;\n            }\n        } finally {\n            close(resultSet, stat, conn);\n        }\n\n        return getSqlResponse(isPushDown, results, columnMetas);\n    }\n","new_comment_raw":"@param sqlRequest","old_comment_raw":"@param sqlRequest","label":0,"pre_label":1,"AST_level":12,"line_counts":55,"new_code_token_num":389},{"new_code_raw":"public static Predicate<ColumnId> excludeColumns(String fullyQualifiedColumnNames) { return Predicates.excludes(fullyQualifiedColumnNames, ColumnId::toString); }","old_code_raw":"    public static Predicate<ColumnId> excludeColumns(String columnNames) {\n        return Predicates.excludes(columnNames, ColumnId::toString);\n    }\n","new_comment_raw":"@param fullyQualifiedColumnNames the comma-separated list of fully-qualified column names to exclude; may be null or","old_comment_raw":"@param columnNames the comma-separated list of column names names to exclude; may be null or empty","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public Action cancelled(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { synchronized (req) { AtmosphereResourceImpl r = null; try { if (trackActiveRequest) { long l = (Long) req.getAttribute(MAX_INACTIVE); if (l == -1) { \/\/ The closedDetector closed the connection. return timedoutAction; } req.setAttribute(MAX_INACTIVE, (long) -1); } logger.debug(\"Cancelling the connection for request {}\", req); r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (r != null) { r.getAtmosphereResourceEvent().setCancelled(true); invokeAtmosphereHandler(r); try { r.getResponse().sendError(503); r.getResponse().getOutputStream().close(); } catch (Throwable t) { try { r.getResponse().getWriter().close(); } catch (Throwable t2) { } } } } catch (Throwable ex) { \/\/ Something wrong happenned, ignore the exception logger.debug(\"failed to cancel resource: \" + r, ex); } finally { try { if (r != null) { r.notifyListeners(); r.setIsInScope(false); r.cancel(); } } catch (Throwable t) { logger.trace(\"cancel\", t); } finally { if (r != null) { destroyResource(r); } } } } return cancelledAction; }","old_code_raw":"    public Action cancelled(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        synchronized (req) {\n            AtmosphereResourceImpl r = null;\n            try {\n                if (trackActiveRequest) {\n                    long l = (Long) req.getAttribute(MAX_INACTIVE);\n                    if (l == -1) {\n                        \/\/ The closedDetector closed the connection.\n                        return timedoutAction;\n                    }\n                    req.setAttribute(MAX_INACTIVE, (long) -1);\n                }\n\n                logger.debug(\"Cancelling the connection for request {}\", req);\n\n                r = (AtmosphereResourceImpl) req.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n                if (r != null) {\n                    r.getAtmosphereResourceEvent().setCancelled(true);\n                    invokeAtmosphereHandler(r);\n\n                    try {\n                        r.getResponse().sendError(503);\n                        r.getResponse().getOutputStream().close();\n                    } catch (Throwable t) {\n                        try {\n                            r.getResponse().getWriter().close();\n                        } catch (Throwable t2) {\n                        }\n                    }\n                }\n            } catch (Throwable ex) {\n                \/\/ Something wrong happenned, ignore the exception\n                logger.debug(\"failed to cancel resource: \" + r, ex);\n            } finally {\n                try {\n                    if (r != null) {\n                        r.notifyListeners();\n                        r.setIsInScope(false);\n                        r.cancel();\n                    }\n                } catch (Throwable t) {\n                    logger.trace(\"cancel\", t);\n                } finally {\n                    if (r != null) {\n                        destroyResource(r);\n                    }\n                }\n            }\n        }\n\n        return cancelledAction;\n    }\n","new_comment_raw":"@param req the  AtmosphereRequest","old_comment_raw":"@param req the HttpServletRequest","label":1,"pre_label":0,"AST_level":12,"line_counts":55,"new_code_token_num":274},{"new_code_raw":"public int recordObject(CollectionId id, Document object, Instant timestamp) throws InterruptedException { source.collectionEvent(replicaSetName, id); final Struct sourceValue = source.struct(); final Map<String, ?> offset = source.lastOffset(replicaSetName); String objId = idObjToJson(object); assert objId != null; return createRecords(sourceValue, offset, Operation.READ, objId, object, timestamp); }","old_code_raw":"        public int recordObject(CollectionId id, Document object, long timestamp) throws InterruptedException {\n            source.collectionEvent(replicaSetName, id);\n            final Struct sourceValue = source.struct();\n            final Map<String, ?> offset = source.lastOffset(replicaSetName);\n            String objId = idObjToJson(object);\n            assert objId != null;\n            return createRecords(sourceValue, offset, Operation.READ, objId, object, timestamp);\n        }\n","new_comment_raw":"@param object the document; may not be null","old_comment_raw":"@param object the document; may not be null","label":0,"pre_label":1,"AST_level":6,"line_counts":9,"new_code_token_num":74},{"new_code_raw":"public static Connection generateProxy(LogicalConnectionImpl logicalConnection) { BorrowedConnectionProxy handler = new BorrowedConnectionProxy( logicalConnection ); return ( Connection ) Proxy.newProxyInstance( getProxyClassLoader(), PROXY_INTERFACES, handler ); }","old_code_raw":"\tpublic static Connection generateProxy(ConnectionManager connectionManager) {\n\t\tBorrowedConnectionProxy handler = new BorrowedConnectionProxy( connectionManager );\n\t\treturn ( Connection ) Proxy.newProxyInstance(\n\t\t\t\tgetProxyClassLoader(),\n\t\t        PROXY_INTERFACES,\n\t\t        handler\n\t\t);\n\t}\n","new_comment_raw":"@param logicalConnection The logical connection to wrap with the connection proxy.","old_comment_raw":"@param connectionManager The connection manager to wrap with the connection proxy.","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":34},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, DurableTopicSubscription sub) { StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub); cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch()); return cursor; }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) {\n        StoreDurableSubscriberCursor cursor = new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub);\n        cursor.setImmediatePriorityDispatch(isImmediatePriorityDispatch());\n        return cursor;\n    }\n","new_comment_raw":"@param clientId","old_comment_raw":"@param clientId","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":48},{"new_code_raw":"public void addPet (Pet pet) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = pet; \/\/ verify the required parameter 'pet' is set if (pet == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'pet' when calling addPet\", new ApiException(400, \"Missing the required parameter 'pet' when calling addPet\")); } \/\/ create path and map variables String path = \"\/pet\"; \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params } String[] authNames = new String[] { \"petstore_auth\" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void addPet (Pet body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling addPet\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling addPet\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/pet\";\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application\/json\",\n      \"application\/xml\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param pet Pet object that needs to be added to the store","old_comment_raw":"@param body Pet object that needs to be added to the store","label":1,"pre_label":0,"AST_level":11,"line_counts":56,"new_code_token_num":349},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { return uploadFileWithRequiredFileWithHttpInfo(petId, requiredFile, additionalMetadata).getData(); }","old_code_raw":"  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    return uploadFileWithRequiredFileWithHttpInfo(petId, file, additionalMetadata).getData();\n      }\n","new_comment_raw":"@param additionalMetadata Additional data to pass to server (optional, default to null)","old_comment_raw":"@param additionalMetadata Additional data to pass to server (optional, default to null)","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) contentType = \"application\/json\"; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = reqBuilder.method(method, reqBody).build(); return httpClient.newCall(request); }","old_code_raw":"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    \/\/ ensuring a default content type\n    if (contentType == null) contentType = \"application\/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart\/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        \/\/ allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        \/\/ use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null && reqBody != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n","new_comment_raw":"@param body The request body object","old_comment_raw":"@param body The request body object","label":0,"pre_label":1,"AST_level":14,"line_counts":34,"new_code_token_num":285},{"new_code_raw":"public BrokerRequest optimize(BrokerRequest brokerRequest) { optimizeFilterQueryTree(brokerRequest); return brokerRequest; }","old_code_raw":"  public BrokerRequest optimize(BrokerRequest inputReq) {\n    \/\/ Flatten the query tree if possible\n    return flatten(inputReq);\n  }\n","new_comment_raw":"@param brokerRequest BrokerRequest that is to be optimized","old_comment_raw":"@param inputReq BrokerRequest that is to be optimized","label":1,"pre_label":0,"AST_level":5,"line_counts":7,"new_code_token_num":17},{"new_code_raw":"public RexProgram normalize(RexBuilder rexBuilder, RexSimplify simplify) { \/\/ Normalize program by creating program builder from the program, then \/\/ converting to a program. getProgram does not need to normalize \/\/ because the builder was normalized on creation. assert isValid(Litmus.THROW, null); final RexProgramBuilder builder = RexProgramBuilder.create(rexBuilder, inputRowType, exprs, projects, condition, outputRowType, true, simplify); return builder.getProgram(false); }","old_code_raw":"  public RexProgram normalize(RexBuilder rexBuilder, boolean simplify) {\n    \/\/ Normalize program by creating program builder from the program, then\n    \/\/ converting to a program. getProgram does not need to normalize\n    \/\/ because the builder was normalized on creation.\n    assert isValid(Litmus.THROW, null);\n    final RexProgramBuilder builder =\n        RexProgramBuilder.create(rexBuilder, inputRowType, exprs, projects,\n            condition, outputRowType, true, simplify);\n    return builder.getProgram(false);\n  }\n","new_comment_raw":"@param simplify Simplifier to simplify (in addition to normalizing), or null to not simplify","old_comment_raw":"@param simplify Whether to simplify (in addition to normalizing)","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":85},{"new_code_raw":"public Action resumed(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { return action(request, response); }","old_code_raw":"    public Action resumed(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n","new_comment_raw":"@param response the  AtmosphereResponse","old_comment_raw":"@param response the HttpServletResponse","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public static RemoteProxy getNewBasicRemoteProxy(String appName, String url,Registry registry) { RegistrationRequest req = new RegistrationRequest(); Map<String, Object> capability = new HashMap<String, Object>(); capability.put(\"applicationName\", appName); req.addDesiredCapabilitiy(capability); Map<String, Object> config = new HashMap<String, Object>(); config.put(\"url\", url); req.setConfiguration(config); return new RemoteProxy(req,registry); }","old_code_raw":"\tpublic static RemoteProxy getNewBasicRemoteProxy(String appName, String url) {\n\n\t\tRegistrationRequest req = new RegistrationRequest();\n\n\t\tMap<String, Object> capability = new HashMap<String, Object>();\n\t\tcapability.put(\"applicationName\", appName);\n\t\treq.addDesiredCapabilitiy(capability);\n\n\t\tMap<String, Object> config = new HashMap<String, Object>();\n\t\tconfig.put(\"url\", url);\n\t\treq.setConfiguration(config);\n\t\treturn new RemoteProxy(req);\n\n\t}\n","new_comment_raw":"@param appName","old_comment_raw":"@param appName","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":90},{"new_code_raw":"public String toDefaultValue(Schema schema) { if (ModelUtils.isBooleanSchema(schema)) { return \"null\"; } else if (ModelUtils.isDateSchema(schema)) { return \"null\"; } else if (ModelUtils.isDateTimeSchema(schema)) { return \"null\"; } else if (ModelUtils.isNumberSchema(schema)) { return \"null\"; } else if (ModelUtils.isIntegerSchema(schema)) { return \"null\"; } else if (ModelUtils.isStringSchema(schema)) { return \"null\"; } else if (ModelUtils.isObjectSchema(schema)) { return \"null\"; } else { return \"null\"; } }","old_code_raw":"    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            return \"null\";\n        } else if (p instanceof BooleanProperty) {\n            return \"null\";\n        } else if (p instanceof DateProperty) {\n            return \"null\";\n        } else if (p instanceof DateTimeProperty) {\n            return \"null\";\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \"null\";\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \"null\";\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \"null\";\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n","new_comment_raw":"@param schema Property schema","old_comment_raw":"@param p Swagger property object","label":1,"pre_label":0,"AST_level":12,"line_counts":20,"new_code_token_num":128},{"new_code_raw":"public static String getObjectName(AssetFile asset, ObjectPath path) { Deserializer deser = new Deserializer(asset); String name = null; try { UnityObject obj = deser.deserialize(path); name = obj.getValue(\"m_Name\"); } catch (OutOfMemoryError ex) { \/\/ Deserializer choked on an array size and clogged the heap, try \/\/ to clean up this mess deser = null; System.gc(); } catch (Throwable ex) { } return name; }","old_code_raw":"    public static String getObjectName(AssetFile asset, AssetObjectPath path) {\n        Deserializer deser = new Deserializer(asset);\n        String name = null;\n        \n        try {\n            UnityObject obj = deser.deserialize(path);\n            name = obj.getValue(\"m_Name\");\n        } catch (OutOfMemoryError ex) {\n            \/\/ Deserializer choked on an array size and clogged the heap, try\n            \/\/ to clean up this mess\n            deser = null;\n            System.gc();\n        } catch (Throwable ex) {\n        }\n        \n        return name;\n    }\n","new_comment_raw":"@param path object path","old_comment_raw":"@param path object path","label":0,"pre_label":1,"AST_level":7,"line_counts":18,"new_code_token_num":91},{"new_code_raw":"public static <T> Method findMethod(Class<?> implClass, Operation<T> operation) throws NoSuchMethodException { String name = operation.getName(); Class<?>[] paramTypes = getPhysicalTypes(operation); return implClass.getMethod(name, paramTypes); }","old_code_raw":"    public static Method findMethod(Operation<?> operation, Method[] methods) {\n        for (Method method : methods) {\n            if (match(operation, method)) {\n                return method;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@param operation the operation to match","old_comment_raw":"@param methods the methods to match against","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":44},{"new_code_raw":"private int scanURL(String url, User user, int maxChildren) throws ApiException { log.debug(\"API Spider scanning url: \" + url); URI startURI; try { \/\/ Try to build uri startURI = new URI(url, true); } catch (URIException e) { throw new ApiException(ApiException.Type.BAD_FORMAT); } SiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI); String scheme = startURI.getScheme(); if (scheme == null || (!scheme.equalsIgnoreCase(\"http\") && !scheme.equalsIgnoreCase(\"https\"))) { throw new ApiException(ApiException.Type.BAD_FORMAT); } Target target = new Target(startNode); target.setRecurse(true); Object[] objs = null; if (maxChildren > 0) { \/\/ Add the filters to filter on maximum number of children MaxChildrenFetchFilter maxChildrenFetchFilter = new MaxChildrenFetchFilter(); maxChildrenFetchFilter.setMaxChildren(maxChildren); maxChildrenFetchFilter.setModel(extension.getModel()); MaxChildrenParseFilter maxChildrenParseFilter = new MaxChildrenParseFilter(); maxChildrenParseFilter.setMaxChildren(maxChildren); maxChildrenParseFilter.setModel(extension.getModel()); objs = new Object[] { maxChildrenFetchFilter, maxChildrenParseFilter }; } return extension.startScan(target.getDisplayName(), target, user, objs); }","old_code_raw":"\tprivate int scanURL(String url, User user) throws ApiException {\n\t\tlog.debug(\"API Spider scanning url: \" + url);\n\n\t\tURI startURI;\n\t\ttry {\n\t\t\t\/\/ Try to build uri\n\t\t\tstartURI = new URI(url, true);\n\t\t} catch (URIException e) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\n\t\tSiteNode startNode = Model.getSingleton().getSession().getSiteTree().findNode(startURI);\n\t\tString scheme = startURI.getScheme();\n\t\tif (scheme == null || (!scheme.equalsIgnoreCase(\"http\") && !scheme.equalsIgnoreCase(\"https\"))) {\n\t\t\tthrow new ApiException(ApiException.Type.BAD_FORMAT);\n\t\t}\n\t\tTarget target = new Target(startNode);\n\t\ttarget.setRecurse(true);\n\t\treturn extension.startScan(target.getDisplayName(), target, user, null);\n\t}\n","new_comment_raw":"@param user the user to scan as, or null if the scan is done without the perspective of any user","old_comment_raw":"@param user the user to scan as, or null if the scan is done without the perspective of any user","label":0,"pre_label":1,"AST_level":9,"line_counts":38,"new_code_token_num":240},{"new_code_raw":"private ColumnState buildMap(ContainerState parent, ColumnMetadata columnSchema) { \/\/ When dynamically adding columns, must add the (empty) \/\/ map by itself, then add columns to the map via separate \/\/ calls. assert columnSchema.isMap(); assert columnSchema.tupleSchema().isEmpty(); \/\/ Create the vector, vector state and writer. if (columnSchema.isArray()) { return buildMapArray(parent, columnSchema); } else { return buildSingleMap(parent, columnSchema); } }","old_code_raw":"  private ColumnState buildMap(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    \/\/ When dynamically adding columns, must add the (empty)\n    \/\/ map by itself, then add columns to the map via separate\n    \/\/ calls.\n\n    assert columnSchema.isMap();\n    assert columnSchema.tupleSchema().isEmpty();\n\n    \/\/ Create the vector, vector state and writer.\n\n    if (columnSchema.isArray()) {\n      return buildMapArray(parent, colProj);\n    } else {\n      return buildSingleMap(parent, colProj);\n    }\n  }\n","new_comment_raw":"@param colProj implied projection type for the column","old_comment_raw":"@param colProj implied projection type for the column","label":0,"pre_label":1,"AST_level":7,"line_counts":16,"new_code_token_num":95},{"new_code_raw":"public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return offsetFormatter().print(instant, this); }","old_code_raw":"    public String getShortName(long millis, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(millis);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(millis, this);\n    }\n","new_comment_raw":"@param instant milliseconds from 1970-01-01T00:00:00Z to get the name for","old_comment_raw":"@param millis milliseconds from 1970-01-01T00:00:00Z to get the name for","label":1,"pre_label":0,"AST_level":7,"line_counts":15,"new_code_token_num":76},{"new_code_raw":"private String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow, String defaultLogLevel) throws IOException { outputFile.createNewFile(); if (!outputFile.canWrite()) { throw new IOException(\"Can't write to outputFile: \" + outputFile.getAbsolutePath()); } long timeoutInMs = 1000l * timeoutInSeconds; if (timeoutInMs < 0) { log.warn(\"Looks like the timeout overflowed, so resetting it to the maximum.\"); timeoutInMs = Long.MAX_VALUE; } RemoteControlConfiguration configuration = remoteControl.getConfiguration(); remoteControl.handleHTMLRunnerResults(this); String sessionId = Long.toString(System.currentTimeMillis() % 1000000); FrameGroupCommandQueueSet.makeQueueSet( sessionId, configuration.getPortDriversShouldContact(), configuration); BrowserConfigurationOptions browserOptions = new BrowserConfigurationOptions(); configuration.copySettingsIntoBrowserOptions(browserOptions); browserOptions.setSingleWindow(!multiWindow); BrowserLauncher launcher = getBrowserLauncher(browser, sessionId, configuration, browserOptions); BrowserSessionInfo sessionInfo = new BrowserSessionInfo(sessionId, browser, browserURL, launcher, null); remoteControl.registerBrowserSession(sessionInfo); \/\/ JB: -- aren't these URLs in the wrong order according to declaration? launcher.launchHTMLSuite(suiteURL, browserURL); sleepTight(timeoutInMs); launcher.close(); remoteControl.deregisterBrowserSession(sessionInfo); if (results == null) { throw new SeleniumCommandTimedOutException(); } writeResults(outputFile); return results.getResult().toUpperCase(); }","old_code_raw":"    private String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, int timeoutInSeconds, boolean multiWindow, String defaultLogLevel) throws IOException {\n        outputFile.createNewFile();\n        if (!outputFile.canWrite()) {\n        \tthrow new IOException(\"Can't write to outputFile: \" + outputFile.getAbsolutePath());\n        }\n    \tlong timeoutInMs = 1000l * timeoutInSeconds;\n        if (timeoutInMs < 0) {\n            log.warn(\"Looks like the timeout overflowed, so resetting it to the maximum.\");\n            timeoutInMs = Long.MAX_VALUE;\n        }\n        \n        RemoteControlConfiguration configuration = remoteControl.getConfiguration();\n        remoteControl.handleHTMLRunnerResults(this);\n\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        FrameGroupCommandQueueSet.makeQueueSet(\n                sessionId, configuration.getPortDriversShouldContact(), configuration);\n\n        BrowserConfigurationOptions browserOptions = new BrowserConfigurationOptions();\n        \n        configuration.copySettingsIntoBrowserOptions(browserOptions);\n        \n        browserOptions.setSingleWindow(!multiWindow);\n        \n        BrowserLauncher launcher = getBrowserLauncher(browser, sessionId, configuration, browserOptions);\n        BrowserSessionInfo sessionInfo = new BrowserSessionInfo(sessionId, \n            browser, browserURL, launcher, null);\n        \n        remoteControl.registerBrowserSession(sessionInfo);\n        \n        \/\/ JB: -- aren't these URLs in the wrong order according to declaration?\n        launcher.launchHTMLSuite(suiteURL, browserURL);\n        \n        sleepTight(timeoutInMs);\n        \n        launcher.close();\n        \n        remoteControl.deregisterBrowserSession(sessionInfo);\n        \n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        \n        writeResults(outputFile);\n        \n        return results.getResult().toUpperCase();\n    }\n","new_comment_raw":"@param outputFile - The file to which we'll output the HTML results","old_comment_raw":"@param outputFile - The file to which we'll output the HTML results","label":0,"pre_label":1,"AST_level":8,"line_counts":48,"new_code_token_num":264},{"new_code_raw":"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(\"?\"); else b.append(\"&\"); b.append(escapeString(key)).append(\"=\").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param accept The request's Accept header","old_comment_raw":"@param accept The request's Accept header","label":0,"pre_label":1,"AST_level":16,"line_counts":111,"new_code_token_num":730},{"new_code_raw":"public boolean isNormalized(Litmus litmus, RexBuilder rexBuilder) { final RexProgram normalizedProgram = normalize(rexBuilder, false); String normalized = normalizedProgram.toString(); String string = toString(); if (!normalized.equals(string)) { return litmus.fail(\"Program is not normalized:\\n\" + \"program: \" + string + \"\\n\" + \"normalized: \" + normalized + \"\\n\"); } return litmus.succeed(); }","old_code_raw":"  public boolean isNormalized(boolean fail, RexBuilder rexBuilder) {\n    final RexProgram normalizedProgram =\n        RexProgramBuilder.normalize(rexBuilder, this);\n    String normalized = normalizedProgram.toString();\n    String string = toString();\n    if (!normalized.equals(string)) {\n      assert !fail\n          : \"Program is not normalized:\\n\"\n          + \"program:    \" + string + \"\\n\"\n          + \"normalized: \" + normalized + \"\\n\";\n      return false;\n    }\n    return true;\n  }\n","new_comment_raw":"@param rexBuilder Rex builder","old_comment_raw":"@param rexBuilder Rex builder","label":0,"pre_label":1,"AST_level":13,"line_counts":12,"new_code_token_num":91},{"new_code_raw":"public boolean highlightNode(JavaEditor editor){ if (!(node instanceof SimpleName)) { return false; } SimpleName nodeName = (SimpleName) node; try { \/\/TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline() int javaLineNumber = getLineNumber(nodeName); int pdeOffs[] = editor.getErrorChecker().calculateTabIndexAndLineNumber(javaLineNumber); PlainDocument javaSource = new PlainDocument(); javaSource.insertString(0, editor.getErrorChecker().sourceCode, null); Element lineElement = javaSource.getDefaultRootElement() .getElement(javaLineNumber-1); if(lineElement == null) { Messages.log(lineNumber + \" line element null while highlighting \" + nodeName); return false; } String javaLine = javaSource.getText(lineElement.getStartOffset(), lineElement.getEndOffset() - lineElement.getStartOffset()); editor.getSketch().setCurrentCode(pdeOffs[0]); String pdeLine = editor.getLineText(pdeOffs[1]); String lookingFor = nodeName.toString(); Messages.log(lookingFor + \", \" + nodeName.getStartPosition()); Messages.log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\" + lineElement.getEndOffset()); Messages.log(pdeOffs[1] + \" PL \" + pdeLine); if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) { Messages.loge(\"Logical error in highLightNode(). Please file a bug report.\"); return false; } OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine); int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition() - lineElement.getStartOffset(), nodeName.getLength()); if (highlightStart == -1) { Messages.loge(\"Logical error in highLightNode() during offset matching. \" + \"Please file a bug report.\"); return false; } int lso = editor.getTextArea().getLineStartOffset(pdeOffs[1]); highlightStart += lso; editor.setSelection(highlightStart, highlightStart + nodeName.getLength()); \/* \/\/ First find the name in the java line, and marks its index Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\"); Matcher matcher = toFind.matcher(javaLine); int count = 0, index = 0; int lsto = lineElement.getStartOffset(); while(matcher.find()){ count++; \/\/log(matcher.start() + lsto); if(lsto + matcher.start() == nodeName.getStartPosition()) break; } log(\"count=\" + count); index = 0; \/\/ find the same name in the pde line by its index and get its offsets matcher = toFind.matcher(pdeLine); while(matcher.find()){ count--; if(count == 0){ log(\"Found on pde line lso: \" + matcher.start()); index = matcher.end(); break; } } log(\"pde lso \" + (index - lookingFor.length())); int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]); astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso + index); *\/ return true; } catch (BadLocationException e) { Messages.loge(\"BLE in highLightNode() for \" + nodeName); e.printStackTrace(); } return false; }","old_code_raw":"  public boolean highlightNode(ASTGenerator astGenerator){\n    if (!(Node instanceof SimpleName)) {\n      return false;\n    }\n    SimpleName nodeName = (SimpleName) node;\n    try {\n      \/\/TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline()\n      int javaLineNumber = getLineNumber(nodeName);\n      int pdeOffs[] = astGenerator.errorCheckerService\n          .calculateTabIndexAndLineNumber(javaLineNumber);\n      PlainDocument javaSource = new PlainDocument();\n      javaSource.insertString(0, astGenerator.errorCheckerService.sourceCode, null);\n      Element lineElement = javaSource.getDefaultRootElement()\n          .getElement(javaLineNumber-1);\n      if(lineElement == null) {\n        Messages.log(lineNumber + \" line element null while highlighting \" + nodeName);\n        return false;\n      }\n\n      String javaLine = javaSource.getText(lineElement.getStartOffset(),\n                                           lineElement.getEndOffset()\n                                               - lineElement.getStartOffset());\n      astGenerator.editor.getSketch().setCurrentCode(pdeOffs[0]);\n      String pdeLine = astGenerator.editor.getLineText(pdeOffs[1]);\n      String lookingFor = nodeName.toString();\n      Messages.log(lookingFor + \", \" + nodeName.getStartPosition());\n      Messages.log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\"\n          + lineElement.getEndOffset());\n      Messages.log(pdeOffs[1] + \" PL \" + pdeLine);\n      if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) {\n        Messages.loge(\"Logical error in highLightNode(). Please file a bug report.\");\n        return false;\n      }\n\n      OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine);\n      int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition()\n                                  - lineElement.getStartOffset(),\n                              nodeName.getLength());\n      if (highlightStart == -1) {\n        Messages.loge(\"Logical error in highLightNode() during offset matching. \" +\n        \t\t\"Please file a bug report.\");\n        return false;\n      }\n      int lso = astGenerator.editor.getTextArea().getLineStartOffset(pdeOffs[1]);\n      highlightStart += lso;\n      astGenerator.editor.setSelection(highlightStart, highlightStart\n          + nodeName.getLength());\n      \/*\n      \/\/ First find the name in the java line, and marks its index\n      Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\");\n      Matcher matcher = toFind.matcher(javaLine);\n      int count = 0, index = 0;\n      int lsto = lineElement.getStartOffset();\n      while(matcher.find()){\n        count++;\n        \/\/log(matcher.start() + lsto);\n        if(lsto + matcher.start() == nodeName.getStartPosition())\n          break;\n      }\n      log(\"count=\" + count);\n      index = 0;\n      \/\/ find the same name in the pde line by its index and get its offsets\n      matcher = toFind.matcher(pdeLine);\n      while(matcher.find()){\n        count--;\n        if(count == 0){\n          log(\"Found on pde line lso: \" + matcher.start());\n          index = matcher.end();\n          break;\n        }\n      }\n      log(\"pde lso \" + (index - lookingFor.length()));\n\n      int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]);\n      astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso\n          + index);\n      *\/\n      return true;\n\n    } catch (BadLocationException e) {\n      Messages.loge(\"BLE in highLightNode() for \" + nodeName);\n      e.printStackTrace();\n    }\n    return false;\n  }\n","new_comment_raw":"@param editor","old_comment_raw":"@param astGenerator","label":1,"pre_label":0,"AST_level":12,"line_counts":85,"new_code_token_num":638},{"new_code_raw":"public int get(long instant) { int year = iChronology.year().get(instant); \/\/ long firstWeekMillis1 = iChronology.getFirstWeekOfYearMillis(year); if (instant < firstWeekMillis1) { return iChronology.getWeeksInYear(year - 1); } long firstWeekMillis2 = iChronology.getFirstWeekOfYearMillis(year + 1); if (instant >= firstWeekMillis2) { return 1; } return (int) ((instant - firstWeekMillis1) \/ DateTimeConstants.MILLIS_PER_WEEK) + 1; }","old_code_raw":"    public int get(long millis) {\n        int year = iChronology.year().get(millis);\n        \/\/\n        long firstWeekMillis1 = iChronology.getFirstWeekOfYearMillis(year);\n        if (millis < firstWeekMillis1) {\n            return iChronology.getWeeksInYear(year - 1);\n        }\n        long firstWeekMillis2 = iChronology.getFirstWeekOfYearMillis(year + 1);\n        if (millis >= firstWeekMillis2) {\n            return 1;\n        }\n        return (int) ((millis - firstWeekMillis1) \/ DateTimeConstants.MILLIS_PER_WEEK) + 1;\n    }\n","new_comment_raw":"@param instant the time instant in millis to query.","old_comment_raw":"@param millis the time instant in millis to query.","label":1,"pre_label":0,"AST_level":8,"line_counts":14,"new_code_token_num":83},{"new_code_raw":"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(\"?\"); else b.append(\"&\"); b.append(escapeString(key)).append(\"=\").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getStatusInfo() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getStatusInfo().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getStatusInfo().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param queryParams The query parameters","old_comment_raw":"@param queryParams The query parameters","label":0,"pre_label":1,"AST_level":16,"line_counts":111,"new_code_token_num":730},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); \/\/System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); } } return nodeList; }","old_code_raw":"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@param t Target for finding governors of t related by this GR","old_comment_raw":"@param t Target for finding dependents of t related by this GR","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":151},{"new_code_raw":"public Builder rootParentType(GraphQLCompositeType rootParentType) { this.rootParentType = rootParentType; return this; }","old_code_raw":"        public Builder rootParentType(GraphQLObjectType rootParentType) {\n            this.rootParentType = rootParentType;\n            return this;\n        }\n","new_comment_raw":"@param rootParentType the root parent type","old_comment_raw":"@param rootParentType the root parent type","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"public static AnnotationMirror getAnnotationMirror(Element element, String fqcn) { assert element != null; assert fqcn != null; AnnotationMirror mirror = null; for ( AnnotationMirror am : element.getAnnotationMirrors() ) { if ( isAnnotationMirrorOfType( am, fqcn ) ) { mirror = am; break; } } return mirror; }","old_code_raw":"\tpublic static AnnotationMirror getAnnotationMirror(Element element, Class<? extends Annotation> clazz) {\n\t\tassert element != null;\n\t\tassert clazz != null;\n\n\t\tAnnotationMirror mirror = null;\n\t\tfor ( AnnotationMirror am : element.getAnnotationMirrors() ) {\n\t\t\tif ( isAnnotationMirrorOfType( am, clazz ) ) {\n\t\t\t\tmirror = am;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn mirror;\n\t}\n","new_comment_raw":"@param fqcn the fully qualified class name of the annotation to check for","old_comment_raw":"@param clazz the annotation class to check for","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":58},{"new_code_raw":"public Object nullSafeGet(ResultSet rs, String name, SharedSessionContractImplementor session, Object owner) throws SQLException { return nullSafeGet( rs, new String[] { name }, session, owner ); }","old_code_raw":"\tpublic Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner) throws SQLException {\n\t\treturn nullSafeGet( rs, new String[] { name }, session, owner );\n\t}\n","new_comment_raw":"@param session The session from which the request is originating.","old_comment_raw":"@param session The session from which the request is originating.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":38},{"new_code_raw":"public void createUser (User user) throws ApiException { Object localVarPostBody = user; \/\/ verify the required parameter 'user' is set if (user == null) { throw new ApiException(400, \"Missing the required parameter 'user' when calling createUser\"); } \/\/ create path and map variables String localVarPath = \"\/user\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); \/\/ form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { \"application\/json\" }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\"; if (localVarContentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { \/\/ normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public void  createUser (User body) throws ApiException {\n    Object localVarPostBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling createUser\");\n    }\n\n    \/\/ create path and map variables\n    String localVarPath = \"\/user\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\";\n\n    if (localVarContentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      \/\/ normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param user Created user object","old_comment_raw":"@param body Created user object","label":1,"pre_label":0,"AST_level":8,"line_counts":47,"new_code_token_num":252},{"new_code_raw":"public CodegenModel fromModel(String name, Schema model, Map<String, Schema> allDefinitions) { CodegenModel codegenModel = super.fromModel(name, model, allDefinitions); return codegenModel; }","old_code_raw":"    public CodegenModel fromModel(String name, Model model, Map<String, Model> allDefinitions) {\n        CodegenModel codegenModel = super.fromModel(name, model, allDefinitions);\n        return codegenModel;\n    }\n","new_comment_raw":"@param allDefinitions a map of all OpenAPI models from the spec","old_comment_raw":"@param allDefinitions a map of all Swagger models from the spec","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":33},{"new_code_raw":"private static void algC(StringBuilder sb, int m, int n, String a, String b) { int i; int j; \/\/ Step 1 if (n == 0) { \/\/ Nothing to do } else if (m == 1) { for (j = 0; j < n; j++) { if (a.charAt(0) == b.charAt(j)) { sb.append(a.charAt(0)); break; } } \/\/ Step 2 } else { i = (int)Math.floor(((double) m) \/ 2); \/\/ Step 3 int[] l1 = algB(i, n, a.substring(0, i), b); int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b)); \/\/ Step 4 int k = findK(l1, l2, n); \/\/ Step 5 algC(sb, i, k, a.substring(0, i), b.substring(0, k)); algC(sb, m - i, n - k, a.substring(i), b.substring(k)); } }","old_code_raw":"    private String algC(int m, int n, String a, String b) {\n        int i;\n        int j;\n        StringBuilder sb;\n\n        \/\/ Step 1\n        if (n == 0) {\n            sb = new StringBuilder();\n            \n        } else if (m == 1) {\n            sb = new StringBuilder();\n            for (j = 0; j < n; j++) {\n                if (a.charAt(0) == b.charAt(j)) {\n                    sb.append(a.charAt(0));\n                    break;\n                }\n            }\n\n        \/\/ Step 2\n        } else {\n            i = (int)Math.floor(((double) m) \/ 2);\n\n            \/\/ Step 3\n            int[] l1 = algB(i, n, a.substring(0, i), b);\n            int[] l2 = algB(m - i, n, reverseString(a.substring(i)), reverseString(b));\n\n            \/\/ Step 4\n            int k = findK(l1, l2, n);\n\n            \/\/ Step 5\n            sb = new StringBuilder(algC(i, k, a.substring(0, i), b.substring(0, k)));\n            sb.append(algC(m - i, n - k, a.substring(i), b.substring(k)));\n        }\n\n        \/\/ Return the LCS\n        return sb.toString();\n    }\n","new_comment_raw":"@param b","old_comment_raw":"@param b","label":0,"pre_label":1,"AST_level":13,"line_counts":32,"new_code_token_num":238},{"new_code_raw":"public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception { return addPropertiesToURI(uri.toString(), properties); }","old_code_raw":"    public static String addPropertiesToURI(URI uri, Map<String, String> props) throws Exception {\n        return addPropertiesToURI(uri.toString(), props);\n    }\n","new_comment_raw":"@param bean The Object whose properties will be added to the target URI.","old_comment_raw":"@param props","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":29},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; while (sentence.governor(startAncestor).isPresent() && sentence.governor(startAncestor).get() >= 0) { rootToStart.addFirst(startAncestor); startAncestor = sentence.governor(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = start; while (sentence.governor(endAncestor).isPresent() && sentence.governor(endAncestor).get() >= 0) { rootToEnd.addFirst(endAncestor); endAncestor = sentence.governor(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node return null; \/\/ TODO(gabor) write me! }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    \/\/ Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n","new_comment_raw":"@param  The type of the element we are getting.","old_comment_raw":"@param The type of the element we are getting.","label":0,"pre_label":1,"AST_level":8,"line_counts":27,"new_code_token_num":178},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException { Object localVarPostBody = booleanPostBody; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/boolean\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"*\/*\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/boolean\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param booleanPostBody Input boolean as post body (optional)","old_comment_raw":"@param body Input boolean as post body (optional)","label":1,"pre_label":0,"AST_level":8,"line_counts":30,"new_code_token_num":176},{"new_code_raw":"public static Struct fromLogical(Schema schema, SpecialValueDecimal value) { Struct result = new Struct(schema); final BigDecimal decimalValue = value.getDecimalValue().orElse(null); assert decimalValue != null : \"Unable to encode special value\"; result.put(VALUE_FIELD, decimalValue.unscaledValue().toByteArray()); result.put(SCALE_FIELD, decimalValue.scale()); return result; }","old_code_raw":"    public static Struct fromLogical(Schema schema, DebeziumDecimal value) {\n        Struct result = new Struct(schema);\n        final BigDecimal decimalValue = value.getDecimalValue().orElse(null);\n        assert decimalValue != null : \"Unable to encode special value\";\n        result.put(VALUE_FIELD, decimalValue.unscaledValue().toByteArray());\n        result.put(SCALE_FIELD, decimalValue.scale());\n        return result;\n    }\n","new_comment_raw":"@param schema of the encoded value","old_comment_raw":"@param schema of the encoded value","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":74},{"new_code_raw":"public static Point getMiniMapImageLocation(Client client, LocalPoint localLocation, BufferedImage image) { Point p = Perspective.worldToMiniMap(client, localLocation.getX(), localLocation.getY()); if (p == null) { return null; } int xOffset = p.getX() - image.getWidth() \/ 2; int yOffset = p.getY() - image.getHeight() \/ 2; return new Point(xOffset, yOffset); }","old_code_raw":"\tpublic static Point getMiniMapImageLocation(Client client, Point localLocation, BufferedImage image)\n\t{\n\t\tPoint p = Perspective.worldToMiniMap(client, localLocation.getX(), localLocation.getY());\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - image.getWidth() \/ 2;\n\t\tint yOffset = p.getY() - image.getHeight() \/ 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n","new_comment_raw":"@param localLocation local location of the tile","old_comment_raw":"@param localLocation local location of the tile","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":81},{"new_code_raw":"public int create(Object[] row, Instant ts) throws InterruptedException { return create(row, ts, 0, 1); }","old_code_raw":"        public int create(Object[] row, long ts) throws InterruptedException {\n            return create(row, ts, 0, 1);\n        }\n","new_comment_raw":"@param row the values of the row, in the same order as the columns in the  Table definition in the  MySqlSchema.","old_comment_raw":"@param row the values of the row, in the same order as the columns in the Table definition in the MySqlSchema.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"private static File getKylinPropertiesFile(String path) { if (path == null) return null; File propFile = new File(path, KYLIN_CONF_PROPERTIES_FILE); if (propFile.exists()) { logger.info(KYLIN_CONF_PROPERTIES_FILE + \" was found at \" + propFile.getAbsolutePath()); } logger.info(KYLIN_CONF_PROPERTIES_FILE + \" was NOT found at \" + propFile.getAbsolutePath()); return null; }","old_code_raw":"    private static File getKylinPropertiesFile(String path, String env) {\n        File dir = new File(path);\n        System.out.println(dir.getAbsolutePath());\n        if (dir.exists() && dir.isDirectory()) {\n            File propFile = new File(dir, KYLIN_CONF_PROPERTIES_FILE);\n            String fName = KYLIN_CONF_PROPERTIES_FILE;\n            File envPropFile = null;\n            if (env != null) {\n                fName = fName.replace(\".\", \"_\" + env + \".\");\n                envPropFile = new File(dir, fName);\n            }\n            if (envPropFile != null && envPropFile.exists()) {\n                logger.info(fName + \" found in \" + path);\n                return envPropFile;\n            }\n            if (propFile != null && propFile.exists()) {\n                logger.info(KYLIN_CONF_PROPERTIES_FILE + \" found in \" + path);\n                return propFile;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@param path","old_comment_raw":"@param path","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":75},{"new_code_raw":"public static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } FontMetrics fm = graphics.getFontMetrics(); Rectangle2D bounds = fm.getStringBounds(text, graphics); int xOffset = p.getX() - (int) (bounds.getWidth() \/ 2); return new Point(xOffset, p.getY()); }","old_code_raw":"\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() \/ 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n","new_comment_raw":"@param graphics","old_comment_raw":"@param graphics","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":109},{"new_code_raw":"public boolean get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public boolean get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"@param withAttributes an object containing an AttributeMap","old_comment_raw":"@param attributes an object containing an AttributeMap","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public TableExtDesc getTableExt(String tableName) { if (tableName.indexOf(\".\") < 0) tableName = \"DEFAULT.\" + tableName; TableExtDesc result = srcTableExdMap.get(tableName.toUpperCase()); \/\/ create new if (null == result) { result = new TableExtDesc(); result.setName(tableName); result.setUuid(UUID.randomUUID().toString()); result.setLastModified(0); result.init(); srcTableExdMap.put(result.getName(), result); } return result; }","old_code_raw":"    public TableExtDesc getTableExt(String tableName, String prj) {\n        TableDesc t = getTableDesc(tableName, prj);\n        if (t == null)\n            return null;\n\n        TableExtDesc result = srcTableExtMap.get(mapKey(t.getIdentity(), t.getProject()));\n\n        \/\/ avoid returning null, since the TableDesc exists\n        if (null == result) {\n            result = new TableExtDesc();\n            result.setIdentity(t.getIdentity());\n            result.setUuid(UUID.randomUUID().toString());\n            result.setLastModified(0);\n            result.init(t.getProject());\n            srcTableExtMap.put(mapKey(t.getIdentity(), t.getProject()), result);\n        }\n        return result;\n    }\n","new_comment_raw":"@param tableName","old_comment_raw":"@param tableName","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":97},{"new_code_raw":"public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws ApiException { com.squareup.okhttp.Call call = uploadFileWithRequiredFileValidateBeforeCall(petId, requiredFile, additionalMetadata, null, null); Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType(); return apiClient.execute(call, localVarReturnType); }","old_code_raw":"    public ApiResponse<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File file, String additionalMetadata) throws ApiException {\n        com.squareup.okhttp.Call call = uploadFileWithRequiredFileValidateBeforeCall(petId, file, additionalMetadata, null, null);\n        Type localVarReturnType = new TypeToken<ModelApiResponse>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n","new_comment_raw":"@param requiredFile file to upload (required)","old_comment_raw":"@param file file to upload (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":58},{"new_code_raw":"private double[] makeDatumUsingEmbedding(List<IN> info, int loc, FeatureFactory<IN> featureFactory, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) { double[] featureValArr; List<double[]> embeddingList = new ArrayList<double[]>(); int concatEmbeddingLen = 0; String currentWord = null; for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) { double[] embedding = null; if (currLoc >=0 && currLoc < info.size()) { currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class); String word = currentWord.toLowerCase(); word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\"); if (embeddings.containsKey(word)) embedding = embeddings.get(word); else embedding = embeddings.get(\"UNKNOWN\"); } else { embedding = embeddings.get(\"PADDING\"); } for (int e = 0; e < embedding.length; e++) { featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e); } if (flags.addCapitalFeatures) { int numOfCapitalFeatures = 4; double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures]; int currLen = embedding.length; System.arraycopy(embedding, 0, newEmbedding, 0, currLen); for (int e = 0; e < numOfCapitalFeatures; e++) featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e); if (currLoc >=0 && currLoc < info.size()) { \/\/ skip PADDING \/\/ check if word is all caps if (currentWord.toUpperCase().equals(currentWord)) newEmbedding[currLen] = 1; else { currLen += 1; \/\/ check if word is all lower if (currentWord.toLowerCase().equals(currentWord)) newEmbedding[currLen] = 1; else { currLen += 1; \/\/ check first letter cap if (Character.isUpperCase(currentWord.charAt(0))) newEmbedding[currLen] = 1; else { currLen += 1; \/\/ check if at least one non-initial letter is cap String remainder = currentWord.substring(1); if (!remainder.toLowerCase().equals(remainder)) newEmbedding[currLen] = 1; } } } } embedding = newEmbedding; } embeddingList.add(embedding); concatEmbeddingLen += embedding.length; } double[] concatEmbedding = new double[concatEmbeddingLen]; int currPos = 0; for (double[] em: embeddingList) { System.arraycopy(em, 0, concatEmbedding, currPos, em.length); currPos += em.length; } if (flags.prependEmbedding) { int additionalFeatureCount = 0; for (Clique c : windowCliques) { Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); \/\/todo useless copy because of typing reasons featuresC.addAll(fCol); additionalFeatureCount += fCol.size(); } featureValArr = new double[concatEmbedding.length + additionalFeatureCount]; System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length); Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0); } else { featureValArr = concatEmbedding; } if (flags.addBiasToEmbedding) { featuresC.add(\"BIAS-FEATURE\"); double[] newFeatureValArr = new double[featureValArr.length + 1]; System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length); newFeatureValArr[newFeatureValArr.length-1] = 1; featureValArr = newFeatureValArr; } return featureValArr; }","old_code_raw":"  private double[] makeDatumUsingEmbedding(List<IN> info, int loc, List<FeatureFactory<IN>> featureFactories, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) {\n    double[] featureValArr;\n    List<double[]> embeddingList = new ArrayList<double[]>();\n    int concatEmbeddingLen = 0;\n    String currentWord = null;\n    for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) {\n      double[] embedding = null;\n      if (currLoc >=0 && currLoc < info.size()) {\n        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);\n        String word = currentWord.toLowerCase();\n        word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\");\n        if (embeddings.containsKey(word))\n          embedding = embeddings.get(word);\n        else\n          embedding = embeddings.get(\"UNKNOWN\");\n      } else {\n        embedding = embeddings.get(\"PADDING\");\n      }\n\n      for (int e = 0; e < embedding.length; e++) {\n        featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e);\n      }\n\n      if (flags.addCapitalFeatures) {\n        int numOfCapitalFeatures = 4;\n        double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures];\n        int currLen = embedding.length;\n        System.arraycopy(embedding, 0, newEmbedding, 0, currLen);\n        for (int e = 0; e < numOfCapitalFeatures; e++)\n          featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e);\n\n        if (currLoc >=0 && currLoc < info.size()) { \/\/ skip PADDING\n          \/\/ check if word is all caps\n          if (currentWord.toUpperCase().equals(currentWord))\n            newEmbedding[currLen] = 1;\n          else {\n            currLen += 1;\n            \/\/ check if word is all lower\n            if (currentWord.toLowerCase().equals(currentWord))\n              newEmbedding[currLen] = 1;\n            else {\n              currLen += 1;\n              \/\/ check first letter cap\n              if (Character.isUpperCase(currentWord.charAt(0)))\n                newEmbedding[currLen] = 1;\n              else {\n                currLen += 1;\n                \/\/ check if at least one non-initial letter is cap\n                String remainder = currentWord.substring(1);\n                if (!remainder.toLowerCase().equals(remainder))\n                  newEmbedding[currLen] = 1;\n              }\n            }\n          }\n        }\n        embedding = newEmbedding;\n      }\n\n      embeddingList.add(embedding);\n      concatEmbeddingLen += embedding.length;\n    }\n    double[] concatEmbedding = new double[concatEmbeddingLen];\n    int currPos = 0;\n    for (double[] em: embeddingList) {\n      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);\n      currPos += em.length;\n    }\n\n    if (flags.prependEmbedding) {\n      int additionalFeatureCount = 0;\n      for (Clique c : windowCliques) {\n        for (FeatureFactory featureFactory : featureFactories) {\n          Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); \/\/todo useless copy because of typing reasons\n          featuresC.addAll(fCol);\n          additionalFeatureCount += fCol.size();\n        }\n      }\n      featureValArr = new double[concatEmbedding.length + additionalFeatureCount];\n      System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length);\n      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);\n    } else {\n      featureValArr = concatEmbedding;\n    }\n\n    if (flags.addBiasToEmbedding) {\n      featuresC.add(\"BIAS-FEATURE\");\n      double[] newFeatureValArr = new double[featureValArr.length + 1];\n      System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length);\n      newFeatureValArr[newFeatureValArr.length-1] = 1;\n      featureValArr = newFeatureValArr;\n    }\n    return featureValArr;\n  }\n","new_comment_raw":"@param featureFactory The FeatureFactory to use to extract features","old_comment_raw":"@param featureFactories The FeatureFactories to use to extract features","label":1,"pre_label":0,"AST_level":20,"line_counts":92,"new_code_token_num":672},{"new_code_raw":"public Client testClassname(Client client) throws ApiException { Object localVarPostBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, \"Missing the required parameter 'client' when calling testClassname\"); } \/\/ create path and map variables String localVarPath = \"\/fake_classname_test\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"api_key_query\" }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client testClassname(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClassname\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake_classname_test\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":218},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); \/\/ Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); \/\/ Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n","new_comment_raw":"@param preview bitmap that can be recycled","old_comment_raw":"@param preview bitmap that can be recycled","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":156},{"new_code_raw":"public Action resumed(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { logger.debug(\"(resumed) invoked:\\n HttpServletRequest: {}\\n HttpServletResponse: {}\", request, response); return action(request, response); }","old_code_raw":"    public Action resumed(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(\"(resumed) invoked:\\n HttpServletRequest: \" + req\n                    + \"\\n HttpServletResponse: \" + res);\n        }\n        return action(req, res);\n    }\n","new_comment_raw":"@param response the  HttpServletResponse","old_comment_raw":"@param res the HttpServletResponse","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":52},{"new_code_raw":"public JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, JoinType joinType, String[] columns) { JoinSequence joinSequence = createJoinSequence(); joinSequence.setUseThetaStyle( implicit ); \/\/ Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from) joinSequence.addJoin( associationType, tableAlias, joinType, columns ); return joinSequence; }","old_code_raw":"\tpublic JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, int joinType, String[] columns) {\n\t\tJoinSequence joinSequence = createJoinSequence();\n\t\tjoinSequence.setUseThetaStyle( implicit );\t\/\/ Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)\n\t\tjoinSequence.addJoin( associationType, tableAlias, joinType, columns );\n\t\treturn joinSequence;\n\t}\n","new_comment_raw":"@param tableAlias The table alias to use in qualifying the join conditions","old_comment_raw":"@param tableAlias The table alias to use in qualifying the join conditions","label":0,"pre_label":1,"AST_level":5,"line_counts":7,"new_code_token_num":71},{"new_code_raw":"public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, Path path, ParquetReaderConfig readerConfig) throws IOException { Metadata metadata = new Metadata(readerConfig); return metadata.getParquetTableMetadata(path, fs); }","old_code_raw":"  public static ParquetTableMetadata_v4 getParquetTableMetadata(FileSystem fs, String path, ParquetReaderConfig readerConfig) throws IOException {\n    Metadata metadata = new Metadata(readerConfig);\n    return metadata.getParquetTableMetadata(path, fs);\n  }\n","new_comment_raw":"@param path path","old_comment_raw":"@param path path","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public RepositoryMethodMetadata lookupMethod(RepositoryMetadata repositoryMetadata, Method method) { return repositoryMetadata.getMethodsMetadata().get(method); }","old_code_raw":"    public RepositoryMethodMetadata lookupMethod(Class<?> repoClass, Method method)\r\n    {\r\n        return lookupComponent(repoClass).getMethodsMetadata().get(method);\r\n    }\r\n","new_comment_raw":"@param repositoryMetadata The Repository metadata to lookup the method for.","old_comment_raw":"@param repoClass The Repository class to lookup the method for","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":22},{"new_code_raw":"public static String normalizeDateString(String s, String ctxdate) { \/\/ TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5 \u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\") \/\/ TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15) \/\/ TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")? Pattern p; Matcher m; String ctxyear = \"XXXX\", ctxmonth = \"XX\", ctxday = \"XX\"; \/\/ set up context date if (ctxdate != null) { p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\"); m = p.matcher(ctxdate); if (m.find() && m.groupCount() == 3) { ctxyear = m.group(1); ctxmonth = m.group(2); ctxday = m.group(3); } } p = Pattern.compile(\"^\" + BIRTH_DECADE_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear, true).substring(0, 3) + \"X\"); res.append(\"-XX-XX\"); return res.toString(); } p = Pattern.compile(\"^\" + RELATIVE_TIME_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(ctxmonth); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(3), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 2) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(ctxmonth); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); if (m.group(3) == null) res.append(ctxyear); else res.append(normalizeYear(m.group(3), ctxyear)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } return s; }","old_code_raw":"  public static String normalizeDateString(String s, Date ctxdate) {\n    \/\/ TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    \/\/ TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15)\n    \/\/ TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")?\n    String ctxyear = new SimpleDateFormat(\"yyyy\").format(ctxdate);\n    String ctxmonth = new SimpleDateFormat(\"MM\").format(ctxdate);\n    String ctxday = new SimpleDateFormat(\"dd\").format(ctxdate);\n\n    Pattern p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");\n    Matcher m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(normalizeYear(m.group(1), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(ctxmonth);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      if (m.group(3) == null)\n        res.append(ctxyear);\n      else\n        res.append(normalizeYear(m.group(3), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    return s;\n  }\n","new_comment_raw":"@param s Input date string","old_comment_raw":"@param s Input date string","label":0,"pre_label":1,"AST_level":10,"line_counts":114,"new_code_token_num":813},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) contentType = \"application\/json\"; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = null; if(progressRequestListener != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return httpClient.newCall(request); }","old_code_raw":"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    \/\/ ensuring a default content type\n    if (contentType == null) contentType = \"application\/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart\/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        \/\/ allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        \/\/ use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n","new_comment_raw":"@param body The request body object","old_comment_raw":"@param body The request body object","label":0,"pre_label":1,"AST_level":14,"line_counts":42,"new_code_token_num":325},{"new_code_raw":"public String applyLocksToSql(String sql, Map aliasedLockOptions, Map keyColumnNames) { return sql + new ForUpdateFragment( this, aliasedLockOptions, keyColumnNames ).toFragmentString(); }","old_code_raw":"\tpublic String applyLocksToSql(String sql, Map aliasedLockModes, Map keyColumnNames) {\n\t\treturn sql + new ForUpdateFragment( this, aliasedLockModes, keyColumnNames ).toFragmentString();\n\t}\n","new_comment_raw":"@param aliasedLockOptions a map of lock options indexed by aliased table names.","old_comment_raw":"@param aliasedLockModes a map of lock modes indexed by aliased table names.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public BrowserLauncher getBrowserLauncher(String browser, String sessionId, RemoteControlConfiguration configuration, Capabilities browserOptions) { if (browser == null) { throw new IllegalArgumentException(\"browser may not be null\"); } String executablePath = null; if (BrowserOptions.hasOptionsSet(browserOptions)) { executablePath = BrowserOptions.getExecutablePath(browserOptions); } else { configuration.copySettingsIntoBrowserOptions(browserOptions); } for (String key : supportedBrowsers.keySet()) { final BrowserStringParser.Result result; result = new BrowserStringParser().parseBrowserStartCommand(key, browser); if (result.match()) { if (executablePath == null) { executablePath = result.customLauncher(); browserOptions = BrowserOptions.setExecutablePath(browserOptions, executablePath); } LOGGER.debug(\"Requested browser string '\" + browser + \"' matches *\" + key + \" \"); return createBrowserLauncher(supportedBrowsers.get(key), executablePath, sessionId, configuration, browserOptions); } } LOGGER.debug(\"Requested browser string '\" + browser + \"' does not match any known browser, treating it as a custom browser...\"); Matcher CustomMatcher = CUSTOM_PATTERN.matcher(browser); if (CustomMatcher.find()) { String browserStartCommand = CustomMatcher.group(1); if (browserStartCommand == null) { throw new RuntimeException( \"You must specify the path to an executable when using *custom!\\n\\n\"); } browserStartCommand = browserStartCommand.substring(1); return new CustomBrowserLauncher(browserStartCommand, sessionId, configuration, browserOptions); } throw browserNotSupported(browser); }","old_code_raw":"  public BrowserLauncher getBrowserLauncher(String browser, String sessionId, RemoteControlConfiguration configuration, BrowserConfigurationOptions browserOptions) {\n    if (browser == null) {\n      throw new IllegalArgumentException(\"browser may not be null\");\n    }\n    String executablePath = null;\n    if (browserOptions.hasOptions()) {\n      executablePath = BrowserOptions.getExecutablePath(browserOptions.asCapabilities());\n    } else {\n      configuration.copySettingsIntoBrowserOptions(browserOptions);\n    }\n\n    for (String key : supportedBrowsers.keySet()) {\n      final BrowserStringParser.Result result;\n      result = new BrowserStringParser().parseBrowserStartCommand(key, browser);\n      if (result.match()) {\n        if (executablePath == null) {\n          executablePath = result.customLauncher();\n          browserOptions.setExecutablePath(executablePath);\n        }\n        LOGGER.debug(\"Requested browser string '\" + browser + \"' matches *\" + key + \" \");\n        return createBrowserLauncher(supportedBrowsers.get(key), executablePath, sessionId,\n            configuration, browserOptions);\n      }\n    }\n\n    LOGGER.debug(\"Requested browser string '\" + browser\n                 + \"' does not match any known browser, treating it as a custom browser...\");\n    Matcher CustomMatcher = CUSTOM_PATTERN.matcher(browser);\n    if (CustomMatcher.find()) {\n      String browserStartCommand = CustomMatcher.group(1);\n      if (browserStartCommand == null) {\n        throw new RuntimeException(\n            \"You must specify the path to an executable when using *custom!\\n\\n\");\n      }\n      browserStartCommand = browserStartCommand.substring(1);\n      return new CustomBrowserLauncher(browserStartCommand, sessionId, configuration,\n          browserOptions);\n    }\n    throw browserNotSupported(browser);\n  }\n","new_comment_raw":"@param sessionId the sessionId to launch","old_comment_raw":"@param sessionId the sessionId to launch","label":0,"pre_label":1,"AST_level":13,"line_counts":41,"new_code_token_num":283},{"new_code_raw":"public Mono<Client> testClientModel(Client body) throws RestClientException { Object postBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClientModel\"); } String path = UriComponentsBuilder.fromPath(\"\/fake\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<Client> testClientModel(Client client) throws RestClientException {\n        Object postBody = client;\n        \n        \/\/ verify the required parameter 'client' is set\n        if (client == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling testClientModel\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param body client model","old_comment_raw":"@param client client model","label":1,"pre_label":0,"AST_level":8,"line_counts":29,"new_code_token_num":201},{"new_code_raw":"public static Transport createLocalTransport(NetworkBridgeConfiguration configuration, URI uri) throws Exception { \/\/ one end of the localbroker<->bridge transport needs to be async to allow concurrent forwards and acks return createLocalTransport(uri, !configuration.isDispatchAsync()); }","old_code_raw":"    public static Transport createLocalTransport(URI uri) throws Exception {\n        return createLocalTransport(uri, false);\n    }\n","new_comment_raw":"@param configuration","old_comment_raw":"@param configuration","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":47},{"new_code_raw":"Tuple2<Boolean, String> setFwkMetadata(String name, String sqlExpr, boolean createTable) throws SQLException { if (Boolean.getBoolean(NOAUTO_CREATE_METADATA)) return Tuple2.create(false, null); final SQLSystem sys = getServer().getSQLSystem(); final SQLSyntax syntax = sys.getSyntax(); final SQLDataSource ds = this.getDBSystemRoot().getDataSource(); synchronized (this.getTreeMutex()) { \/\/ don't refresh until after the insert, that way if the refresh triggers an access to \/\/ the metadata name will already be set to value. final boolean shouldRefresh; if (createTable && !this.contains(METADATA_TABLENAME)) { final SQLCreateMoveableTable create = getCreateMetadata(syntax); ds.execute(create.asString(getDBRoot().getName())); shouldRefresh = true; } else { shouldRefresh = false; } final Tuple2<Boolean, String> res; if (createTable || this.contains(METADATA_TABLENAME)) { \/\/ don't use SQLRowValues, cause it means getting the SQLTable and thus calling \/\/ fetchTables(), but setFwkMetadata() might itself be called by fetchTables() \/\/ furthermore SQLRowValues support only rowable tables final List<String> queries = new ArrayList<String>(); final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME); final String where = \" WHERE \" + SQLBase.quoteIdentifier(\"NAME\") + \" = \" + getBase().quoteString(name); queries.add(\"DELETE FROM \" + tableName.quote() + where); final String returning = sys == SQLSystem.POSTGRESQL ? \" RETURNING \" + SQLBase.quoteIdentifier(\"VALUE\") : \"\"; final String ins = syntax.getInsertOne(tableName, Arrays.asList(\"NAME\", \"VALUE\"), getBase().quoteString(name), sqlExpr) + returning; queries.add(ins); final List<? extends ResultSetHandler> handlers; if (returning.length() == 0) { queries.add(\"SELECT \" + SQLBase.quoteIdentifier(\"VALUE\") + \" FROM \" + tableName.quote() + where); handlers = Arrays.asList(null, null, SQLDataSource.SCALAR_HANDLER); } else { handlers = Arrays.asList(null, SQLDataSource.SCALAR_HANDLER); } final List<?> ress = SQLUtils.executeMultiple(getDBSystemRoot(), queries, handlers); res = Tuple2.create(true, (String) ress.get(ress.size() - 1)); } else { res = Tuple2.create(false, null); } if (shouldRefresh) this.fetchTable(METADATA_TABLENAME); return res; } }","old_code_raw":"    boolean setFwkMetadata(String name, String value, boolean createTable) throws SQLException {\r\n        if (Boolean.getBoolean(NOAUTO_CREATE_METADATA))\r\n            return false;\r\n\r\n        synchronized (this.getTreeMutex()) {\r\n            \/\/ don't refresh until after the insert, that way if the refresh triggers an access to\r\n            \/\/ the metadata name will already be set to value.\r\n            final boolean shouldRefresh;\r\n            if (createTable && !this.contains(METADATA_TABLENAME)) {\r\n                final SQLCreateMoveableTable create = getCreateMetadata(getServer().getSQLSystem().getSyntax());\r\n                this.getBase().getDataSource().execute(create.asString(getDBRoot().getName()));\r\n                shouldRefresh = true;\r\n            } else\r\n                shouldRefresh = false;\r\n\r\n            final boolean res;\r\n            if (createTable || this.contains(METADATA_TABLENAME)) {\r\n                \/\/ don't use SQLRowValues, cause it means getting the SQLTable and thus calling\r\n                \/\/ fetchTables(), but setFwkMetadata() might itself be called by fetchTables()\r\n                \/\/ furthermore SQLRowValues support only rowable tables\r\n                final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME);\r\n                final String del = SQLSelect.quote(\"DELETE FROM %i WHERE %i = %s\", tableName, \"NAME\", name);\r\n                final String ins = SQLSelect.quote(\"INSERT INTO %i(%i,%i) VALUES(%s,%s)\", tableName, \"NAME\", \"VALUE\", name, value);\r\n                SQLUtils.executeAtomic(this.getBase().getDataSource(), new SQLFactory<Object>() {\r\n                    public Object create() throws SQLException {\r\n                        getBase().getDataSource().execute(del);\r\n                        getBase().getDataSource().execute(ins);\r\n                        return null;\r\n                    }\r\n                });\r\n                res = true;\r\n            } else\r\n                res = false;\r\n            if (shouldRefresh)\r\n                this.fetchTable(METADATA_TABLENAME);\r\n            return res;\r\n        }\r\n    }\r\n","new_comment_raw":"@param sqlExpr SQL value of the metadata, e.g. \"'ACME, inc'\".","old_comment_raw":"@param value value of the metadata, eg \"ACME, inc\".","label":1,"pre_label":0,"AST_level":15,"line_counts":55,"new_code_token_num":484},{"new_code_raw":"public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(\"petId\", petId); String path = UriComponentsBuilder.fromPath(\"\/fake\/{petId}\/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) formParams.add(\"requiredFile\", new FileSystemResource(requiredFile)); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"multipart\/form-data\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"petstore_auth\" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<ModelApiResponse> uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws RestClientException {\n        Object postBody = null;\n        \n        \/\/ verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        \/\/ verify the required parameter 'file' is set\n        if (file == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n        }\n        \n        \/\/ create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = UriComponentsBuilder.fromPath(\"\/fake\/{petId}\/uploadImageWithRequiredFile\").buildAndExpand(uriVariables).toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n        \n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (file != null)\n            formParams.add(\"file\", new FileSystemResource(file));\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart\/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param petId ID of pet to update","old_comment_raw":"@param petId ID of pet to update","label":0,"pre_label":1,"AST_level":8,"line_counts":42,"new_code_token_num":325},{"new_code_raw":"public Client testClientModel(Client body) throws IOException { HttpResponse response = testClientModelForHttpResponse(body); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public Client testClientModel(Client client) throws IOException {\n        HttpResponse response = testClientModelForHttpResponse(client);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param body client model","old_comment_raw":"@param client client model","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"public static SemanticGraph parseTree(JsonReader json, List<CoreLabel> tokens) { SemanticGraph tree = new SemanticGraph(); JsonArray array = json.readArray(); if (array == null || array.isEmpty()) { return tree; } IndexedWord[] vertices = new IndexedWord[tokens.size() + 2]; \/\/ Add edges for(int i = 0; i < array.size(); i++) { JsonObject entry = array.getJsonObject(i); \/\/ Parse row int dependentIndex = entry.getInt(\"dependent\"); if (vertices[dependentIndex] == null) { if (dependentIndex > tokens.size()) { \/\/ Bizarre mismatch in sizes; the malt parser seems to do this often return new SemanticGraph(); } vertices[dependentIndex] = new IndexedWord(tokens.get(dependentIndex - 1)); } IndexedWord dependent = vertices[dependentIndex]; int governorIndex = entry.getInt(\"governor\"); if (governorIndex > tokens.size()) { \/\/ Bizarre mismatch in sizes; the malt parser seems to do this often return new SemanticGraph(); } if (vertices[governorIndex] == null && governorIndex > 0) { vertices[governorIndex] = new IndexedWord(tokens.get(governorIndex - 1)); } IndexedWord governor = vertices[governorIndex]; String relation = entry.getString(\"dep\"); \/\/ Process row if (governorIndex == 0) { tree.addRoot(dependent); } else { tree.addVertex(dependent); if (!tree.containsVertex(governor)) { tree.addVertex(governor); } if (!\"ref\".equals(relation)) { tree.addEdge(governor, dependent, GrammaticalRelation.valueOf(Language.English, relation), Double.NEGATIVE_INFINITY, false); } } } return tree; }","old_code_raw":"  public static SemanticGraph parseTree(String conll, List<CoreLabel> tokens) {\n    SemanticGraph tree = new SemanticGraph();\n    if (conll == null || conll.isEmpty()) {\n      return tree;\n    }\n    String[] treeLines = newline.split(conll);\n    IndexedWord[] vertices = new IndexedWord[tokens.size() + 2];\n    \/\/ Add edges\n    for (String line : treeLines) {\n      \/\/ Parse row\n      String[] fields = tab.split(line);\n      int dependentIndex = Integer.parseInt(fields[0]);\n      if (vertices[dependentIndex] == null) {\n        if (dependentIndex > tokens.size()) {\n          \/\/ Bizarre mismatch in sizes; the malt parser seems to do this often\n          return new SemanticGraph();\n        }\n        vertices[dependentIndex] = new IndexedWord(tokens.get(dependentIndex - 1));\n      }\n      IndexedWord dependent = vertices[dependentIndex];\n      int governorIndex = Integer.parseInt(fields[1]);\n      if (governorIndex > tokens.size()) {\n        \/\/ Bizarre mismatch in sizes; the malt parser seems to do this often\n        return new SemanticGraph();\n      }\n      if (vertices[governorIndex] == null && governorIndex > 0) {\n        vertices[governorIndex] = new IndexedWord(tokens.get(governorIndex - 1));\n      }\n      IndexedWord governor = vertices[governorIndex];\n      String relation = fields[2];\n\n      \/\/ Process row\n      if (governorIndex == 0) {\n        tree.addRoot(dependent);\n      } else {\n        tree.addVertex(dependent);\n        if (!tree.containsVertex(governor)) {\n          tree.addVertex(governor);\n        }\n        if (!\"ref\".equals(relation)) {\n          tree.addEdge(governor, dependent, GrammaticalRelation.valueOf(Language.English, relation), Double.NEGATIVE_INFINITY, false);\n        }\n      }\n    }\n    return tree;\n  }\n","new_comment_raw":"@param json The JSON string tree to parse, e.g: \"[\\\"\\\"dependent\\\"\\\": 7, \\\"\\\"dep\\\"\\\": \\\"\\\"ROOT\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"ROOT\\\"\\\", \\\"\\\"governor\\\"\\\": 0, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"sport\\\"\\\", \\\"\\\"dependent\\\"\\\": 1, \\\"\\\"dep\\\"\\\": \\\"\\\"nsubj\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"sport\\\"\\\", \\\"\\\"governor\\\"\\\": 7, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"Chess\\\"\\\", \\\"\\\"dependent\\\"\\\": 2, \\\"\\\"dep\\\"\\\": \\\"\\\"cop\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"sport\\\"\\\", \\\"\\\"governor\\\"\\\": 7, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"is\\\"\\\", \\\"\\\"dependent\\\"\\\": 3, \\\"\\\"dep\\\"\\\": \\\"\\\"neg\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"sport\\\"\\\", \\\"\\\"governor\\\"\\\": 7, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"not\\\"\\\", \\\"\\\"dependent\\\"\\\": 4, \\\"\\\"dep\\\"\\\": \\\"\\\"det\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"sport\\\"\\\", \\\"\\\"governor\\\"\\\": 7, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"a\\\"\\\", \\\"\\\"dependent\\\"\\\": 5, \\\"\\\"dep\\\"\\\": \\\"\\\"advmod\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"physical\\\"\\\", \\\"\\\"governor\\\"\\\": 6, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"predominantly\\\"\\\", \\\"\\\"dependent\\\"\\\": 6, \\\"\\\"dep\\\"\\\": \\\"\\\"amod\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"sport\\\"\\\", \\\"\\\"governor\\\"\\\": 7, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"physical\\\"\\\", \\\"\\\"dependent\\\"\\\": 9, \\\"\\\"dep\\\"\\\": \\\"\\\"advmod\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"sport\\\"\\\", \\\"\\\"governor\\\"\\\": 7, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"yet\\\"\\\", \\\"\\\"dependent\\\"\\\": 10, \\\"\\\"dep\\\"\\\": \\\"\\\"nsubj\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"shooting\\\"\\\", \\\"\\\"governor\\\"\\\": 12, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"neither\\\"\\\", \\\"\\\"dependent\\\"\\\": 11, \\\"\\\"dep\\\"\\\": \\\"\\\"cop\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"shooting\\\"\\\", \\\"\\\"governor\\\"\\\": 12, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"are\\\"\\\", \\\"\\\"dependent\\\"\\\": 12, \\\"\\\"dep\\\"\\\": \\\"\\\"parataxis\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"sport\\\"\\\", \\\"\\\"governor\\\"\\\": 7, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"shooting\\\"\\\", \\\"\\\"dependent\\\"\\\": 13, \\\"\\\"dep\\\"\\\": \\\"\\\"cc\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"shooting\\\"\\\", \\\"\\\"governor\\\"\\\": 12, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"and\\\"\\\", \\\"\\\"dependent\\\"\\\": 14, \\\"\\\"dep\\\"\\\": \\\"\\\"parataxis\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"sport\\\"\\\", \\\"\\\"governor\\\"\\\": 7, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"curling\\\"\\\", \\\"\\\"dependent\\\"\\\": 14, \\\"\\\"dep\\\"\\\": \\\"\\\"conj:and\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"shooting\\\"\\\", \\\"\\\"governor\\\"\\\": 12, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"curling\\\"\\\", \\\"\\\"dependent\\\"\\\": 16, \\\"\\\"dep\\\"\\\": \\\"\\\"nsubjpass\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"nicknamed\\\"\\\", \\\"\\\"governor\\\"\\\": 23, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"which\\\"\\\", \\\"\\\"dependent\\\"\\\": 18, \\\"\\\"dep\\\"\\\": \\\"\\\"case\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"fact\\\"\\\", \\\"\\\"governor\\\"\\\": 19, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"in\\\"\\\", \\\"\\\"dependent\\\"\\\": 19, \\\"\\\"dep\\\"\\\": \\\"\\\"nmod:in\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"nicknamed\\\"\\\", \\\"\\\"governor\\\"\\\": 23, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"fact\\\"\\\", \\\"\\\"dependent\\\"\\\": 21, \\\"\\\"dep\\\"\\\": \\\"\\\"aux\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"nicknamed\\\"\\\", \\\"\\\"governor\\\"\\\": 23, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"has\\\"\\\", \\\"\\\"dependent\\\"\\\": 22, \\\"\\\"dep\\\"\\\": \\\"\\\"auxpass\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"nicknamed\\\"\\\", \\\"\\\"governor\\\"\\\": 23, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"been\\\"\\\", \\\"\\\"dependent\\\"\\\": 23, \\\"\\\"dep\\\"\\\": \\\"\\\"dep\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"shooting\\\"\\\", \\\"\\\"governor\\\"\\\": 12, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"nicknamed\\\"\\\", \\\"\\\"dependent\\\"\\\": 25, \\\"\\\"dep\\\"\\\": \\\"\\\"dobj\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"nicknamed\\\"\\\", \\\"\\\"governor\\\"\\\": 23, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"chess\\\"\\\", \\\"\\\"dependent\\\"\\\": 26, \\\"\\\"dep\\\"\\\": \\\"\\\"case\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"ice\\\"\\\", \\\"\\\"governor\\\"\\\": 27, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"on\\\"\\\", \\\"\\\"dependent\\\"\\\": 27, \\\"\\\"dep\\\"\\\": \\\"\\\"nmod:on\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"chess\\\"\\\", \\\"\\\"governor\\\"\\\": 25, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"ice\\\"\\\", \\\"\\\"dependent\\\"\\\": 29, \\\"\\\"dep\\\"\\\": \\\"\\\"amod\\\"\\\", \\\"\\\"governorGloss\\\"\\\": \\\"\\\"chess\\\"\\\", \\\"\\\"governor\\\"\\\": 25, \\\"\\\"dependentGloss\\\"\\\": \\\"\\\"5\\\"\\\"]\");","old_comment_raw":"@param conll The CoNLL tree to parse.","label":1,"pre_label":0,"AST_level":12,"line_counts":49,"new_code_token_num":336},{"new_code_raw":"public List<AuditEvent> convertToAuditEvent(Iterable<PersistentAuditEvent> persistentAuditEvents) { if (persistentAuditEvents == null) { return Collections.emptyList(); } List<AuditEvent> auditEvents = new ArrayList<>(); for (PersistentAuditEvent persistentAuditEvent : persistentAuditEvents) { AuditEvent auditEvent = new AuditEvent(persistentAuditEvent.getAuditEventDate().toDate(), persistentAuditEvent.getPrincipal(), persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData())); auditEvents.add(auditEvent); } return auditEvents; }","old_code_raw":"    public List<AuditEvent> convertToAuditEvent(List<PersistentAuditEvent> persistentAuditEvents) {\n        if (persistentAuditEvents == null) {\n            return Collections.emptyList();\n        }\n\n        List<AuditEvent> auditEvents = new ArrayList<>();\n\n        for (PersistentAuditEvent persistentAuditEvent : persistentAuditEvents) {\n            AuditEvent auditEvent = new AuditEvent(persistentAuditEvent.getAuditEventDate().toDate(), persistentAuditEvent.getPrincipal(),\n                    persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData()));\n            auditEvents.add(auditEvent);\n        }\n\n        return auditEvents;\n    }\n","new_comment_raw":"@param persistentAuditEvents the list to convert","old_comment_raw":"@param persistentAuditEvents the list to convert","label":0,"pre_label":1,"AST_level":9,"line_counts":16,"new_code_token_num":82},{"new_code_raw":"private static CoreLabel createDatum(String token, String label, int index) { CoreLabel newTok = new CoreLabel(); newTok.set(CoreAnnotations.CharAnnotation.class, token); newTok.set(CoreAnnotations.AnswerAnnotation.class, label); newTok.set(CoreAnnotations.GoldAnswerAnnotation.class, label); newTok.setIndex(index); return newTok; }","old_code_raw":"  private static CoreLabel createDatum(CoreLabel cl, String token, String label) {\n    CoreLabel newTok = new CoreLabel();\n    newTok.set(CoreAnnotations.TextAnnotation.class, token);\n    newTok.set(CoreAnnotations.CharAnnotation.class, token);\n    newTok.set(CoreAnnotations.AnswerAnnotation.class, label);\n    newTok.set(CoreAnnotations.GoldAnswerAnnotation.class, label);\n    if (cl != null && cl.containsKey(CoreAnnotations.DomainAnnotation.class))\n      newTok.set(CoreAnnotations.DomainAnnotation.class,\n                 cl.get(CoreAnnotations.DomainAnnotation.class));\n    return newTok;\n  }\n","new_comment_raw":"@param token","old_comment_raw":"@param cl","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":62},{"new_code_raw":"public static RequestQueue newRequestQueue(IRestProtocol implRestConnection, int threadPoolSize) { return newRequestQueue(RestParser.getInstance(implRestConnection), threadPoolSize); }","old_code_raw":"    public static RequestQueue newRequestQueue(ImplRestConnection implRestConnection, int threadPoolSize) {\n        return newRequestQueue(HttpRestParser.getInstance(implRestConnection), threadPoolSize);\n    }\n","new_comment_raw":"@param implRestConnection network operating interface, The implementation of the network layer.","old_comment_raw":"@param implRestConnection network operating interface, The implementation of the network layer.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"Field type must not be null\"); } DateTimeField field = fieldType.getField(iChronoUTC); return append0(new TextField(iChrono, field, iLocale, false)); }","old_code_raw":"    public DateTimeFormatterBuilder appendText(final DateTimeField field) {\n        return append0(new TextField(iChrono, field, iLocale, false));\n    }\n","new_comment_raw":"@param fieldType type of field to append","old_comment_raw":"@param field field should operate in UTC or be time zone agnostic","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"protected int writeImportList(PrintWriter out, List<String> imports) { return writeImportList(out, (String[]) imports.toArray(new String[0])); }","old_code_raw":"  protected int writeImportList(PrintStream out, List<String> imports) {\n    return writeImportList(out, (String[]) imports.toArray(new String[0]));\n  }\n","new_comment_raw":"@param programImports","old_comment_raw":"@param programImports","label":0,"pre_label":1,"AST_level":8,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public Action suspended(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { logger.debug(\"(suspend) invoked:\\n HttpServletRequest: {}\\n HttpServletResponse: {}\", request, response); return action(request, response); }","old_code_raw":"    public Action suspended(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n        if (logger.isLoggable(Level.FINE)) {\n            logger.fine(\"(suspend) invoked:\\n HttpServletRequest: \" + req\n                    + \"\\n HttpServletResponse: \" + res);\n        }\n        return action(req, res);\n    }\n","new_comment_raw":"@param request the  HttpServletRequest","old_comment_raw":"@param req the HttpServletRequest","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":52},{"new_code_raw":"public static Point getCanvasTextLocation(Client client, Graphics2D graphics, LocalPoint localLocation, String text, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } FontMetrics fm = graphics.getFontMetrics(); Rectangle2D bounds = fm.getStringBounds(text, graphics); int xOffset = p.getX() - (int) (bounds.getWidth() \/ 2); return new Point(xOffset, p.getY()); }","old_code_raw":"\tpublic static Point getCanvasTextLocation(Client client, Graphics2D graphics, Point localLocation, String text, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tFontMetrics fm = graphics.getFontMetrics();\n\t\tRectangle2D bounds = fm.getStringBounds(text, graphics);\n\t\tint xOffset = p.getX() - (int) (bounds.getWidth() \/ 2);\n\n\t\treturn new Point(xOffset, p.getY());\n\t}\n","new_comment_raw":"@param text string for width measurement","old_comment_raw":"@param text string for width measurement","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":109},{"new_code_raw":"public static DataFileReadResult decompress(byte[] b, int[] keys) { InputStream stream = new InputStream(b); int compression = stream.readUnsignedByte(); int compressedLength = stream.readInt(); if (compressedLength < 0 || compressedLength > 1000000) throw new RuntimeException(\"Invalid data\"); Crc32 crc32 = new Crc32(); crc32.update(b, 0, 5); \/\/ compression + length byte[] data; int revision = -1; switch (compression) { case CompressionType.NONE: { byte[] encryptedData = new byte[compressedLength]; stream.readBytes(encryptedData, 0, compressedLength); crc32.update(encryptedData, 0, compressedLength); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } data = decryptedData; break; } case CompressionType.BZ2: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = BZip2.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } case CompressionType.GZ: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = GZip.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } default: throw new RuntimeException(\"Unknown decompression type\"); } DataFileReadResult res = new DataFileReadResult(); res.data = data; res.revision = revision; int length = revision != -1 ? b.length - 2 : b.length;; res.crc = crc32.getHash(); res.whirlpool = Whirlpool.getHash(b, length); res.compression = compression; return res; }","old_code_raw":"\tpublic static DataFileReadResult decompress(byte[] b)\n\t{\n\t\tInputStream stream = new InputStream(b);\n\t\t\n\t\tint compression = stream.readUnsignedByte();\n\t\tint compressedLength = stream.readInt();\n\t\tif (compressedLength < 0 || compressedLength > 1000000)\n\t\t\tthrow new RuntimeException(\"Invalid data\");\n\t\t\n\t\tbyte[] data;\n\t\tint revision;\n\t\tswitch (compression)\n\t\t{\n\t\t\tcase CompressionType.NONE:\n\t\t\t\tdata = new byte[compressedLength];\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tstream.readBytes(data, 0, compressedLength);\n\t\t\t\tbreak;\n\t\t\tcase CompressionType.BZ2:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = BZip2.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.GZ:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = GZip.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unknown decompression type\");\n\t\t}\n\t\t\n\t\tDataFileReadResult res = new DataFileReadResult();\n\t\tres.data = data;\n\t\tres.revision = revision;\n\t\tint length = revision != -1 ? b.length - 2 : b.length;\n\t\tres.crc = CRC32HGenerator.getHash(b, length);\n\t\tres.whirlpool = Whirlpool.getHash(b, length);\n\t\tres.compression = compression;\n\t\treturn res;\n\t}\n","new_comment_raw":"@param archiveId expected archive of contents being read","old_comment_raw":"@param archiveId","label":1,"pre_label":0,"AST_level":10,"line_counts":104,"new_code_token_num":469},{"new_code_raw":"public Serializable generate(SharedSessionContractImplementor session, Object object) throws HibernateException { return optimizer.generate( databaseStructure.buildCallback( session ) ); }","old_code_raw":"\tpublic Serializable generate(SessionImplementor session, Object object) throws HibernateException {\n\t\treturn optimizer.generate( databaseStructure.buildCallback( session ) );\n\t}\n","new_comment_raw":"@param incrementSize the increment size to use (afterQuery any adjustments).","old_comment_raw":"@param incrementSize the increment size to use (after any adjustments).","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public static int generateId(final String url, final String path) { return CustomComponentHolder.getImpl().getIdGeneratorInstance() .generateId(url, path, false); }","old_code_raw":"    public static int generateId(final String url, final String path, final boolean pathAsDirectory) {\n        return CustomComponentHolder.getImpl().getIdGeneratorInstance().generateId(url, path, pathAsDirectory);\n    }\n","new_comment_raw":"@param url The downloading URL.","old_comment_raw":"@param url The downloading URL.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public List<WebElement> apply(WebDriver driver) { WebElement current = findElement(parent, driver); List<WebElement> allChildren = current.findElements(childLocator); \/\/ The original code only checked the first element. Fair enough. if (!allChildren.isEmpty() && allChildren.get(0).isDisplayed()) { return allChildren; } return null; }","old_code_raw":"      public List<WebElement> apply(WebDriver webDriver) {\n        Boolean displayed = false;\n        Boolean exists = false;\n        try {\n          exists = findElement(locator, webDriver).findElements(sub_locator).size() > 0;\n          displayed =\n            findElement(locator, webDriver).findElement(sub_locator).isDisplayed();\n        } catch (Exception e) {\n          int i = 0;\n        }\n        return (exists && displayed) ?\n               findElement(locator, webDriver).findElements(sub_locator) :\n               null;\n      }\n","new_comment_raw":"@param parent used to check parent element. For example table with locator By.id(\"fish\")","old_comment_raw":"@param locator used to check parent element. For example table with locator By.xpath(\"\/\/table\")","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":66},{"new_code_raw":"public static String uniquify(String name, Set<String> nameList) { if (name == null) { name = \"EXPR$\"; } if (nameList.add(name)) { return name; } String aliasBase = name; for (int j = 0;; j++) { name = aliasBase + j; if (nameList.add(name)) { return name; } } }","old_code_raw":"    public static String uniquify(String name, Collection<String> nameList)\n    {\n        if (name == null) {\n            name = \"EXPR$\";\n        }\n        if (nameList.contains(name)) {\n            String aliasBase = name;\n            for (int j = 0;; j++) {\n                name = aliasBase + j;\n                if (!nameList.contains(name)) {\n                    break;\n                }\n            }\n        }\n        nameList.add(name);\n        return name;\n    }\n","new_comment_raw":"@param nameList Collection of names already used","old_comment_raw":"@param nameList Collection of names already used","label":0,"pre_label":1,"AST_level":8,"line_counts":17,"new_code_token_num":75},{"new_code_raw":"protected Object convertEnumToString(List<String> options, Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return \"\"; } if (data instanceof String) { \/\/ JDBC should return strings ... return data; } if (data instanceof Integer) { if (options != null) { \/\/ The binlog will contain an int with the 1-based index of the option in the enum value ... int index = ((Integer) data).intValue() - 1; \/\/ 'options' is 0-based if (index < options.size()) { return options.get(index); } } return null; } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertEnumToString(String options, Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return \"\";\n        }\n        if (data instanceof String) {\n            \/\/ JDBC should return strings ...\n            return data;\n        }\n        if (data instanceof Integer) {\n            \/\/ The binlog will contain an int with the 1-based index of the option in the enum value ...\n            int index = ((Integer) data).intValue() - 1; \/\/ 'options' is 0-based\n            if (index < options.length()) {\n                return options.substring(index, index + 1);\n            }\n            return null;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@param column the column definition describing the  data value; never null","old_comment_raw":"@param column the column definition describing the data value; never null","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":163},{"new_code_raw":"public ApiResponse<Client> testClassnameWithHttpInfo(Client client) throws ApiException { Object localVarPostBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, \"Missing the required parameter 'client' when calling testClassname\"); } \/\/ create path and map variables String localVarPath = \"\/fake_classname_test\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"api_key_query\" }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ApiResponse<Client> testClassnameWithHttpInfo(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClassname\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake_classname_test\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key_query\" };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":203},{"new_code_raw":"protected String getParameterDataType(Parameter parameter, Schema schema) { return null; }","old_code_raw":"   protected String getParameterDataType(Parameter parameter, Property property) {\n        return null;\n   }\n","new_comment_raw":"@param schema Schema","old_comment_raw":"@param property","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"static public boolean isCompatible(Base base, File exampleFolder) { String currentIdentifier = base.getActiveEditor().getMode().getIdentifier(); File propertiesFile = new File(exampleFolder, EXAMPLES.getPropertiesName()); if (propertiesFile.exists()) { StringList compatibleList = parseModeList(Util.readSettings(propertiesFile)); if (compatibleList.size() == 0) { return true; \/\/ if no mode specified, just include everywhere } for (String c : compatibleList) { if (c.equals(currentIdentifier)) { return true; } } } return false; }","old_code_raw":"  static public boolean isCompatible(Base base, StringDict props) {\n    String currentIdentifier =\n      base.getActiveEditor().getMode().getIdentifier();\n    StringList compatibleList = parseModeList(props);\n    if (compatibleList.size() == 0) {\n      return true;  \/\/ if no mode specified, assume compatible everywhere\n    }\n    for (String c : compatibleList) {\n      if (c.equals(currentIdentifier)) {\n        return true;\n      }\n    }\n    return false;\n  }\n","new_comment_raw":"@param exampleFolder","old_comment_raw":"@param exampleFolder","label":0,"pre_label":1,"AST_level":10,"line_counts":19,"new_code_token_num":107},{"new_code_raw":"private boolean hasSingleValue(ColumnStatistics columnStatistics, long rowCount) { return columnStatistics != null && isSingleVal(columnStatistics, rowCount); }","old_code_raw":"  private boolean hasSingleValue(ColumnMetadata columnChunkMetaData, long rowCount) {\n    return (columnChunkMetaData != null) && (columnChunkMetaData.hasSingleValue(rowCount));\n  }\n","new_comment_raw":"@param columnStatistics metadata to check","old_comment_raw":"@param columnChunkMetaData metadata to check","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"private HttpURLConnection createHttpURLConnection(IBasicRequest request) throws Exception { \/\/ 1.Pre operation notice request.onPreExecute(); \/\/ 2.Build URL String urlStr = request.url(); Logger.i(\"Request address: \" + urlStr); URL url = new URL(urlStr); HttpURLConnection connection; Proxy proxy = request.getProxy(); if (proxy == null) connection = (HttpURLConnection) url.openConnection(); else connection = (HttpURLConnection) url.openConnection(proxy); connection.setConnectTimeout(request.getConnectTimeout()); connection.setReadTimeout(request.getReadTimeout()); connection.setInstanceFollowRedirects(false); if (connection instanceof HttpsURLConnection) { SSLSocketFactory sslSocketFactory = request.getSSLSocketFactory(); if (sslSocketFactory != null) ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory); HostnameVerifier hostnameVerifier = request.getHostnameVerifier(); if (hostnameVerifier != null) ((HttpsURLConnection) connection).setHostnameVerifier(hostnameVerifier); } \/\/ 3. Base attribute RequestMethod requestMethod = request.getRequestMethod(); String requestMethodStr = requestMethod.toString(); Logger.i(\"Request method: \" + requestMethodStr); \/\/ Fix delete patch error. try { connection.setRequestMethod(requestMethodStr); } catch (ProtocolException protocol) { try { Field methodField = connection.getClass().getDeclaredField(\"method\"); methodField.setAccessible(true); methodField.set(connection, requestMethodStr); } catch (Exception noSuchFieldIllegalAccess) { throw protocol; } } connection.setDoInput(true); connection.setDoOutput(requestMethod.allowRequestBody()); \/\/ 4.Set request headers setHeaders(url.toURI(), connection, request); \/\/ 5. Connect connection.connect(); return connection; }","old_code_raw":"    protected HttpURLConnection createHttpURLConnection(BasicServerRequest request) throws IOException, URISyntaxException {\n        \/\/ 1.Pre operation notice\n        request.onPreExecute();\n\n        \/\/ 2.Build URL\n        String urlStr = request.url();\n        Logger.i(\"Request address: \" + urlStr);\n        URL url = new URL(urlStr);\n        HttpURLConnection connection;\n        Proxy proxy = request.getProxy();\n        if (proxy == null)\n            connection = (HttpURLConnection) url.openConnection();\n        else\n            connection = (HttpURLConnection) url.openConnection(proxy);\n\n        connection.setConnectTimeout(request.getConnectTimeout());\n        connection.setReadTimeout(request.getReadTimeout());\n        connection.setInstanceFollowRedirects(false);\n\n        if (connection instanceof HttpsURLConnection) {\n            SSLSocketFactory sslSocketFactory = request.getSSLSocketFactory();\n            if (sslSocketFactory != null)\n                ((HttpsURLConnection) connection).setSSLSocketFactory(sslSocketFactory);\n            HostnameVerifier hostnameVerifier = request.getHostnameVerifier();\n            if (hostnameVerifier != null)\n                ((HttpsURLConnection) connection).setHostnameVerifier(hostnameVerifier);\n        }\n\n        \/\/ 3. Base attribute\n        RequestMethod requestMethod = request.getRequestMethod();\n        Logger.i(\"Request method: \" + requestMethod.toString());\n        \/\/ Fix delete patch error.\n        try {\n            connection.setRequestMethod(requestMethod.toString());\n        } catch (ProtocolException protocol) {\n            try {\n                Field methodField = connection.getClass().getDeclaredField(\"method\");\n                methodField.setAccessible(true);\n                methodField.set(connection, requestMethod.toString());\n            } catch (Exception noSuchFieldIllegalAccess) {\n                throw protocol;\n            }\n        }\n\n        connection.setDoInput(true);\n        connection.setDoOutput(requestMethod.allowRequestBody());\n\n        \/\/ 4.Set request headers\n        URI uri = null;\n        try {\n            uri = url.toURI();\n        } catch (URISyntaxException e) {\n            Logger.w(e);\n        }\n        setHeaders(uri, connection, request);\n\n        \/\/ 5. Connect\n        connection.connect();\n\n        \/\/ 6. Write request body\n        if (requestMethod.allowRequestBody()) {\n            Logger.i(\"-------Send request data start-------\");\n            OutputStream outputStream = IOUtils.toBufferedOutputStream(connection.getOutputStream());\n            request.onWriteRequestBody(outputStream);\n            IOUtils.flushQuietly(outputStream);\n            IOUtils.closeQuietly(outputStream);\n            Logger.i(\"-------Send request data end-------\");\n        }\n\n        return connection;\n    }\n","new_comment_raw":"@param request  IBasicRequest.","old_comment_raw":"@param request BasicServerRequest.","label":1,"pre_label":0,"AST_level":10,"line_counts":56,"new_code_token_num":307},{"new_code_raw":"public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values, Lock readValuesLock) { readValuesLock.lock(); try { for (GrammaticalRelation reln : values) { if (reln.toString().equals(s)) return reln; } } finally { readValuesLock.unlock(); } return null; }","old_code_raw":"  public static GrammaticalRelation valueOf(String s, Collection<GrammaticalRelation> values) {\n    for (GrammaticalRelation reln : values) {\n      if (reln.toString().equals(s)) return reln;\n    }\n\n    return null;\n  }\n","new_comment_raw":"@param s The short name of the GrammaticalRelation","old_comment_raw":"@param s The short name of the GrammaticalRelation","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":59},{"new_code_raw":"public static float length(float x, float y, float z) { return (float) Math.sqrt(length2(x, y, z)); }","old_code_raw":"\tpublic static double length(double x, double y, double z) {\n\t\treturn Math.sqrt(length2(x, y, z));\n\t}\n","new_comment_raw":"@param z float The z component.","old_comment_raw":"@param z double The z component.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":33},{"new_code_raw":"protected ReadableInstant create(long instant, Chronology chrono) { \/\/ ignore chrono if (instant == getMillis()) { return this; } return new Instant(instant); }","old_code_raw":"    protected ReadableInstant create(long millis, Chronology chrono) {\n        \/\/ ignore chrono\n        if (millis == getMillis()) {\n            return this;\n        }\n        return new Instant(millis);\n    }\n","new_comment_raw":"@param instant the new instant, from 1970-01-01T00:00:00Z","old_comment_raw":"@param millis the new millis, from 1970-01-01T00:00:00Z","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException { final Connection conn = connection(); final ResultSet[] resultSets = new ResultSet[multiQuery.length]; final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length]; try { for (int i = 0; i < multiQuery.length; i++) { final String query = multiQuery[i]; if (LOGGER.isTraceEnabled()) { LOGGER.trace(\"running '{}'\", query); } final PreparedStatement statement = conn.prepareStatement(query); preparedStatements[i] = statement; preparer.accept(statement); resultSets[i] = statement.executeQuery(); } if (resultConsumer != null) { resultConsumer.accept(resultSets); } } finally { for (ResultSet rs: resultSets) { if (rs != null) { try { rs.close(); } catch (Exception ei) { } } } for (PreparedStatement ps: preparedStatements) { if (ps != null) { try { ps.close(); } catch (Exception ei) { } } } } return this; }","old_code_raw":"    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, MultiResultSetConsumer resultConsumer) throws SQLException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = conn.prepareStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n            for (PreparedStatement ps: preparedStatements) {\n                if (ps != null) {\n                    try {\n                        ps.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n","new_comment_raw":"@param preparer the function that supplied arguments to the prepared statement; may not be null","old_comment_raw":"@param preparer the function that supplied arguments to the prepared statement; may not be null","label":0,"pre_label":1,"AST_level":10,"line_counts":43,"new_code_token_num":216},{"new_code_raw":"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param formParams The form parameters","old_comment_raw":"@param formParams The form parameters","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public static BooleanOperation booleanOperation(Operator operator, Expression<?>... args) { return predicate(operator, args); }","old_code_raw":"    public static BooleanOperation booleanOperation(Operator operation, Expression<?>... args) {\n        return predicate(operation, args);\n    }\n","new_comment_raw":"@param args operation arguments","old_comment_raw":"@param args","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public static Criterion between(String propertyName, Object low, Object high) { return new BetweenExpression( propertyName, low, high ); }","old_code_raw":"\tpublic static Criterion between(String propertyName, Object lo, Object hi) {\n\t\treturn new BetweenExpression( propertyName, lo, hi );\n\t}\n","new_comment_raw":"@param propertyName The name of the property","old_comment_raw":"@param propertyName The name of the property","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"private static void installAddOnActiveScanRules(AddOn addOn, AddOnClassLoader addOnClassLoader) { List<AbstractPlugin> ascanrules = AddOnLoaderUtils.getActiveScanRules(addOn, addOnClassLoader); if (!ascanrules.isEmpty()) { for (AbstractPlugin ascanrule : ascanrules) { String name = ascanrule.getClass().getCanonicalName(); logger.debug(\"Install ascanrule: \" + name); PluginFactory.loadedPlugin(ascanrule); if (!PluginFactory.isPluginLoaded(ascanrule)) { logger.error(\"Failed to install ascanrule: \" + name); } } } }","old_code_raw":"    private static void installAddOnActiveScanRules(AddOn addOn) {\n        List<String> ascanNames = addOn.getAscanrules();\n        if (ascanNames != null) {\n            for (String name : ascanNames) {\n                logger.debug(\"Install ascanrule: \" + name);\n                if (!PluginFactory.loadedPlugin(name)) {\n                    logger.error(\"Failed to install ascanrule: \" + name);\n                }\n            }\n        }\n    }\n","new_comment_raw":"@param extension the extension that should be uninstalled","old_comment_raw":"@param extension the extension that should be uninstalled","label":0,"pre_label":1,"AST_level":12,"line_counts":14,"new_code_token_num":96},{"new_code_raw":"public int compareTo(ReadablePartial partial) { if (partial == null) { throw new IllegalArgumentException(\"The instant must not be null\"); } int thisValue = get(); int otherValue = partial.get(getFieldType()); if (thisValue < otherValue) { return -1; } else if (thisValue > otherValue) { return 1; } else { return 0; } }","old_code_raw":"    public int compareTo(ReadableInstant instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        int thisValue = get();\n        int otherValue = instant.get(getField());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n","new_comment_raw":"@param partial the partial to compare to","old_comment_raw":"@param instant the instant to compare to","label":1,"pre_label":0,"AST_level":7,"line_counts":15,"new_code_token_num":74},{"new_code_raw":"private void setCurrent(RelNode root, Correlate corRel) { currentRel = corRel; if (corRel != null) { cm = new CorelMapBuilder().build(Util.first(root, corRel)); } }","old_code_raw":"  private void setCurrent(RelNode root, LogicalCorrelate corRel) {\n    currentRel = corRel;\n    if (corRel != null) {\n      cm = new CorelMapBuilder().build(Util.first(root, corRel));\n    }\n  }\n","new_comment_raw":"@param relBuilder Builder for relational expressions","old_comment_raw":"@param relBuilder Builder for relational expressions","label":0,"pre_label":1,"AST_level":10,"line_counts":7,"new_code_token_num":39},{"new_code_raw":"private HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final Set<String> tokens) { \/\/ Pre-checks if (sessions.isEmpty()) { return null; } List<HttpSession> matchingSessions = new LinkedList<>(sessions); for (String token : tokens) { \/\/ Get the corresponding cookie from the cookies list HttpCookie matchingCookie = null; for (HttpCookie cookie : cookies) { if (cookie.getName().equals(token)) { matchingCookie = cookie; break; } } \/\/ Filter the sessions that do not match the cookie value Iterator<HttpSession> it = matchingSessions.iterator(); while (it.hasNext()) { if (!it.next().matchesToken(token, matchingCookie)) { it.remove(); } } } \/\/ Return the matching session if (matchingSessions.size() >= 1) { if (matchingSessions.size() > 1) { log.warn(\"Multiple sessions matching the cookies from response for site: \" + getSite() + \". Using first one.\"); } return matchingSessions.get(0); } return null; }","old_code_raw":"\tprivate HttpSession getMatchingHttpSession(List<HttpCookie> cookies, final HttpSessionTokensSet siteTokens) {\n\n\t\treturn CookieBasedSessionManagementHelper.getMatchingHttpSession(sessions, cookies, siteTokens);\n\t}\n","new_comment_raw":"@param tokens the tokens","old_comment_raw":"@param siteTokens the tokens","label":1,"pre_label":0,"AST_level":11,"line_counts":38,"new_code_token_num":204},{"new_code_raw":"private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException { if (suiteURL.startsWith(\"https:\/\/\") || suiteURL.startsWith(\"http:\/\/\")) { return verifySuiteUrl(new URL(suiteURL)); } \/\/ Is the suiteURL a file? Path path = Paths.get(suiteURL); if (Files.exists(path)) { \/\/ Not all drivers can read files from the disk, so we need to host the suite somewhere. try (SocketLock lock = new SocketLock()) { server = new Server(); HttpConfiguration httpConfig = new HttpConfiguration(); ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig)); int port = PortProber.findFreePort(); http.setPort(port); http.setIdleTimeout(500000); server.setConnectors(new Connector[]{http}); ResourceHandler handler = new ResourceHandler(); handler.setDirectoriesListed(true); handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"}); handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath())); ContextHandler context = new ContextHandler(\"\/tests\"); context.setHandler(handler); server.setHandler(context); server.start(); PortProber.waitForPortUp(port, 15, SECONDS); URL serverUrl = server.getURI().toURL(); return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(), \"\/tests\/\"); } catch (Exception e) { throw new IOException(e); } } \/\/ Well then, it must be a URL relative to whatever the browserUrl. Probe and find out. URL browser = new URL(startURL); return verifySuiteUrl(new URL(browser, suiteURL)); }","old_code_raw":"  private URL determineSuiteUrl(String browserUrl, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https:\/\/\") || suiteURL.startsWith(\"http:\/\/\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    \/\/ Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      \/\/ Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"\/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"\/tests\/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    \/\/ Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(browserUrl);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n","new_comment_raw":"@param browser - the browserString (\"firefox\", \"iexplore\" or an executable path)","old_comment_raw":"@param browser - the browserString (\"firefox\", \"iexplore\" or an executable path)","label":0,"pre_label":1,"AST_level":11,"line_counts":45,"new_code_token_num":351},{"new_code_raw":"@CheckForNull public final SCMRevision fetch(@NonNull String thingName, @CheckForNull TaskListener listener) throws IOException, InterruptedException { return retrieve(thingName, defaultListener(listener)); }","old_code_raw":"    @CheckForNull\n    public final SCMRevision fetch(@NonNull String revision, @CheckForNull TaskListener listener)\n            throws IOException, InterruptedException {\n        return retrieve(revision, defaultListener(listener));\n    }\n","new_comment_raw":"@param thingName might be a branch name, a tag name, a cryptographic hash, a thingName number, etc.","old_comment_raw":"@param revision might be a branch name, a tag name, a cryptographic hash, a revision number, etc.","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":34},{"new_code_raw":"public Client testClassname(Client client) throws ApiException { return testClassnameWithHttpInfo(client).getData(); }","old_code_raw":"  public Client testClassname(Client body) throws ApiException {\n    return testClassnameWithHttpInfo(body).getData();\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(\"?\"); else b.append(\"&\"); b.append(escapeString(key)).append(\"=\").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param formParams The form parameters","old_comment_raw":"@param formParams The form parameters","label":0,"pre_label":1,"AST_level":16,"line_counts":111,"new_code_token_num":730},{"new_code_raw":"public String createFileName(URL url, String prefixSubstitute, String substituteReplacement) { File file = new File(directory_prefix + File.separator + url.getFile()); return file.getAbsolutePath().replaceAll(prefixSubstitute, substituteReplacement); }","old_code_raw":"    public String createFileName(URL url) {\n        File file = new File(directory_prefix + File.separator + url.getFile());\n\n        return file.getAbsolutePath();\n    }\n","new_comment_raw":"@param url URL of resource, which has been downloaded and shall be saved","old_comment_raw":"@param url DOCUMENT ME!","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"public MultiIterator init(IteratorSource iteratorSource){ this.iteratorSource = iteratorSource; this.iterators = new Iterator<?>[sources.size()]; this.lastEntry = new boolean[iterators.length]; this.values = new Object[iterators.length]; return this; }","old_code_raw":"    public MultiIterator init(IndexSupport indexSupport){\n        this.indexSupport = indexSupport;\n        this.iterators = new Iterator<?>[sources.size()];\n        this.lastEntry = new boolean[iterators.length];\n        this.values = new Object[iterators.length];\n        return this;\n    }\n","new_comment_raw":"@param indexSupport","old_comment_raw":"@param indexSupport","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":46},{"new_code_raw":"protected String getParameterDataType(Parameter parameter, Schema schema) { return null; }","old_code_raw":"   protected String getParameterDataType(Parameter parameter, Property property) {\n        return null;\n   }\n","new_comment_raw":"@param parameter Parameter","old_comment_raw":"@param parameter","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public int recordEvent(Document oplogEvent, Instant timestamp) throws InterruptedException { return recordEvent(oplogEvent, oplogEvent, timestamp, 0); }","old_code_raw":"        public int recordEvent(Document oplogEvent, long timestamp) throws InterruptedException {\n            return recordEvent(oplogEvent, oplogEvent, timestamp, 0);\n        }\n","new_comment_raw":"@param oplogEvent the event; may not be null","old_comment_raw":"@param oplogEvent the event; may not be null","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SharedSessionContractImplementor session) throws HibernateException { int[] props = TypeHelper.findDirty( entityMetamodel.getProperties(), currentState, previousState, propertyColumnUpdateable, hasUninitializedLazyProperties( entity ), session ); if ( props == null ) { return null; } else { logDirtyProperties( props ); return props; } }","old_code_raw":"\tpublic int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findDirty(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrentState,\n\t\t\t\tpreviousState,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n","new_comment_raw":"@param currentState The current state of the entity (the state to be checked).","old_comment_raw":"@param currentState The current state of the entity (the state to be checked).","label":0,"pre_label":1,"AST_level":7,"line_counts":19,"new_code_token_num":73},{"new_code_raw":"public Single<Client> rxTestClassname(Client client) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.testClassname(client, fut); })); }","old_code_raw":"    public Single<Client> rxTestClassname(Client body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.testClassname(body, fut);\n        }));\n    }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":10,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"private RexNode adjustCondition(LogicalProject project, LogicalJoin semiJoin) { \/\/ create two RexPrograms -- the bottom one representing a \/\/ concatenation of the project and the RHS of the semijoin and the \/\/ top one representing the semijoin condition RexBuilder rexBuilder = project.getCluster().getRexBuilder(); RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory(); RelNode rightChild = semiJoin.getRight(); \/\/ for the bottom RexProgram, the input is a concatenation of the \/\/ child of the project and the RHS of the semijoin RelDataType bottomInputRowType = SqlValidatorUtil.deriveJoinRowType( project.getInput().getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder bottomProgramBuilder = new RexProgramBuilder(bottomInputRowType, rexBuilder); \/\/ add the project expressions, then add input references for the RHS \/\/ of the semijoin for (Pair<RexNode, String> pair : project.getNamedProjects()) { bottomProgramBuilder.addProject(pair.left, pair.right); } int nLeftFields = project.getInput().getRowType().getFieldCount(); List<RelDataTypeField> rightFields = rightChild.getRowType().getFieldList(); int nRightFields = rightFields.size(); for (int i = 0; i < nRightFields; i++) { final RelDataTypeField field = rightFields.get(i); RexNode inputRef = rexBuilder.makeInputRef( field.getType(), i + nLeftFields); bottomProgramBuilder.addProject(inputRef, field.getName()); } RexProgram bottomProgram = bottomProgramBuilder.getProgram(); \/\/ input rowtype into the top program is the concatenation of the \/\/ project and the RHS of the semijoin RelDataType topInputRowType = SqlValidatorUtil.deriveJoinRowType( project.getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder topProgramBuilder = new RexProgramBuilder( topInputRowType, rexBuilder); topProgramBuilder.addIdentity(); topProgramBuilder.addCondition(semiJoin.getCondition()); RexProgram topProgram = topProgramBuilder.getProgram(); \/\/ merge the programs and expand out the local references to form \/\/ the new semijoin condition; it now references a concatenation of \/\/ the project's child and the RHS of the semijoin RexProgram mergedProgram = RexProgramBuilder.mergePrograms( topProgram, bottomProgram, rexBuilder); return mergedProgram.expandLocalRef( mergedProgram.getCondition()); }","old_code_raw":"  private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) {\n    \/\/ create two RexPrograms -- the bottom one representing a\n    \/\/ concatenation of the project and the RHS of the semijoin and the\n    \/\/ top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    \/\/ for the bottom RexProgram, the input is a concatenation of the\n    \/\/ child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        SqlValidatorUtil.deriveJoinRowType(\n            project.getInput().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    \/\/ add the project expressions, then add input references for the RHS\n    \/\/ of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getInput().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    \/\/ input rowtype into the top program is the concatenation of the\n    \/\/ project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        SqlValidatorUtil.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    \/\/ merge the programs and expand out the local references to form\n    \/\/ the new semijoin condition; it now references a concatenation of\n    \/\/ the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n","new_comment_raw":"@param project LogicalProject on the LHS of the semijoin","old_comment_raw":"@param project LogicalProject on the LHS of the semijoin","label":0,"pre_label":1,"AST_level":9,"line_counts":71,"new_code_token_num":411},{"new_code_raw":"public boolean searchEditText(String text) { boolean found = searcher.searchWithTimeoutFor(EditText.class, text, 1, true); return found; }","old_code_raw":"\tpublic boolean searchEditText(String search) {\n\t\tboolean found = searcher.searchWithTimeoutFor(EditText.class, search, 1, true);\n\t\treturn found;\n\t}\n","new_comment_raw":"@param text the text to search for","old_comment_raw":"@param search the search string to be searched","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":27},{"new_code_raw":"public static EBoolean startsWith(Expr<String> left, Expr<String> right) { return operationFactory.createBoolean(Ops.STARTSWITH, left, right); }","old_code_raw":"    public static EBoolean startsWith(Expr<String> left, Expr<String> right, boolean caseSensitive) {\n        if (caseSensitive){\n            return startsWith(left, right);            \n        }else{\n            return operationFactory.createBoolean(Ops.STARTSWITH_IC, left, right);\n        }\n    }\n","new_comment_raw":"@param left","old_comment_raw":"@param left","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public static MemberID parse(String memberID, boolean isClassMember) { return parse(memberID, isClassMember, null); }","old_code_raw":"    public static MemberID parse(String signature, boolean isClassMember) {\n        return parse(signature, isClassMember, null);\n    }\n","new_comment_raw":"@param isClassMember If the ID is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.","old_comment_raw":"@param isClassMember If the signature is ambiguous, if true always assume that the last simple member name is a method or field, else assume it is a class name.","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":23},{"new_code_raw":"public int[] findModified(Object[] old, Object[] current, Object entity, SharedSessionContractImplementor session) throws HibernateException { int[] props = TypeHelper.findModified( entityMetamodel.getProperties(), current, old, propertyColumnUpdateable, hasUninitializedLazyProperties( entity ), session ); if ( props == null ) { return null; } else { logDirtyProperties( props ); return props; } }","old_code_raw":"\tpublic int[] findModified(Object[] old, Object[] current, Object entity, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findModified(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrent,\n\t\t\t\told,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n","new_comment_raw":"@param current The current state of the entity.","old_comment_raw":"@param current The current state of the entity.","label":0,"pre_label":1,"AST_level":7,"line_counts":19,"new_code_token_num":73},{"new_code_raw":"ChromeResponse execute(DriverCommand driverCommand, Object... parameters) { Command command = new Command(new SessionId(\"[No sessionId]\"), new Context(\"[No context]\"), driverCommand, parameters); try { return executor.execute(command); } catch (Exception e) { if (e instanceof IllegalArgumentException || e instanceof FatalChromeException) { \/\/These exceptions may leave the extension hung, or in an \/\/inconsistent state, so we restart Chrome stopClient(); init(); } if (e instanceof RuntimeException) { throw (RuntimeException)e; } else { throw new WebDriverException(e); } } }","old_code_raw":"  ChromeResponse execute(String commandName, Object... parameters) {\n    Command command = new Command(new SessionId(\"[No sessionId]\"),\n                                  new Context(\"[No context]\"),\n                                  commandName,\n                                  parameters);\n    try {\n      return executor.execute(command);\n    } catch (Exception e) {\n      if (e instanceof IllegalArgumentException ||\n          e instanceof FatalChromeException) {\n        \/\/These exceptions may leave the extension hung, or in an\n        \/\/inconsistent state, so we restart Chrome\n        \/*if (e instanceof FatalChromeException) {\n          try { Thread.sleep(100000000); } catch (InterruptedException e2) {}\n        }*\/\n        stopClient();\n        init();\n      }\n      if (e instanceof RuntimeException) {\n        throw (RuntimeException)e;\n      } else {\n        throw new WebDriverException(e);\n      }\n    }\n  }\n","new_comment_raw":"@param driverCommand command to execute","old_comment_raw":"@param commandName command to execute","label":1,"pre_label":0,"AST_level":9,"line_counts":23,"new_code_token_num":127},{"new_code_raw":"public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) { Map<String, MergedFields> subFields = new LinkedHashMap<>(); List<String> visitedFragments = new ArrayList<>(); this.collectFields(parameters, selectionSet, visitedFragments, subFields); return newMergedSelectionSet().subFields(subFields).build(); }","old_code_raw":"    private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, MergedFields> fields) {\n\n        for (Selection selection : selectionSet.getSelections()) {\n            if (selection instanceof Field) {\n                collectField(parameters, fields, (Field) selection);\n            } else if (selection instanceof InlineFragment) {\n                collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection);\n            } else if (selection instanceof FragmentSpread) {\n                collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection);\n            }\n        }\n    }\n","new_comment_raw":"@param selectionSet the selection set to collect on","old_comment_raw":"@param selectionSet the selection set to collect on","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } \/\/ Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\"); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\"); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    \/\/ Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n","new_comment_raw":"@param end The end word, 0-indexed.","old_comment_raw":"@param selector The property of the sentence we are getting the mode of. For example, Sentence::posTags","label":1,"pre_label":0,"AST_level":11,"line_counts":64,"new_code_token_num":555},{"new_code_raw":"public Order getOrderById (Long orderId) throws ApiException { Object postBody = null; \/\/ verify the required parameter 'orderId' is set if (orderId == null) { throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\"); } \/\/ create path and map variables String path = \"\/store\/order\/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiInvoker.escapeString(orderId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { \/\/ normal form params } try { String response = apiInvoker.invokeAPI(basePath, path, \"GET\", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return (Order) ApiInvoker.deserialize(response, \"\", Order.class); } else { return null; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public Order  getOrderById (String orderId) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'orderId' is set\n    if (orderId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/store\/order\/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiInvoker.escapeString(orderId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"GET\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return (Order) ApiInvoker.deserialize(response, \"\", Order.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param orderId ID of pet that needs to be fetched","old_comment_raw":"@param orderId ID of pet that needs to be fetched","label":0,"pre_label":1,"AST_level":10,"line_counts":53,"new_code_token_num":299},{"new_code_raw":"String evaluate(String url, String host) throws ScriptException { try { return (String) pacImpl.invokeFunction(\"FindProxyForURL\", url, host); } catch (NoSuchMethodException | ScriptAbuseException e) { throw new ScriptException(e); } }","old_code_raw":"    public String evaluate(String destURL, String destHost) throws ScriptException {\n        try {\n            return (String) pacImpl.invokeFunction(\"FindProxyForURL\", destURL, destHost);\n        } catch (NoSuchMethodException | ScriptAbuseException e) {\n            throw new ScriptException(e);\n        }\n    }\n","new_comment_raw":"@param url the url param of FindProxyForURL(url, host)","old_comment_raw":"@param destURL the url param of FindProxyForURL(url, host)","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":48},{"new_code_raw":"public Order placeOrder(Order order) throws RestClientException { Object postBody = order; \/\/ verify the required parameter 'order' is set if (order == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'order' when calling placeOrder\"); } String path = UriComponentsBuilder.fromPath(\"\/store\/order\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/xml\", \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Order placeOrder(Order body) throws RestClientException {\n        Object postBody = body;\n        \n        \/\/ verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling placeOrder\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"\/store\/order\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/xml\", \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Order> returnType = new ParameterizedTypeReference<Order>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param order order placed for purchasing the pet","old_comment_raw":"@param body order placed for purchasing the pet","label":1,"pre_label":0,"AST_level":8,"line_counts":27,"new_code_token_num":203},{"new_code_raw":"private GenericRecord deserialize(Event event, GenericRecord reuse) throws EventDeliveryException { decoder = DecoderFactory.get().binaryDecoder(event.getBody(), decoder); \/\/ no checked exception is thrown in the CacheLoader DatumReader<GenericRecord> reader = readers.getUnchecked(schema(event)); try { return reader.read(reuse, decoder); } catch (IOException ex) { throw new EventDeliveryException(\"Cannot deserialize event\", ex); } }","old_code_raw":"  private Object deserialize(Event event, Object reuse)\n      throws EventDeliveryException {\n    decoder = DecoderFactory.get().binaryDecoder(event.getBody(), decoder);\n    \/\/ no checked exception is thrown in the CacheLoader\n    ReflectDatumReader<Object> reader = readers.getUnchecked(schema(event));\n    try {\n      return reader.read(reuse, decoder);\n    } catch (IOException ex) {\n      throw new EventDeliveryException(\"Cannot deserialize event\", ex);\n    }\n  }\n","new_comment_raw":"@param event","old_comment_raw":"@param event","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":83},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) contentType = \"application\/json\"; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = reqBuilder.method(method, reqBody).build(); return httpClient.newCall(request); }","old_code_raw":"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    \/\/ ensuring a default content type\n    if (contentType == null) {\n      contentType = \"application\/json\";\n    }\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart\/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        \/\/ allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        \/\/ use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = null;\n\n    if(progressRequestListener != null && reqBody != null) {\n      ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n      request = reqBuilder.method(method, progressRequestBody).build();\n    } else {\n      request = reqBuilder.method(method, reqBody).build();\n    }\n\n    return httpClient.newCall(request);\n  }\n","new_comment_raw":"@param authNames The authentications to apply","old_comment_raw":"@param authNames The authentications to apply","label":0,"pre_label":1,"AST_level":14,"line_counts":34,"new_code_token_num":285},{"new_code_raw":"public static long toMicroOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration); } \/\/ conversion to nanos is fine as TIME values won't exceed long range return ((Duration) value).toNanos() \/ 1_000; } \/\/ TODO only needed for SQL Server\/Oracle, where we don't produce Duration right away; \/\/ this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND); }","old_code_raw":"    public static long toMicroOfDay(Object value, TemporalAdjuster adjuster) {\n        \/\/ conversion to nanos is fine as TIME values won't exceed long range\n        if (value instanceof Duration) {\n            return ((Duration) value).toNanos() \/ 1_000;\n        }\n\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster != null) {\n            time = time.with(adjuster);\n        }\n        return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND);\n    }\n","new_comment_raw":"@param value the duration value; may not be null","old_comment_raw":"@param value the local or SQL date, time, or timestamp value; may not be null","label":1,"pre_label":0,"AST_level":10,"line_counts":17,"new_code_token_num":166},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException { return fakeOuterBooleanSerializeWithHttpInfo(booleanPostBody).getData(); }","old_code_raw":"  public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n    return fakeOuterBooleanSerializeWithHttpInfo(body).getData();\n      }\n","new_comment_raw":"@param booleanPostBody Input boolean as post body (optional)","old_comment_raw":"@param body Input boolean as post body (optional)","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public long get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public long get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"@param withAttributes an object containing an AttributeMap","old_comment_raw":"@param attributes an object containing an AttributeMap","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public boolean waitForSpace(long timeout, int highWaterMark) throws InterruptedException { if (parent != null) { if (!parent.waitForSpace(timeout, highWaterMark)) { return false; } } synchronized (usageMutex) { percentUsage=caclPercentUsage(); if (percentUsage >= highWaterMark) { long deadline = timeout > 0 ? System.currentTimeMillis() + timeout : Long.MAX_VALUE; long timeleft = deadline; while (timeleft > 0) { percentUsage=caclPercentUsage(); if (percentUsage >= highWaterMark) { usageMutex.wait(pollingTime); timeleft = deadline - System.currentTimeMillis(); } else { break; } } } return percentUsage < highWaterMark; } }","old_code_raw":"    public boolean waitForSpace(long timeout) throws InterruptedException {\n        if (parent != null) {\n            if (!parent.waitForSpace(timeout)) {\n                return false;\n            }\n        }\n        synchronized (usageMutex) {\n            percentUsage=caclPercentUsage();\n            if (percentUsage >= 100) {\n                long deadline = timeout > 0 ? System.currentTimeMillis() + timeout : Long.MAX_VALUE;\n                long timeleft = deadline;\n                while (timeleft > 0) {\n                    percentUsage=caclPercentUsage();\n                    if (percentUsage >= 100) {\n                        usageMutex.wait(pollingTime);\n                        timeleft = deadline - System.currentTimeMillis();\n                    } else {\n                        break;\n                    }\n                }\n            }\n            return percentUsage < 100;\n        }\n    }\n","new_comment_raw":"@param timeout","old_comment_raw":"@param timeout","label":0,"pre_label":1,"AST_level":13,"line_counts":25,"new_code_token_num":117},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(String type, StructuredTextEnvironment environment) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$ return getStatefulExpert(handler, environment); }","old_code_raw":"\tstatic public ISTextExpert getStatefulExpert(String type, STextEnvironment environment) {\n\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\tif (handler == null)\n\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$\n\t\treturn getStatefulExpert(handler, environment);\n\t}\n","new_comment_raw":"@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the  StructuredTextEnvironment#DEFAULT environment should be assumed.","old_comment_raw":"@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the STextEnvironment#DEFAULT environment should be assumed.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"public static QName getXSIType(Parameter param) { if (param.getMIMEType() != null) { return getMIMETypeQName(param.getMIMEType()); } QName xmlType = null; TypeEntry te = param.getType(); \/\/ If the TypeEntry describes an Element, get \/\/ the referenced Type. if (te != null && te instanceof Element && te.getRefType() != null) { te = te.getRefType(); } \/\/ If the TypeEntry is a CollectionType, use \/\/ the TypeEntry representing the component Type \/\/ So for example a parameter that takes a \/\/ collection type for \/\/ <element name=\"A\" type=\"xsd:string\" maxOccurs=\"unbounded\"\/> \/\/ will be \/\/ new ParameterDesc(<QName of A>, IN, \/\/ <QName of xsd:string>, \/\/ String[]) if (te != null && te instanceof CollectionType && te.getRefType() != null) { te = te.getRefType(); } if (te != null) { xmlType = te.getQName(); } return xmlType; }","old_code_raw":"    public static QName getXSIType(TypeEntry te) {\n        QName xmlType = null;\n\n        \/\/ If the TypeEntry describes an Element, get\n        \/\/ the referenced Type.\n        if (te != null &&\n            te instanceof Element &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        } \n        \/\/ If the TypeEntry is a CollectionType, use\n        \/\/ the TypeEntry representing the component Type\n        \/\/ So for example a parameter that takes a \n        \/\/ collection type for\n        \/\/ <element name=\"A\" type=\"xsd:string\" maxOccurs=\"unbounded\"\/>\n        \/\/ will be \n        \/\/ new ParameterDesc(<QName of A>, IN,\n        \/\/                   <QName of xsd:string>,\n        \/\/                   String[])\n        if (te != null &&\n            te instanceof CollectionType &&\n            te.getRefType() != null) {\n            te = te.getRefType();\n        }\n        if (te != null) {\n            xmlType = te.getQName();\n        }\n        return xmlType;\n    }\n","new_comment_raw":"@param param is a parameter","old_comment_raw":"@param te is the typeEntry from the Parameters object, which represents the parameter","label":1,"pre_label":0,"AST_level":7,"line_counts":36,"new_code_token_num":207},{"new_code_raw":"public static Polygon getCanvasTileAreaPoly(Client client, LocalPoint localLocation, int size) { int plane = client.getPlane(); int halfTile = LOCAL_TILE_SIZE \/ 2; \/\/ If the size is 5, we need to shift it up and left 2 units, then expand by 5 units to make a 5x5 int aoeSize = size \/ 2; \/\/ Shift over one half tile as localLocation is the center point of the tile, and then shift the area size Point topLeft = new Point(localLocation.getX() - (aoeSize * LOCAL_TILE_SIZE) - halfTile, localLocation.getY() - (aoeSize * LOCAL_TILE_SIZE) - halfTile); \/\/ expand by size Point bottomRight = new Point(topLeft.getX() + size * LOCAL_TILE_SIZE - 1, topLeft.getY() + size * LOCAL_TILE_SIZE - 1); \/\/ Take the x of top left and the y of bottom right to create bottom left Point bottomLeft = new Point(topLeft.getX(), bottomRight.getY()); \/\/ Similarly for top right Point topRight = new Point(bottomRight.getX(), topLeft.getY()); Point p1 = worldToCanvas(client, topLeft.getX(), topLeft.getY(), plane); Point p2 = worldToCanvas(client, topRight.getX(), topRight.getY(), plane); Point p3 = worldToCanvas(client, bottomRight.getX(), bottomRight.getY(), plane); Point p4 = worldToCanvas(client, bottomLeft.getX(), bottomLeft.getY(), plane); if (p1 == null || p2 == null || p3 == null || p4 == null) { return null; } Polygon poly = new Polygon(); poly.addPoint(p1.getX(), p1.getY()); poly.addPoint(p2.getX(), p2.getY()); poly.addPoint(p3.getX(), p3.getY()); poly.addPoint(p4.getX(), p4.getY()); return poly; }","old_code_raw":"\tpublic static Polygon getCanvasTileAreaPoly(Client client, Point localLocation, int size)\n\t{\n\t\tint plane = client.getPlane();\n\t\tint halfTile = LOCAL_TILE_SIZE \/ 2;\n\n\t\t\/\/ If the size is 5, we need to shift it up and left 2 units, then expand by 5 units to make a 5x5\n\t\tint aoeSize = size \/ 2;\n\n\t\t\/\/ Shift over one half tile as localLocation is the center point of the tile, and then shift the area size\n\t\tPoint topLeft = new Point(localLocation.getX() - (aoeSize * LOCAL_TILE_SIZE) - halfTile,\n\t\t\tlocalLocation.getY() - (aoeSize * LOCAL_TILE_SIZE) - halfTile);\n\t\t\/\/ expand by size\n\t\tPoint bottomRight = new Point(topLeft.getX() + size * LOCAL_TILE_SIZE - 1,\n\t\t\ttopLeft.getY() + size * LOCAL_TILE_SIZE - 1);\n\t\t\/\/ Take the x of top left and the y of bottom right to create bottom left\n\t\tPoint bottomLeft = new Point(topLeft.getX(), bottomRight.getY());\n\t\t\/\/ Similarly for top right\n\t\tPoint topRight = new Point(bottomRight.getX(), topLeft.getY());\n\n\t\tPoint p1 = worldToCanvas(client, topLeft.getX(), topLeft.getY(), plane);\n\t\tPoint p2 = worldToCanvas(client, topRight.getX(), topRight.getY(), plane);\n\t\tPoint p3 = worldToCanvas(client, bottomRight.getX(), bottomRight.getY(), plane);\n\t\tPoint p4 = worldToCanvas(client, bottomLeft.getX(), bottomLeft.getY(), plane);\n\n\t\tif (p1 == null || p2 == null || p3 == null || p4 == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tPolygon poly = new Polygon();\n\t\tpoly.addPoint(p1.getX(), p1.getY());\n\t\tpoly.addPoint(p2.getX(), p2.getY());\n\t\tpoly.addPoint(p3.getX(), p3.getY());\n\t\tpoly.addPoint(p4.getX(), p4.getY());\n\n\t\treturn poly;\n\t}\n","new_comment_raw":"@param size size of the area. Ex. Lizardman Shaman AoE is a 3x3, so size = 3","old_comment_raw":"@param size size of the area. Ex. Lizardman Shaman AoE is a 3x3, so size = 3","label":0,"pre_label":1,"AST_level":9,"line_counts":38,"new_code_token_num":371},{"new_code_raw":"private boolean isAncestorOf(Object node, Object target) { if (target == null) return false; Object parent = getParent(target); if (parent == node) return true; return isAncestorOf(node, parent); }","old_code_raw":"\tprivate boolean isAncestorOf(Object object1, Object object2) {\r\n\t\tif (object2 == null) return false;\r\n\t\tObject parent = getParent(object2);\r\n\t\tif (parent == object1) return true;\r\n\t\treturn isAncestorOf(object1, parent);\r\n   }\r\n","new_comment_raw":"@param node The node to be tested.","old_comment_raw":"@param object1 The first object to be tested.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":43},{"new_code_raw":"public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFolder, String filename, boolean isRange, boolean isDeleteOld) { return new RestDownloadRequestor(url, requestMethod, fileFolder, filename, isRange, isDeleteOld); }","old_code_raw":"    public static DownloadRequest createDownloadRequest(String url, RequestMethod requestMethod, String fileFloder, String filename, boolean isRange, boolean isDeleteOld) {\n        return new RestDownloadRequestor(url, requestMethod, fileFloder, filename, isRange, isDeleteOld);\n    }\n","new_comment_raw":"@param fileFolder Folder to save file","old_comment_raw":"@param fileFloder Folder to save file","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":42},{"new_code_raw":"public ASTNode getASTNodeAt(int javaOffset) { Messages.log(\"* getASTNodeAt\"); PreprocessedSketch ps = errorCheckerService.latestResult; ASTNode node = NodeFinder.perform(ps.compilationUnit, javaOffset, 0); if (node == null) { Messages.log(\"no node found\"); return null; } Messages.log(\"found \" + node.toString()); return node; }","old_code_raw":"  public ASTNode getASTNodeAt(int offset) {\n    Messages.log(\"* getASTNodeAt\");\n\n    PreprocessedSketch ps = errorCheckerService.latestResult;\n    int tabIndex = ps.sketch.getCodeIndex(editor.getCurrentTab());\n    int javaOffset = ps.tabOffsetToJavaOffset(tabIndex, offset);\n    ASTNode node = NodeFinder.perform(ps.compilationUnit, javaOffset, 0);\n\n    if (node == null) {\n      Messages.log(\"no node found\");\n      return null;\n    }\n\n    Messages.log(\"found \" + node.toString());\n    return node;\n  }\n","new_comment_raw":"@param name","old_comment_raw":"@param name","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":72},{"new_code_raw":"private ColumnState buildSimpleList(ContainerState parent, ColumnReadProjection colProj) { ColumnMetadata columnSchema = colProj.providedSchema(); \/\/ The variant must have the one and only type. assert columnSchema.variantSchema().size() == 1; assert columnSchema.variantSchema().isSimple(); \/\/ Create the manager for the one and only column within the list. final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name())); \/\/ Create the child vector, writer and state. final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype(); final ColumnState memberState = buildColumn(listState, memberSchema); listState.setSubColumn(memberState); \/\/ Create the list vector. Contains a single type. final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(), parent.loader().allocator(), null); listVector.setChildVector(memberState.vector()); \/\/ Create the list writer: an array of the one type. final ListWriterImpl listWriter = new ListWriterImpl(columnSchema, listVector, memberState.writer()); final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter); \/\/ Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(listWriter, memberState.writer().events(), listVector); \/\/ Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listObjWriter, vectorState, listState); }","old_code_raw":"  private ColumnState buildSimpleList(ContainerState parent, ColumnTransform outputCol) {\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    \/\/ The variant must have the one and only type.\n\n    assert columnSchema.variantSchema().size() == 1;\n    assert columnSchema.variantSchema().isSimple();\n\n    \/\/ Create the manager for the one and only column within the list.\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()),\n        new ImpliedTupleRequest(true));\n\n    \/\/ Create the child vector, writer and state.\n\n    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();\n    final ColumnState memberState = buildColumn(listState, memberSchema);\n    listState.setSubColumn(memberState);\n\n    \/\/ Create the list vector. Contains a single type.\n\n    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),\n        parent.loader().allocator(), null);\n    listVector.setChildVector(memberState.vector());\n\n    \/\/ Create the list writer: an array of the one type.\n\n    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,\n        listVector, memberState.writer());\n    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);\n\n    \/\/ Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(listWriter,\n        memberState.writer().events(), listVector);\n\n    \/\/ Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listObjWriter, vectorState, listState);\n  }\n","new_comment_raw":"@param parent the parent (tuple, union or list) that holds this list","old_comment_raw":"@param parent the parent (tuple, union or list) that holds this list","label":0,"pre_label":1,"AST_level":8,"line_counts":42,"new_code_token_num":264},{"new_code_raw":"public final static AtmosphereRequest cloneRequest(HttpServletRequest request, boolean loadInMemory, boolean copySession, boolean isDestroyable) { Builder b; HttpServletRequest r; boolean isWrapped = false; if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) { b = AtmosphereRequest.class.cast(request).b; isWrapped = true; } else { b = new Builder(); b.request(request); } b.servletPath(request.getServletPath()) .pathInfo(request.getPathInfo()) .contextPath(request.getContextPath()) .requestURI(request.getRequestURI()) .requestURL(request.getRequestURL().toString()) .method(request.getMethod()) .serverName(request.getServerName()) .serverPort(request.getServerPort()) .destroyable(isDestroyable) .session(copySession ? new FakeHttpSession(request.getSession(true)) : null); if (loadInMemory) { r = new NoOpsRequest(); if (isWrapped) { load(b.request, b); } else { load(request, b); } b.request(r); } return isWrapped ? AtmosphereRequest.class.cast(request) : b.build(); }","old_code_raw":"    public final static AtmosphereRequest cloneRequest(HttpServletRequest request, boolean loadInMemory, boolean copySession) {\n        Builder b;\n        HttpServletRequest r;\n        boolean isWrapped = false;\n        if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) {\n            b = AtmosphereRequest.class.cast(request).b;\n            isWrapped = true;\n        } else {\n            b = new Builder();\n            b.request(request);\n        }\n\n        b.servletPath(request.getServletPath())\n                .pathInfo(request.getPathInfo())\n                .contextPath(request.getContextPath())\n                .requestURI(request.getRequestURI())\n                .requestURL(request.getRequestURL().toString())\n                .method(request.getMethod())\n                .serverName(request.getServerName())\n                .serverPort(request.getServerPort())\n                .destroyable(false)\n                .session(copySession ? new FakeHttpSession(request.getSession(true)) : null);\n\n        if (loadInMemory) {\n            r = new NoOpsRequest();\n            if (isWrapped) {\n                load(b.request, b);\n            } else {\n                load(request, b);\n            }\n            b.request(r);\n        }\n\n        return isWrapped ? AtmosphereRequest.class.cast(request) : b.build();\n    }\n","new_comment_raw":"@param request  HttpServletRequest","old_comment_raw":"@param request HttpServletRequest","label":0,"pre_label":1,"AST_level":9,"line_counts":36,"new_code_token_num":209},{"new_code_raw":"private SourceRecord createSourceRecordWithTimestamp(Instant ts) { Map<String, ?> offset = Collections.singletonMap(SourceInfo.TIMESTAMP_KEY, ts.getEpochSecond()); return new SourceRecord(null, offset, null, null, null); }","old_code_raw":"    private SourceRecord createSourceRecordWithTimestamp(long tsSec) {\n        Map<String, ?> offset = Collections.singletonMap(SourceInfo.TIMESTAMP_KEY, tsSec);\n        return new SourceRecord(null, offset, null, null, null);\n    }\n","new_comment_raw":"@param tsSec the timestamp in the resulting offset.","old_comment_raw":"@param tsSec the timestamp (in seconds) in the resulting offset.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":41},{"new_code_raw":"public Struct update(Object before, Struct after, Struct source, Long timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.UPDATE.code()); if (before != null) struct.put(FieldName.BEFORE, before); struct.put(FieldName.AFTER, after); if (source != null) struct.put(FieldName.SOURCE, source); if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp); return struct; }","old_code_raw":"    public Struct update(Struct before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) struct.put(FieldName.BEFORE, before);\n        struct.put(FieldName.AFTER, after);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n","new_comment_raw":"@param before the state of the record before the update; may be null","old_comment_raw":"@param before the state of the record before the update; may be null","label":0,"pre_label":1,"AST_level":6,"line_counts":10,"new_code_token_num":96},{"new_code_raw":"long getLoad(MigratableHandler handler) { return handlerLoadCounter.get(handler); }","old_code_raw":"    long getLoad(MigratablePipeline pipeline) {\n        return handlerLoadCounter.get(pipeline);\n    }\n","new_comment_raw":"@param handler","old_comment_raw":"@param pipeline","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":15},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); \/\/ Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); \/\/ Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n","new_comment_raw":"@param launcher","old_comment_raw":"@param launcher","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":156},{"new_code_raw":"public DateTime withPeriodAdded(ReadablePeriod period, int scalar) { if (period == null || scalar == 0) { return this; } long instant = getChronology().add(getMillis(), period, scalar); return withMillis(instant); }","old_code_raw":"    public DateTime withPeriodAdded(ReadablePeriod periodToAdd, int scalar) {\n        if (periodToAdd == null || scalar == 0) {\n            return this;\n        }\n        long instant = periodToAdd.addTo(getMillis(), scalar, getChronology());\n        return withMillis(instant);\n    }\n","new_comment_raw":"@param period the period to add to this one, null means zero","old_comment_raw":"@param periodToAdd the period to add to this one, null means zero","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":48},{"new_code_raw":"public static boolean isValidTimeExtract(RexNode rexNode) { if (rexNode.getKind() != SqlKind.EXTRACT) { return false; } final RexCall call = (RexCall) rexNode; final RexLiteral flag = (RexLiteral) call.operands.get(0); final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue(); return timeUnit != null && VALID_TIME_EXTRACT.contains(timeUnit); }","old_code_raw":"  public static boolean isValidTimeExtract(RexCall call) {\n    if (call.getKind() != SqlKind.EXTRACT) {\n      return false;\n    }\n    final RexLiteral flag = (RexLiteral) call.operands.get(0);\n    final TimeUnitRange timeUnit = (TimeUnitRange) flag.getValue();\n    return timeUnit != null && VALID_TIME_EXTRACT.contains(timeUnit);\n  }\n","new_comment_raw":"@param rexNode Extract expression","old_comment_raw":"@param call Extract expression","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":69},{"new_code_raw":"public long set(long instant, int month) { Utils.verifyValueBounds(this, month, MIN, MAX); \/\/ int thisYear = iChronology.year().get(instant); \/\/ int thisDom = iChronology.getDayOfMonth(instant, thisYear); int maxDom = iChronology.getDaysInYearMonth(thisYear, month); if (thisDom > maxDom) { \/\/ Quietly force DOM to nearest sane value. thisDom = maxDom; } \/\/ Return newly calculated millis value return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) + iChronology.millisOfDay().get(instant); }","old_code_raw":"    public long set(long millis, int month) {\n        super.verifyValueBounds(month, MIN, MAX);\n        \/\/\n        int thisYear = iChronology.year().get(millis);\n        \/\/\n        int thisDom = iChronology.getDayOfMonth(millis, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            \/\/ Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        \/\/ Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.millisOfDay().get(millis);\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":7,"line_counts":16,"new_code_token_num":105},{"new_code_raw":"public WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){ if(minimumNumberOfMatches < 1){ minimumNumberOfMatches = 1; } List<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by); addViewsToList (webElements, viewsFromScreen); return getViewFromList(webElements, minimumNumberOfMatches); }","old_code_raw":"\tpublic WebElement searchForWebElement(final By by, int match, int timeout, boolean scroll){\n\n\t\tif(match < 1){\n\t\t\tmatch = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, match);\n\t}\n","new_comment_raw":"@param by the By object e.g. By.id(\"id\");","old_comment_raw":"@param by the By object e.g. By.id(\"id\");","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"public Field withValidation(Validator... validators) { Validator actualValidator = validator; for (Validator validator : validators) { if (validator != null) actualValidator = validator.and(actualValidator); } return new Field(name(), displayName(), type(), width(), description(), importance(), dependents, defaultValueGenerator, actualValidator, recommender); }","old_code_raw":"    public Field withValidation(Predicate<String>... predicates) {\n        return new Field(name(), description(), defaultValueGenerator, (config, field, problems) -> {\n            String value = config.getString(field);\n            for (Predicate<String> predicate : predicates) {\n                if (predicate != null) {\n                    try {\n                        if (!predicate.test(value)) {\n                            problems.accept(\"The \" + field.name() + \" value '\" + value + \"' is not valid\");\n                            return 1;\n                        }\n                    } catch (Throwable t) {\n                        problems.accept(\"The \" + field.name() + \" value '\" + value + \"' is not allowed: \" + t.getMessage());\n                        return 1;\n                    }\n                }\n            }\n            return 0;\n        });\n    }\n","new_comment_raw":"@param validators the additional validation function(s); may be null","old_comment_raw":"@param predicates the functions that attempt to validate the object; may be null","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":72},{"new_code_raw":"private List<HttpCookie> prepareCookies(String uriS) { if (parent.getSpiderParam().isSendCookies()) { java.net.URI uri = null; try { uri = new java.net.URI(uriS); } catch (URISyntaxException e) { log.error(\"Error while preparing cookies. \", e); } return parent.getCookieManager().getCookieStore().get(uri); } return null; }","old_code_raw":"\tprivate List<HttpCookie> prepareCookies(HttpMessage msg) {\n\t\tif (parent.getSpiderParam().isSendCookies()) {\n\t\t\tjava.net.URI uri = null;\n\t\t\ttry {\n\t\t\t\turi = new java.net.URI(msg.getRequestHeader().getURI().toString());\n\t\t\t} catch (URISyntaxException e) {\n\t\t\t\tlog.error(\"Error while preparing cookies. \", e);\n\t\t\t}\n\t\t\treturn parent.getCookieManager().getCookieStore().get(uri);\n\t\t}\n\t\treturn null;\n\t}\n","new_comment_raw":"@param uriS the uri","old_comment_raw":"@param msg the response message where the uri was found","label":1,"pre_label":0,"AST_level":11,"line_counts":13,"new_code_token_num":76},{"new_code_raw":"public Action timedout(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { logger.trace(\"Timing out {}\", req); if (trackActiveRequest(req) && completeLifecycle(req.resource(), false)) { config.framework().notify(Action.TYPE.TIMEOUT, req, res); } return timedoutAction; }","old_code_raw":"    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n\n        try {\n            SessionTimeoutSupport.restoreTimeout(request);\n\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    \/\/ The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            \/\/ Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.isCancelled()) {\n                return cancelledAction;\n            }\n\n            if (r == null) {\n                logger.debug(\"AtmosphereResource was null, failed to timeout AtmosphereRequest {}\", request);\n            }\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            config.framework().notify(Action.TYPE.TIMEOUT, request, response);\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    r._destroy();\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"@param res the  AtmosphereResponse","old_comment_raw":"@param response the AtmosphereResponse","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":67},{"new_code_raw":"private double[] makeDatumUsingEmbedding(List<IN> info, int loc, List<FeatureFactory<IN>> featureFactories, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) { double[] featureValArr; List<double[]> embeddingList = new ArrayList<double[]>(); int concatEmbeddingLen = 0; String currentWord = null; for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) { double[] embedding = null; if (currLoc >=0 && currLoc < info.size()) { currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class); String word = currentWord.toLowerCase(); word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\"); if (embeddings.containsKey(word)) embedding = embeddings.get(word); else embedding = embeddings.get(\"UNKNOWN\"); } else { embedding = embeddings.get(\"PADDING\"); } for (int e = 0; e < embedding.length; e++) { featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e); } if (flags.addCapitalFeatures) { int numOfCapitalFeatures = 4; double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures]; int currLen = embedding.length; System.arraycopy(embedding, 0, newEmbedding, 0, currLen); for (int e = 0; e < numOfCapitalFeatures; e++) featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e); if (currLoc >=0 && currLoc < info.size()) { \/\/ skip PADDING \/\/ check if word is all caps if (currentWord.toUpperCase().equals(currentWord)) newEmbedding[currLen] = 1; else { currLen += 1; \/\/ check if word is all lower if (currentWord.toLowerCase().equals(currentWord)) newEmbedding[currLen] = 1; else { currLen += 1; \/\/ check first letter cap if (Character.isUpperCase(currentWord.charAt(0))) newEmbedding[currLen] = 1; else { currLen += 1; \/\/ check if at least one non-initial letter is cap String remainder = currentWord.substring(1); if (!remainder.toLowerCase().equals(remainder)) newEmbedding[currLen] = 1; } } } } embedding = newEmbedding; } embeddingList.add(embedding); concatEmbeddingLen += embedding.length; } double[] concatEmbedding = new double[concatEmbeddingLen]; int currPos = 0; for (double[] em: embeddingList) { System.arraycopy(em, 0, concatEmbedding, currPos, em.length); currPos += em.length; } if (flags.prependEmbedding) { int additionalFeatureCount = 0; for (Clique c : windowCliques) { for (FeatureFactory featureFactory : featureFactories) { Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); \/\/todo useless copy because of typing reasons featuresC.addAll(fCol); additionalFeatureCount += fCol.size(); } } featureValArr = new double[concatEmbedding.length + additionalFeatureCount]; System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length); Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0); } else { featureValArr = concatEmbedding; } if (flags.addBiasToEmbedding) { featuresC.add(\"BIAS-FEATURE\"); double[] newFeatureValArr = new double[featureValArr.length + 1]; System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length); newFeatureValArr[newFeatureValArr.length-1] = 1; featureValArr = newFeatureValArr; } return featureValArr; }","old_code_raw":"  private double[] makeDatumUsingEmbedding(List<IN> info, int loc, FeatureFactory<IN> featureFactory, PaddedList<IN> pInfo, List<String> featuresC, List<Clique> windowCliques) {\n    double[] featureValArr;\n    List<double[]> embeddingList = new ArrayList<double[]>();\n    int concatEmbeddingLen = 0;\n    String currentWord = null;\n    for (int currLoc = loc-2; currLoc <= loc+2; currLoc++) {\n      double[] embedding = null;\n      if (currLoc >=0 && currLoc < info.size()) {\n        currentWord = info.get(loc).get(CoreAnnotations.TextAnnotation.class);\n        String word = currentWord.toLowerCase();\n        word = word.replaceAll(\"(-)?\\\\d+(\\\\.\\\\d*)?\", \"0\");\n        if (embeddings.containsKey(word))\n          embedding = embeddings.get(word);\n        else\n          embedding = embeddings.get(\"UNKNOWN\");\n      } else {\n        embedding = embeddings.get(\"PADDING\");\n      }\n\n      for (int e = 0; e < embedding.length; e++) {\n        featuresC.add(\"EMBEDDING-(\" + (currLoc-loc) + \")-\" + e);\n      }\n\n      if (flags.addCapitalFeatures) {\n        int numOfCapitalFeatures = 4;\n        double[] newEmbedding = new double[embedding.length + numOfCapitalFeatures];\n        int currLen = embedding.length;\n        System.arraycopy(embedding, 0, newEmbedding, 0, currLen);\n        for (int e = 0; e < numOfCapitalFeatures; e++)\n          featuresC.add(\"CAPITAL-(\" + (currLoc-loc) + \")-\" + e);\n\n        if (currLoc >=0 && currLoc < info.size()) { \/\/ skip PADDING\n          \/\/ check if word is all caps\n          if (currentWord.toUpperCase().equals(currentWord))\n            newEmbedding[currLen] = 1;\n          else {\n            currLen += 1;\n            \/\/ check if word is all lower\n            if (currentWord.toLowerCase().equals(currentWord))\n              newEmbedding[currLen] = 1;\n            else {\n              currLen += 1;\n              \/\/ check first letter cap\n              if (Character.isUpperCase(currentWord.charAt(0)))\n                newEmbedding[currLen] = 1;\n              else {\n                currLen += 1;\n                \/\/ check if at least one non-initial letter is cap\n                String remainder = currentWord.substring(1);\n                if (!remainder.toLowerCase().equals(remainder))\n                  newEmbedding[currLen] = 1;\n              }\n            }\n          }\n        }\n        embedding = newEmbedding;\n      }\n\n      embeddingList.add(embedding);\n      concatEmbeddingLen += embedding.length;\n    }\n    double[] concatEmbedding = new double[concatEmbeddingLen];\n    int currPos = 0;\n    for (double[] em: embeddingList) {\n      System.arraycopy(em, 0, concatEmbedding, currPos, em.length);\n      currPos += em.length;\n    }\n\n    if (flags.prependEmbedding) {\n      int additionalFeatureCount = 0;\n      for (Clique c : windowCliques) {\n        Collection<String> fCol = featureFactory.getCliqueFeatures(pInfo, loc, c); \/\/todo useless copy because of typing reasons\n        featuresC.addAll(fCol);\n        additionalFeatureCount += fCol.size();\n      }\n      featureValArr = new double[concatEmbedding.length + additionalFeatureCount];\n      System.arraycopy(concatEmbedding, 0, featureValArr, 0, concatEmbedding.length);\n      Arrays.fill(featureValArr, concatEmbedding.length, featureValArr.length, 1.0);\n    } else {\n      featureValArr = concatEmbedding;\n    }\n\n    if (flags.addBiasToEmbedding) {\n      featuresC.add(\"BIAS-FEATURE\");\n      double[] newFeatureValArr = new double[featureValArr.length + 1];\n      System.arraycopy(featureValArr, 0, newFeatureValArr, 0, featureValArr.length);\n      newFeatureValArr[newFeatureValArr.length-1] = 1;\n      featureValArr = newFeatureValArr;\n    }\n    return featureValArr;\n  }\n","new_comment_raw":"@param info The input data","old_comment_raw":"@param info The input data","label":0,"pre_label":1,"AST_level":20,"line_counts":94,"new_code_token_num":682},{"new_code_raw":"public static Properties getPartitionMetadata(final HivePartition partition, final HiveTableWithColumnCache table) { final Properties properties; restoreColumns(table, partition); properties = MetaStoreUtils.getPartitionMetadata(partition, table); \/\/ SerDe expects properties from Table, but above call doesn't add Table properties. \/\/ Include Table properties in final list in order to not to break SerDes that depend on \/\/ Table properties. For example AvroSerDe gets the schema from properties (passed as second argument) for (Map.Entry<String, String> entry : table.getParameters().entrySet()) { if (entry.getKey() != null && entry.getKey() != null) { properties.put(entry.getKey(), entry.getValue()); } } return properties; }","old_code_raw":"  public static Properties getPartitionMetadata(final Partition partition, final Table table) {\n    final Properties properties = MetaStoreUtils.getPartitionMetadata(partition, table);\n\n    \/\/ SerDe expects properties from Table, but above call doesn't add Table properties.\n    \/\/ Include Table properties in final list in order to not to break SerDes that depend on\n    \/\/ Table properties. For example AvroSerDe gets the schema from properties (passed as second argument)\n    for (Map.Entry<String, String> entry : table.getParameters().entrySet()) {\n      if (entry.getKey() != null && entry.getKey() != null) {\n        properties.put(entry.getKey(), entry.getValue());\n      }\n    }\n\n    return properties;\n  }\n","new_comment_raw":"@param table the source of table level parameters","old_comment_raw":"@param table","label":1,"pre_label":0,"AST_level":9,"line_counts":17,"new_code_token_num":143},{"new_code_raw":"public List<TypedDependency> typedDependenciesCCprocessed(Extras includeExtras) { List<TypedDependency> tdl = typedDependencies(includeExtras); collapseDependencies(tdl, true, includeExtras); return tdl; }","old_code_raw":"  public List<TypedDependency> typedDependenciesCCprocessed(boolean includeExtras) {\n    List<TypedDependency> tdl = typedDependencies(includeExtras);\n    collapseDependencies(tdl, true, includeExtras);\n    return tdl;\n  }\n","new_comment_raw":"@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.","old_comment_raw":"@param includeExtras If true, the list of typed dependencies returned may include \"extras\", such as controlled subject links.","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":30},{"new_code_raw":"protected QualifiedName determineGeneratorTableName(Properties params, JdbcEnvironment jdbcEnvironment) { final String tableName = ConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ); if ( tableName.contains( \".\" ) ) { return QualifiedNameParser.INSTANCE.parse( tableName ); } else { \/\/ todo : need to incorporate implicit catalog and schema names final Identifier catalog = jdbcEnvironment.getIdentifierHelper().toIdentifier( ConfigurationHelper.getString( CATALOG, params ) ); final Identifier schema = jdbcEnvironment.getIdentifierHelper().toIdentifier( ConfigurationHelper.getString( SCHEMA, params ) ); return new QualifiedNameParser.NameParts( catalog, schema, jdbcEnvironment.getIdentifierHelper().toIdentifier( tableName ) ); } }","old_code_raw":"\tprotected QualifiedName determineGeneratorTableName(Properties params, Dialect dialect) {\n\t\tfinal ObjectNameNormalizer normalizer = (ObjectNameNormalizer) params.get( IDENTIFIER_NORMALIZER );\n\n\t\treturn QualifiedNameParser.INSTANCE.parse(\n\t\t\t\tConfigurationHelper.getString( TABLE_PARAM, params, DEF_TABLE ),\n\t\t\t\tnormalizer.normalizeIdentifierQuoting( params.getProperty( CATALOG ) ),\n\t\t\t\tnormalizer.normalizeIdentifierQuoting( params.getProperty( SCHEMA ) )\n\t\t);\n\t}\n","new_comment_raw":"@param jdbcEnvironment The JDBC environment","old_comment_raw":"@param dialect The dialect in effect","label":1,"pre_label":0,"AST_level":10,"line_counts":22,"new_code_token_num":114},{"new_code_raw":"public Single<Client> rxCall123testSpecialTags(Client body) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.call123testSpecialTags(body, fut); })); }","old_code_raw":"    public Single<Client> rxCall123testSpecialTags(Client client) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.call123testSpecialTags(client, fut);\n        }));\n    }\n","new_comment_raw":"@param body client model (required)","old_comment_raw":"@param client client model (required)","label":1,"pre_label":0,"AST_level":10,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"public String getInitParameter(String key, String defaultValue) { String s = getInitParameter(key); if (s == null) { return defaultValue; } return s; }","old_code_raw":"    public String getInitParameter(String closedAtmosphereThinkTime, String defaultValue) {\n        String s = getInitParameter(closedAtmosphereThinkTime);\n        if (s == null) {\n            return defaultValue;\n        }\n        return s;\n    }\n","new_comment_raw":"@param key","old_comment_raw":"@param closedAtmosphereThinkTime","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":32},{"new_code_raw":"public StringBuilder toStringBuilder(StringBuilder sb, boolean printOnlyLabelValue) { if (isLeaf()) { if (label() != null) { if(printOnlyLabelValue) { sb.append(label().value()); } else { sb.append(label()); } } return sb; } else { sb.append('('); if (label() != null) { if (printOnlyLabelValue) { if (value() != null) { sb.append(label().value()); } \/\/ don't print a null, just nothing! } else { sb.append(label()); } } Tree[] kids = children(); if (kids != null) { for (Tree kid : kids) { sb.append(' '); kid.toStringBuilder(sb, printOnlyLabelValue); } } return sb.append(')'); } }","old_code_raw":"  public StringBuilder toStringBuilder(StringBuilder sb, Function<Label,String> labelFormatter) {\n    if (isLeaf()) {\n      if (label() != null) {\n        sb.append(labelFormatter.apply(label()));\n      }\n      return sb;\n    } else {\n      sb.append('(');\n      if (label() != null) {\n        sb.append(labelFormatter.apply(label()));\n      }\n      Tree[] kids = children();\n      if (kids != null) {\n        for (Tree kid : kids) {\n          sb.append(' ');\n          kid.toStringBuilder(sb, labelFormatter);\n        }\n      }\n      return sb.append(')');\n    }\n  }\n","new_comment_raw":"@param printOnlyLabelValue If true, print only the value() of each node's label","old_comment_raw":"@param labelFormatter Formatting routine for how to print a Label","label":1,"pre_label":0,"AST_level":14,"line_counts":33,"new_code_token_num":181},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); \/\/ Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); \/\/ Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n","new_comment_raw":"@param info information about the widget","old_comment_raw":"@param info information about the widget","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":156},{"new_code_raw":"public static Criterion between(String propertyName, Object low, Object high) { return new BetweenExpression( propertyName, low, high ); }","old_code_raw":"\tpublic static Criterion between(String propertyName, Object lo, Object hi) {\n\t\treturn new BetweenExpression( propertyName, lo, hi );\n\t}\n","new_comment_raw":"@param high The high value","old_comment_raw":"@param hi The high value","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public static RemoteProxy getNewBasicRemoteProxy(String browser, String url, Registry registry) { RegistrationRequest req = RegistrationRequest.build(\"-role\", \"webdriver\"); req.getCapabilities().clear(); DesiredCapabilities capability = new DesiredCapabilities(); capability.setBrowserName(browser); req.addDesiredCapabilitiy(capability); Map<String, Object> config = new HashMap<String, Object>(); config.put(\"url\", url); req.setConfiguration(config); return new RemoteProxy(req, registry); }","old_code_raw":"  public static RemoteProxy getNewBasicRemoteProxy(Map<String, Object> cap, String url, Registry registry) {\n    RegistrationRequest req = RegistrationRequest.build(\"-role\", \"webdriver\");\n    req.getCapabilities().clear();\n    req.addDesiredCapabilitiy(cap);\n    req.getConfiguration().put(RegistrationRequest.REMOTE_URL, url);\n    return new RemoteProxy(req, registry);\n\n  }\n","new_comment_raw":"@param registry","old_comment_raw":"@param registry","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":96},{"new_code_raw":"private URL determineSuiteUrl(String startURL, String suiteURL) throws IOException { if (suiteURL.startsWith(\"https:\/\/\") || suiteURL.startsWith(\"http:\/\/\")) { return verifySuiteUrl(new URL(suiteURL)); } \/\/ Is the suiteURL a file? Path path = Paths.get(suiteURL); if (Files.exists(path)) { \/\/ Not all drivers can read files from the disk, so we need to host the suite somewhere. try (SocketLock lock = new SocketLock()) { server = new Server(); HttpConfiguration httpConfig = new HttpConfiguration(); ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig)); int port = PortProber.findFreePort(); http.setPort(port); http.setIdleTimeout(500000); server.setConnectors(new Connector[]{http}); ResourceHandler handler = new ResourceHandler(); handler.setDirectoriesListed(true); handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"}); handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath())); ContextHandler context = new ContextHandler(\"\/tests\"); context.setHandler(handler); server.setHandler(context); server.start(); PortProber.waitForPortUp(port, 15, SECONDS); URL serverUrl = server.getURI().toURL(); return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(), \"\/tests\/\"); } catch (Exception e) { throw new IOException(e); } } \/\/ Well then, it must be a URL relative to whatever the browserUrl. Probe and find out. URL browser = new URL(startURL); return verifySuiteUrl(new URL(browser, suiteURL)); }","old_code_raw":"  private URL determineSuiteUrl(String browserUrl, String suiteURL) throws IOException {\n    if (suiteURL.startsWith(\"https:\/\/\") || suiteURL.startsWith(\"http:\/\/\")) {\n      return verifySuiteUrl(new URL(suiteURL));\n    }\n\n    \/\/ Is the suiteURL a file?\n    Path path = Paths.get(suiteURL);\n    if (Files.exists(path)) {\n      \/\/ Not all drivers can read files from the disk, so we need to host the suite somewhere.\n      try (SocketLock lock = new SocketLock()) {\n        server = new Server();\n        HttpConfiguration httpConfig = new HttpConfiguration();\n\n        ServerConnector http = new ServerConnector(server, new HttpConnectionFactory(httpConfig));\n        int port = PortProber.findFreePort();\n        http.setPort(port);\n        http.setIdleTimeout(500000);\n        server.setConnectors(new Connector[]{http});\n\n        ResourceHandler handler = new ResourceHandler();\n        handler.setDirectoriesListed(true);\n        handler.setWelcomeFiles(new String[]{path.getFileName().toString(), \"index.html\"});\n        handler.setBaseResource(new PathResource(path.toFile().getParentFile().toPath().toRealPath()));\n\n        ContextHandler context = new ContextHandler(\"\/tests\");\n        context.setHandler(handler);\n\n        server.setHandler(context);\n        server.start();\n\n        PortProber.waitForPortUp(port, 15, SECONDS);\n\n        URL serverUrl = server.getURI().toURL();\n        return new URL(serverUrl.getProtocol(), serverUrl.getHost(), serverUrl.getPort(),\n                       \"\/tests\/\");\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    \/\/ Well then, it must be a URL relative to whatever the browserUrl. Probe and find out.\n    URL browser = new URL(browserUrl);\n    return verifySuiteUrl(new URL(browser, suiteURL));\n  }\n","new_comment_raw":"@param outputFile - The file to which we'll output the HTML results","old_comment_raw":"@param outputFile - The file to which we'll output the HTML results","label":0,"pre_label":1,"AST_level":11,"line_counts":45,"new_code_token_num":351},{"new_code_raw":"public boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) { boolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible); return found; }","old_code_raw":"\tpublic boolean searchButton(String text, int minimumNumberOfMatches, boolean visible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, visible);\n\t\treturn found;\n\t}\n","new_comment_raw":"@param minimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found","old_comment_raw":"@param minimumNumberOfMatches the minimum number of matches expected to be found. 0 matches means that one or more matches are expected to be found","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams, collectionQueryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) { contentType = \"application\/json\"; } RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = serialize(body, contentType); } \/\/ Associate callback with request (if not null) so interceptor can \/\/ access it when creating ProgressResponseBody reqBuilder.tag(callback); Request request = null; if (callback != null && reqBody != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return request; }","old_code_raw":"    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        \/\/ ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application\/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart\/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                \/\/ allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                \/\/ use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        Request request = null;\n\n        if(progressRequestListener != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n","new_comment_raw":"@param path The sub-path of the HTTP URL","old_comment_raw":"@param path The sub-path of the HTTP URL","label":0,"pre_label":1,"AST_level":14,"line_counts":48,"new_code_token_num":350},{"new_code_raw":"public ArrayList<View> getAllViews(boolean onlySufficientlyVisible) { Activity activity = activityUtils.getCurrentActivity(false); final View [] views = getWindowDecorViews(); final ArrayList<View> allViews = new ArrayList<View>(); final View [] nonDecorViews = getNonDecorViews(views); if(views !=null && views.length > 0) { if(!activity.hasWindowFocus()){ for(View view : views){ if(!activity.getWindow().getDecorView().equals(view)){ try{ addChildren(allViews,(ViewGroup) view, onlySufficientlyVisible); } catch (Exception ignored) {} } } } else{ for(View view : nonDecorViews){ try{ addChildren(allViews,(ViewGroup) view, onlySufficientlyVisible); } catch (Exception ignored) {} } try{ addChildren(allViews,(ViewGroup) getRecentDecorView(views), onlySufficientlyVisible); } catch (Exception ignored) {} } } return allViews; }","old_code_raw":"\tpublic ArrayList<View> getAllViews(boolean onlyFullyVisible)\n\t{\n\t\tActivity activity = activityUtils.getCurrentActivity(false);\n\t\tfinal View [] views = getWindowDecorViews();\n\t\tfinal ArrayList<View> allViews = new ArrayList<View>();\n\t\tfinal View [] nonDecorViews = getNonDecorViews(views);\n\t\tif(views !=null && views.length > 0)\n\t\t{\n\t\t\tif(!activity.hasWindowFocus()){\n\t\t\t\tfor(View view : views){\n\t\t\t\t\tif(!activity.getWindow().getDecorView().equals(view)){\n\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\taddChildren(allViews,(ViewGroup) view, onlyFullyVisible);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ignored) {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(View view : nonDecorViews){\n\t\t\t\t\ttry{\n\t\t\t\t\t\taddChildren(allViews,(ViewGroup) view, onlyFullyVisible);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ignored) {}\n\t\t\t\t}\t\n\t\t\t\ttry{\n\t\t\t\t\taddChildren(allViews,(ViewGroup) getRecentDecorView(views), onlyFullyVisible);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ignored) {}\n\t\t\t}\n\t\t}\n\t\treturn allViews;\n\t}\n","new_comment_raw":"@param onlySufficientlyVisible if only sufficiently visible views should be returned","old_comment_raw":"@param onlyFullyVisible if only fully visible views should be returned","label":1,"pre_label":0,"AST_level":15,"line_counts":34,"new_code_token_num":180},{"new_code_raw":"public CloseableIterator<Tuple> iterate(Expression<?>... args) { return iterate(queryMixin.createProjection(args)); }","old_code_raw":"    public CloseableIterator<T> iterate() {\n        try {\n            Expression<T> projection = (Expression<T>)queryMixin.getMetadata().getProjection();\n            return new IteratorAdapter<T>(queryEngine.list(getMetadata(), iterables, projection).iterator());\n        } finally {\n            reset();\n        }\n    }\n","new_comment_raw":"@param target","old_comment_raw":"@param target","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public void createUsersWithListInput (List<User> user) throws ApiException { Object localVarPostBody = user; \/\/ verify the required parameter 'user' is set if (user == null) { throw new ApiException(400, \"Missing the required parameter 'user' when calling createUsersWithListInput\"); } \/\/ create path and map variables String localVarPath = \"\/user\/createWithList\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); \/\/ form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\"; if (localVarContentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { \/\/ normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public void  createUsersWithListInput (List<User> body) throws ApiException {\n    Object localVarPostBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling createUsersWithListInput\");\n    }\n\n    \/\/ create path and map variables\n    String localVarPath = \"\/user\/createWithList\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\";\n\n    if (localVarContentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      \/\/ normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param user List of user object","old_comment_raw":"@param body List of user object","label":1,"pre_label":0,"AST_level":8,"line_counts":47,"new_code_token_num":250},{"new_code_raw":"static public Mode parseMode(CharSequence code) { \/\/ See if we can find any function in the global scope if (findInCurrentScope(FUNCTION_DECL, code) != null) { return Mode.ACTIVE; } \/\/ See if we can find any public class extending PApplet if (findInCurrentScope(PUBLIC_CLASS, code) != null) { return Mode.JAVA; } return Mode.STATIC; }","old_code_raw":"  static public Mode parseMode(String code) {\n\n    \/\/ See if we can find any function in the global scope\n    if (findInCurrentScope(FUNCTION_DECL, code) != null) {\n      return Mode.ACTIVE;\n    }\n\n    \/\/ See if we can find any public class extending PApplet\n    if (findInCurrentScope(PUBLIC_CLASS, code) != null) {\n      return Mode.JAVA;\n    }\n\n    return Mode.STATIC;\n  }\n","new_comment_raw":"@param code code without comments","old_comment_raw":"@param code code without comments","label":0,"pre_label":1,"AST_level":6,"line_counts":15,"new_code_token_num":73},{"new_code_raw":"public static String getClassName(String memberID, boolean isClassMember) { int pos = memberID.indexOf(ALT_MEMBER_SEPARATOR); \/\/ uses alternative separator, easy if (pos != -1) return memberID.substring(0, pos); pos = memberID.indexOf('('); if ( pos != -1 ) { \/\/ has a descriptor, is a method ID, strip last member part pos = memberID.lastIndexOf('.', pos); return pos != -1 ? memberID.substring(0, pos) : \"\"; } if (isClassMember) { \/\/ field or class name, cannot decide, assume it is a field pos = memberID.lastIndexOf('.'); return pos != -1 ? memberID.substring(0, pos) : \"\"; } else { \/\/ assume it is a class name return memberID; } }","old_code_raw":"    public static String getClassName(String signature, boolean isClassMember) {\n        int pos = signature.indexOf(ALT_MEMBER_SEPARATOR);\n        \/\/ uses alternative separator, easy\n        if (pos != -1) return signature.substring(0, pos);\n\n        pos = signature.indexOf('(');\n        if ( pos != -1 ) {\n            \/\/ has a descriptor, is a method signature, strip last member part\n            pos = signature.lastIndexOf('.', pos);\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        }\n\n        if (isClassMember) {\n            \/\/ field or class name, cannot decide, assume it is a field\n            pos = signature.lastIndexOf('.');\n            return pos != -1 ? signature.substring(0, pos) : \"\";\n        } else {\n            \/\/ assume it is a class name\n            return signature;\n        }\n    }\n","new_comment_raw":"@param memberID the member ID to parse.","old_comment_raw":"@param signature the signature to parse.","label":1,"pre_label":0,"AST_level":8,"line_counts":23,"new_code_token_num":164},{"new_code_raw":"public boolean checkAlreadyExist(AccountDatabase.AccountName s) { \/\/ Query in the realm database RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class); \/\/ Checking if string equals to is exist or not query.equalTo(\"name\", s.toString()); RealmResults<AccountDatabase> result1 = query.findAll(); \/\/ Here checking if count of that values is greater than zero return (result1.size() > 0) ? true : false; }","old_code_raw":"    public boolean checkAlreadyExist(String s) {\n\n        \/\/ Query in the realm database\n        RealmQuery<AccountDatabase> query = realm.where(AccountDatabase.class);\n\n        \/\/ Checking if string equals to is exist or not\n        query.equalTo(\"name\", s);\n        RealmResults<AccountDatabase> result1 = query.findAll();\n\n        \/\/ Here checking if count of that values is greater than zero\n        return (result1.size() > 0) ? true : false;\n    }\n","new_comment_raw":"@param s Name of the account from accountList e.g. Twitter","old_comment_raw":"@param s Name of the account from accountList e.g. Twitter","label":0,"pre_label":1,"AST_level":7,"line_counts":13,"new_code_token_num":85},{"new_code_raw":"private String getArrayTypeDeclaration(ArraySchema arr) { \/\/ TODO: collection type here should be fully qualified namespace to avoid model conflicts \/\/ This supports arrays of arrays. String arrayType = typeMapping.get(\"array\"); StringBuilder instantiationType = new StringBuilder(arrayType); Schema items = arr.getItems(); String nestedType = getTypeDeclaration(items); \/\/ TODO: We may want to differentiate here between generics and primitive arrays. instantiationType.append(\"<\").append(nestedType).append(\">\"); return instantiationType.toString(); }","old_code_raw":"    private String getArrayTypeDeclaration(ArrayProperty arr) {\n        \/\/ TODO: collection type here should be fully qualified namespace to avoid model conflicts\n        \/\/ This supports arrays of arrays.\n        String arrayType = typeMapping.get(\"array\");\n        StringBuilder instantiationType = new StringBuilder(arrayType);\n        Property items = arr.getItems();\n        String nestedType = getTypeDeclaration(items);\n        \/\/ TODO: We may want to differentiate here between generics and primitive arrays.\n        instantiationType.append(\"<\").append(nestedType).append(\">\");\n        return instantiationType.toString();\n    }\n","new_comment_raw":"@param arr Array schema","old_comment_raw":"@param arr","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":101},{"new_code_raw":"public boolean remove(final BaseDownloadTask willRemoveDownload, final int removeByStatus) { boolean succeed; synchronized (list) { succeed = list.remove(willRemoveDownload); } if (succeed) { \/\/ \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af switch (removeByStatus) { case FileDownloadStatus.warn: willRemoveDownload.getDriver().notifyWarn(); break; case FileDownloadStatus.error: willRemoveDownload.getDriver().notifyError(); break; case FileDownloadStatus.paused: willRemoveDownload.getDriver().notifyPaused(); break; case FileDownloadStatus.completed: Throwable ex = null; try{ willRemoveDownload.getDriver().notifyBlockComplete(); }catch (Throwable e){ ex = e; } if (ex != null) { willRemoveDownload.setStatus(FileDownloadStatus.error); willRemoveDownload.setEx(ex); willRemoveDownload.getDriver().notifyError(); } else { willRemoveDownload.getDriver().notifyCompleted(); } break; } } else { FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload); } return succeed; }","old_code_raw":"    public boolean remove(final BaseFileDownloadInternal willRemoveDownload, final int removeByStatus) {\n        boolean succeed;\n        synchronized (list) {\n            succeed = list.remove(willRemoveDownload);\n        }\n\n        if (succeed) {\n            \/\/ \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af\n            switch (removeByStatus) {\n                case FileDownloadStatus.warn:\n                    willRemoveDownload.getDriver().notifyWarn();\n                    break;\n                case FileDownloadStatus.error:\n                    willRemoveDownload.getDriver().notifyError();\n                    break;\n                case FileDownloadStatus.paused:\n                    willRemoveDownload.getDriver().notifyPaused();\n                    break;\n                case FileDownloadStatus.completed:\n                    Throwable ex = null;\n                    try{\n                        willRemoveDownload.getDriver().notifyBlockComplete();\n                    }catch (Throwable e){\n                        ex = e;\n                    }\n\n                    if (ex != null) {\n                        willRemoveDownload.setStatus(FileDownloadStatus.error);\n                        willRemoveDownload.setEx(ex);\n                        willRemoveDownload.getDriver().notifyError();\n                    } else {\n                        willRemoveDownload.getDriver().notifyCompleted();\n                    }\n                    break;\n            }\n\n        } else {\n            FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload);\n        }\n\n        return succeed;\n    }\n","new_comment_raw":"@param willRemoveDownload","old_comment_raw":"@param willRemoveDownload","label":0,"pre_label":1,"AST_level":11,"line_counts":43,"new_code_token_num":185},{"new_code_raw":"public int compareTo(ReadablePartial other) { if (this == other) { return 0; } if (size() != other.size()) { throw new ClassCastException(\"ReadablePartial objects must have matching field types\"); } for (int i = 0, isize = size(); i < isize; i++) { if (getFieldType(i) != other.getFieldType(i)) { throw new ClassCastException(\"ReadablePartial objects must have matching field types\"); } } \/\/ fields are ordered largest first for (int i = 0, isize = size(); i < isize; i++) { if (getValue(i) > other.getValue(i)) { return 1; } if (getValue(i) < other.getValue(i)) { return -1; } } return 0; }","old_code_raw":"    public int compareTo(Object partial) {\n        if (this == partial) {\n            return 0;\n        }\n        ReadablePartial other = (ReadablePartial) partial;\n        if (size() != other.size()) {\n            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i) != other.getFieldType(i)) {\n                throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n            }\n        }\n        \/\/ fields are ordered largest first\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getValue(i) > other.getValue(i)) {\n                return 1;\n            }\n            if (getValue(i) < other.getValue(i)) {\n                return -1;\n            }\n        }\n        return 0;\n    }\n","new_comment_raw":"@param other an object to check against","old_comment_raw":"@param partial an object to check against","label":1,"pre_label":0,"AST_level":9,"line_counts":24,"new_code_token_num":162},{"new_code_raw":"private static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SharedSessionContractImplementor session) { final Object optionalObject = queryParameters.getOptionalObject(); final Serializable optionalId = queryParameters.getOptionalId(); final String optionalEntityName = queryParameters.getOptionalEntityName(); if ( optionalObject != null && optionalEntityName != null ) { return session.generateEntityKey( optionalId, session.getEntityPersister( optionalEntityName, optionalObject ) ); } else { return null; } }","old_code_raw":"\tprivate static EntityKey getOptionalObjectKey(QueryParameters queryParameters, SessionImplementor session) {\n\t\tfinal Object optionalObject = queryParameters.getOptionalObject();\n\t\tfinal Serializable optionalId = queryParameters.getOptionalId();\n\t\tfinal String optionalEntityName = queryParameters.getOptionalEntityName();\n\n\t\tif ( optionalObject != null && optionalEntityName != null ) {\n\t\t\treturn session.generateEntityKey(\n\t\t\t\t\toptionalId, session.getEntityPersister(\n\t\t\t\t\t\t\toptionalEntityName,\n\t\t\t\t\t\t\toptionalObject\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\n\t}\n","new_comment_raw":"@param queryParameters The query parameters specified by the user.","old_comment_raw":"@param queryParameters The query parameters specified by the user.","label":0,"pre_label":1,"AST_level":8,"line_counts":19,"new_code_token_num":71},{"new_code_raw":"public Object getCollection(Serializable key, SharedSessionContractImplementor session, Object owner) { CollectionPersister persister = getPersister( session ); final PersistenceContext persistenceContext = session.getPersistenceContext(); final EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode(); \/\/ check if collection is currently being loaded PersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key ); if ( collection == null ) { \/\/ check if it is already completely loaded, but unowned collection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) ); if ( collection == null ) { collection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) ); if ( collection == null ) { \/\/ create a new collection wrapper, to be initialized later collection = instantiate( session, persister, key ); collection.setOwner( owner ); persistenceContext.addUninitializedCollection( persister, collection, key ); \/\/ some collections are not lazy: if ( initializeImmediately() ) { session.initializeCollection( collection, false ); } else if ( !persister.isLazy() ) { persistenceContext.addNonLazyCollection( collection ); } if ( hasHolder() ) { session.getPersistenceContext().addCollectionHolder( collection ); } } } if ( LOG.isTraceEnabled() ) { LOG.tracef( \"Created collection wrapper: %s\", MessageHelper.collectionInfoString( persister, collection, key, session ) ); } } collection.setOwner(owner); return collection.getValue(); }","old_code_raw":"\tpublic Object getCollection(Serializable key, SessionImplementor session, Object owner) {\n\n\t\tCollectionPersister persister = getPersister( session );\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\tfinal EntityMode entityMode = persister.getOwnerEntityPersister().getEntityMode();\n\n\t\t\/\/ check if collection is currently being loaded\n\t\tPersistentCollection collection = persistenceContext.getLoadContexts().locateLoadingCollection( persister, key );\n\t\t\n\t\tif ( collection == null ) {\n\t\t\t\n\t\t\t\/\/ check if it is already completely loaded, but unowned\n\t\t\tcollection = persistenceContext.useUnownedCollection( new CollectionKey(persister, key, entityMode) );\n\t\t\t\n\t\t\tif ( collection == null ) {\n\n\t\t\t\tcollection = persistenceContext.getCollection( new CollectionKey(persister, key, entityMode) );\n\n\t\t\t\tif ( collection == null ) {\n\t\t\t\t\t\/\/ create a new collection wrapper, to be initialized later\n\t\t\t\t\tcollection = instantiate( session, persister, key );\n\n\t\t\t\t\tcollection.setOwner( owner );\n\n\t\t\t\t\tpersistenceContext.addUninitializedCollection( persister, collection, key );\n\n\t\t\t\t\t\/\/ some collections are not lazy:\n\t\t\t\t\tif ( initializeImmediately() ) {\n\t\t\t\t\t\tsession.initializeCollection( collection, false );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( !persister.isLazy() ) {\n\t\t\t\t\t\tpersistenceContext.addNonLazyCollection( collection );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasHolder() ) {\n\t\t\t\t\t\tsession.getPersistenceContext().addCollectionHolder( collection );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef( \"Created collection wrapper: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, collection,\n\t\t\t\t\t\t\t\tkey, session ) );\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcollection.setOwner(owner);\n\n\t\treturn collection.getValue();\n\t}\n","new_comment_raw":"@param session The session from which the request is originating.","old_comment_raw":"@param session The session from which the request is originating.","label":0,"pre_label":1,"AST_level":14,"line_counts":54,"new_code_token_num":268},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); if (DEBUG) { System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(\"target\")) continue; System.err.println(\" node \" + nodeName + \": \" + m.getNode(nodeName)); } } } } return nodeList; }","old_code_raw":"  public Collection<Tree> getRelatedNodes(Tree t, Tree root, HeadFinder headFinder) {\n    Set<Tree> nodeList = new ArraySet<Tree>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@param t Target for finding governors of t related by this GR","old_comment_raw":"@param t Target for finding dependents of t related by this GR","label":1,"pre_label":0,"AST_level":18,"line_counts":22,"new_code_token_num":200},{"new_code_raw":"public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, ColumnNameFilter filter, ColumnMappers mappers) { if (schemaPrefix == null) { schemaPrefix = \"\"; } \/\/ Build the schemas ... final TableId tableId = table.id(); final String tableIdStr = tableSchemaName(tableId); final String schemaNamePrefix = schemaPrefix + tableIdStr; LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix); SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\")); SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\")); AtomicBoolean hasPrimaryKey = new AtomicBoolean(false); table.columns().forEach(column -> { if (table.isPrimaryKeyColumn(column.name())) { \/\/ The column is part of the primary key, so ALWAYS add it to the PK schema ... addField(keySchemaBuilder, column, null); hasPrimaryKey.set(true); } if (filter == null || filter.matches(tableId.catalog(), tableId.schema(), tableId.table(), column.name())) { \/\/ Add the column to the value schema only if the column has not been filtered ... ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column); addField(valSchemaBuilder, column, mapper); } }); Schema valSchema = valSchemaBuilder.optional().build(); Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null; if (LOGGER.isDebugEnabled()) { LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema)); LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema)); } Envelope envelope = Envelope.defineSchema() .withName(schemaNameAdjuster.adjust(envelopSchemaName)) .withRecord(valSchema) .withSource(sourceInfoSchema) .build(); \/\/ Create the generators ... Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns()); Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers); \/\/ And the table schema ... return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator); }","old_code_raw":"    public TableSchema create(String schemaPrefix, String envelopSchemaName, Table table, Predicate<ColumnId> filter, ColumnMappers mappers) {\n        if (schemaPrefix == null) {\n            schemaPrefix = \"\";\n        }\n        \/\/ Build the schemas ...\n        final TableId tableId = table.id();\n        final String tableIdStr = tableSchemaName(tableId);\n        final String schemaNamePrefix = schemaPrefix + tableIdStr;\n        LOGGER.debug(\"Mapping table '{}' to schemas under '{}'\", tableId, schemaNamePrefix);\n        SchemaBuilder valSchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Value\"));\n        SchemaBuilder keySchemaBuilder = SchemaBuilder.struct().name(schemaNameAdjuster.adjust(schemaNamePrefix + \".Key\"));\n        AtomicBoolean hasPrimaryKey = new AtomicBoolean(false);\n        table.columns().forEach(column -> {\n            if (table.isPrimaryKeyColumn(column.name())) {\n                \/\/ The column is part of the primary key, so ALWAYS add it to the PK schema ...\n                addField(keySchemaBuilder, column, null);\n                hasPrimaryKey.set(true);\n            }\n            if (filter == null || filter.test(new ColumnId(tableId, column.name()))) {\n                \/\/ Add the column to the value schema only if the column has not been filtered ...\n                ColumnMapper mapper = mappers == null ? null : mappers.mapperFor(tableId, column);\n                addField(valSchemaBuilder, column, mapper);\n            }\n        });\n        Schema valSchema = valSchemaBuilder.optional().build();\n        Schema keySchema = hasPrimaryKey.get() ? keySchemaBuilder.build() : null;\n\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Mapped primary key for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(keySchema));\n            LOGGER.debug(\"Mapped columns for table '{}' to schema: {}\", tableId, SchemaUtil.asDetailedString(valSchema));\n        }\n\n        Envelope envelope = Envelope.defineSchema()\n                .withName(schemaNameAdjuster.adjust(envelopSchemaName))\n                .withRecord(valSchema)\n                .withSource(sourceInfoSchema)\n                .build();\n\n\n        \/\/ Create the generators ...\n        Function<Object[], Object> keyGenerator = createKeyGenerator(keySchema, tableId, table.primaryKeyColumns());\n        Function<Object[], Struct> valueGenerator = createValueGenerator(valSchema, tableId, table.columns(), filter, mappers);\n\n        \/\/ And the table schema ...\n        return new TableSchema(tableId, keySchema, keyGenerator, envelope, valSchema, valueGenerator);\n    }\n","new_comment_raw":"@param table the table definition; may not be null","old_comment_raw":"@param table the table definition; may not be null","label":0,"pre_label":1,"AST_level":13,"line_counts":48,"new_code_token_num":448},{"new_code_raw":"public boolean parseMoreData(final EncodedImage encodedImage) { if (mParserState == NOT_A_JPEG) { return false; } final int dataBufferSize = encodedImage.getSize(); \/\/ Is there any new data to parse? \/\/ mBytesParsed might be greater than size of dataBuffer - that happens when \/\/ we skip more data than is available to read inside doParseMoreData method if (dataBufferSize <= mBytesParsed) { return false; } final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream( encodedImage.getInputStream(), mByteArrayPool.get(BUFFER_SIZE), mByteArrayPool); try { StreamUtil.skip(bufferedDataStream, mBytesParsed); return doParseMoreData(bufferedDataStream); } catch (IOException ioe) { \/\/ Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions Throwables.propagate(ioe); return false; } finally { Closeables.closeQuietly(bufferedDataStream); } }","old_code_raw":"  public boolean parseMoreData(final CloseableReference<PooledByteBuffer> dataBufferRef) {\n    if (mParserState == NOT_A_JPEG) {\n      return false;\n    }\n\n    final PooledByteBuffer dataBuffer = dataBufferRef.get();\n    final int dataBufferSize = dataBuffer.size();\n\n    \/\/ Is there any new data to parse?\n    \/\/ mBytesParsed might be greater than size of dataBuffer - that happens when\n    \/\/ we skip more data than is available to read inside doParseMoreData method\n    if (dataBufferSize <= mBytesParsed) {\n      return false;\n    }\n\n    final InputStream bufferedDataStream = new PooledByteArrayBufferedInputStream(\n        new PooledByteBufferInputStream(dataBuffer),\n        mByteArrayPool.get(BUFFER_SIZE),\n        mByteArrayPool);\n    try {\n      StreamUtil.skip(bufferedDataStream, mBytesParsed);\n      return doParseMoreData(bufferedDataStream);\n    } catch (IOException ioe) {\n      \/\/ Does not happen - streams returned by PooledByteBuffers do not throw IOExceptions\n      Throwables.propagate(ioe);\n      return false;\n    } finally {\n      Closeables.closeQuietly(bufferedDataStream);\n    }\n  }\n","new_comment_raw":"@param encodedImage Next set of bytes received by the caller","old_comment_raw":"@param dataBufferRef Next set of bytes received by the caller","label":1,"pre_label":0,"AST_level":7,"line_counts":30,"new_code_token_num":152},{"new_code_raw":"public boolean applyAPSRequest(APSResult request, Callback callback) { PumpInterface pump = getActivePump(); request.rate = applyBasalConstraints(request.rate); PumpEnactResult result; if (!pump.isInitialized()) { log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpNotInitialized)).enacted(false).success(false)).run(); } return false; } if (pump.isSuspended()) { log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended)); if (callback != null) { callback.result(new PumpEnactResult().comment(MainApp.sResources.getString(R.string.pumpsuspended)).enacted(false).success(false)).run(); } return false; } if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: \" + request.toString()); if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - pump.getBaseBasalRate()) < pump.getPumpDescription().basalStep) { if (isTempBasalInProgress()) { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: cancelTempBasal()\"); getCommandQueue().cancelTempBasal(false, callback); return true; } else { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: Basal set correctly\"); if (callback != null) { callback.result(new PumpEnactResult().absolute(request.rate).duration(0).enacted(false).success(true).comment(\"Basal set correctly\")).run(); } return false; } } else if (isTempBasalInProgress() && getTempBasalRemainingMinutesFromHistory() > 5 && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < pump.getPumpDescription().basalStep) { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: Temp basal set correctly\"); if (callback != null) { callback.result(new PumpEnactResult().absolute(getTempBasalAbsoluteRateHistory()).duration(getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes()).enacted(false).success(true).comment(\"Temp basal set correctly\")).run(); } return false; } else { if (Config.logCongigBuilderActions) log.debug(\"applyAPSRequest: setTempBasalAbsolute()\"); getCommandQueue().tempBasalAbsolute(request.rate, request.duration, false, callback); return true; } }","old_code_raw":"    public PumpEnactResult applyAPSRequest(APSResult request) {\n        request.rate = applyBasalConstraints(request.rate);\n        PumpEnactResult result;\n\n        if (!isInitialized()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpNotInitialized);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpNotInitialized));\n            return result;\n        }\n\n        if (isSuspended()) {\n            result = new PumpEnactResult();\n            result.comment = MainApp.sResources.getString(R.string.pumpsuspended);\n            result.enacted = false;\n            result.success = false;\n            log.debug(\"applyAPSRequest: \" + MainApp.sResources.getString(R.string.pumpsuspended));\n            return result;\n        }\n\n        if (Config.logCongigBuilderActions)\n            log.debug(\"applyAPSRequest: \" + request.toString());\n        if ((request.rate == 0 && request.duration == 0) || Math.abs(request.rate - getBaseBasalRate()) < getPumpDescription().basalStep) {\n            if (isTempBasalInProgress()) {\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: cancelTempBasal()\");\n                result = cancelTempBasal(false);\n            } else {\n                result = new PumpEnactResult();\n                result.absolute = request.rate;\n                result.duration = 0;\n                result.enacted = false;\n                result.comment = \"Basal set correctly\";\n                result.success = true;\n                if (Config.logCongigBuilderActions)\n                    log.debug(\"applyAPSRequest: Basal set correctly\");\n            }\n        } else if (isTempBasalInProgress()\n                && getTempBasalRemainingMinutesFromHistory() > 5\n                && Math.abs(request.rate - getTempBasalAbsoluteRateHistory()) < getPumpDescription().basalStep) {\n            result = new PumpEnactResult();\n            result.absolute = getTempBasalAbsoluteRateHistory();\n            result.duration = getTempBasalFromHistory(System.currentTimeMillis()).getPlannedRemainingMinutes();\n            result.enacted = false;\n            result.comment = \"Temp basal set correctly\";\n            result.success = true;\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: Temp basal set correctly\");\n        } else {\n            if (Config.logCongigBuilderActions)\n                log.debug(\"applyAPSRequest: setTempBasalAbsolute()\");\n            result = setTempBasalAbsolute(request.rate, request.duration);\n        }\n        return result;\n    }\n","new_comment_raw":"@param request","old_comment_raw":"@param request","label":0,"pre_label":1,"AST_level":13,"line_counts":54,"new_code_token_num":474},{"new_code_raw":"public Order placeOrder (Order order) throws ApiException { Object localVarPostBody = order; \/\/ verify the required parameter 'order' is set if (order == null) { throw new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\"); } \/\/ create path and map variables String localVarPath = \"\/store\/order\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); \/\/ form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { \"application\/json\" }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\"; if (localVarContentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { \/\/ normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class); } else { return null; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public Order  placeOrder (Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n\n    \/\/ create path and map variables\n    String localVarPath = \"\/store\/order\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\";\n\n    if (localVarContentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      \/\/ normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param order order placed for purchasing the pet","old_comment_raw":"@param body order placed for purchasing the pet","label":1,"pre_label":0,"AST_level":10,"line_counts":47,"new_code_token_num":269},{"new_code_raw":"public static Properties getPartitionMetadata(final HivePartition partition, final HiveTableWithColumnCache table) { final Properties properties; restoreColumns(table, partition); properties = MetaStoreUtils.getPartitionMetadata(partition, table); \/\/ SerDe expects properties from Table, but above call doesn't add Table properties. \/\/ Include Table properties in final list in order to not to break SerDes that depend on \/\/ Table properties. For example AvroSerDe gets the schema from properties (passed as second argument) for (Map.Entry<String, String> entry : table.getParameters().entrySet()) { if (entry.getKey() != null && entry.getKey() != null) { properties.put(entry.getKey(), entry.getValue()); } } return properties; }","old_code_raw":"  public static Properties getPartitionMetadata(final Partition partition, final Table table) {\n    final Properties properties = MetaStoreUtils.getPartitionMetadata(partition, table);\n\n    \/\/ SerDe expects properties from Table, but above call doesn't add Table properties.\n    \/\/ Include Table properties in final list in order to not to break SerDes that depend on\n    \/\/ Table properties. For example AvroSerDe gets the schema from properties (passed as second argument)\n    for (Map.Entry<String, String> entry : table.getParameters().entrySet()) {\n      if (entry.getKey() != null && entry.getKey() != null) {\n        properties.put(entry.getKey(), entry.getValue());\n      }\n    }\n\n    return properties;\n  }\n","new_comment_raw":"@param partition the source of partition level parameters","old_comment_raw":"@param partition","label":1,"pre_label":0,"AST_level":9,"line_counts":17,"new_code_token_num":143},{"new_code_raw":"public Collection<String> getCandidateEIPs(String myInstanceId, String myZone) { if (myZone == null) { myZone = \"us-east-1d\"; } Collection<String> eipCandidates = (DiscoveryManager.getInstance() .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone) : getEIPsForZoneFromConfig(myZone)); if (eipCandidates == null || eipCandidates.size() == 0) { throw new RuntimeException( \"Could not get any elastic ips from the EIP pool for zone :\" + myZone); } return eipCandidates; }","old_code_raw":"    public Collection<String> getCandidateEIPs(String myInstanceId, String myZone, String myPublicIP) {\n\n        if (myZone == null) {\n            myZone = \"us-east-1d\";\n            myPublicIP = \"us-east-1d\";\n        }\n        Collection<String> eipCandidates = (DiscoveryManager.getInstance()\n                .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone)\n                        : getEIPsForZoneFromConfig(myZone));\n\n        if (eipCandidates == null || eipCandidates.size() == 0) {\n            throw new RuntimeException(\n                    \"Could not get any elastic ips from the EIP pool for zone :\"\n                    + myZone);\n        }\n       \n        return eipCandidates;\n    }\n","new_comment_raw":"@param myZone the zone where this instance is in","old_comment_raw":"@param myZone the zone where this instance is in","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":95},{"new_code_raw":"public Actions release(WebElement target) { if (isBuildingActions()) { action.addAction(new ButtonReleaseAction(jsonMouse, (Locatable) target)); return this; } return moveToElement(target).release(); }","old_code_raw":"  public Actions release(WebElement onElement) {\n    action.addAction(new ButtonReleaseAction(mouse, (Locatable) onElement));\n    return this;\n  }\n","new_comment_raw":"@param target Element to release the mouse button above.","old_comment_raw":"@param onElement Element to release the mouse button above.","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":44},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback); return httpClient.newCall(request); }","old_code_raw":"    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n","new_comment_raw":"@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"","old_comment_raw":"@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":75},{"new_code_raw":"public boolean searchButton(String regex, int matches) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForButton(regex, matches) && now < endTime) { now = System.currentTimeMillis(); } if(now < endTime) return true; else return false; }","old_code_raw":"\tpublic boolean searchButton(String search, int matches) {\n\t\t\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForButton(search, matches) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        if(now < endTime)\n        \treturn true;\n        else\n        \treturn false;\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":7,"line_counts":14,"new_code_token_num":60},{"new_code_raw":"View createShortcut(int layoutResId, ViewGroup parent, ShortcutInfo info) { TextView favorite = (TextView) mInflater.inflate(layoutResId, parent, false); favorite.setCompoundDrawablesWithIntrinsicBounds(null, new FastBitmapDrawable(info.getIcon(mIconCache)), null, null); favorite.setText(info.title); favorite.setTag(info); favorite.setOnClickListener(this); return favorite; }","old_code_raw":"    View createShortcut(int layoutResId, ViewGroup parent, ApplicationInfo info) {\n        TextView favorite = (TextView) mInflater.inflate(layoutResId, parent, false);\n\n        if (info.icon == null) {\n            info.icon = AppInfoCache.getIconDrawable(getPackageManager(), info);\n        }\n        if (!info.filtered) {\n            info.icon = Utilities.createIconThumbnail(info.icon, this);\n            info.filtered = true;\n        }\n\n        favorite.setCompoundDrawablesWithIntrinsicBounds(null, info.icon, null, null);\n        favorite.setText(info.title);\n        favorite.setTag(info);\n        favorite.setOnClickListener(this);\n\n        return favorite;\n    }\n","new_comment_raw":"@param info The data structure describing the shortcut.","old_comment_raw":"@param info The data structure describing the shortcut.","label":0,"pre_label":1,"AST_level":7,"line_counts":13,"new_code_token_num":71},{"new_code_raw":"public String invokeAPI(String path, String method, Set<QueryParam> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (QueryParam queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param body The request body object","old_comment_raw":"@param body The request body object","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"protected Object suspendAndGet(Object key, FlagAdapter opt, boolean suppressTimeout) throws CacheException { Transaction tx = suspend(); try { if (suppressTimeout) return cacheAdapter.getAllowingTimeout(key); else return cacheAdapter.get(key); } finally { resume(tx); } }","old_code_raw":"   protected Object suspendAndGet(Object key, Flag opt, boolean suppressTimeout) throws CacheException {\n       Transaction tx = suspend();\n       try {\n           if (suppressTimeout)\n               return CacheHelper.getAllowingTimeout(cache, key);\n           else\n               return CacheHelper.get(cache, key);\n       } finally {\n           resume(tx);\n       }\n   }\n","new_comment_raw":"@param key The key of the item to get","old_comment_raw":"@param key The key of the item to get","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"private boolean isKeepLock(String lockClient, String lockPath) { try { if (zkClient.checkExists().forPath(lockPath) != null) { byte[] data = zkClient.getData().forPath(lockPath); String lockServerName = new String(data, Charset.forName(\"UTF-8\")); return lockServerName.equalsIgnoreCase(lockClient); } } catch (Exception e) { logger.error(\"fail to get the lockClient for the path: \" + lockPath, e); } return false; }","old_code_raw":"\n    private boolean isKeepLock(String serverName, String lockPath) {\n        try {\n            if (zkClient.checkExists().forPath(lockPath) != null) {\n                byte[] data = zkClient.getData().forPath(lockPath);\n                String lockServerName = new String(data, Charset.forName(\"UTF-8\"));\n                return lockServerName.equalsIgnoreCase(serverName);\n            }\n        } catch (Exception e) {\n            logger.error(\"fail to get the serverName for the path: \" + lockPath, e);\n        }\n        return false;\n    }\n","new_comment_raw":"@param lockPath the zookeeper node path for the lock","old_comment_raw":"@param lockPath the zookeeper node path of segment","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":98},{"new_code_raw":"public int[] addInField(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { int current = values[fieldIndex]; int wrapped = FieldUtils.getWrappedValue (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant)); return set(instant, fieldIndex, values, wrapped); \/\/ adjusts smaller fields }","old_code_raw":"    public int[] addInField(PartialInstant instant, int fieldIndex, int[] values, int valueToAdd) {\n        int current = values[fieldIndex];\n        int wrapped = FieldUtils.getWrappedValue\n            (current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n        return set(instant, fieldIndex, values, wrapped);  \/\/ adjusts smaller fields\n    }\n","new_comment_raw":"@param fieldIndex the index of this field in the instant","old_comment_raw":"@param fieldIndex the index of this field in the instant","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":66},{"new_code_raw":"public Mono<Client> testClassname(Client body) throws RestClientException { Object postBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClassname\"); } String path = UriComponentsBuilder.fromPath(\"\/fake_classname_test\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"api_key_query\" }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<Client> testClassname(Client client) throws RestClientException {\n        Object postBody = client;\n        \n        \/\/ verify the required parameter 'client' is set\n        if (client == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling testClassname\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake_classname_test\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key_query\" };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param body client model","old_comment_raw":"@param client client model","label":1,"pre_label":0,"AST_level":8,"line_counts":29,"new_code_token_num":204},{"new_code_raw":"public ExecutionStepInfo changeTypeWithPreservedNonNull(GraphQLOutputType newType) { assertTrue(!GraphQLTypeUtil.isNonNull(newType), \"newType can't be non null\"); if (isNonNullType()) { return new ExecutionStepInfo(GraphQLNonNull.nonNull(newType), fieldDefinition, field, path, this.parent, arguments); } else { return new ExecutionStepInfo(newType, fieldDefinition, field, path, this.parent, arguments); } }","old_code_raw":"    public ExecutionStepInfo changeTypeWithPreservedNonNull(GraphQLType newType) {\n        assertTrue(!GraphQLTypeUtil.isNonNull(newType), \"newType can't be non null\");\n        if (isNonNullType()) {\n            return new ExecutionStepInfo(GraphQLNonNull.nonNull(newType), fieldDefinition, field, path, this.parent, arguments);\n        } else {\n            return new ExecutionStepInfo(newType, fieldDefinition, field, path, this.parent, arguments);\n        }\n    }\n","new_comment_raw":"@param newType the new type to be","old_comment_raw":"@param newType the new type to be","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":80},{"new_code_raw":"public String getAuthorizationUrl(OAuth1RequestToken requestToken) { return api.getAuthorizationUrl(requestToken); }","old_code_raw":"    public String getAuthorizationUrl(Token requestToken) {\n        return api.getAuthorizationUrl(requestToken);\n    }\n","new_comment_raw":"@param requestToken the request token you need to authorize","old_comment_raw":"@param requestToken the request token you need to authorize","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public Object readPayload(DataInput dataIn) throws IOException{ return dataIn.readUTF(); }","old_code_raw":"    public Object readPayload(DataInputStream dataIn) throws IOException{\n        return dataIn.readUTF();\n    }\n","new_comment_raw":"@param dataIn","old_comment_raw":"@param dataIn","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public Serializable generate(SharedSessionContractImplementor session, Object object) throws HibernateException { return optimizer.generate( databaseStructure.buildCallback( session ) ); }","old_code_raw":"\tpublic Serializable generate(SessionImplementor session, Object object) throws HibernateException {\n\t\treturn optimizer.generate( databaseStructure.buildCallback( session ) );\n\t}\n","new_comment_raw":"@param initialValue The initial value.","old_comment_raw":"@param initialValue The initial value.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public byte getStatus(final int id, final String path) { byte status; BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(id); if (task == null) { status = FileDownloadServiceProxy.getImpl().getStatus(id); } else { status = task.getOrigin().getStatus(); } if (path != null && status == FileDownloadStatus.INVALID_STATUS) { if (FileDownloadUtils.isFilenameConverted(FileDownloadHelper.getAppContext()) && new File(path).exists()) { status = FileDownloadStatus.completed; } } return status; }","old_code_raw":"    public byte getStatus(final int downloadId, final String path) {\n        byte status;\n        BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(downloadId);\n        if (task == null) {\n            status = FileDownloadServiceProxy.getImpl().getStatus(downloadId);\n        } else {\n            status = task.getOrigin().getStatus();\n        }\n\n        if (path != null && status == FileDownloadStatus.INVALID_STATUS) {\n            if (FileDownloadUtils.isFilenameConverted(FileDownloadHelper.getAppContext()) &&\n                    new File(path).exists()) {\n                status = FileDownloadStatus.completed;\n            }\n        }\n\n        return status;\n    }\n","new_comment_raw":"@param path The target file path.","old_comment_raw":"@param path Use to judge whether has already completed downloading.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":101},{"new_code_raw":"private boolean limitTranslation(Matrix transform, boolean shouldLimitX, boolean shouldLimitY) { if (!shouldLimitX && !shouldLimitY) { return false; } RectF b = mTempRect; b.set(mImageBounds); transform.mapRect(b); float offsetLeft = !shouldLimitX ? 0 : getOffset(b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX()); float offsetTop = !shouldLimitY ? 0 : getOffset(b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY()); if (offsetLeft != 0 || offsetTop != 0) { transform.postTranslate(offsetLeft, offsetTop); return true; } return false; }","old_code_raw":"  private boolean limitTranslation(Matrix transform, boolean limitX, boolean limitY) {\n    RectF bounds = mTempRect;\n    bounds.set(mImageBounds);\n    transform.mapRect(bounds);\n    float offsetLeft = limitX ?\n        getOffset(bounds.left, bounds.right, mViewBounds.left, mViewBounds.right) : 0;\n    float offsetTop = limitY ?\n        getOffset(bounds.top, bounds.bottom, mViewBounds.top, mViewBounds.bottom) : 0;\n    if (offsetLeft != 0 || offsetTop != 0) {\n      transform.postTranslate(offsetLeft, offsetTop);\n      return true;\n    }\n    return false;\n  }\n","new_comment_raw":"@param shouldLimitX whether to apply the limit on the x-axis","old_comment_raw":"@param limitX whether to apply the limit on the x-axis","label":1,"pre_label":0,"AST_level":7,"line_counts":18,"new_code_token_num":126},{"new_code_raw":"public ArrayList<TextView> clickInList(int line, int index) { return clicker.clickInList(line, index); }","old_code_raw":"\tpublic ArrayList<TextView> clickInList(int line, int listIndex) {\n\t\treturn clicker.clickInList(line, listIndex);\n\t}\n","new_comment_raw":"@param index the index of the list. 1 if two lists are available","old_comment_raw":"@param listIndex the index of the list. 1 if two lists are available","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public static String getConsoleIconPath(DesiredCapabilities cap, GridRegistry registry) { String name = consoleIconName(cap, registry); String path = \"org\/openqa\/grid\/images\/\"; InputStream in = Thread.currentThread().getContextClassLoader() .getResourceAsStream(path + name + \".png\"); if (in == null) { return null; } return \"\/grid\/resources\/\" + path + name + \".png\"; }","old_code_raw":"  public static String getConsoleIconPath(DesiredCapabilities cap, Registry registry) {\n    String name = consoleIconName(cap, registry);\n    String path = \"org\/openqa\/grid\/images\/\";\n    InputStream in =\n        Thread.currentThread().getContextClassLoader()\n            .getResourceAsStream(path + name + \".png\");\n    if (in == null) {\n      return null;\n    }\n    return \"\/grid\/resources\/\" + path + name + \".png\";\n  }\n","new_comment_raw":"@param cap - Capability","old_comment_raw":"@param cap - Capability","label":0,"pre_label":1,"AST_level":9,"line_counts":12,"new_code_token_num":82},{"new_code_raw":"public Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) { for ( JaxbRoot<XMLEntityMappings> root : mappings ) { root.getRoot().toString(); } return annotationIndex; }","old_code_raw":"\tpublic Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) {\n\t\tClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class );\n\t\tSet<InputStream> mappingStreams = new HashSet<InputStream>();\n\t\tfor ( String fileName : mappingFileNames ) {\n\n\t\t\tXMLEntityMappings entityMappings;\n\t\t\ttry {\n\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\tfileName, ORM2_MAPPING_XSD, XMLEntityMappings.class, classLoaderService\n\t\t\t\t).getRoot();\n\t\t\t}\n\t\t\tcatch ( JAXBException orm2Exception ) {\n\t\t\t\t\/\/ if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility\n\t\t\t\ttry {\n\t\t\t\t\tentityMappings = XmlHelper.unmarshallXml(\n\t\t\t\t\t\t\tfileName, ORM1_MAPPING_XSD, XMLEntityMappings.class, classLoaderService\n\t\t\t\t\t).getRoot();\n\t\t\t\t}\n\t\t\t\tcatch ( JAXBException orm1Exception ) {\n\t\t\t\t\tthrow new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tentityMappings.toString();\n\t\t}\n\n\t\treturn null;\n\t}\n","new_comment_raw":"@param mappings list of  XMLEntityMappings created from the specified orm xml files","old_comment_raw":"@param mappingFileNames the file names of the xml files to parse","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":35},{"new_code_raw":"private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) { \/\/ create two RexPrograms -- the bottom one representing a \/\/ concatenation of the project and the RHS of the semijoin and the \/\/ top one representing the semijoin condition RexBuilder rexBuilder = project.getCluster().getRexBuilder(); RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory(); RelNode rightChild = semiJoin.getRight(); \/\/ for the bottom RexProgram, the input is a concatenation of the \/\/ child of the project and the RHS of the semijoin RelDataType bottomInputRowType = Join.deriveJoinRowType( project.getInput().getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder bottomProgramBuilder = new RexProgramBuilder(bottomInputRowType, rexBuilder); \/\/ add the project expressions, then add input references for the RHS \/\/ of the semijoin for (Pair<RexNode, String> pair : project.getNamedProjects()) { bottomProgramBuilder.addProject(pair.left, pair.right); } int nLeftFields = project.getInput().getRowType().getFieldCount(); List<RelDataTypeField> rightFields = rightChild.getRowType().getFieldList(); int nRightFields = rightFields.size(); for (int i = 0; i < nRightFields; i++) { final RelDataTypeField field = rightFields.get(i); RexNode inputRef = rexBuilder.makeInputRef( field.getType(), i + nLeftFields); bottomProgramBuilder.addProject(inputRef, field.getName()); } RexProgram bottomProgram = bottomProgramBuilder.getProgram(); \/\/ input rowtype into the top program is the concatenation of the \/\/ project and the RHS of the semijoin RelDataType topInputRowType = Join.deriveJoinRowType( project.getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder topProgramBuilder = new RexProgramBuilder( topInputRowType, rexBuilder); topProgramBuilder.addIdentity(); topProgramBuilder.addCondition(semiJoin.getCondition()); RexProgram topProgram = topProgramBuilder.getProgram(); \/\/ merge the programs and expand out the local references to form \/\/ the new semijoin condition; it now references a concatenation of \/\/ the project's child and the RHS of the semijoin RexProgram mergedProgram = RexProgramBuilder.mergePrograms( topProgram, bottomProgram, rexBuilder); return mergedProgram.expandLocalRef( mergedProgram.getCondition()); }","old_code_raw":"  private RexNode adjustCondition(ProjectRel project, SemiJoinRel semiJoin) {\n    \/\/ create two RexPrograms -- the bottom one representing a\n    \/\/ concatenation of the project and the RHS of the semijoin and the\n    \/\/ top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    \/\/ for the bottom RexProgram, the input is a concatenation of the\n    \/\/ child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getChild().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    \/\/ add the project expressions, then add input references for the RHS\n    \/\/ of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getChild().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    \/\/ input rowtype into the top program is the concatenation of the\n    \/\/ project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    \/\/ merge the programs and expand out the local references to form\n    \/\/ the new semijoin condition; it now references a concatenation of\n    \/\/ the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n","new_comment_raw":"@param project LogicalProject on the LHS of the semijoin","old_comment_raw":"@param project ProjectRel on the LHS of the semijoin","label":1,"pre_label":0,"AST_level":9,"line_counts":71,"new_code_token_num":411},{"new_code_raw":"public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) { ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class ); Set<InputStream> mappingStreams = new HashSet<InputStream>(); for ( String fileName : mappingFileNames ) { EntityMappings entityMappings; try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm2Exception ) { \/\/ if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm1Exception ) { throw new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception ); } } entityMappings.toString(); } return null; }","old_code_raw":"\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tfor ( JaxbRoot<XMLEntityMappings> root : mappings ) {\n\t\t\troot.getRoot().toString();\n\t\t}\n\t\treturn annotationIndex;\n\t}\n","new_comment_raw":"@param mappingFileNames the file names of the xml files to parse","old_comment_raw":"@param mappings list of XMLEntityMappings created from the specified orm xml files","label":1,"pre_label":0,"AST_level":12,"line_counts":29,"new_code_token_num":139},{"new_code_raw":"private void preparHtmlForGlobalDescription(OpenAPI openAPI) { if (openAPI.getInfo() == null) { return; } String currentDescription = openAPI.getInfo().getDescription(); if (currentDescription != null && !currentDescription.isEmpty()) { Markdown markInstance = new Markdown(); openAPI.getInfo().setDescription( markInstance.toHtml(currentDescription) ); } else { LOGGER.error(\"OpenAPI object description is empty [\" + openAPI.getInfo().getTitle() + \"]\"); } }","old_code_raw":"    private void preparHtmlForGlobalDescription(Swagger swagger) {\n        String currentDescription = swagger.getInfo().getDescription();\n        if (currentDescription != null && !currentDescription.isEmpty()) {\n            Markdown markInstance = new Markdown();\n            swagger.getInfo().setDescription( markInstance.toHtml(currentDescription) );\n        } else {\n            LOGGER.error(\"Swagger object description is empty [\" + swagger.getInfo().getTitle() + \"]\");\n        }\n    }\n","new_comment_raw":"@param swagger The base object containing the global description through \"Info\" class","old_comment_raw":"@param swagger The base object containing the global description through \"Info\" class","label":0,"pre_label":1,"AST_level":10,"line_counts":14,"new_code_token_num":94},{"new_code_raw":"public ProtonJMessage convert(Message message) throws JMSException, UnsupportedEncodingException { Header header = new Header(); Properties props = new Properties(); Map<Symbol, Object> daMap = null; Map<Symbol, Object> maMap = null; Map<String,Object> apMap = null; Map<Object, Object> footerMap = null; Section body = null; body = convertBody(message); header.setDurable(message.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false); header.setPriority(new UnsignedByte((byte) message.getJMSPriority())); if (message.getJMSType() != null) { props.setSubject(message.getJMSType()); } if (message.getJMSMessageID() != null) { props.setMessageId(vendor.getOriginalMessageId(message)); } if (message.getJMSDestination() != null) { props.setTo(vendor.toAddress(message.getJMSDestination())); if (maMap == null) { maMap = new HashMap<Symbol, Object>(); } maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(message.getJMSDestination())); \/\/ Deprecated: used by legacy QPid AMQP 1.0 JMS client maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(message.getJMSDestination())); } if (message.getJMSReplyTo() != null) { props.setReplyTo(vendor.toAddress(message.getJMSReplyTo())); if (maMap == null) { maMap = new HashMap<Symbol, Object>(); } maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(message.getJMSReplyTo())); \/\/ Deprecated: used by legacy QPid AMQP 1.0 JMS client maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(message.getJMSReplyTo())); } if (message.getJMSCorrelationID() != null) { String correlationId = message.getJMSCorrelationID(); try { props.setCorrelationId(AMQPMessageIdHelper.INSTANCE.toIdObject(correlationId)); } catch (AmqpProtocolException e) { props.setCorrelationId(correlationId); } } if (message.getJMSExpiration() != 0) { long ttl = message.getJMSExpiration() - System.currentTimeMillis(); if (ttl < 0) { ttl = 1; } header.setTtl(new UnsignedInteger((int) ttl)); props.setAbsoluteExpiryTime(new Date(message.getJMSExpiration())); } if (message.getJMSTimestamp() != 0) { props.setCreationTime(new Date(message.getJMSTimestamp())); } @SuppressWarnings(\"unchecked\") final Enumeration<String> keys = message.getPropertyNames(); while (keys.hasMoreElements()) { String key = keys.nextElement(); if (key.equals(messageFormatKey) || key.equals(nativeKey) || key.equals(AMQP_ORIGINAL_ENCODING_KEY)) { \/\/ skip transformer appended properties } else if (key.equals(firstAcquirerKey)) { header.setFirstAcquirer(message.getBooleanProperty(key)); } else if (key.startsWith(\"JMSXDeliveryCount\")) { \/\/ The AMQP delivery-count field only includes prior failed delivery attempts, \/\/ whereas JMSXDeliveryCount includes the first\/current delivery attempt. int amqpDeliveryCount = message.getIntProperty(key) - 1; if (amqpDeliveryCount > 0) { header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount)); } } else if (key.startsWith(\"JMSXUserID\")) { String value = message.getStringProperty(key); props.setUserId(new Binary(value.getBytes(\"UTF-8\"))); } else if (key.startsWith(\"JMSXGroupID\")) { String value = message.getStringProperty(key); props.setGroupId(value); if (apMap == null) { apMap = new HashMap<String, Object>(); } apMap.put(key, value); } else if (key.startsWith(\"JMSXGroupSeq\")) { UnsignedInteger value = new UnsignedInteger(message.getIntProperty(key)); props.setGroupSequence(value); if (apMap == null) { apMap = new HashMap<String, Object>(); } apMap.put(key, value); } else if (key.startsWith(prefixDeliveryAnnotationsKey)) { if (daMap == null) { daMap = new HashMap<Symbol, Object>(); } String name = key.substring(prefixDeliveryAnnotationsKey.length()); daMap.put(Symbol.valueOf(name), message.getObjectProperty(key)); } else if (key.startsWith(prefixMessageAnnotationsKey)) { if (maMap == null) { maMap = new HashMap<Symbol, Object>(); } String name = key.substring(prefixMessageAnnotationsKey.length()); maMap.put(Symbol.valueOf(name), message.getObjectProperty(key)); } else if (key.equals(contentTypeKey)) { props.setContentType(Symbol.getSymbol(message.getStringProperty(key))); } else if (key.equals(contentEncodingKey)) { props.setContentEncoding(Symbol.getSymbol(message.getStringProperty(key))); } else if (key.equals(replyToGroupIDKey)) { props.setReplyToGroupId(message.getStringProperty(key)); } else if (key.startsWith(prefixFooterKey)) { if (footerMap == null) { footerMap = new HashMap<Object, Object>(); } String name = key.substring(prefixFooterKey.length()); footerMap.put(name, message.getObjectProperty(key)); } else { if (apMap == null) { apMap = new HashMap<String, Object>(); } apMap.put(key, message.getObjectProperty(key)); } } MessageAnnotations ma = null; if (maMap != null) { ma = new MessageAnnotations(maMap); } DeliveryAnnotations da = null; if (daMap != null) { da = new DeliveryAnnotations(daMap); } ApplicationProperties ap = null; if (apMap != null) { ap = new ApplicationProperties(apMap); } Footer footer = null; if (footerMap != null) { footer = new Footer(footerMap); } return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer); }","old_code_raw":"    public ProtonJMessage convert(Message msg) throws JMSException, UnsupportedEncodingException {\n        Header header = new Header();\n        Properties props = new Properties();\n        HashMap<Symbol, Object> daMap = null;\n        HashMap<Symbol, Object> maMap = null;\n        HashMap apMap = null;\n        Section body = null;\n        HashMap footerMap = null;\n        if (msg instanceof BytesMessage) {\n            BytesMessage m = (BytesMessage) msg;\n            byte data[] = new byte[(int) m.getBodyLength()];\n            m.readBytes(data);\n            m.reset(); \/\/ Need to reset after readBytes or future readBytes\n                       \/\/ calls (ex: redeliveries) will fail and return -1\n            body = new Data(new Binary(data));\n        }\n        if (msg instanceof TextMessage) {\n            body = new AmqpValue(((TextMessage) msg).getText());\n        }\n        if (msg instanceof MapMessage) {\n            final HashMap<String, Object> map = new HashMap<String, Object>();\n            final MapMessage m = (MapMessage) msg;\n            final Enumeration<String> names = m.getMapNames();\n            while (names.hasMoreElements()) {\n                String key = names.nextElement();\n                map.put(key, m.getObject(key));\n            }\n            body = new AmqpValue(map);\n        }\n        if (msg instanceof StreamMessage) {\n            ArrayList<Object> list = new ArrayList<Object>();\n            final StreamMessage m = (StreamMessage) msg;\n            try {\n                while (true) {\n                    list.add(m.readObject());\n                }\n            } catch (MessageEOFException e) {\n            }\n            body = new AmqpSequence(list);\n        }\n        if (msg instanceof ObjectMessage) {\n            body = new AmqpValue(((ObjectMessage) msg).getObject());\n        }\n\n        header.setDurable(msg.getJMSDeliveryMode() == DeliveryMode.PERSISTENT ? true : false);\n        header.setPriority(new UnsignedByte((byte) msg.getJMSPriority()));\n        if (msg.getJMSType() != null) {\n            props.setSubject(msg.getJMSType());\n        }\n        if (msg.getJMSMessageID() != null) {\n            ActiveMQMessage amqMsg = (ActiveMQMessage) msg;\n\n            MessageId msgId = amqMsg.getMessageId();\n            if (msgId.getTextView() != null) {\n                try {\n                    props.setMessageId(AMQPMessageIdHelper.INSTANCE.toIdObject(msgId.getTextView()));\n                } catch (AmqpProtocolException e) {\n                    props.setMessageId(msgId.getTextView().toString());\n                }\n            } else {\n                props.setMessageId(msgId.toString());\n            }\n        }\n        if (msg.getJMSDestination() != null) {\n            props.setTo(vendor.toAddress(msg.getJMSDestination()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_DEST_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSDestination()));\n\n            \/\/ Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_DEST_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSDestination()));\n        }\n        if (msg.getJMSReplyTo() != null) {\n            props.setReplyTo(vendor.toAddress(msg.getJMSReplyTo()));\n            if (maMap == null) {\n                maMap = new HashMap<Symbol, Object>();\n            }\n            maMap.put(JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationType(msg.getJMSReplyTo()));\n\n            \/\/ Deprecated: used by legacy QPid AMQP 1.0 JMS client\n            maMap.put(LEGACY_JMS_REPLY_TO_TYPE_MSG_ANNOTATION, destinationAttributes(msg.getJMSReplyTo()));\n        }\n        if (msg.getJMSCorrelationID() != null) {\n            String correlationId = msg.getJMSCorrelationID();\n            try {\n                props.setCorrelationId(AMQPMessageIdHelper.INSTANCE.toIdObject(correlationId));\n            } catch (AmqpProtocolException e) {\n                props.setCorrelationId(correlationId);\n            }\n        }\n        if (msg.getJMSExpiration() != 0) {\n            long ttl = msg.getJMSExpiration() - System.currentTimeMillis();\n            if (ttl < 0) {\n                ttl = 1;\n            }\n            header.setTtl(new UnsignedInteger((int) ttl));\n\n            props.setAbsoluteExpiryTime(new Date(msg.getJMSExpiration()));\n        }\n        if (msg.getJMSTimestamp() != 0) {\n            props.setCreationTime(new Date(msg.getJMSTimestamp()));\n        }\n\n        final Enumeration<String> keys = msg.getPropertyNames();\n        while (keys.hasMoreElements()) {\n            String key = keys.nextElement();\n            if (key.equals(messageFormatKey) || key.equals(nativeKey)) {\n                \/\/ skip..\n            } else if (key.equals(firstAcquirerKey)) {\n                header.setFirstAcquirer(msg.getBooleanProperty(key));\n            } else if (key.startsWith(\"JMSXDeliveryCount\")) {\n                \/\/ The AMQP delivery-count field only includes prior failed delivery attempts,\n                \/\/ whereas JMSXDeliveryCount includes the first\/current delivery attempt.\n                int amqpDeliveryCount = msg.getIntProperty(key) - 1;\n                if (amqpDeliveryCount > 0) {\n                    header.setDeliveryCount(new UnsignedInteger(amqpDeliveryCount));\n                }\n            } else if (key.startsWith(\"JMSXUserID\")) {\n                String value = msg.getStringProperty(key);\n                props.setUserId(new Binary(value.getBytes(\"UTF-8\")));\n            } else if (key.startsWith(\"JMSXGroupID\")) {\n                String value = msg.getStringProperty(key);\n                props.setGroupId(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(\"JMSXGroupSeq\")) {\n                UnsignedInteger value = new UnsignedInteger(msg.getIntProperty(key));\n                props.setGroupSequence(value);\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, value);\n            } else if (key.startsWith(prefixDeliveryAnnotationsKey)) {\n                if (daMap == null) {\n                    daMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixDeliveryAnnotationsKey.length());\n                daMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.startsWith(prefixMessageAnnotationsKey)) {\n                if (maMap == null) {\n                    maMap = new HashMap<Symbol, Object>();\n                }\n                String name = key.substring(prefixMessageAnnotationsKey.length());\n                maMap.put(Symbol.valueOf(name), msg.getObjectProperty(key));\n            } else if (key.equals(contentTypeKey)) {\n                props.setContentType(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(contentEncodingKey)) {\n                props.setContentEncoding(Symbol.getSymbol(msg.getStringProperty(key)));\n            } else if (key.equals(replyToGroupIDKey)) {\n                props.setReplyToGroupId(msg.getStringProperty(key));\n            } else if (key.startsWith(prefixFooterKey)) {\n                if (footerMap == null) {\n                    footerMap = new HashMap();\n                }\n                String name = key.substring(prefixFooterKey.length());\n                footerMap.put(name, msg.getObjectProperty(key));\n            } else {\n                if (apMap == null) {\n                    apMap = new HashMap();\n                }\n                apMap.put(key, msg.getObjectProperty(key));\n            }\n        }\n\n        MessageAnnotations ma = null;\n        if (maMap != null) {\n            ma = new MessageAnnotations(maMap);\n        }\n        DeliveryAnnotations da = null;\n        if (daMap != null) {\n            da = new DeliveryAnnotations(daMap);\n        }\n        ApplicationProperties ap = null;\n        if (apMap != null) {\n            ap = new ApplicationProperties(apMap);\n        }\n        Footer footer = null;\n        if (footerMap != null) {\n            footer = new Footer(footerMap);\n        }\n\n        return (ProtonJMessage) org.apache.qpid.proton.message.Message.Factory.create(header, da, ma, props, ap, body, footer);\n    }\n","new_comment_raw":"@param message The message to transform into an AMQP version for dispatch.","old_comment_raw":"@param msg","label":1,"pre_label":0,"AST_level":25,"line_counts":146,"new_code_token_num":1085},{"new_code_raw":"private int constituents(Set<Constituent> constituentsSet, int left, ConstituentFactory cf, boolean charLevel, Predicate<Tree> filter, int maxDepth, int depth) { if(isPreTerminal()) return left + ((charLevel) ? firstChild().value().length() : 1); int position = left; \/\/ System.err.println(\"In bracketing trees left is \" + left); \/\/ System.err.println(\" label is \" + label() + \/\/ \"; num daughters: \" + children().length); Tree[] kids = children(); for (Tree kid : kids) { position = kid.constituents(constituentsSet, position, cf, charLevel, filter, maxDepth, depth + 1); \/\/ System.err.println(\" position went to \" + position); } if ((filter == null || filter.test(this)) && (maxDepth < 0 || depth <= maxDepth)) { \/\/Compute span of entire tree at the end of recursion constituentsSet.add(cf.newConstituent(left, position - 1, label(), score())); } \/\/ System.err.println(\" added \" + label()); return position; }","old_code_raw":"  private int constituents(Set<Constituent> constituentsSet, int left, ConstituentFactory cf, boolean charLevel, Filter<Tree> filter, int maxDepth, int depth) {\n\n    if(isPreTerminal())\n      return left + ((charLevel) ? firstChild().value().length() : 1);\n\n    int position = left;\n\n    \/\/ System.err.println(\"In bracketing trees left is \" + left);\n    \/\/ System.err.println(\"  label is \" + label() +\n    \/\/                       \"; num daughters: \" + children().length);\n    Tree[] kids = children();\n    for (Tree kid : kids) {\n      position = kid.constituents(constituentsSet, position, cf, charLevel, filter, maxDepth, depth + 1);\n      \/\/ System.err.println(\"  position went to \" + position);\n    }\n\n    if ((filter == null || filter.accept(this)) &&\n        (maxDepth < 0 || depth <= maxDepth)) {\n      \/\/Compute span of entire tree at the end of recursion\n      constituentsSet.add(cf.newConstituent(left, position - 1, label(), score()));\n    }\n    \/\/ System.err.println(\"  added \" + label());\n    return position;\n  }\n","new_comment_raw":"@param constituentsSet set of constituents to add results of bracketing this tree to","old_comment_raw":"@param constituentsSet set of constituents to add results of bracketing this tree to","label":0,"pre_label":1,"AST_level":9,"line_counts":25,"new_code_token_num":238},{"new_code_raw":"public void updateUser (String username, User user) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = user; \/\/ verify the required parameter 'username' is set if (username == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'username' when calling updateUser\", new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\")); } \/\/ verify the required parameter 'user' is set if (user == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'user' when calling updateUser\", new ApiException(400, \"Missing the required parameter 'user' when calling updateUser\")); } \/\/ create path and map variables String path = \"\/user\/{username}\".replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"application\/json\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void updateUser (String username, User body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    \/\/ verify the required parameter 'username' is set\n    if (username == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'username' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\"));\n    }\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling updateUser\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling updateUser\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/user\/{username}\".replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"PUT\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param username name that need to be deleted","old_comment_raw":"@param username name that need to be deleted","label":0,"pre_label":1,"AST_level":11,"line_counts":62,"new_code_token_num":441},{"new_code_raw":"protected BroadcastAction filter(HttpServletRequest request, HttpServletResponse response, Object object) { BroadcastAction transformed = new BroadcastAction(object); for (PerRequestBroadcastFilter mf : perRequestFilters) { transformed = mf.filter(request, response, transformed.message()); if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) { return transformed; } } return transformed; }","old_code_raw":"    protected BroadcastAction filter(HttpServletRequest request, Object object) {\n        BroadcastAction transformed = new BroadcastAction(object);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            transformed = mf.filter(request, transformed.message());\n            if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {\n                return transformed;\n            }\n        }\n        return transformed;\n    }\n","new_comment_raw":"@param object the broadcasted object.","old_comment_raw":"@param object the broadcasted object.","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public ServletBuilder addServlet(Class<? extends Servlet> klass, String urlPattern) { final ServletHolder holder = new ServletHolder(checkNotNull(klass)); final ServletBuilder builder = new ServletBuilder(holder, handler); builder.addUrlPattern(checkNotNull(urlPattern)); return builder; }","old_code_raw":"    public ServletRegistration.Dynamic addServlet(String name, Class<? extends Servlet> klass) {\n        final ServletHolder holder = new ServletHolder(checkNotNull(klass));\n        holder.setName(name);\n        handler.getServletHandler().addServlet(holder);\n        return holder.getRegistration();\n    }\n","new_comment_raw":"@param klass the servlet class","old_comment_raw":"@param name the servlet's name","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":50},{"new_code_raw":"public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) { ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class ); Set<InputStream> mappingStreams = new HashSet<InputStream>(); for ( String fileName : mappingFileNames ) { EntityMappings entityMappings; try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm2Exception ) { \/\/ if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm1Exception ) { throw new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception ); } } entityMappings.toString(); } return null; }","old_code_raw":"\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tList<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );\n\t\tfor ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {\n\t\t\tlist.add( jaxbRoot.getRoot() );\n\t\t}\n\t\treturn new EntityMappingsMocker(\n\t\t\t\tlist, annotationIndex, meta.getServiceRegistry()\n\t\t).mockNewIndex();\n\t}\n","new_comment_raw":"@param annotationIndex the annotation index based on scanned annotations","old_comment_raw":"@param annotationIndex the annotation index based on scanned annotations","label":0,"pre_label":1,"AST_level":12,"line_counts":29,"new_code_token_num":139},{"new_code_raw":"static String formatSQLParsingError(String sql, DrillSqlParseException ex) { final String sqlErrorMessageHeader = \"SQL Query: \"; final SqlParserPos pos = ex.getPos(); if (pos != null) { int issueLineNumber = pos.getLineNum() - 1; \/\/ recalculates to base 0 int issueColumnNumber = pos.getColumnNum() - 1; \/\/ recalculates to base 0 int messageHeaderLength = sqlErrorMessageHeader.length(); \/\/ If the issue happens on the first line, header width should be calculated alongside with the sql query int shiftLength = (issueLineNumber == 0) ? issueColumnNumber + messageHeaderLength : issueColumnNumber; StringBuilder sb = new StringBuilder(); String[] lines = sql.split(DrillParserUtil.EOL); for (int i = 0; i < lines.length; i++) { sb.append(lines[i]); if (i == issueLineNumber) { sb .append(DrillParserUtil.EOL) .append(StringUtils.repeat(' ', shiftLength)) .append(\"^\"); } if (i < lines.length - 1) { sb.append(DrillParserUtil.EOL); } } sql = sb.toString(); } return sqlErrorMessageHeader + sql; }","old_code_raw":"  static String formatSQLParsingError(String sql, SqlParserPos pos) {\n    if (pos == null) {\n      return sql;\n    }\n    StringBuilder sb = new StringBuilder();\n    String[] lines = sql.split(\"\\n\");\n    for (int i = 0; i < lines.length; i++) {\n      String line = lines[i];\n      sb.append(line).append(\"\\n\");\n      if (i == (pos.getLineNum() - 1)) {\n        for (int j = 0; j < pos.getColumnNum() - 1; j++) {\n          sb.append(\" \");\n        }\n        sb.append(\"^\\n\");\n      }\n    }\n    return sb.toString();\n  }\n","new_comment_raw":"@param ex exception object","old_comment_raw":"@param pos the position of the error","label":1,"pre_label":0,"AST_level":13,"line_counts":33,"new_code_token_num":210},{"new_code_raw":"private HiscoreLookup getCorrectLookupFor(final ChatMessage chatMessage) { final String player; final HiscoreEndpoint ironmanStatus; if (chatMessage.getType().equals(ChatMessageType.PRIVATE_MESSAGE_SENT)) { player = client.getLocalPlayer().getName(); ironmanStatus = hiscoreEndpoint; } else { player = sanitize(chatMessage.getName()); if (player.equals(client.getLocalPlayer().getName())) { \/\/ Get ironman status from for the local player ironmanStatus = hiscoreEndpoint; } else { \/\/ Get ironman status from their icon in chat ironmanStatus = getHiscoreEndpointByName(chatMessage.getName()); } } return new HiscoreLookup(player, ironmanStatus); }","old_code_raw":"\tprivate HiscoreLookup getCorrectLookupFor(final SetMessage setMessage)\n\t{\n\t\tfinal String player;\n\t\tfinal HiscoreEndpoint ironmanStatus;\n\n\t\tif (setMessage.getType().equals(ChatMessageType.PRIVATE_MESSAGE_SENT))\n\t\t{\n\t\t\tplayer = client.getLocalPlayer().getName();\n\t\t\tironmanStatus = hiscoreEndpoint;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tplayer = sanitize(setMessage.getName());\n\n\t\t\tif (player.equals(client.getLocalPlayer().getName()))\n\t\t\t{\n\t\t\t\t\/\/ Get ironman status from for the local player\n\t\t\t\tironmanStatus = hiscoreEndpoint;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\/\/ Get ironman status from their icon in chat\n\t\t\t\tironmanStatus = getHiscoreEndpointByName(setMessage.getName());\n\t\t\t}\n\t\t}\n\n\t\treturn new HiscoreLookup(player, ironmanStatus);\n\t}\n","new_comment_raw":"@param chatMessage chat message","old_comment_raw":"@param setMessage chat message","label":1,"pre_label":0,"AST_level":10,"line_counts":29,"new_code_token_num":116},{"new_code_raw":"private static Method getMethod(Class<?> clazz, String attributeName) { try { char string[] = attributeName.toCharArray(); string[0] = Character.toUpperCase( string[0] ); String casedAttributeName = new String( string ); try { return clazz.getDeclaredMethod( \"get\" + casedAttributeName ); } catch ( NoSuchMethodException e ) { return clazz.getDeclaredMethod( \"is\" + casedAttributeName ); } } catch ( NoSuchMethodException e ) { return null; } }","old_code_raw":"\tprivate static Method getMethod(Class<?> clazz, String methodName) {\n\t\ttry {\n\t\t\tchar string[] = methodName.toCharArray();\n\t\t\tstring[0] = Character.toUpperCase( string[0] );\n\t\t\tmethodName = new String( string );\n\t\t\ttry {\n\t\t\t\treturn clazz.getDeclaredMethod( \"get\" + methodName );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException e ) {\n\t\t\t\treturn clazz.getDeclaredMethod( \"is\" + methodName );\n\t\t\t}\n\t\t}\n\t\tcatch ( NoSuchMethodException e ) {\n\t\t\treturn null;\n\t\t}\n\t}\n","new_comment_raw":"@param clazz The class to check.","old_comment_raw":"@param clazz The class to check.","label":0,"pre_label":1,"AST_level":9,"line_counts":17,"new_code_token_num":89},{"new_code_raw":"public Client testClientModel(Client client) throws ApiException { Object localVarPostBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, \"Missing the required parameter 'client' when calling testClientModel\"); } \/\/ create path and map variables String localVarPath = \"\/fake\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client testClientModel(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":215},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new VMPendingMessageCursor(); }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new VMPendingMessageCursor();\n    }\n","new_comment_raw":"@param clientId","old_comment_raw":"@param clientId","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public Action resumed(AtmosphereRequest request, AtmosphereResponse response) throws IOException, ServletException { return action(request, response); }","old_code_raw":"    public Action resumed(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        return action(request, response);\n    }\n","new_comment_raw":"@param request the  AtmosphereRequest","old_comment_raw":"@param request the HttpServletRequest","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public Collection<String> getCandidateEIPs(String myInstanceId, String myZone) { if (myZone == null) { myZone = \"us-east-1d\"; } Collection<String> eipCandidates = (DiscoveryManager.getInstance() .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone) : getEIPsForZoneFromConfig(myZone)); if (eipCandidates == null || eipCandidates.size() == 0) { throw new RuntimeException( \"Could not get any elastic ips from the EIP pool for zone :\" + myZone); } return eipCandidates; }","old_code_raw":"    public Collection<String> getCandidateEIPs(String myInstanceId, String myZone, String myPublicIP) {\n\n        if (myZone == null) {\n            myZone = \"us-east-1d\";\n            myPublicIP = \"us-east-1d\";\n        }\n        Collection<String> eipCandidates = (DiscoveryManager.getInstance()\n                .getEurekaClientConfig().shouldUseDnsForFetchingServiceUrls() ? getEIPsForZoneFromDNS(myZone)\n                        : getEIPsForZoneFromConfig(myZone));\n\n        if (eipCandidates == null || eipCandidates.size() == 0) {\n            throw new RuntimeException(\n                    \"Could not get any elastic ips from the EIP pool for zone :\"\n                    + myZone);\n        }\n       \n        return eipCandidates;\n    }\n","new_comment_raw":"@param myPublicIP the public ip of this instance","old_comment_raw":"@param myPublicIP the public ip of this instance","label":0,"pre_label":1,"AST_level":8,"line_counts":18,"new_code_token_num":95},{"new_code_raw":"public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) { ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class ); Set<InputStream> mappingStreams = new HashSet<InputStream>(); for ( String fileName : mappingFileNames ) { EntityMappings entityMappings; try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm2Exception ) { \/\/ if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm1Exception ) { throw new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception ); } } entityMappings.toString(); } return null; }","old_code_raw":"\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tList<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );\n\t\tfor ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {\n\t\t\tlist.add( jaxbRoot.getRoot() );\n\t\t}\n\t\treturn new EntityMappingsMocker(\n\t\t\t\tlist, annotationIndex, meta.getServiceRegistry()\n\t\t).mockNewIndex();\n\t}\n","new_comment_raw":"@param mappingFileNames the file names of the xml files to parse","old_comment_raw":"@param mappings list of XMLEntityMappings created from the specified orm xml files","label":1,"pre_label":0,"AST_level":12,"line_counts":29,"new_code_token_num":139},{"new_code_raw":"public ApiResponse<Void> testEndpointParametersWithHttpInfo(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException { Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null); return apiClient.execute(call); }","old_code_raw":"  public ApiResponse<Void> testEndpointParametersWithHttpInfo(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password) throws ApiException {\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, null, null);\n    return apiClient.execute(call);\n  }\n","new_comment_raw":"@param _float None (optional)","old_comment_raw":"@param _float None (optional)","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":89},{"new_code_raw":"private Expression translate0(RexNode expr, RexImpTable.NullAs nullAs) { if (expr instanceof RexInputRef) { final int index = ((RexInputRef) expr).getIndex(); Expression x = inputGetter.field(list, index); return nullAs.handle(list.append(\"v\", x)); } if (expr instanceof RexLocalRef) { return translate( program.getExprList().get(((RexLocalRef) expr).getIndex()), nullAs); } if (expr instanceof RexLiteral) { return translateLiteral(expr, null, typeFactory, nullAs); } if (expr instanceof RexCall) { final RexCall call = (RexCall) expr; final SqlOperator operator = call.getOperator(); RexImpTable.CallImplementor implementor = RexImpTable.INSTANCE.get(operator); if (implementor != null) { return implementor.implement(this, call, nullAs); } } switch (expr.getKind()) { default: throw new RuntimeException( \"cannot translate expression \" + expr); } }","old_code_raw":"    private Expression translate0(RexNode expr, boolean mayBeNull) {\n        if (expr instanceof RexInputRef) {\n            final int index = ((RexInputRef) expr).getIndex();\n            return inputGetter.field(list, index);\n        }\n        if (expr instanceof RexLocalRef) {\n            return translate(\n                program.getExprList().get(((RexLocalRef) expr).getIndex()),\n                mayBeNull);\n        }\n        if (expr instanceof RexLiteral) {\n            return translateLiteral(expr, null, typeFactory);\n        }\n        if (expr instanceof RexCall) {\n            final RexCall call = (RexCall) expr;\n            final SqlOperator operator = call.getOperator();\n            RexImpTable.CallImplementor implementor =\n                RexImpTable.INSTANCE.get(operator);\n            if (implementor != null) {\n                return implementor.implement(this, call, mayBeNull);\n            }\n        }\n        switch (expr.getKind()) {\n        default:\n            throw new RuntimeException(\n                \"cannot translate expression \" + expr);\n        }\n    }\n","new_comment_raw":"@param nullAs If false, if expression is definitely not null at runtime. Therefore we can optimize. For example, we can cast to int using x.intValue().","old_comment_raw":"@param mayBeNull If false, if expression is definitely not null at runtime. Therefore we can optimize. For example, we can cast to int using x.intValue().","label":1,"pre_label":0,"AST_level":10,"line_counts":30,"new_code_token_num":187},{"new_code_raw":"public boolean waitForText(String text, int minimumNumberOfMatches, long timeout) { return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout); }","old_code_raw":"\tpublic boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout) {\n       return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout);\n    }\n","new_comment_raw":"@param minimumNumberOfMatches the minimum number of text matches that are expected to be shown.  0 means any number of matches","old_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. 0 means any number of matches","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public static DownloadQueue newDownloadQueue() { return newDownloadQueue(2); }","old_code_raw":"\tpublic static DownloadQueue newDownloadQueue(Context context) {\n\t\treturn newDownloadQueue(context, 2);\n\t}\n","new_comment_raw":"@param context ApplicationContext","old_comment_raw":"@param context ApplicationContext","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public static BooleanExpression fuzzyLike(Path<String> path, String value, int maxEdits) { Term term = new Term(path.getMetadata().getName(), value); return new QueryElement(new FuzzyQuery(term, maxEdits)); }","old_code_raw":"    public static BooleanExpression fuzzyLike(Path<String> path, String value, float minimumSimilarity) {\n        Term term = new Term(path.getMetadata().getName(), value);\n        return new QueryElement(new FuzzyQuery(term, minimumSimilarity));\n    }\n","new_comment_raw":"@param path","old_comment_raw":"@param path","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":46},{"new_code_raw":"public int getMaximumValue(ReadablePartial instant, int[] values) { return getMaximumValue(instant); }","old_code_raw":"    public int getMaximumValue(PartialInstant instant, int[] values) {\n        return getMaximumValue(instant);\n    }\n","new_comment_raw":"@param instant the partial instant to query","old_comment_raw":"@param instant the partial instant to query","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public static int readVInt(DrillBuf buffer, int start, int end) { long n = readVLong(buffer, start, end); if ((n > Integer.MAX_VALUE) || (n < Integer.MIN_VALUE)) { throw new NumberFormatException(\"Value \" + n + \" too long to fit in integer\"); } return (int)n; }","old_code_raw":"    public static int readVInt(ByteBuf buffer, int start, int end) {\n      long n = readVLong(buffer, start, end);\n      if ((n > Integer.MAX_VALUE) || (n < Integer.MIN_VALUE)) {\n        throw new NumberFormatException(\"Value \" + n + \" too long to fit in integer\");\n      }\n      return (int)n;\n    }\n","new_comment_raw":"@param buffer DrillBuf to read from","old_comment_raw":"@param buffer ByteBuf to read from","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":70},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, callback); return httpClient.newCall(request); }","old_code_raw":"    public Call buildCall(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        Request request = buildRequest(path, method, queryParams, collectionQueryParams, body, headerParams, formParams, authNames, progressRequestListener);\n\n        return httpClient.newCall(request);\n    }\n","new_comment_raw":"@param collectionQueryParams The collection query parameters","old_comment_raw":"@param collectionQueryParams The collection query parameters","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":75},{"new_code_raw":"File getBaseDir(File base, File file) { if (base == null) { return file.getParentFile().getAbsoluteFile(); } else { Iterator bases = getParents(base).iterator(); Iterator fileParents = getParents(file.getAbsoluteFile()).iterator(); File result = null; while (bases.hasNext() && fileParents.hasNext()) { File next = (File) bases.next(); if (next.equals(fileParents.next())) { result = next; } else { break; } } return result; } }","old_code_raw":"    File getBaseDir(final File file1, final File file2) {\n        if (file1 == null || file2 == null) {\n            return null;\n        }\n        final Iterator file1Parents = getParents(file1).iterator();\n        final Iterator file2Parents = getParents(file2.getAbsoluteFile()).iterator();\n        File result = null;\n        while (file1Parents.hasNext() && file2Parents.hasNext()) {\n            File next = (File) file1Parents.next();\n            if (next.equals(file2Parents.next())) {\n                result = next;\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n","new_comment_raw":"@param file the file for which the new base directory should be returned.","old_comment_raw":"@param file2 The other file for which the common base directory should be returned, may be null.","label":1,"pre_label":0,"AST_level":11,"line_counts":20,"new_code_token_num":106},{"new_code_raw":"private void init(MetadataContext metaContext) throws IOException { if (entries.size() == 1 && parquetTableMetadata == null) { Path p = Path.getPathWithoutSchemeAndAuthority(new Path(entries.get(0).getPath())); Path metaPath = null; if (fs.isDirectory(p)) { \/\/ Using the metadata file makes sense when querying a directory; otherwise \/\/ if querying a single file we can look up the metadata directly from the file metaPath = new Path(p, Metadata.METADATA_FILENAME); } if (metaPath != null && fs.exists(metaPath)) { usedMetadataCache = true; parquetTableMetadata = Metadata.readBlockMeta(fs, metaPath.toString(), metaContext); } else { parquetTableMetadata = Metadata.getParquetTableMetadata(fs, p.toString()); } } else { Path p = Path.getPathWithoutSchemeAndAuthority(new Path(selectionRoot)); Path metaPath = new Path(p, Metadata.METADATA_FILENAME); if (fs.isDirectory(new Path(selectionRoot)) && fs.exists(metaPath)) { usedMetadataCache = true; if (parquetTableMetadata == null) { parquetTableMetadata = Metadata.readBlockMeta(fs, metaPath.toString(), metaContext); } if (fileSet != null) { parquetTableMetadata = removeUnneededRowGroups(parquetTableMetadata); } } else { final List<FileStatus> fileStatuses = Lists.newArrayList(); for (ReadEntryWithPath entry : entries) { getFiles(entry.getPath(), fileStatuses); } parquetTableMetadata = Metadata.getParquetTableMetadata(fs, fileStatuses); } } if (fileSet == null) { fileSet = Sets.newHashSet(); for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) { fileSet.add(file.getPath()); } } Map<String, DrillbitEndpoint> hostEndpointMap = Maps.newHashMap(); for (DrillbitEndpoint endpoint : formatPlugin.getContext().getBits()) { hostEndpointMap.put(endpoint.getAddress(), endpoint); } rowGroupInfos = Lists.newArrayList(); for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) { int rgIndex = 0; for (RowGroupMetadata rg : file.getRowGroups()) { RowGroupInfo rowGroupInfo = new RowGroupInfo(file.getPath(), rg.getStart(), rg.getLength(), rgIndex, rg.getRowCount()); EndpointByteMap endpointByteMap = new EndpointByteMapImpl(); for (String host : rg.getHostAffinity().keySet()) { if (hostEndpointMap.containsKey(host)) { endpointByteMap .add(hostEndpointMap.get(host), (long) (rg.getHostAffinity().get(host) * rg.getLength())); } } rowGroupInfo.setEndpointByteMap(endpointByteMap); rgIndex++; rowGroupInfos.add(rowGroupInfo); } } this.endpointAffinities = AffinityCreator.getAffinityMap(rowGroupInfos); columnValueCounts = Maps.newHashMap(); this.rowCount = 0; boolean first = true; for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) { for (RowGroupMetadata rowGroup : file.getRowGroups()) { long rowCount = rowGroup.getRowCount(); for (ColumnMetadata column : rowGroup.getColumns()) { SchemaPath schemaPath = SchemaPath.getCompoundPath(column.getName()); Long previousCount = columnValueCounts.get(schemaPath); if (previousCount != null) { if (previousCount != GroupScan.NO_COLUMN_STATS) { if (column.getNulls() != null) { Long newCount = rowCount - column.getNulls(); columnValueCounts.put(schemaPath, columnValueCounts.get(schemaPath) + newCount); } } } else { if (column.getNulls() != null) { Long newCount = rowCount - column.getNulls(); columnValueCounts.put(schemaPath, newCount); } else { columnValueCounts.put(schemaPath, GroupScan.NO_COLUMN_STATS); } } boolean partitionColumn = checkForPartitionColumn(column, first); if (partitionColumn) { Map<SchemaPath, Object> map = partitionValueMap.get(file.getPath()); if (map == null) { map = Maps.newHashMap(); partitionValueMap.put(file.getPath(), map); } Object value = map.get(schemaPath); Object currentValue = column.getMaxValue(); if (value != null) { if (value != currentValue) { columnTypeMap.remove(schemaPath); } } else { map.put(schemaPath, currentValue); } } else { columnTypeMap.remove(schemaPath); } } this.rowCount += rowGroup.getRowCount(); first = false; } } }","old_code_raw":"  private void init() throws IOException {\n    if (entries.size() == 1 && parquetTableMetadata == null) {\n      Path p = Path.getPathWithoutSchemeAndAuthority(new Path(entries.get(0).getPath()));\n      Path metaPath = null;\n      if (fs.isDirectory(p)) {\n        \/\/ Using the metadata file makes sense when querying a directory; otherwise\n        \/\/ if querying a single file we can look up the metadata directly from the file\n        metaPath = new Path(p, Metadata.METADATA_FILENAME);\n      }\n      if (metaPath != null && fs.exists(metaPath)) {\n        usedMetadataCache = true;\n        parquetTableMetadata = Metadata.readBlockMeta(fs, metaPath.toString());\n      } else {\n        parquetTableMetadata = Metadata.getParquetTableMetadata(fs, p.toString());\n      }\n    } else {\n      Path p = Path.getPathWithoutSchemeAndAuthority(new Path(selectionRoot));\n      Path metaPath = new Path(p, Metadata.METADATA_FILENAME);\n      if (fs.isDirectory(new Path(selectionRoot)) && fs.exists(metaPath)) {\n        usedMetadataCache = true;\n        if (parquetTableMetadata == null) {\n          parquetTableMetadata = Metadata.readBlockMeta(fs, metaPath.toString());\n        }\n        if (fileSet != null) {\n          parquetTableMetadata = removeUnneededRowGroups(parquetTableMetadata);\n        }\n      } else {\n        final List<FileStatus> fileStatuses = Lists.newArrayList();\n        for (ReadEntryWithPath entry : entries) {\n          getFiles(entry.getPath(), fileStatuses);\n        }\n        parquetTableMetadata = Metadata.getParquetTableMetadata(fs, fileStatuses);\n      }\n    }\n\n    if (fileSet == null) {\n      fileSet = Sets.newHashSet();\n      for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n        fileSet.add(file.getPath());\n      }\n    }\n\n    Map<String, DrillbitEndpoint> hostEndpointMap = Maps.newHashMap();\n\n    for (DrillbitEndpoint endpoint : formatPlugin.getContext().getBits()) {\n      hostEndpointMap.put(endpoint.getAddress(), endpoint);\n    }\n\n    rowGroupInfos = Lists.newArrayList();\n    for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n      int rgIndex = 0;\n      for (RowGroupMetadata rg : file.getRowGroups()) {\n        RowGroupInfo rowGroupInfo =\n            new RowGroupInfo(file.getPath(), rg.getStart(), rg.getLength(), rgIndex, rg.getRowCount());\n        EndpointByteMap endpointByteMap = new EndpointByteMapImpl();\n        for (String host : rg.getHostAffinity().keySet()) {\n          if (hostEndpointMap.containsKey(host)) {\n            endpointByteMap\n                .add(hostEndpointMap.get(host), (long) (rg.getHostAffinity().get(host) * rg.getLength()));\n          }\n        }\n        rowGroupInfo.setEndpointByteMap(endpointByteMap);\n        rgIndex++;\n        rowGroupInfos.add(rowGroupInfo);\n      }\n    }\n\n    this.endpointAffinities = AffinityCreator.getAffinityMap(rowGroupInfos);\n\n    columnValueCounts = Maps.newHashMap();\n    this.rowCount = 0;\n    boolean first = true;\n    for (ParquetFileMetadata file : parquetTableMetadata.getFiles()) {\n      for (RowGroupMetadata rowGroup : file.getRowGroups()) {\n        long rowCount = rowGroup.getRowCount();\n        for (ColumnMetadata column : rowGroup.getColumns()) {\n          SchemaPath schemaPath = SchemaPath.getCompoundPath(column.getName());\n          Long previousCount = columnValueCounts.get(schemaPath);\n          if (previousCount != null) {\n            if (previousCount != GroupScan.NO_COLUMN_STATS) {\n              if (column.getNulls() != null) {\n                Long newCount = rowCount - column.getNulls();\n                columnValueCounts.put(schemaPath, columnValueCounts.get(schemaPath) + newCount);\n              }\n            }\n          } else {\n            if (column.getNulls() != null) {\n              Long newCount = rowCount - column.getNulls();\n              columnValueCounts.put(schemaPath, newCount);\n            } else {\n              columnValueCounts.put(schemaPath, GroupScan.NO_COLUMN_STATS);\n            }\n          }\n          boolean partitionColumn = checkForPartitionColumn(column, first);\n          if (partitionColumn) {\n            Map<SchemaPath, Object> map = partitionValueMap.get(file.getPath());\n            if (map == null) {\n              map = Maps.newHashMap();\n              partitionValueMap.put(file.getPath(), map);\n            }\n            Object value = map.get(schemaPath);\n            Object currentValue = column.getMaxValue();\n            if (value != null) {\n              if (value != currentValue) {\n                columnTypeMap.remove(schemaPath);\n              }\n            } else {\n              map.put(schemaPath, currentValue);\n            }\n          } else {\n            columnTypeMap.remove(schemaPath);\n          }\n        }\n        this.rowCount += rowGroup.getRowCount();\n        first = false;\n      }\n    }\n  }\n","new_comment_raw":"@param metaFilePath metadata cache file path","old_comment_raw":"@param metaFilePath metadata cache file path","label":0,"pre_label":1,"AST_level":19,"line_counts":119,"new_code_token_num":779},{"new_code_raw":"public static int numberOfLeadingZeros(long lng) { lng |= lng >> 1; lng |= lng >> 2; lng |= lng >> 4; lng |= lng >> 8; lng |= lng >> 16; lng |= lng >> 32; return bitCount(~lng); }","old_code_raw":"    public static int numberOfLeadingZeros(long v) {\n        \/\/ After Hacker's Delight, Figure 5-6\n        if (v < 0) {\n            return 0;\n        }\n        if (v == 0) {\n            return 64;\n        }\n        \/\/ On a 64-bit VM, the two previous tests should probably be replaced by\n        \/\/ if (v <= 0) return ((int) (~v >> 57)) & 64;\n\n        int n = 1;\n        int i = (int) (v >>> 32);\n        if (i == 0) {\n            n +=  32;\n            i = (int) v;\n        }\n        if (i >>> 16 == 0) {\n            n +=  16;\n            i <<= 16;\n        }\n        if (i >>> 24 == 0) {\n            n +=  8;\n            i <<= 8;\n        }\n        if (i >>> 28 == 0) {\n            n +=  4;\n            i <<= 4;\n        }\n        if (i >>> 30 == 0) {\n            n +=  2;\n            i <<= 2;\n        }\n        return n - (i >>> 31);\n    }\n","new_comment_raw":"@param lng the long to examine.","old_comment_raw":"@param v the long to examine.","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":46},{"new_code_raw":"public int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SharedSessionContractImplementor session) throws HibernateException { int[] props = TypeHelper.findDirty( entityMetamodel.getProperties(), currentState, previousState, propertyColumnUpdateable, hasUninitializedLazyProperties( entity ), session ); if ( props == null ) { return null; } else { logDirtyProperties( props ); return props; } }","old_code_raw":"\tpublic int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tint[] props = TypeHelper.findDirty(\n\t\t\t\tentityMetamodel.getProperties(),\n\t\t\t\tcurrentState,\n\t\t\t\tpreviousState,\n\t\t\t\tpropertyColumnUpdateable,\n\t\t\t\thasUninitializedLazyProperties( entity ),\n\t\t\t\tsession\n\t\t);\n\t\tif ( props == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tlogDirtyProperties( props );\n\t\t\treturn props;\n\t\t}\n\t}\n","new_comment_raw":"@param previousState The previous state of the entity (the state to be checked against).","old_comment_raw":"@param previousState The previous state of the entity (the state to be checked against).","label":0,"pre_label":1,"AST_level":7,"line_counts":19,"new_code_token_num":73},{"new_code_raw":"public List<String> dependencyPathBetween(int start, int end, Optional<Function<Sentence, List<String>>> selector) { \/\/ Get paths from a node to the root of the sentence LinkedList<Integer> rootToStart = new LinkedList<>(); LinkedList<Integer> rootToEnd = new LinkedList<>(); int startAncestor = start; List<Optional<Integer>> governors = sentence.governors(); Set<Integer> seenVertices = new HashSet<>(); while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) { if (seenVertices.contains(startAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(startAncestor); rootToStart.addFirst(startAncestor); startAncestor = governors.get(startAncestor).get(); } if (startAncestor == -1) { rootToStart.addFirst(-1); } int endAncestor = end; seenVertices.clear(); while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) { if (seenVertices.contains(endAncestor)) { \/\/ Found loopiness -- revert to BFS return loopyDependencyPathBetween(start, end, selector); } seenVertices.add(endAncestor); rootToEnd.addFirst(endAncestor); endAncestor = governors.get(endAncestor).get(); } if (endAncestor == -1) { rootToEnd.addFirst(-1); } \/\/ Get least common node int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0; for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) { if (rootToStart.get(i).equals(rootToEnd.get(i))) { leastCommonNodeIndex = i; } } \/\/ Construct the path if (leastCommonNodeIndex < 0) { return Collections.emptyList(); } List<String> path = new ArrayList<>(); Optional<List<String>> words = selector.map(x -> x.apply(sentence)); for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) { final int index = i; words.ifPresent(x -> path.add(x.get(rootToStart.get(index)))); path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\"); } if (words.isPresent()) { path.add(words.get().get(rootToStart.get(leastCommonNodeIndex))); } for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) { final int index = i; path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\"); words.ifPresent(x -> path.add(x.get(rootToEnd.get(index)))); } return path; }","old_code_raw":"  public List<String> dependencyPathBetween(int start, int end, Function<Sentence, List<String>> selector) {\n    \/\/ Get paths from a node to the root of the sentence\n    LinkedList<Integer> rootToStart = new LinkedList<>();\n    LinkedList<Integer> rootToEnd = new LinkedList<>();\n    int startAncestor = start;\n    List<Optional<Integer>> governors = sentence.governors();\n    Set<Integer> seenVertices = new HashSet<>();\n    while (startAncestor >= 0 && governors.get(startAncestor).isPresent()) {\n      if (seenVertices.contains(startAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(startAncestor);\n      rootToStart.addFirst(startAncestor);\n      startAncestor = governors.get(startAncestor).get();\n    }\n    if (startAncestor == -1) {\n      rootToStart.addFirst(-1);\n    }\n    int endAncestor = end;\n    seenVertices.clear();\n    while (endAncestor >= 0 && governors.get(endAncestor).isPresent()) {\n      if (seenVertices.contains(endAncestor)) {\n        return Collections.EMPTY_LIST;\n      }\n      seenVertices.add(endAncestor);\n      rootToEnd.addFirst(endAncestor);\n      endAncestor = governors.get(endAncestor).get();\n    }\n    if (endAncestor == -1) {\n      rootToEnd.addFirst(-1);\n    }\n\n    \/\/ Get least common node\n    int leastCommonNodeIndex = (rootToStart.size() == 0 || rootToEnd.size() == 0 || !rootToStart.get(0).equals(rootToEnd.get(0))) ? -1 : 0;\n    for (int i = 1; i < Math.min(rootToStart.size(), rootToEnd.size()); ++i) {\n      if (rootToStart.get(i).equals(rootToEnd.get(i))) {\n        leastCommonNodeIndex = i;\n      }\n    }\n\n    \/\/ Construct the path\n    if (leastCommonNodeIndex < 0) {\n      return Collections.EMPTY_LIST;\n    }\n    List<String> path = new ArrayList<>();\n    for (int i = rootToStart.size() - 1; i > leastCommonNodeIndex; --i) {\n      path.add(selector.apply(sentence).get(rootToStart.get(i)));\n      path.add(\"<-\" + sentence.incomingDependencyLabel(rootToStart.get(i)).orElse(\"dep\") + \"-\");\n    }\n    path.add(selector.apply(sentence).get(rootToStart.get(leastCommonNodeIndex)));\n    for (int i = leastCommonNodeIndex + 1; i < rootToEnd.size(); ++i) {\n      path.add(\"-\" + sentence.incomingDependencyLabel(rootToEnd.get(i)).orElse(\"dep\") + \"->\");\n      path.add(selector.apply(sentence).get(rootToEnd.get(i)));\n    }\n    return path;\n  }\n","new_comment_raw":"@param start The start word, 0-indexed.","old_comment_raw":"@param span The span of the sentence to find the mode element in. This must be entirely contained in the sentence.","label":1,"pre_label":0,"AST_level":11,"line_counts":64,"new_code_token_num":555},{"new_code_raw":"public boolean isSupported(DateTimeFieldType type) { for (int i = 0, isize = size(); i < isize; i++) { if (getFieldType(i) == type) { return true; } } return false; }","old_code_raw":"    public boolean isSupported(DateTimeField field) {\n        for (int i = 0, isize = getFieldSize(); i < isize; i++) {\n            if (getField(i) == field) {\n                return true;\n            }\n        }\n        return false;\n    }\n","new_comment_raw":"@param type the type to check, may be null which returns false","old_comment_raw":"@param field the field to check, may be null which returns false","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":45},{"new_code_raw":"public SQLInsertClause insertOnDuplicateKeyUpdate(RelationalPath<?> entity, Expression<?>... clauses) { SQLInsertClause insert = insert(entity); StringBuilder flag = new StringBuilder(\" on duplicate key update \"); for (int i = 0; i < clauses.length; i++) { flag.append(i > 0 ? \", \" : \"\").append(\"{\" + i + \"}\"); } insert.addFlag(Position.END, ExpressionUtils.template(String.class, flag.toString(), clauses)); return insert; }","old_code_raw":"    public SQLInsertClause insertOnDuplicateKeyUpdate(RelationalPath<?> entity, Expression<?> clause) {\n        SQLInsertClause insert = insert(entity);\n        insert.addFlag(Position.END, ExpressionUtils.template(String.class, \" on duplicate key update {0}\", clause));\n        return insert;\n    }\n","new_comment_raw":"@param clauses clauses","old_comment_raw":"@param clause clause","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":100},{"new_code_raw":"private MessageBatcher getBatcher(final String serviceUrl, String pBatcherName) { String batcherName = null; try { batcherName = new URL(serviceUrl).getHost(); } catch (MalformedURLException e1) { batcherName = serviceUrl; } String absoluteBatcherName = batcherName + \"-\" + pBatcherName; ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".queue.maxMessages\", config.getMaxElementsInPeerReplicationPool()); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".batch.maxMessages\", 250); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".keepAliveTime\", config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".maxThreads\", config.getMaxThreadsForPeerReplication()); return BatcherFactory.createBatcher(absoluteBatcherName, new MessageProcessor<ReplicationTask>() { private String BATCH_URL_PATH = \"apps\/batch\/\";; @Override public void process(List<ReplicationTask> tasks) { if (!tasks.get(0).isBatchingSupported()) { executeSingle(tasks); } else if (!executeBatch(tasks)) { executeSingle(tasks); } } private boolean executeBatch(List<ReplicationTask> tasks) { boolean success = true; boolean done = true; PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList(); for (ReplicationTask task : tasks) { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { logger.warn( \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\", args); continue; } PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance(); instance.setAppName(task.getAppName()); instance.setId(task.getId()); InstanceInfo instanceInfo = task.getInstanceInfo(); if (instanceInfo != null) { String overriddenStatus = (task .getOverriddenStatus() == null ? null : task.getOverriddenStatus().name()); instance.setOverriddenStatus(overriddenStatus); instance.setLastDirtyTimestamp(instanceInfo .getLastDirtyTimestamp()); if (task.shouldReplicateInstanceInfo()) { instance.setInstanceInfo(instanceInfo); } String instanceStatus = instanceInfo .getStatus() == null ? null : instanceInfo.getStatus().name(); instance.setStatus(instanceStatus); } list.addReplicationInstance(instance); } if (list.getList().size() == 0) { return true; } list.setAction(tasks.get(0).getAction()); DynamicCounter.increment(\"Batch_\" + list.getAction().name() + \"_tries\"); do { done = true; ClientResponse response = null; try { response = jerseyApacheClient .resource(serviceUrl) .path(BATCH_URL_PATH) .accept(MediaType.APPLICATION_JSON_TYPE) .type(MediaType.APPLICATION_JSON_TYPE) .post(ClientResponse.class, list); if (isSuccess(response)) { return false; } DynamicCounter.increment(\"Batch_\" + list.getAction().name() + \"_success\"); PeerEurekaNode.ReplicationListResponse batchResponse = response .getEntity(PeerEurekaNode.ReplicationListResponse.class); int ctr = 0; for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse .getResponseList()) { int statusCode = singleResponse .getStatusCode(); if ((!isSuccess(response)) || (singleResponse .getResponseEntity() != null)) { if (singleResponse.getResponseEntity() != null) { tasks.get(ctr) .setPeerInstanceInfo( singleResponse .getResponseEntity()); } tasks.get(ctr) .handleFailure(statusCode); } ++ctr; } done = true; } catch (Throwable e) { if ((isNetworkConnectException(e))) { DynamicCounter.increment(\"Batch_\" + list.getAction().name() + \"_retries\"); done = false; } else { success = false; logger.info( \"Not re-trying this exception because it does not seem to be a network exception\", e); } } finally { if (response != null) { response.close(); } } } while (!done); return success; } private boolean isSuccess(ClientResponse response) { return response.getStatus() < 200 || response.getStatus() >= 300; } private void executeSingle(List<ReplicationTask> tasks) { for (ReplicationTask task : tasks) { boolean done = true; do { done = true; try { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { logger.warn( \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\", args); continue; } DynamicCounter.increment(\"Single_\" + task.getAction().name() + \"_tries\"); int statusCode = task.execute(); if (statusCode < 200 && statusCode > 299) { task.handleFailure(statusCode); } DynamicCounter.increment(\"Single_\" + task.getAction().name() + \"_success\"); } catch (Throwable e) { logger.error( name + task.getAppName() + \"\/\" + task.getId() + \":\" + task.getAction(), e); try { Thread.sleep(RETRY_SLEEP_TIME_MS); } catch (InterruptedException e1) { } if ((isNetworkConnectException(e))) { DynamicCounter.increment(task .getAction().name() + \"_retries\"); done = false; } else { logger.info( \"Not re-trying this exception because it does not seem to be a network exception\", e); } } } while (!done); } } }); }","old_code_raw":"    private MessageBatcher getBatcher(String serviceUrl, Action action) {\n        String batcherName = null;\n        try {\n            batcherName = new URL(serviceUrl).getHost();\n        } catch (MalformedURLException e1) {\n            batcherName = serviceUrl;\n        }\n        String absoluteBatcherName = batcherName + \"-\" + action.name();\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".queue.maxMessages\",\n                config.getMaxElementsInPeerReplicationPool());\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".keepAliveTime\",\n                config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60);\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".maxThreads\",\n                config.getMaxThreadsForPeerReplication());\n\n        return BatcherFactory.createBatcher(absoluteBatcherName,\n                new MessageProcessor<ReplicationTask>() {\n\n                    @Override\n                    public void process(List<ReplicationTask> tasks) {\n                        for (ReplicationTask task : tasks) {\n                            boolean done = true;\n                            do {\n                                done = true;\n                                try {\n                                    Object[] args = {\n                                            task.getAppName(),\n                                            task.getId(),\n                                            task.getAction(),\n                                            new Date(System.currentTimeMillis()),\n                                            new Date(task.getSubmitTime()) };\n                                    if (System.currentTimeMillis()\n                                            - config.getMaxTimeForReplication() > task\n                                            .getSubmitTime()) {\n                                        logger.warn(\n                                                \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\",\n                                                args);\n\n                                        continue;\n                                    }\n                                    task.execute();\n                                } catch (Throwable e) {\n                                    logger.error(\n                                            name + task.getAppName() + \"\/\"\n                                                    + task.getId() + \":\"\n                                                    + task.getAction(), e);\n                                    try {\n                                        Thread.sleep(RETRY_SLEEP_TIME_MS);\n                                    } catch (InterruptedException e1) {\n\n                                    }\n                                    if ((isNetworkConnectException(e))) {\n                                        DynamicCounter.increment(task\n                                                .getAction().name()\n                                                + \"_retries\");\n                                        done = false;\n                                    } else {\n                                        logger.info(\n                                                \"Not re-trying this exception because it does not seem to be a network exception\",\n                                                e);\n                                    }\n                                }\n                            } while (!done);\n                        }\n                    }\n                });\n    }\n","new_comment_raw":"@param action the action that indicates the type of replication event - registrations, heartbeat etc","old_comment_raw":"@param action the action that indicates the type of replication event - registrations, heartbeat etc","label":0,"pre_label":1,"AST_level":20,"line_counts":215,"new_code_token_num":1124},{"new_code_raw":"public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); for(String key : queryParams.keySet()) { String value = queryParams.get(key); if (value != null){ if(b.toString().length() == 0) b.append(\"?\"); else b.append(\"&\"); b.append(escapeString(key)).append(\"=\").append(escapeString(value)); } } String querystring = b.toString(); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getStatusInfo() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getStatusInfo().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getStatusInfo().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param method The request method, one of \"GET\", \"POST\", \"PUT\", and \"DELETE\"","old_comment_raw":"@param method The request method, one of \"GET\", \"POST\", \"PUT\", and \"DELETE\"","label":0,"pre_label":1,"AST_level":16,"line_counts":111,"new_code_token_num":730},{"new_code_raw":"public String getTypeDeclaration(Schema p) { if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return getTypeDeclaration(inner) + \"[]\"; } else if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); \/\/ TODO not sure if the following map\/hash declaration is correct return \"{String, \" + getTypeDeclaration(inner) + \"}\"; } else if (!languageSpecificPrimitives.contains(getSchemaType(p))) { return packageName + \".Model.\" + super.getTypeDeclaration(p); } return super.getTypeDeclaration(p); }","old_code_raw":"    public String getTypeDeclaration(Property p) {\n        if (p instanceof ArrayProperty) {\n            ArrayProperty ap = (ArrayProperty) p;\n            Property inner = ap.getItems();\n            return getTypeDeclaration(inner) + \"[]\";\n        } else if (p instanceof MapProperty) {\n            MapProperty mp = (MapProperty) p;\n            Property inner = mp.getAdditionalProperties();\n            \/\/ TODO not sure if the following map\/hash declaration is correct\n            return \"{String, \" + getTypeDeclaration(inner) + \"}\";\n        } else if (!languageSpecificPrimitives.contains(getSwaggerType(p))) {\n            return packageName + \".Model.\" + super.getTypeDeclaration(p);\n        }\n        return super.getTypeDeclaration(p);\n    }\n","new_comment_raw":"@param p OpenAPI Schema object","old_comment_raw":"@param p Swagger Property object","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":130},{"new_code_raw":"public static SemgrexPattern compile(String semgrex, Env env) { try { SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\")); SemgrexPattern newPattern = parser.Root(); newPattern.env = env; newPattern.patternString = semgrex; return newPattern; } catch (ParseException ex) { throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex); } catch (TokenMgrError er) { throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er); } }","old_code_raw":"  public static SemgrexPattern compile(String semgrex) {\n    try {\n      SemgrexParser parser = new SemgrexParser(new StringReader(semgrex + \"\\n\"));\n      SemgrexPattern newPattern = parser.Root();\n      newPattern.patternString = semgrex;\n      return newPattern;\n    } catch (ParseException ex) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, ex);\n    } catch (TokenMgrError er) {\n      throw new SemgrexParseException(\"Error parsing semgrex pattern \" + semgrex, er);\n    }\n  }\n","new_comment_raw":"@param semgrex the pattern string","old_comment_raw":"@param semgrex the pattern string","label":0,"pre_label":1,"AST_level":9,"line_counts":14,"new_code_token_num":97},{"new_code_raw":"public long set(long instant, int era) { Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); int oldEra = get(instant); if (oldEra != era) { int year = iChronology.year().get(instant); return iChronology.year().set(instant, -year); } else { return instant; } }","old_code_raw":"    public long set(long millis, int era) {\n        super.verifyValueBounds(era, DateTimeConstants.BCE, DateTimeConstants.CE);\n            \n        int oldEra = get(millis);\n        if (oldEra != era) {\n            int year = iChronology.year().get(millis);\n            return iChronology.year().set(millis, -year);\n        } else {\n            return millis;\n        }\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":71},{"new_code_raw":"public static String ensurePrerequisiteAnnotators(String[] annotators) { \/\/ Get an unordered set of annotators Set<String> unorderedAnnotators = new LinkedHashSet<>(); \/\/ linked to preserve order Collections.addAll(unorderedAnnotators, annotators); for (String annotator : annotators) { \/\/ Add the annotator if (!getNamedAnnotators().containsKey(annotator.toLowerCase())) { throw new IllegalArgumentException(\"Unknown annotator: \" + annotator); } \/\/ Add its transitive dependencies unorderedAnnotators.add(annotator.toLowerCase()); if (!Annotator.DEFAULT_REQUIREMENTS.containsKey(annotator.toLowerCase())) { throw new IllegalArgumentException(\"Cannot infer requirements for annotator: \" + annotator); } Queue<String> fringe = new LinkedList<>(Annotator.DEFAULT_REQUIREMENTS.get(annotator.toLowerCase())); int ticks = 0; while (!fringe.isEmpty()) { ticks += 1; if (ticks == 1000000) { throw new IllegalStateException(\"[INTERNAL ERROR] Annotators have a circular dependency.\"); } String prereq = fringe.poll(); unorderedAnnotators.add(prereq); fringe.addAll(Annotator.DEFAULT_REQUIREMENTS.get(prereq.toLowerCase())); } } \/\/ Order the annotators List<String> orderedAnnotators = new ArrayList<>(); while (!unorderedAnnotators.isEmpty()) { boolean somethingAdded = false; \/\/ to make sure the dependencies are satisfiable \/\/ Loop over candidate annotators to add Iterator<String> iter = unorderedAnnotators.iterator(); while (iter.hasNext()) { String candidate = iter.next(); \/\/ Are the requirements satisfied? boolean canAdd = true; for (String prereq : Annotator.DEFAULT_REQUIREMENTS.get(candidate.toLowerCase())) { if (!orderedAnnotators.contains(prereq)) { canAdd = false; break; } } \/\/ If so, add the annotator if (canAdd) { orderedAnnotators.add(candidate); iter.remove(); somethingAdded = true; } } \/\/ Make sure we're making progress every iteration, to prevent an infinite loop if (!somethingAdded) { throw new IllegalArgumentException(\"Unsatisfiable annotator list: \" + StringUtils.join(annotators, \",\")); } } \/\/ Return return StringUtils.join(orderedAnnotators, \",\"); }","old_code_raw":"  public static String ensurePrerequisiteAnnotators(String[] annotators, Properties props) {\n    \/\/ Get an unordered set of annotators\n    Set<String> unorderedAnnotators = new LinkedHashSet<>();  \/\/ linked to preserve order\n    Collections.addAll(unorderedAnnotators, annotators);\n    for (String annotator : annotators) {\n      \/\/ Add the annotator\n      if (!getNamedAnnotators().containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Unknown annotator: \" + annotator);\n      }\n\n      \/\/ Add its transitive dependencies\n      unorderedAnnotators.add(annotator.toLowerCase());\n      if (!Annotator.DEFAULT_REQUIREMENTS.containsKey(annotator.toLowerCase())) {\n        throw new IllegalArgumentException(\"Cannot infer requirements for annotator: \" + annotator);\n      }\n      Queue<String> fringe = new LinkedList<>(Annotator.DEFAULT_REQUIREMENTS.get(annotator.toLowerCase()));\n      int ticks = 0;\n      while (!fringe.isEmpty()) {\n        ticks += 1;\n        if (ticks == 1000000) {\n          throw new IllegalStateException(\"[INTERNAL ERROR] Annotators have a circular dependency.\");\n        }\n        String prereq = fringe.poll();\n        unorderedAnnotators.add(prereq);\n        fringe.addAll(Annotator.DEFAULT_REQUIREMENTS.get(prereq.toLowerCase()));\n      }\n    }\n\n    \/\/ Order the annotators\n    List<String> orderedAnnotators = new ArrayList<>();\n    while (!unorderedAnnotators.isEmpty()) {\n      boolean somethingAdded = false;  \/\/ to make sure the dependencies are satisfiable\n      \/\/ Loop over candidate annotators to add\n      Iterator<String> iter = unorderedAnnotators.iterator();\n      while (iter.hasNext()) {\n        String candidate = iter.next();\n        \/\/ Are the requirements satisfied?\n        boolean canAdd = true;\n        for (String prereq : Annotator.DEFAULT_REQUIREMENTS.get(candidate.toLowerCase())) {\n          if (!orderedAnnotators.contains(prereq)) {\n            canAdd = false;\n            break;\n          }\n        }\n        \/\/ If so, add the annotator\n        if (canAdd) {\n          orderedAnnotators.add(candidate);\n          iter.remove();\n          somethingAdded = true;\n        }\n      }\n      \/\/ Make sure we're making progress every iteration, to prevent an infinite loop\n      if (!somethingAdded) {\n        throw new IllegalArgumentException(\"Unsatisfiable annotator list: \" + StringUtils.join(annotators, \",\"));\n      }\n    }\n\n    \/\/ Remove depparse + parse -- these are redundant\n    if (orderedAnnotators.contains(STANFORD_PARSE) && !ArrayUtils.contains(annotators, STANFORD_DEPENDENCIES)) {\n      orderedAnnotators.remove(STANFORD_DEPENDENCIES);\n    }\n\n    \/\/ Tweak the properties, if necessary\n    \/\/ (set the mention annotator to use dependency trees, if appropriate)\n    if (orderedAnnotators.contains(Annotator.STANFORD_MENTION) && !orderedAnnotators.contains(Annotator.STANFORD_PARSE) &&\n        !props.containsKey(\"coref.md.type\")) {\n      props.setProperty(\"coref.md.type\", \"dep\");\n    }\n    \/\/ (ensure regexner is after ner)\n    if (orderedAnnotators.contains(Annotator.STANFORD_NER) && orderedAnnotators.contains(STANFORD_REGEXNER)) {\n      orderedAnnotators.remove(STANFORD_REGEXNER);\n      int nerIndex = orderedAnnotators.indexOf(Annotator.STANFORD_NER);\n      orderedAnnotators.add(nerIndex + 1, STANFORD_REGEXNER);\n    }\n    \/\/ (ensure coref is before openie)\n    if (orderedAnnotators.contains(Annotator.STANFORD_COREF) && orderedAnnotators.contains(STANFORD_OPENIE)) {\n      int maxIndex = Math.max(\n          orderedAnnotators.indexOf(STANFORD_OPENIE),\n          orderedAnnotators.indexOf(STANFORD_COREF)\n          );\n      if (Objects.equals(orderedAnnotators.get(maxIndex), STANFORD_OPENIE)) {\n        orderedAnnotators.add(maxIndex, STANFORD_COREF);\n        orderedAnnotators.remove(STANFORD_COREF);\n      } else {\n        orderedAnnotators.add(maxIndex + 1, STANFORD_OPENIE);\n        orderedAnnotators.remove(STANFORD_OPENIE);\n      }\n    }\n\n    \/\/ Return\n    return StringUtils.join(orderedAnnotators, \",\");\n  }\n","new_comment_raw":"@param annotators The annotators the user has requested.","old_comment_raw":"@param annotators The annotators the user has requested.","label":0,"pre_label":1,"AST_level":13,"line_counts":61,"new_code_token_num":417},{"new_code_raw":"public PumpEnactResult setTempBasalAbsolute(Double absoluteRate, Integer durationInMinutes, boolean force) { Double rateAfterConstraints = applyBasalConstraints(absoluteRate); PumpEnactResult result = activePump.setTempBasalAbsolute(rateAfterConstraints, durationInMinutes, force); if (Config.logCongigBuilderActions) log.debug(\"setTempBasalAbsolute rate: \" + rateAfterConstraints + \" durationInMinutes: \" + durationInMinutes + \" success: \" + result.success + \" enacted: \" + result.enacted); return result; }","old_code_raw":"    public PumpEnactResult setTempBasalAbsolute(Double absoluteRate, Integer durationInMinutes) {\n        Double rateAfterConstraints = applyBasalConstraints(absoluteRate);\n        PumpEnactResult result = activePump.setTempBasalAbsolute(rateAfterConstraints, durationInMinutes);\n        if (Config.logCongigBuilderActions)\n            log.debug(\"setTempBasalAbsolute rate: \" + rateAfterConstraints + \" durationInMinutes: \" + durationInMinutes + \" success: \" + result.success + \" enacted: \" + result.enacted);\n        return result;\n    }\n","new_comment_raw":"@param absoluteRate","old_comment_raw":"@param absoluteRate","label":0,"pre_label":1,"AST_level":13,"line_counts":8,"new_code_token_num":77},{"new_code_raw":"public final static AtmosphereRequest cloneRequest(HttpServletRequest request, boolean loadInMemory, boolean copySession, boolean isDestroyable, boolean createSession) { Builder b; HttpServletRequest r; Cookie[] cs = request.getCookies(); Set<Cookie> hs = Collections.synchronizedSet(new HashSet()); if (cs != null) { for (Cookie c : cs) { hs.add(c); } } boolean isWrapped = false; if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) { b = AtmosphereRequest.class.cast(request).b; isWrapped = true; } else { b = new Builder(); b.request(request); } HttpSession session = null; if (copySession) { session = request.getSession(createSession); if (session != null) { session = new FakeHttpSession(session); } else { session = new FakeHttpSession(\"\", null, System.currentTimeMillis(), -1); } } b.servletPath(request.getServletPath()) .pathInfo(request.getPathInfo()) .contextPath(request.getContextPath()) .requestURI(request.getRequestURI()) .requestURL(request.getRequestURL().toString()) .method(request.getMethod()) .serverName(request.getServerName()) .serverPort(request.getServerPort()) .remoteAddr(request.getRemoteAddr()) .remoteHost(request.getRemoteHost()) .remotePort(request.getRemotePort()) .destroyable(isDestroyable) .cookies(hs) .session(session) .principal(request.getUserPrincipal()) .authType(request.getAuthType()) .isSSecure(request.isSecure()); if (loadInMemory) { String s = (String) attributeWithoutException(request, FrameworkConfig.THROW_EXCEPTION_ON_CLONED_REQUEST); boolean throwException = s != null && Boolean.parseBoolean(s); r = new NoOpsRequest(throwException); if (isWrapped) { load(b.request, b); } else { load(request, b); } b.request(r); } return isWrapped ? AtmosphereRequest.class.cast(request) : b.build(); }","old_code_raw":"    public final static AtmosphereRequest cloneRequest(HttpServletRequest request, boolean loadInMemory, boolean copySession, boolean isDestroyable) {\n        Builder b;\n        HttpServletRequest r;\n\n        Cookie[] cs = request.getCookies();\n        Set<Cookie> hs = Collections.synchronizedSet(new HashSet());\n        if (cs != null) {\n            for (Cookie c : cs) {\n                hs.add(c);\n            }\n        }\n\n        boolean isWrapped = false;\n        if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) {\n            b = AtmosphereRequest.class.cast(request).b;\n            isWrapped = true;\n        } else {\n            b = new Builder();\n            b.request(request);\n        }\n\n        HttpSession session = null;\n        if (copySession) {\n            session = request.getSession(true);\n            if (session != null) {\n                session = new FakeHttpSession(session);\n            }\n        }\n\n        b.servletPath(request.getServletPath())\n                .pathInfo(request.getPathInfo())\n                .contextPath(request.getContextPath())\n                .requestURI(request.getRequestURI())\n                .requestURL(request.getRequestURL().toString())\n                .method(request.getMethod())\n                .serverName(request.getServerName())\n                .serverPort(request.getServerPort())\n                .remoteAddr(request.getRemoteAddr())\n                .remoteHost(request.getRemoteHost())\n                .remotePort(request.getRemotePort())\n                .destroyable(isDestroyable)\n                .cookies(hs)\n                .session(session)\n                .principal(request.getUserPrincipal())\n                .authType(request.getAuthType())\n                .isSSecure(request.isSecure());\n\n        if (loadInMemory) {\n            String s = (String) attributeWithoutException(request, FrameworkConfig.THROW_EXCEPTION_ON_CLONED_REQUEST);\n            boolean throwException = s != null && Boolean.parseBoolean(s);\n            r = new NoOpsRequest(throwException);\n            if (isWrapped) {\n                load(b.request, b);\n            } else {\n                load(request, b);\n            }\n            b.request(r);\n        }\n\n        return isWrapped ? AtmosphereRequest.class.cast(request) : b.build();\n    }\n","new_comment_raw":"@param request  HttpServletRequest","old_comment_raw":"@param request HttpServletRequest","label":0,"pre_label":1,"AST_level":10,"line_counts":64,"new_code_token_num":370},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); p.setColor(Color.WHITE); \/\/ Key shadow p.setShadowLayer(shadowBlur, 0, keyShadowDistance, ShadowGenerator.KEY_SHADOW_ALPHA << 24); c.drawRoundRect(bounds, corner, corner, p); \/\/ Ambient shadow p.setShadowLayer(shadowBlur, 0, 0, ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA)); c.drawRoundRect(bounds, corner, corner, p); p.clearShadowLayer(); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, int width, int height) {\n        Resources res = mContext.getResources();\n\n        ShadowGenerator.Builder builder = new ShadowGenerator.Builder(Color.WHITE);\n        builder.shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        builder.radius = res.getDimension(R.dimen.widget_preview_corner_radius);\n        builder.keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n\n        builder.bounds.set(builder.shadowBlur, builder.shadowBlur,\n                width - builder.shadowBlur,\n                height - builder.shadowBlur - builder.keyShadowDistance);\n        builder.drawShadow(c);\n        return builder.bounds;\n    }\n","new_comment_raw":"@param maxPreviewWidth width of the preview on either workspace or tray","old_comment_raw":"@param maxPreviewWidth width of the preview on either workspace or tray","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":156},{"new_code_raw":"private boolean isAncestorOf(Object object1, Object object2) { if (object2 == null) return false; Object parent = getParent(object2); if (parent == object1) return true; return isAncestorOf(object1, parent); }","old_code_raw":"\tprivate boolean isAncestorOf(Object node, Object target) {\r\n\t\tif (target == null) return false;\r\n\t\tObject parent = getParent(target);\r\n\t\tif (parent == node) return true;\r\n\t\treturn isAncestorOf(node, parent);\r\n   }\r\n","new_comment_raw":"@param object2 The second object to be tested.","old_comment_raw":"@param target The target node.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":43},{"new_code_raw":"public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException { Object localVarPostBody = body; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/composite\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"*\/*\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException {\n    Object localVarPostBody = outerComposite;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/composite\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*\/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param body Input composite as post body (optional)","old_comment_raw":"@param outerComposite Input composite as post body (optional)","label":1,"pre_label":0,"AST_level":8,"line_counts":31,"new_code_token_num":171},{"new_code_raw":"public ApiResponse<Order> placeOrderWithHttpInfo(Order order) throws ApiException { Object localVarPostBody = order; \/\/ verify the required parameter 'order' is set if (order == null) { throw new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\"); } \/\/ create path and map variables String localVarPath = \"\/store\/order\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ApiResponse<Order> placeOrderWithHttpInfo(Order body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/store\/order\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param order order placed for purchasing the pet (required)","old_comment_raw":"@param body order placed for purchasing the pet (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":203},{"new_code_raw":"public Builder(DataFetcherResult<T> existing) { data = existing.getData(); localContext = existing.getLocalContext(); errors.addAll(existing.getErrors()); mapRelativeErrors = existing.isMapRelativeErrors(); }","old_code_raw":"        public Builder(T data) {\n            this.data = data;\n        }\n","new_comment_raw":"@param  the type of the result","old_comment_raw":"@param the type of the result","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":36},{"new_code_raw":"public float get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"    public float get(WithAttributes attributes) {\r\n        return attributes.getAttributes().get(this);\r\n    }\r\n","new_comment_raw":"@param withAttributes an object containing an AttributeMap","old_comment_raw":"@param attributes an object containing an AttributeMap","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"static OptiqConnection getConnection(SchemaSpec schemaSpec) throws ClassNotFoundException, SQLException { Class.forName(\"net.hydromatic.optiq.jdbc.Driver\"); Connection connection = DriverManager.getConnection(\"jdbc:optiq:\"); OptiqConnection optiqConnection = connection.unwrap(OptiqConnection.class); final SchemaPlus rootSchema = optiqConnection.getRootSchema(); switch (schemaSpec) { case JDBC_FOODMART: addSchema(rootSchema, schemaSpec); break; case CLONE_FOODMART: case JDBC_FOODMART_WITH_LATTICE: addSchema(rootSchema, SchemaSpec.JDBC_FOODMART); addSchema(rootSchema, schemaSpec); break; default: throw new AssertionError(\"unknown schema \" + schemaSpec); } optiqConnection.setSchema(\"foodmart2\"); return optiqConnection; }","old_code_raw":"  static OptiqConnection getConnection(boolean withClone)\n      throws ClassNotFoundException, SQLException {\n    Class.forName(\"net.hydromatic.optiq.jdbc.Driver\");\n    Connection connection = DriverManager.getConnection(\"jdbc:optiq:\");\n    OptiqConnection optiqConnection =\n        connection.unwrap(OptiqConnection.class);\n    final SchemaPlus rootSchema = optiqConnection.getRootSchema();\n    addSchema(rootSchema, SchemaSpec.JDBC_FOODMART);\n    if (withClone) {\n      addSchema(rootSchema, SchemaSpec.CLONE_FOODMART);\n    }\n    optiqConnection.setSchema(\"foodmart2\");\n    return optiqConnection;\n  }\n","new_comment_raw":"@param schemaSpec Schema specification; whether to create a \"foodmart2\" schema as in-memory clone","old_comment_raw":"@param withClone Whether to create a \"foodmart2\" schema as in-memory clone","label":1,"pre_label":0,"AST_level":8,"line_counts":23,"new_code_token_num":121},{"new_code_raw":"public static BooleanExpression fuzzyLike(Path<String> path, String value, int maxEdits) { Term term = new Term(path.getMetadata().getName(), value); return new QueryElement(new FuzzyQuery(term, maxEdits)); }","old_code_raw":"    public static BooleanExpression fuzzyLike(Path<String> path, String value, float minimumSimilarity) {\n        Term term = new Term(path.getMetadata().getName(), value);\n        return new QueryElement(new FuzzyQuery(term, minimumSimilarity));\n    }\n","new_comment_raw":"@param maxEdits","old_comment_raw":"@param minimumSimilarity","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":46},{"new_code_raw":"public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean visible) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll, visible); if (foundAnyMatchingView){ return true; } } return false; }","old_code_raw":"\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n","new_comment_raw":"@param scroll whether scrolling should be performed","old_comment_raw":"@param scroll whether scrolling should be performed","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":77},{"new_code_raw":"public void updatePetWithForm (Long petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling updatePetWithForm\", new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\")); } \/\/ create path and map variables String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"application\/x-www-form-urlencoded\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); if (name != null) { localVarBuilder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8); } if (status != null) { localVarBuilder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8); } HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params formParams.put(\"name\", ApiInvoker.parameterToString(name)); formParams.put(\"status\", ApiInvoker.parameterToString(status)); } String[] authNames = new String[] { \"petstore_auth\" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public void updatePetWithForm (String petId, String name, String status) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling updatePetWithForm\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling updatePetWithForm\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"application\/x-www-form-urlencoded\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (name != null) {\n        localVarBuilder.addTextBody(\"name\", ApiInvoker.parameterToString(name), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (status != null) {\n        localVarBuilder.addTextBody(\"status\", ApiInvoker.parameterToString(status), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      formParams.put(\"name\", ApiInvoker.parameterToString(name));\n      formParams.put(\"status\", ApiInvoker.parameterToString(status));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return ;\n      } else {\n         return ;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n       if (ex.getCause() instanceof VolleyError) {\n         VolleyError volleyError = (VolleyError)ex.getCause();\n         if (volleyError.networkResponse != null) {\n           throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n         }\n       }\n       throw ex;\n    } catch (TimeoutException ex) {\n       throw ex;\n    }\n  }\n","new_comment_raw":"@param name Updated name of the pet","old_comment_raw":"@param name Updated name of the pet","label":0,"pre_label":1,"AST_level":11,"line_counts":65,"new_code_token_num":475},{"new_code_raw":"public float distanceTo(float x, float y, float z) { final float a = this.x - x; final float b = this.y - y; final float c = this.z - z; return (float) Math.sqrt(a * a + b * b + c * c); }","old_code_raw":"\tpublic double distanceTo(double x, double y, double z) {\n\t\tfinal double a = this.x - x;\n\t\tfinal double b = this.y - y;\n\t\tfinal double c = this.z - z;\n\t\treturn Math.sqrt(a * a + b * b + c * c);\n\t}\n","new_comment_raw":"@param float z The point z coordinate.","old_comment_raw":"@param double z The point z coordinate.","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":59},{"new_code_raw":"public int bind(PreparedStatement statement, QueryParameters qp, SharedSessionContractImplementor session, int position) throws SQLException { Type type = qp.getPositionalParameterTypes()[hqlPosition]; Object value = qp.getPositionalParameterValues()[hqlPosition]; type.nullSafeSet( statement, value, position, session ); return type.getColumnSpan( session.getFactory() ); }","old_code_raw":"\tpublic int bind(PreparedStatement statement, QueryParameters qp, SessionImplementor session, int position) throws SQLException {\n\t\tType type = qp.getPositionalParameterTypes()[hqlPosition];\n\t\tObject value = qp.getPositionalParameterValues()[hqlPosition];\n\n\t\ttype.nullSafeSet( statement, value, position, session );\n\t\treturn type.getColumnSpan( session.getFactory() );\n\t}\n","new_comment_raw":"@param position The position from which to start binding value(s).","old_comment_raw":"@param position The position from which to start binding value(s).","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":62},{"new_code_raw":"public boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) { boolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible); return found; }","old_code_raw":"\tpublic boolean searchButton(String text, int minimumNumberOfMatches, boolean visible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, visible);\n\t\treturn found;\n\t}\n","new_comment_raw":"@param onlyVisible  true if only  Buttons visible on the screen should be searched","old_comment_raw":"@param visible true if only Buttons visible on the screen should be searched","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"private String terminalToShowWhenClosing(String handle) { int terminalClosing = terminals_.indexOfTerminal(handle); if (terminalClosing > 0) return terminals_.terminalHandleAtIndex(terminalClosing - 1); else if (terminalClosing + 1 < terminals_.terminalCount()) return terminals_.terminalHandleAtIndex(terminalClosing + 1); else return null; }","old_code_raw":"   private int terminalToShowWhenClosing(int terminalClosing)\n   {\n      if (terminalClosing > 0)\n         return terminalClosing - 1;\n      else if (terminalClosing + 1 < getTerminalCount())\n         return terminalClosing + 1;\n      else\n         return -1;\n   }\n","new_comment_raw":"@param handle terminal being closed","old_comment_raw":"@param terminalClosing index of terminal being closed","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":55},{"new_code_raw":"public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) { Map<String, MergedFields> subFields = new LinkedHashMap<>(); List<String> visitedFragments = new ArrayList<>(); this.collectFields(parameters, selectionSet, visitedFragments, subFields); return newMergedSelectionSet().subFields(subFields).build(); }","old_code_raw":"    private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, MergedFields> fields) {\n\n        for (Selection selection : selectionSet.getSelections()) {\n            if (selection instanceof Field) {\n                collectField(parameters, fields, (Field) selection);\n            } else if (selection instanceof InlineFragment) {\n                collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection);\n            } else if (selection instanceof FragmentSpread) {\n                collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection);\n            }\n        }\n    }\n","new_comment_raw":"@param parameters the parameters to this method","old_comment_raw":"@param parameters the parameters to this method","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer[] preparers, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException { final ResultSet[] resultSets = new ResultSet[multiQuery.length]; final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length]; try { for (int i = 0; i < multiQuery.length; i++) { final String query = multiQuery[i]; if (LOGGER.isTraceEnabled()) { LOGGER.trace(\"running '{}'\", query); } final PreparedStatement statement = createPreparedStatement(query); preparedStatements[i] = statement; preparers[i].accept(statement); resultSets[i] = statement.executeQuery(); } if (resultConsumer != null) { resultConsumer.accept(resultSets); } } finally { for (ResultSet rs: resultSets) { if (rs != null) { try { rs.close(); } catch (Exception ei) { } } } } return this; }","old_code_raw":"    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = createPreparedStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n","new_comment_raw":"@param resultConsumer the consumer of the query results","old_comment_raw":"@param resultConsumer the consumer of the query results","label":0,"pre_label":1,"AST_level":10,"line_counts":33,"new_code_token_num":181},{"new_code_raw":"public static long toNanoOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration); } return ((Duration) value).toNanos(); } \/\/ TODO only needed for SQL Server\/Oracle, where we don't produce Duration right away; \/\/ this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return time.toNanoOfDay(); }","old_code_raw":"    public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) {\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster !=null) {\n            time = time.with(adjuster);\n        }\n        return time.toNanoOfDay();\n    }\n","new_comment_raw":"@param acceptLargeValues whether to accept values less than 00:00:00 and larger than 24:00:00 or not","old_comment_raw":"@param adjuster the optional component that adjusts the local date value before obtaining the epoch day; may be null if no adjustment is necessary","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":141},{"new_code_raw":"public static Point getCanvasSpriteLocation(Client client, Graphics2D graphics, LocalPoint localLocation, SpritePixels sprite, int zOffset) { int plane = client.getPlane(); Point p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset); if (p == null) { return null; } int xOffset = p.getX() - sprite.getWidth() \/ 2; int yOffset = p.getY() - sprite.getHeight() \/ 2; return new Point(xOffset, yOffset); }","old_code_raw":"\tpublic static Point getCanvasSpriteLocation(Client client, Graphics2D graphics, Point localLocation, SpritePixels sprite, int zOffset)\n\t{\n\t\tint plane = client.getPlane();\n\n\t\tPoint p = Perspective.worldToCanvas(client, localLocation.getX(), localLocation.getY(), plane, zOffset);\n\n\t\tif (p == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint xOffset = p.getX() - sprite.getWidth() \/ 2;\n\t\tint yOffset = p.getY() - sprite.getHeight() \/ 2;\n\n\t\treturn new Point(xOffset, yOffset);\n\t}\n","new_comment_raw":"@param client","old_comment_raw":"@param client","label":0,"pre_label":1,"AST_level":7,"line_counts":17,"new_code_token_num":98},{"new_code_raw":"public Mono<Client> call123testSpecialTags(Client body) throws RestClientException { Object postBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling call123testSpecialTags\"); } String path = UriComponentsBuilder.fromPath(\"\/another-fake\/dummy\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<Client> call123testSpecialTags(Client client) throws RestClientException {\n        Object postBody = client;\n        \n        \/\/ verify the required parameter 'client' is set\n        if (client == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling call123testSpecialTags\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"\/another-fake\/dummy\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param body client model","old_comment_raw":"@param client client model","label":1,"pre_label":0,"AST_level":8,"line_counts":29,"new_code_token_num":205},{"new_code_raw":"public Actions sendKeys(CharSequence... keys) { if (isBuildingActions()) { action.addAction(new SendKeysAction(jsonKeyboard, jsonMouse, null, keys)); return this; } for (CharSequence key : keys) { key.codePoints().forEach(codePoint -> { tick(defaultKeyboard.createKeyDown(codePoint)); tick(defaultKeyboard.createKeyUp(codePoint)); }); } return this; }","old_code_raw":"  public Actions sendKeys(CharSequence... keysToSend) {\n    return this.sendKeys(null, keysToSend);\n  }\n","new_comment_raw":"@param keys The keys.","old_comment_raw":"@param keysToSend The keys.","label":1,"pre_label":0,"AST_level":12,"line_counts":16,"new_code_token_num":78},{"new_code_raw":"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param authNames The authentications to apply","old_comment_raw":"@param authNames The authentications to apply","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public Action timedout(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { logger.trace(\"Timing out {}\", req); if (trackActiveRequest(req) && completeLifecycle(req.resource(), false)) { config.framework().notify(Action.TYPE.TIMEOUT, req, res); } return timedoutAction; }","old_code_raw":"    public Action timedout(AtmosphereRequest request, AtmosphereResponse response)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl r = null;\n\n        try {\n            SessionTimeoutSupport.restoreTimeout(request);\n\n            if (trackActiveRequest) {\n                long l = (Long) request.getAttribute(MAX_INACTIVE);\n                if (l == -1) {\n                    \/\/ The closedDetector closed the connection.\n                    return timedoutAction;\n                }\n                request.setAttribute(MAX_INACTIVE, (long) -1);\n            }\n\n            logger.debug(\"Timing out the connection for request {}\", request);\n\n            \/\/ Something went wrong.\n            if (request == null || response == null) {\n                logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response);\n                return timedoutAction;\n            }\n\n            r = (AtmosphereResourceImpl) request.getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (r != null && r.isCancelled()) {\n                return cancelledAction;\n            }\n\n            if (r == null) {\n                logger.debug(\"AtmosphereResource was null, failed to timeout AtmosphereRequest {}\", request);\n            }\n\n            if (r != null && r.getAtmosphereResourceEvent().isSuspended()) {\n                r.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n                Broadcaster b = r.getBroadcaster();\n                if (b instanceof DefaultBroadcaster) {\n                    ((DefaultBroadcaster) b).broadcastOnResume(r);\n                }\n\n                if (request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT) != null) {\n                    r.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                            (Boolean) request.getAttribute(ApplicationConfig.RESUMED_ON_TIMEOUT));\n                }\n\n                invokeAtmosphereHandler(r);\n            }\n        } catch (Throwable t) {\n            logger.error(\"failed to timeout resource {}\", r, t);\n        } finally {\n            config.framework().notify(Action.TYPE.TIMEOUT, request, response);\n            try {\n                if (r != null) {\n                    r.notifyListeners();\n                    r.setIsInScope(false);\n                    r.cancel();\n                }\n            } catch (Throwable t) {\n                logger.trace(\"timedout\", t);\n            } finally {\n                try {\n                    response.getOutputStream().close();\n                } catch (Throwable t) {\n                    try {\n                        response.getWriter().close();\n                    } catch (Throwable t2) {\n                    }\n                }\n\n                if (r != null) {\n                    r._destroy();\n                }\n            }\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"@param req the  AtmosphereRequest","old_comment_raw":"@param request the AtmosphereRequest","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":67},{"new_code_raw":"public static UserAuthenticator createAuthenticator(final DrillConfig config, ScanResult scan) throws DrillbitStartupException { final String authImplConfigured = config.getString(USER_AUTHENTICATOR_IMPL); if (Strings.isNullOrEmpty(authImplConfigured)) { throw new DrillbitStartupException(String.format(\"Invalid value '%s' for BOOT option '%s'\", authImplConfigured, USER_AUTHENTICATOR_IMPL)); } final Collection<Class<? extends UserAuthenticator>> authImpls = scan.getImplementations(UserAuthenticator.class); for(Class<? extends UserAuthenticator> clazz : authImpls) { final UserAuthenticatorTemplate template = clazz.getAnnotation(UserAuthenticatorTemplate.class); if (template == null) { logger.warn(\"{} doesn't have {} annotation. Skipping.\", clazz.getCanonicalName(), UserAuthenticatorTemplate.class); continue; } if (Strings.isNullOrEmpty(template.type())) { logger.warn(\"{} annotation doesn't have valid type field for UserAuthenticator implementation {}. Skipping..\", UserAuthenticatorTemplate.class, clazz.getCanonicalName()); continue; } if (template.type().equalsIgnoreCase(authImplConfigured)) { Constructor<?> validConstructor = null; for (Constructor<?> c : clazz.getConstructors()) { if (c.getParameterTypes().length == 0) { validConstructor = c; break; } } if (validConstructor == null) { logger.warn(\"Skipping UserAuthenticator implementation class '{}' since it doesn't \" + \"implement a constructor [{}()]\", clazz.getCanonicalName(), clazz.getName()); continue; } \/\/ Instantiate authenticator and initialize it try { final UserAuthenticator authenticator = clazz.newInstance(); authenticator.setup(config); return authenticator; } catch(IllegalArgumentException | IllegalAccessException | InstantiationException e) { throw new DrillbitStartupException( String.format(\"Failed to create and initialize the UserAuthenticator class '%s'\", clazz.getCanonicalName()), e); } } } String errMsg = String.format(\"Failed to find the implementation of '%s' for type '%s'\", UserAuthenticator.class.getCanonicalName(), authImplConfigured); logger.error(errMsg); throw new DrillbitStartupException(errMsg); }","old_code_raw":"  public static UserAuthenticator createAuthenticator(final DrillConfig config) throws DrillbitStartupException {\n    final String authImplConfigured = config.getString(USER_AUTHENTICATOR_IMPL);\n\n    if (Strings.isNullOrEmpty(authImplConfigured)) {\n      throw new DrillbitStartupException(String.format(\"Invalid value '%s' for BOOT option '%s'\", authImplConfigured,\n          USER_AUTHENTICATOR_IMPL));\n    }\n\n    final Collection<Class<? extends UserAuthenticator>> authImpls =\n        PathScanner.scanForImplementations(UserAuthenticator.class,\n            config.getStringList(ExecConstants.USER_AUTHENTICATOR_IMPL_PACKAGES));\n\n    for(Class<? extends UserAuthenticator> clazz : authImpls) {\n      final UserAuthenticatorTemplate template = clazz.getAnnotation(UserAuthenticatorTemplate.class);\n      if (template == null) {\n        logger.warn(\"{} doesn't have {} annotation. Skipping.\", clazz.getCanonicalName(), UserAuthenticatorTemplate.class);\n        continue;\n      }\n\n      if (Strings.isNullOrEmpty(template.type())) {\n        logger.warn(\"{} annotation doesn't have valid type field for UserAuthenticator implementation {}. Skipping..\",\n            UserAuthenticatorTemplate.class, clazz.getCanonicalName());\n        continue;\n      }\n\n      if (template.type().equalsIgnoreCase(authImplConfigured)) {\n        Constructor<?> validConstructor = null;\n        for (Constructor<?> c : clazz.getConstructors()) {\n          if (c.getParameterTypes().length == 0) {\n            validConstructor = c;\n            break;\n          }\n        }\n\n        if (validConstructor == null) {\n          logger.warn(\"Skipping UserAuthenticator implementation class '{}' since it doesn't \" +\n              \"implement a constructor [{}()]\", clazz.getCanonicalName(), clazz.getName());\n          continue;\n        }\n\n        \/\/ Instantiate authenticator and initialize it\n        try {\n          final UserAuthenticator authenticator = clazz.newInstance();\n          authenticator.setup(config);\n          return authenticator;\n        } catch(IllegalArgumentException | IllegalAccessException | InstantiationException e) {\n          throw new DrillbitStartupException(\n              String.format(\"Failed to create and initialize the UserAuthenticator class '%s'\",\n                  clazz.getCanonicalName()), e);\n        }\n      }\n    }\n\n    String errMsg = String.format(\"Failed to find the implementation of '%s' for type '%s'\",\n        UserAuthenticator.class.getCanonicalName(), authImplConfigured);\n    logger.error(errMsg);\n    throw new DrillbitStartupException(errMsg);\n  }\n","new_comment_raw":"@param config DrillConfig containing BOOT options.","old_comment_raw":"@param config DrillConfig containing BOOT options.","label":0,"pre_label":1,"AST_level":13,"line_counts":58,"new_code_token_num":393},{"new_code_raw":"File getBaseDir(final File file1, final File file2) { if (file1 == null || file2 == null) { return null; } final Iterator bases = getParents(file1).iterator(); final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator(); File result = null; while (bases.hasNext() && fileParents.hasNext()) { File next = (File) bases.next(); if (next.equals(fileParents.next())) { result = next; } else { break; } } return result; }","old_code_raw":"    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n","new_comment_raw":"@param file1 One of the files, for which the common base directory is being sought, may be null.","old_comment_raw":"@param base the current base directory, may be null.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":105},{"new_code_raw":"public static ENumber<Byte> create(byte i){ if (i >= 0 && i < 256){ return bytes[i]; }else{ return new ENumberConst<Byte>(Byte.class, Byte.valueOf(i)); } }","old_code_raw":"    public static ENumber<Integer> create(int i){\n        if (i >= 0 && i < 256){\n            return ints[i];\n        }else{\n            return new ENumberConst<Integer>(Integer.class, Integer.valueOf(i));\n        }\n    }\n","new_comment_raw":"@param val","old_comment_raw":"@param val","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":46},{"new_code_raw":"public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws RestClientException { Object postBody = body; String path = UriComponentsBuilder.fromPath(\"\/fake\/outer\/composite\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"*\/*\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws RestClientException {\n        Object postBody = outerComposite;\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake\/outer\/composite\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*\/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param body Input composite as post body","old_comment_raw":"@param outerComposite Input composite as post body","label":1,"pre_label":0,"AST_level":8,"line_counts":22,"new_code_token_num":160},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\" .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); if (additionalMetadata != null) localVarFormParams.put(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) localVarFormParams.put(\"requiredFile\", requiredFile); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"multipart\/form-data\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"petstore_auth\" }; GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart\/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param petId ID of pet to update (required)","old_comment_raw":"@param petId ID of pet to update (required)","label":0,"pre_label":1,"AST_level":9,"line_counts":46,"new_code_token_num":324},{"new_code_raw":"private static String findValidPath(EnvVar... vars) { for (EnvVar var : vars) { String path; if (var.mIsSysProp) { path = checkPath(System.getProperty(var.mName)); if (path != null) { return path; } } if (var.mIsEnvVar) { path = checkPath(System.getenv(var.mName)); if (path != null) { return path; } } } return null; }","old_code_raw":"    private static String findValidPath(String... names) {\n        for (String name : names) {\n            String path;\n            if (name.indexOf('.') != -1) {\n                path = System.getProperty(name);\n            } else {\n                path = System.getenv(name);\n            }\n\n            if (path != null) {\n                File f = new File(path);\n                if (f.isDirectory()) {\n                    return path;\n                }\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"@param vars The variables to check. Order does matter.","old_comment_raw":"@param names","label":1,"pre_label":0,"AST_level":11,"line_counts":22,"new_code_token_num":83},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new FilePendingMessageCursor(name, tmpStorage); }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new FilePendingMessageCursor(name, tmpStorage);\n    }\n","new_comment_raw":"@param tmpStorage","old_comment_raw":"@param tmpStorage","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"private Connection createConnection(ActiveMQConnectionRequestInfo connectionRequestInfo) throws JMSException { try { if (connectionRequestInfo.isUseInboundSessionEnabled()) { return new InboundConnectionProxy(); } if (manager == null) { throw new JMSException(\"No JCA ConnectionManager configured! Either enable UseInboundSessionEnabled or get your JCA container to configure one.\"); } return (Connection)manager.allocateConnection(factory, connectionRequestInfo); } catch (ResourceException e) { \/\/ Throw the root cause if it was a JMSException.. if (e.getCause() instanceof JMSException) { throw (JMSException)e.getCause(); } LOG.debug(\"Connection could not be created:\", e); throw new JMSException(e.getMessage()); } }","old_code_raw":"    private Connection createConnection(ActiveMQConnectionRequestInfo info) throws JMSException {\n        try {\n            if (info.isUseInboundSessionEnabled()) {\n                return new InboundConnectionProxy();\n            }\n            if (manager == null) {\n                throw new JMSException(\"No JCA ConnectionManager configured! Either enable UseInboundSessionEnabled or get your JCA container to configure one.\");\n            }\n            return (Connection)manager.allocateConnection(factory, info);\n        } catch (ResourceException e) {\n            \/\/ Throw the root cause if it was a JMSException..\n            if (e.getCause() instanceof JMSException) {\n                throw (JMSException)e.getCause();\n            }\n            LOG.debug(\"Connection could not be created:\", e);\n            throw new JMSException(e.getMessage());\n        }\n    }\n","new_comment_raw":"@param connectionRequestInfo","old_comment_raw":"@param info","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":135},{"new_code_raw":"public Response getApplication(@PathParam(\"version\") String version, @HeaderParam(\"Accept\") final String acceptHeader, @HeaderParam(EurekaAccept.HTTP_X_EUREKA_ACCEPT) String eurekaAccept) { if (!registry.shouldAllowAccess(false)) { return Response.status(Status.FORBIDDEN).build(); } EurekaMonitors.GET_APPLICATION.increment(); CurrentRequestVersion.set(Version.toEnum(version)); KeyType keyType = KeyType.JSON; if (acceptHeader == null || !acceptHeader.contains(\"json\")) { keyType = KeyType.XML; } Key cacheKey = new Key( Key.EntityType.Application, appName, keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept) ); String payLoad = responseCache.get(cacheKey); if (payLoad != null) { logger.debug(\"Found: {}\", appName); return Response.ok(payLoad).build(); } else { logger.debug(\"Not Found: {}\", appName); return Response.status(Status.NOT_FOUND).build(); } }","old_code_raw":"    public Response getApplication(@PathParam(\"version\") String version,\n                                   @HeaderParam(\"Accept\") final String acceptHeader) {\n        if (!PeerAwareInstanceRegistryImpl.getInstance().shouldAllowAccess(false)) {\n            return Response.status(Status.FORBIDDEN).build();\n        }\n\n        EurekaMonitors.GET_APPLICATION.increment();\n\n        CurrentRequestVersion.set(Version.toEnum(version));\n        KeyType keyType = KeyType.JSON;\n        if (acceptHeader == null || !acceptHeader.contains(\"json\")) {\n            keyType = KeyType.XML;\n        }\n\n        Key cacheKey = new Key(Key.EntityType.Application, appName, keyType, CurrentRequestVersion.get());\n\n        String payLoad = ResponseCache.getInstance().get(cacheKey);\n\n        if (payLoad != null) {\n            logger.debug(\"Found: {}\", appName);\n            return Response.ok(payLoad).build();\n        } else {\n            logger.debug(\"Not Found: {}\", appName);\n            return Response.status(Status.NOT_FOUND).build();\n        }\n    }\n","new_comment_raw":"@param acceptHeader the accept header of the request to indicate whether to serve JSON or XML data.","old_comment_raw":"@param acceptHeader the accept header of the request to indicate whether to serve JSON or XML data.","label":0,"pre_label":1,"AST_level":7,"line_counts":34,"new_code_token_num":192},{"new_code_raw":"public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws ApiException { Object localVarPostBody = outerComposite; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/composite\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"*\/*\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/composite\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<OuterComposite> localVarReturnType = new GenericType<OuterComposite>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param outerComposite Input composite as post body (optional)","old_comment_raw":"@param body Input composite as post body (optional)","label":1,"pre_label":0,"AST_level":8,"line_counts":30,"new_code_token_num":176},{"new_code_raw":"public ArrayList<TextView> clickInRecyclerView(int itemIndex, int recyclerViewIndex, int id, boolean longClick, int time) { View viewOnLine = null; final long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout(); if(itemIndex < 0) itemIndex = 0; ArrayList<View> views = new ArrayList<View>(); ViewGroup recyclerView = viewFetcher.getRecyclerView(recyclerViewIndex, Timeout.getSmallTimeout()); if(recyclerView == null){ Assert.fail(\"RecyclerView is not found!\"); } else{ failIfIndexHigherThenChildCount(recyclerView, itemIndex, endTime); viewOnLine = getViewOnRecyclerItemIndex((ViewGroup) recyclerView, recyclerViewIndex, itemIndex); } if(viewOnLine != null){ views = viewFetcher.getViews(viewOnLine, true); views = RobotiumUtils.removeInvisibleViews(views); if(id == 0){ clickOnScreen(viewOnLine, longClick, time); } else{ clickOnScreen(getView(id, views)); } } return RobotiumUtils.filterViews(TextView.class, views); }","old_code_raw":"\tpublic ArrayList<TextView> clickInRecyclerView(int itemIndex, int recyclerViewIndex, boolean longClick, int time) {\n\t\tView viewOnLine = null;\n\t\tfinal long endTime = SystemClock.uptimeMillis() + Timeout.getSmallTimeout();\n\n\t\tif(itemIndex < 0)\n\t\t\titemIndex = 0;\n\n\t\tArrayList<View> views = new ArrayList<View>();\n\t\tViewGroup recyclerView = viewFetcher.getRecyclerView(recyclerViewIndex, Timeout.getSmallTimeout());\n\t\t\n\t\tif(recyclerView == null){\n\t\t\tAssert.fail(\"RecyclerView is not found!\");\n\t\t}\n\t\telse{\n\t\t\tfailIfIndexHigherThenChildCount(recyclerView, itemIndex, endTime);\n\t\t\tviewOnLine = getViewOnRecyclerItemIndex((ViewGroup) recyclerView, recyclerViewIndex, itemIndex);\n\t\t}\n\t\t\n\t\tif(viewOnLine != null){\n\t\t\tviews = viewFetcher.getViews(viewOnLine, true);\n\t\t\tviews = RobotiumUtils.removeInvisibleViews(views);\n\t\t\tclickOnScreen(viewOnLine, longClick, time);\n\t\t}\n\t\treturn RobotiumUtils.filterViews(TextView.class, views);\n\t}\n","new_comment_raw":"@param recyclerViewIndex the index of the RecyclerView. E.g. Index 1 if two RecyclerViews are available","old_comment_raw":"@param recyclerViewIndex the index of the RecyclerView. E.g. Index 1 if two RecyclerViews are available","label":0,"pre_label":1,"AST_level":10,"line_counts":32,"new_code_token_num":176},{"new_code_raw":"public void updateUser (String username, User user) throws ApiException { Object localVarPostBody = user; \/\/ verify the required parameter 'username' is set if (username == null) { throw new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\"); } \/\/ verify the required parameter 'user' is set if (user == null) { throw new ApiException(400, \"Missing the required parameter 'user' when calling updateUser\"); } \/\/ create path and map variables String localVarPath = \"\/user\/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); \/\/ form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { \"application\/json\" }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\"; if (localVarContentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { \/\/ normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"PUT\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public void  updateUser (String username, User body) throws ApiException {\n    Object localVarPostBody = body;\n    \/\/ verify the required parameter 'username' is set\n    if (username == null) {\n       throw new ApiException(400, \"Missing the required parameter 'username' when calling updateUser\");\n    }\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling updateUser\");\n    }\n\n    \/\/ create path and map variables\n    String localVarPath = \"\/user\/{username}\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"username\" + \"\\\\}\", apiInvoker.escapeString(username.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\";\n\n    if (localVarContentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      \/\/ normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"PUT\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param user Updated user object","old_comment_raw":"@param body Updated user object","label":1,"pre_label":0,"AST_level":9,"line_counts":51,"new_code_token_num":324},{"new_code_raw":"public static Transport createLocalTransport(NetworkBridgeConfiguration configuration, URI uri) throws Exception { \/\/ one end of the localbroker<->bridge transport needs to be async to allow concurrent forwards and acks return createLocalTransport(uri, !configuration.isDispatchAsync()); }","old_code_raw":"    public static Transport createLocalTransport(URI uri) throws Exception {\n        return createLocalTransport(uri, false);\n    }\n","new_comment_raw":"@param listener","old_comment_raw":"@param listener","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":47},{"new_code_raw":"public Timer getTimer(TimerDesc timerDesc) { return getTimer(timerDesc.getName(), timerDesc.getDurationUnit(), timerDesc.getTimeUnit()); }","old_code_raw":"  public Timer getTimer(String name) {\n    return getTimer(name, TimeUnit.MILLISECONDS, TimeUnit.SECONDS);\n  }\n","new_comment_raw":"@param timerDesc TimerDesc describing the timer","old_comment_raw":"@param name the name of the metric","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":28},{"new_code_raw":"public WebElement searchForWebElement(final By by, int minimumNumberOfMatches, int timeout, boolean scroll){ if(minimumNumberOfMatches < 1){ minimumNumberOfMatches = 1; } List<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by); addViewsToList (webElements, viewsFromScreen); return getViewFromList(webElements, minimumNumberOfMatches); }","old_code_raw":"\tpublic WebElement searchForWebElement(final By by, int match, int timeout, boolean scroll){\n\n\t\tif(match < 1){\n\t\t\tmatch = 1;\n\t\t}\n\n\t\tList<WebElement> viewsFromScreen = webUtils.getCurrentWebElements(by);\n\t\taddViewsToList (webElements, viewsFromScreen);\n\n\t\treturn getViewFromList(webElements, match);\n\t}\n","new_comment_raw":"@param scroll true if scrolling should be performed","old_comment_raw":"@param scroll true if scrolling should be performed","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"public boolean isASGEnabled(InstanceInfo instanceInfo) { CacheKey cacheKey = new CacheKey(getAccountId(instanceInfo, accountId), instanceInfo.getASGName()); asgCache.refresh(cacheKey); Boolean result = asgCache.getIfPresent(cacheKey); if (result != null) { return result; } else { logger.warn(\"Cache value for asg {} does not exist yet\", cacheKey.asgName); return true; } }","old_code_raw":"    public boolean isASGEnabled(String asgName) {\n        try {\n            return asgCache.get(asgName);\n        } catch (ExecutionException e) {\n            logger.error(\"Error getting cache value for asg : \" + asgName, e);\n        }\n        return true;\n    }\n","new_comment_raw":"@param instanceInfo the instanceInfo for the lookup","old_comment_raw":"@param asgName - The name of the ASG","label":1,"pre_label":0,"AST_level":7,"line_counts":12,"new_code_token_num":78},{"new_code_raw":"public boolean determineSize(long recordsReadInCurrentPass) throws IOException { if (readPage()) { return true; } if (processPageData((int) recordsReadInCurrentPass)) { return true; } return checkVectorCapacityReached(); }","old_code_raw":"  public boolean determineSize(long recordsReadInCurrentPass, Integer lengthVarFieldsInCurrentRecord) throws IOException {\n\n    boolean doneReading = readPage();\n    if (doneReading) {\n      return true;\n    }\n\n    doneReading = processPageData((int) recordsReadInCurrentPass);\n    if (doneReading) {\n      return true;\n    }\n\n    \/\/ Never used in this code path. Hard to remove because the method is overidden by subclasses\n    lengthVarFieldsInCurrentRecord = -1;\n\n    doneReading = checkVectorCapacityReached();\n    if (doneReading) {\n      return true;\n    }\n\n    return false;\n  }\n","new_comment_raw":"@param recordsReadInCurrentPass","old_comment_raw":"@param recordsReadInCurrentPass","label":0,"pre_label":1,"AST_level":6,"line_counts":13,"new_code_token_num":42},{"new_code_raw":"public static BufferedImage alphaOffset(final Image rawImg, final float percentage) { BufferedImage image = toARGB(rawImg); final int numComponents = image.getColorModel().getNumComponents(); final float[] scales = new float[numComponents]; final float[] offsets = new float[numComponents]; Arrays.fill(scales, 1f); Arrays.fill(offsets, 0f); scales[numComponents - 1] = percentage; return offset(image, scales, offsets); }","old_code_raw":"\tpublic static BufferedImage alphaOffset(final BufferedImage image, final float percentage)\n\t{\n\t\tfinal int numComponents = image.getColorModel().getNumComponents();\n\t\tfinal float[] scales = new float[numComponents];\n\t\tfinal float[] offsets = new float[numComponents];\n\n\t\tArrays.fill(scales, 1f);\n\t\tArrays.fill(offsets, 0f);\n\t\tscales[numComponents - 1] = percentage;\n\t\treturn offset(image, scales, offsets);\n\t}\n","new_comment_raw":"@param rawImg The image to be made more or less transparent.","old_comment_raw":"@param image The image to be made more or less transparent.","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":89},{"new_code_raw":"public boolean searchButton(String text, boolean onlyVisible) { boolean found = searcher.searchWithTimeoutFor(Button.class, text, 0, true, onlyVisible); return found; }","old_code_raw":"\tpublic boolean searchButton(String text, boolean visible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, 0, true, visible);\n\t\treturn found;\n\t}\n","new_comment_raw":"@param onlyVisible  true if only  Buttons visible on the screen should be searched","old_comment_raw":"@param visible true if only Buttons visible on the screen should be searched","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public int compareTo(ReadablePartial partial) { if (partial == null) { throw new IllegalArgumentException(\"The instant must not be null\"); } int thisValue = get(); int otherValue = partial.get(getFieldType()); if (thisValue < otherValue) { return -1; } else if (thisValue > otherValue) { return 1; } else { return 0; } }","old_code_raw":"    public int compareTo(ReadablePartial instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        int thisValue = get();\n        int otherValue = instant.get(getField());\n        if (thisValue < otherValue) {\n            return -1;\n        } else if (thisValue > otherValue) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n","new_comment_raw":"@param partial the partial to compare to","old_comment_raw":"@param instant the instant to compare to","label":1,"pre_label":0,"AST_level":7,"line_counts":15,"new_code_token_num":74},{"new_code_raw":"public Struct delete(Object before, Struct source, Instant timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.DELETE.code()); if (before != null) { struct.put(FieldName.BEFORE, before); } if (source != null) { struct.put(FieldName.SOURCE, source); } if (timestamp != null) { struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli()); } return struct; }","old_code_raw":"    public Struct delete(Object before, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.DELETE.code());\n        if (before != null) {\n            struct.put(FieldName.BEFORE, before);\n        }\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp);\n        }\n        return struct;\n    }\n","new_comment_raw":"@param timestamp the timestamp for this message; may be null","old_comment_raw":"@param timestamp the timestamp for this message; may be null","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":93},{"new_code_raw":"public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }","old_code_raw":"  public Call testEndpointParametersAsync(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n","new_comment_raw":"@param _float None (optional)","old_comment_raw":"@param _float None (optional)","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":187},{"new_code_raw":"public static boolean canEdit(Permissions perms, Permissions user2Perms) { if(isAdmin(perms)) return true; if(isAdmin(user2Perms)) return false; return getManagementLevel(perms) > getManagementLevel(user2Perms); }","old_code_raw":"\tpublic static boolean canEdit(User manager, User toEdit)\r\n\t{\r\n\t\tif(isAdmin(manager))\r\n\t\t\treturn true;\r\n\t\tif(isAdmin(toEdit))\r\n\t\t\treturn false;\r\n\r\n\t\treturn getManagementLevel(manager) > getManagementLevel(toEdit);\r\n\t}\r\n","new_comment_raw":"@param user2Perms The permissions of the user to be edited","old_comment_raw":"@param toEdit The user to be edited","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":43},{"new_code_raw":"public Order getOrderById(String orderId) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'orderId' is set if (orderId == null) { throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\"); } \/\/ create path and map variables String localVarPath = \"\/store\/order\/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiClient.escapeString(orderId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\", \"application\/xml\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"test_api_key_query\", \"test_api_key_header\" }; GenericType<Order> localVarReturnType = new GenericType<Order>() {}; return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Order getOrderById(Long orderId) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'orderId' is set\n    if (orderId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/store\/order\/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiClient.escapeString(orderId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Order> localVarReturnType = new GenericType<Order>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param orderId ID of pet that needs to be fetched (required)","old_comment_raw":"@param orderId ID of pet that needs to be fetched (required)","label":0,"pre_label":1,"AST_level":9,"line_counts":41,"new_code_token_num":256},{"new_code_raw":"protected void coordinateSharedCacheCleanup(SharedSessionContractImplementor session) { final BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() ); if ( session.isEventSource() ) { ( (EventSource) session ).getActionQueue().addAction( action ); } else { action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session ); } }","old_code_raw":"\tprotected void coordinateSharedCacheCleanup(SessionImplementor session) {\n\t\tfinal BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() );\n\n\t\tif ( session.isEventSource() ) {\n\t\t\t( (EventSource) session ).getActionQueue().addAction( action );\n\t\t}\n\t\telse {\n\t\t\taction.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );\n\t\t}\n\t}\n","new_comment_raw":"@param ps The prepared statement to which to bind the parameter values.","old_comment_raw":"@param ps The prepared statement to which to bind the parameter values.","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":62},{"new_code_raw":"public CalciteSchema createSnapshot(SchemaVersion version) { Preconditions.checkArgument(this.isRoot(), \"must be root schema\"); return snapshot(null, version); }","old_code_raw":"  public CalciteSchema createSnapshot(long now) {\n    Preconditions.checkArgument(this.isRoot(), \"must be root schema\");\n    return snapshot(null, now);\n  }\n","new_comment_raw":"@param version The current schema version","old_comment_raw":"@param now The current time in millis, as returned by System#currentTimeMillis()","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":33},{"new_code_raw":"private List<SourceLocation> createAbsoluteLocations(GraphQLError relativeError, MergedFields fields) { Optional<SourceLocation> baseLocation = Optional.ofNullable(fields.getSingleField().getSourceLocation()); \/\/ if (!fields.isEmpty()) { \/\/ baseLocation = Optional.ofNullable(fields.get(0).getSourceLocation()); \/\/ } else { \/\/ baseLocation = Optional.empty(); \/\/ } \/\/ relative error empty path should yield an absolute error with the base path if (relativeError.getLocations() != null && relativeError.getLocations().isEmpty()) { return baseLocation.map(Collections::singletonList).orElse(null); } return Optional.ofNullable( relativeError.getLocations()) .map(locations -> locations.stream() .map(l -> baseLocation .map(base -> new SourceLocation( base.getLine() + l.getLine(), base.getColumn() + l.getColumn())) .orElse(null)) .collect(Collectors.toList())) .map(Collections::unmodifiableList) .orElse(null); }","old_code_raw":"    private List<SourceLocation> createAbsoluteLocations(GraphQLError relativeError, List<Field> fields) {\n        Optional<SourceLocation> baseLocation;\n        if (!fields.isEmpty()) {\n            baseLocation = Optional.ofNullable(fields.get(0).getSourceLocation());\n        } else {\n            baseLocation = Optional.empty();\n        }\n\n        \/\/ relative error empty path should yield an absolute error with the base path\n        if (relativeError.getLocations() != null && relativeError.getLocations().isEmpty()) {\n            return baseLocation.map(Collections::singletonList).orElse(null);\n        }\n\n        return Optional.ofNullable(\n                relativeError.getLocations())\n                .map(locations -> locations.stream()\n                        .map(l ->\n                                baseLocation\n                                        .map(base -> new SourceLocation(\n                                                base.getLine() + l.getLine(),\n                                                base.getColumn() + l.getColumn()))\n                                        .orElse(null))\n                        .collect(Collectors.toList()))\n                .map(Collections::unmodifiableList)\n                .orElse(null);\n    }\n","new_comment_raw":"@param relativeError relative error","old_comment_raw":"@param relativeError relative error","label":0,"pre_label":1,"AST_level":14,"line_counts":27,"new_code_token_num":195},{"new_code_raw":"File getBaseDir(final File file1, final File file2) { if (file1 == null || file2 == null) { return null; } final Iterator bases = getParents(file1).iterator(); final Iterator fileParents = getParents(file2.getAbsoluteFile()).iterator(); File result = null; while (bases.hasNext() && fileParents.hasNext()) { File next = (File) bases.next(); if (next.equals(fileParents.next())) { result = next; } else { break; } } return result; }","old_code_raw":"    File getBaseDir(File base, File file) {\n        if (base == null) {\n            return file.getParentFile().getAbsoluteFile();\n        } else {\n            Iterator bases = getParents(base).iterator();\n            Iterator fileParents = getParents(file.getAbsoluteFile()).iterator();\n            File result = null;\n            while (bases.hasNext() && fileParents.hasNext()) {\n                File next = (File) bases.next();\n                if (next.equals(fileParents.next())) {\n                    result = next;\n                } else {\n                    break;\n                }\n            }\n            return result;\n        }\n    }\n","new_comment_raw":"@param file2 The other file for which the common base directory should be returned.","old_comment_raw":"@param file the file for which the new base directory should be returned.","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":105},{"new_code_raw":"protected long copyCollection(CollectionId collectionId, Instant timestamp) throws InterruptedException { AtomicLong docCount = new AtomicLong(); primaryClient.executeBlocking(\"sync '\" + collectionId + \"'\", primary -> { docCount.set(copyCollection(primary, collectionId, timestamp)); }); return docCount.get(); }","old_code_raw":"    protected long copyCollection(CollectionId collectionId, long timestamp) throws InterruptedException {\n        AtomicLong docCount = new AtomicLong();\n        primaryClient.executeBlocking(\"sync '\" + collectionId + \"'\", primary -> {\n            docCount.set(copyCollection(primary, collectionId, timestamp));\n        });\n        return docCount.get();\n    }\n","new_comment_raw":"@param timestamp the timestamp in milliseconds at which the copy operation was started","old_comment_raw":"@param timestamp the timestamp in milliseconds at which the copy operation was started","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":60},{"new_code_raw":"public StringBuilder toStringBuilder(StringBuilder sb, Function<Label,String> labelFormatter) { if (isLeaf()) { if (label() != null) { sb.append(labelFormatter.apply(label())); } return sb; } else { sb.append('('); if (label() != null) { sb.append(labelFormatter.apply(label())); } Tree[] kids = children(); if (kids != null) { for (Tree kid : kids) { sb.append(' '); kid.toStringBuilder(sb, labelFormatter); } } return sb.append(')'); } }","old_code_raw":"  public StringBuilder toStringBuilder(StringBuilder sb, boolean printOnlyLabelValue) {\n    if (isLeaf()) {\n      if (label() != null) {\n        if(printOnlyLabelValue) {\n          sb.append(label().value());\n        } else {\n          sb.append(label());\n        }\n      }\n      return sb;\n    } else {\n      sb.append('(');\n      if (label() != null) {\n        if (printOnlyLabelValue) {\n          if (value() != null) {\n            sb.append(label().value());\n          }\n          \/\/ don't print a null, just nothing!\n        } else {\n          sb.append(valueAndSentimentString());\n        }\n      }\n      Tree[] kids = children();\n      if (kids != null) {\n        for (Tree kid : kids) {\n          sb.append(' ');\n          kid.toStringBuilder(sb, printOnlyLabelValue);\n        }\n      }\n      return sb.append(')');\n    }\n  }\n","new_comment_raw":"@param labelFormatter Formatting routine for how to print a Label","old_comment_raw":"@param printOnlyLabelValue If true, print only the value() of each node's label","label":1,"pre_label":0,"AST_level":11,"line_counts":22,"new_code_token_num":130},{"new_code_raw":"public RepositoryMetadata lookupComponent(Class<?> repositoryClass) { if (repositoriesMetadata.containsKey(repositoryClass)) { return repositoriesMetadata.get(repositoryClass); } throw new RuntimeException(\"Unknown Repository class \" + repositoryClass.getName()); }","old_code_raw":"    public RepositoryMetadata lookupComponent(Class<?> repoClass)\r\n    {\r\n        if (repositoriesMetadata.containsKey(repoClass))\r\n        {\r\n            return repositoriesMetadata.get(repoClass);\r\n        }\r\n        throw new RuntimeException(\"Unknown Repository class \" + repoClass.getName());\r\n    }\r\n","new_comment_raw":"@param repositoryClass The repository class to lookup the method for","old_comment_raw":"@param repoClass The Repository class to lookup the method for","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":43},{"new_code_raw":"public static StringTemplate stringTemplate(String template, ImmutableList<?> args) { return new StringTemplate(createTemplate(template), args); }","old_code_raw":"    public static StringExpression stringTemplate(Template template, Object... args) {\n        return new StringTemplate(template, ImmutableList.copyOf(args));\n    }\n","new_comment_raw":"@param template","old_comment_raw":"@param template","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public CodegenModel fromModel(String name, Schema schema, Map<String, Schema> allDefinitions) { if (typeAliases == null) { \/\/ Only do this once during first call typeAliases = getAllAliases(allDefinitions); } CodegenModel m = CodegenModelFactory.newInstance(CodegenModelType.MODEL); if (reservedWords.contains(name)) { m.name = escapeReservedWord(name); } else { m.name = name; } m.title = escapeText(schema.getTitle()); m.description = escapeText(schema.getDescription()); m.unescapedDescription = schema.getDescription(); m.classname = toModelName(name); m.classVarName = toVarName(name); m.classFilename = toModelFilename(name); m.modelJson = Json.pretty(schema); m.externalDocumentation = schema.getExternalDocs(); if (schema.getExtensions() != null && !schema.getExtensions().isEmpty()) { m.getVendorExtensions().putAll(schema.getExtensions()); } m.isAlias = typeAliases.containsKey(name); m.discriminator = schema.getDiscriminator(); if (schema.getXml() != null) { m.xmlPrefix = schema.getXml().getPrefix(); m.xmlNamespace = schema.getXml().getNamespace(); m.xmlName = schema.getXml().getName(); } if (ModelUtils.isArraySchema(schema)) { m.isArrayModel = true; m.arrayModelType = fromProperty(name, schema).complexType; addParentContainer(m, name, schema); } else if (schema instanceof ComposedSchema) { final ComposedSchema composed = (ComposedSchema) schema; Map<String, Schema> properties = new LinkedHashMap<String, Schema>(); List<String> required = new ArrayList<String>(); Map<String, Schema> allProperties; List<String> allRequired; if (supportsInheritance || supportsMixins) { allProperties = new LinkedHashMap<String, Schema>(); allRequired = new ArrayList<String>(); m.allVars = new ArrayList<CodegenProperty>(); int modelImplCnt = 0; \/\/ only one inline object allowed in a ComposedModel for (Schema innerModel : composed.getAllOf()) { if (m.discriminator == null) { m.discriminator = schema.getDiscriminator(); } if (innerModel.getXml() != null) { m.xmlPrefix = innerModel.getXml().getPrefix(); m.xmlNamespace = innerModel.getXml().getNamespace(); m.xmlName = innerModel.getXml().getName(); } if (modelImplCnt++ > 1) { LOGGER.warn(\"More than one inline schema specified in allOf:. Only the first one is recognized. All others are ignored.\"); break; \/\/ only one ModelImpl with discriminator allowed in allOf } } } else { allProperties = null; allRequired = null; } \/\/ parent model final String parentName = getParentName(composed, allDefinitions); final Schema parent = StringUtils.isBlank(parentName) ? null : allDefinitions.get(parentName); List<Schema> interfaces = getInterfaces(composed); \/\/ interfaces (intermediate models) if (interfaces != null) { if (m.interfaces == null) m.interfaces = new ArrayList<String>(); for (Schema interfaceSchema : interfaces) { if (StringUtils.isBlank(interfaceSchema.get$ref())) { continue; } Schema refSchema = null; String ref = getSimpleRef(interfaceSchema.get$ref()); if (allDefinitions != null) { refSchema = allDefinitions.get(ref); } final String modelName = toModelName(ref); m.interfaces.add(modelName); addImport(m, modelName); if (allDefinitions != null && refSchema != null) { if (!supportsMixins && !supportsInheritance) { addProperties(properties, required, refSchema, allDefinitions); } if (supportsInheritance) { addProperties(allProperties, allRequired, refSchema, allDefinitions); } } } } if (parent != null) { m.parentSchema = parentName; m.parent = toModelName(parentName); addImport(m, m.parent); if (allDefinitions != null && !allDefinitions.isEmpty()) { if (supportsInheritance) { addProperties(allProperties, allRequired, parent, allDefinitions); } else { addProperties(properties, required, parent, allDefinitions); } } } \/\/ child model (properties owned by the model itself) Schema child = null; if (composed.getAllOf() != null && !composed.getAllOf().isEmpty()) { for (Schema component : composed.getAllOf()) { if (component.get$ref() == null) { child = component; } } } if (child != null) { addProperties(properties, required, child, allDefinitions); if (supportsInheritance) { addProperties(allProperties, allRequired, child, allDefinitions); } } addVars(m, properties, required, allProperties, allRequired); \/\/ TODO \/\/} else if (schema instanceof RefModel) { } else { m.dataType = getSchemaType(schema); if (schema.getEnum() != null && !schema.getEnum().isEmpty()) { m.isEnum = true; \/\/ comment out below as allowableValues is not set in post processing model enum m.allowableValues = new HashMap<String, Object>(); m.allowableValues.put(\"values\", schema.getEnum()); } if (ModelUtils.isMapSchema(schema)) { addAdditionPropertiesToCodeGenModel(m, schema); } addVars(m, schema.getProperties(), schema.getRequired()); } if (m.vars != null) { for (CodegenProperty prop : m.vars) { postProcessModelProperty(m, prop); } } LOGGER.debug(\"debugging fromModel return: \" + m); return m; }","old_code_raw":"    public CodegenModel fromModel(String name, Model model, Map<String, Model> allDefinitions) {\n        if (typeAliases == null) {\n            \/\/ Only do this once during first call\n            typeAliases = getAllAliases(allDefinitions);\n        }\n        CodegenModel m = CodegenModelFactory.newInstance(CodegenModelType.MODEL);\n        if (reservedWords.contains(name)) {\n            m.name = escapeReservedWord(name);\n        } else {\n            m.name = name;\n        }\n        m.title = escapeText(model.getTitle());\n        m.description = escapeText(model.getDescription());\n        m.unescapedDescription = model.getDescription();\n        m.classname = toModelName(name);\n        m.classVarName = toVarName(name);\n        m.classFilename = toModelFilename(name);\n        m.modelJson = Json.pretty(model);\n        m.externalDocs = model.getExternalDocs();\n        m.vendorExtensions = model.getVendorExtensions();\n        m.isAlias = typeAliases.containsKey(name);\n\n        if (model instanceof ModelImpl) {\n            ModelImpl modelImpl = (ModelImpl) model;\n            m.discriminator = modelImpl.getDiscriminator();\n\n            if (modelImpl.getXml() != null) {\n                m.xmlPrefix = modelImpl.getXml().getPrefix();\n                m.xmlNamespace = modelImpl.getXml().getNamespace();\n                m.xmlName = modelImpl.getXml().getName();\n            }\n        }\n\n        if (model instanceof ArrayModel) {\n            ArrayModel am = (ArrayModel) model;\n            ArrayProperty arrayProperty = new ArrayProperty(am.getItems());\n            m.isArrayModel = true;\n            m.arrayModelType = fromProperty(name, arrayProperty).complexType;\n            addParentContainer(m, name, arrayProperty);\n        } else if (model instanceof RefModel) {\n            \/\/ TODO\n        } else if (model instanceof ComposedModel) {\n            final ComposedModel composed = (ComposedModel) model;\n            Map<String, Property> properties = new LinkedHashMap<String, Property>();\n            List<String> required = new ArrayList<String>();\n            Map<String, Property> allProperties;\n            List<String> allRequired;\n            if (supportsInheritance || supportsMixins) {\n                allProperties = new LinkedHashMap<String, Property>();\n                allRequired = new ArrayList<String>();\n                m.allVars = new ArrayList<CodegenProperty>();\n                int modelImplCnt = 0; \/\/ only one inline object allowed in a ComposedModel\n                for (Model innerModel: ((ComposedModel)model).getAllOf()) {\n                    if (innerModel instanceof ModelImpl) {\n                        ModelImpl modelImpl = (ModelImpl) innerModel;\n                        if (m.discriminator == null) {\n                            m.discriminator = modelImpl.getDiscriminator();\n                        }\n                        if (modelImpl.getXml() != null) {\n                            m.xmlPrefix = modelImpl.getXml().getPrefix();\n                            m.xmlNamespace = modelImpl.getXml().getNamespace();\n                            m.xmlName = modelImpl.getXml().getName();\n                        }\n                        if (modelImplCnt++ > 1) {\n                            LOGGER.warn(\"More than one inline schema specified in allOf:. Only the first one is recognized. All others are ignored.\");\n                            break; \/\/ only one ModelImpl with discriminator allowed in allOf\n                        }\n                    }\n                }\n            } else {\n                allProperties = null;\n                allRequired = null;\n            }\n            \/\/ parent model\n            RefModel parent = (RefModel) composed.getParent();\n\n            \/\/ interfaces (intermediate models)\n            if (composed.getInterfaces() != null) {\n                if (m.interfaces == null)\n                    m.interfaces = new ArrayList<String>();\n                for (RefModel _interface : composed.getInterfaces()) {\n                    Model interfaceModel = null;\n                    if (allDefinitions != null) {\n                        interfaceModel = allDefinitions.get(_interface.getSimpleRef());\n                    }\n                    \/\/ set first interface with discriminator found as parent\n                    if (parent == null\n                            && ((interfaceModel instanceof ModelImpl && ((ModelImpl) interfaceModel).getDiscriminator() != null)\n                            || (interfaceModel instanceof ComposedModel && isDiscriminatorInInterfaceTree((ComposedModel) interfaceModel, allDefinitions)))) {\n                        parent = _interface;\n                    } else {\n                        final String interfaceRef = toModelName(_interface.getSimpleRef());\n                        m.interfaces.add(interfaceRef);\n                        addImport(m, interfaceRef);\n                        if (allDefinitions != null) {\n                            if (!supportsMixins) {\n                                addProperties(properties, required, interfaceModel, allDefinitions);\n                            }\n                            if (supportsInheritance) {\n                                addProperties(allProperties, allRequired, interfaceModel, allDefinitions);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (parent != null) {\n                final String parentRef = parent.getSimpleRef();\n                m.parentSchema = parentRef;\n                m.parent = toModelName(parent.getSimpleRef());\n                addImport(m, m.parent);\n                if (allDefinitions != null) {\n                    final Model parentModel = allDefinitions.get(m.parentSchema);\n                    if (supportsInheritance) {\n                        addProperties(allProperties, allRequired, parentModel, allDefinitions);\n                    } else {\n                        addProperties(properties, required, parentModel, allDefinitions);\n                    }\n                }\n            }\n\n            \/\/ child model (properties owned by the model itself)\n            Model child = composed.getChild();\n            if (child != null && child instanceof RefModel && allDefinitions != null) {\n                final String childRef = ((RefModel) child).getSimpleRef();\n                child = allDefinitions.get(childRef);\n            }\n            if (child != null && child instanceof ModelImpl) {\n                addProperties(properties, required, child, allDefinitions);\n                if (supportsInheritance) {\n                    addProperties(allProperties, allRequired, child, allDefinitions);\n                }\n            }\n            addVars(m, properties, required, allProperties, allRequired);\n        } else {\n            ModelImpl impl = (ModelImpl) model;\n            if (impl.getType() != null) {\n                Property p = PropertyBuilder.build(impl.getType(), impl.getFormat(), null);\n                m.dataType = getSwaggerType(p);\n            }\n            if(impl.getEnum() != null && impl.getEnum().size() > 0) {\n                m.isEnum = true;\n                \/\/ comment out below as allowableValues is not set in post processing model enum\n                m.allowableValues = new HashMap<String, Object>();\n                m.allowableValues.put(\"values\", impl.getEnum());\n            }\n            if (impl.getAdditionalProperties() != null) {\n                addAdditionPropertiesToCodeGenModel(m, impl);\n            }\n            addVars(m, impl.getProperties(), impl.getRequired());\n        }\n\n        if (m.vars != null) {\n            for(CodegenProperty prop : m.vars) {\n                postProcessModelProperty(m, prop);\n            }\n        }\n        return m;\n    }\n","new_comment_raw":"@param allDefinitions a map of all OAS models from the spec","old_comment_raw":"@param allDefinitions a map of all Swagger models from the spec","label":1,"pre_label":0,"AST_level":16,"line_counts":156,"new_code_token_num":1025},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new FilePendingMessageCursor(name, tmpStorage); }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new FilePendingMessageCursor(name, tmpStorage);\n    }\n","new_comment_raw":"@param clientId","old_comment_raw":"@param clientId","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public Location writeCommand(DataStructure command, boolean syncHint) throws IOException { return asyncDataManager.write(wireFormat.marshal(command), (syncHint && syncOnWrite)); }","old_code_raw":"    public Location writeCommand(DataStructure command, boolean sync) throws IOException {\n        return asyncDataManager.write(wireFormat.marshal(command), sync);\n    }\n","new_comment_raw":"@param syncHint","old_comment_raw":"@param sync","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":32},{"new_code_raw":"public Task<Boolean> contains(final CacheKey key) { if (containsSync(key)) { return Task.forResult(true); } return containsAsync(key); }","old_code_raw":"  public Task<Boolean> contains(final List<CacheKey> keys) {\n    if (keys.isEmpty()) {\n      return Task.forResult(false);\n    }\n    if (containsSync(keys)) {\n      return Task.forResult(true);\n    }\n    Task<Boolean> masterTask = containsAsync(keys.get(0));\n    if (keys.size() == 1) {\n      return masterTask;\n    }\n    for (final CacheKey key : keys.subList(1, keys.size())) {\n      masterTask = masterTask.continueWithTask(\n          new Continuation<Boolean, Task<Boolean>>() {\n            @Override\n            public Task<Boolean> then(Task<Boolean> previousTask) throws Exception {\n              if (previousTask.isCancelled() || previousTask.getResult()) {\n                return previousTask;\n              }\n              return containsAsync(key);\n            }\n          },\n          mReadExecutor);\n    }\n    return masterTask;\n  }\n","new_comment_raw":"@param key","old_comment_raw":"@param keys","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":33},{"new_code_raw":"public static String getConsoleIconPath(DesiredCapabilities cap,Registry registry) { String name = consoleIconName(cap,registry); InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"images\/\"+name+\".png\"); if (in == null){ return null; }else { return \"\/grid\/resources\/images\/\" + name + \".png\"; } }","old_code_raw":"\tpublic static String getConsoleIconPath(DesiredCapabilities cap) {\n\t\tString name = consoleIconName(cap);\n\t\tInputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"images\/\"+name+\".png\");\n\t\tif (in == null){\n\t\t\treturn null;\n\t\t}else {\n\t\t\treturn \"\/grid\/resources\/images\/\" + name + \".png\";\n\t\t}\n\t\t\n\t}\n","new_comment_raw":"@param cap","old_comment_raw":"@param cap","label":0,"pre_label":1,"AST_level":9,"line_counts":11,"new_code_token_num":75},{"new_code_raw":"public DrillBuf retain(BufferAllocator target) { if (isEmpty) { return this; } if (BaseAllocator.DEBUG) { historicalLog.recordEvent(\"retain(%s)\", target.getName()); } final BufferLedger otherLedger = this.ledger.getLedgerForAllocator(target); return otherLedger.newDrillBuf(offset, length, null); }","old_code_raw":"  public DrillBuf retain(BufferAllocator allocator) {\n\n    if (isEmpty) {\n      return this;\n    }\n\n    if (BaseAllocator.DEBUG) {\n      historicalLog.recordEvent(\"retain(%s)\", allocator.getName());\n    }\n    BufferLedger otherLedger = this.ledger.getLedgerForAllocator(allocator);\n    return otherLedger.newDrillBuf(offset, length, null, true);\n  }\n","new_comment_raw":"@param target The target allocator to create an association with.","old_comment_raw":"@param allocator The target allocator to create an association with.","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":63},{"new_code_raw":"public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, dialect, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }","old_code_raw":"\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createSchemas, Dialect dialect) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateSchemas,\n\t\t\t\tdialect,\n\t\t\t\tnew Target() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n","new_comment_raw":"@param metadata The metadata for which to generate the creation commands.","old_comment_raw":"@param metadata The metadata for which to generate the creation commands.","label":0,"pre_label":1,"AST_level":9,"line_counts":30,"new_code_token_num":92},{"new_code_raw":"public static long toNanoOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration); } return ((Duration) value).toNanos(); } \/\/ TODO only needed for SQL Server\/Oracle, where we don't produce Duration right away; \/\/ this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return time.toNanoOfDay(); }","old_code_raw":"    public static long toNanoOfDay(Object value, TemporalAdjuster adjuster) {\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster !=null) {\n            time = time.with(adjuster);\n        }\n        return time.toNanoOfDay();\n    }\n","new_comment_raw":"@param value the duration value; may not be null","old_comment_raw":"@param value the local or SQL date, time, or timestamp value; may not be null","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":141},{"new_code_raw":"private static String toString(Collection<TypedDependency> dependencies, boolean extraSep) { StringBuilder buf = new StringBuilder(); if (extraSep) { List<TypedDependency> extraDeps = new ArrayList<TypedDependency>(); for (TypedDependency td : dependencies) { if (td.extra()) { extraDeps.add(td); } else { buf.append(td.toString()).append('\\n'); } } \/\/ now we print the separator for extra dependencies, and print these if there are some if (!extraDeps.isEmpty()) { buf.append(\"======\\n\"); for (TypedDependency td : extraDeps) { buf.append(td.toString()).append('\\n'); } } } else { for (TypedDependency td : dependencies) { buf.append(td.toString()).append('\\n'); } } return buf.toString(); }","old_code_raw":"  private static String toString(Collection<TypedDependency> dependencies, boolean extraSep, boolean includeTags) {\n    CoreLabel.OutputFormat labelFormat = (includeTags) ? CoreLabel.OutputFormat.VALUE_TAG_INDEX : CoreLabel.OutputFormat.VALUE_INDEX;\n    StringBuilder buf = new StringBuilder();\n    if (extraSep) {\n      List<TypedDependency> extraDeps =  new ArrayList<TypedDependency>();\n      for (TypedDependency td : dependencies) {\n        if (td.extra()) {\n          extraDeps.add(td);\n        } else {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n      \/\/ now we print the separator for extra dependencies, and print these if there are some\n      if (!extraDeps.isEmpty()) {\n        buf.append(\"======\\n\");\n        for (TypedDependency td : extraDeps) {\n          buf.append(td.toString(labelFormat)).append('\\n');\n        }\n      }\n    } else {\n      for (TypedDependency td : dependencies) {\n        buf.append(td.toString(labelFormat)).append('\\n');\n      }\n    }\n    return buf.toString();\n  }\n","new_comment_raw":"@param dependencies The TypedDependencies to print","old_comment_raw":"@param dependencies The TypedDependencies to print","label":0,"pre_label":1,"AST_level":12,"line_counts":27,"new_code_token_num":175},{"new_code_raw":"protected BroadcastAction filter(HttpServletRequest request, HttpServletResponse response, Object object) { BroadcastAction transformed = new BroadcastAction(object); for (PerRequestBroadcastFilter mf : perRequestFilters) { transformed = mf.filter(request, response, transformed.message()); if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) { return transformed; } } return transformed; }","old_code_raw":"    protected BroadcastAction filter(HttpServletRequest request, Object object) {\n        BroadcastAction transformed = new BroadcastAction(object);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            transformed = mf.filter(request, transformed.message());\n            if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {\n                return transformed;\n            }\n        }\n        return transformed;\n    }\n","new_comment_raw":"@param request  javax.servlet.http.HttpServletRequest","old_comment_raw":"@param request javax.servlet.http.HttpServletRequest","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) { return new VMPendingMessageCursor(); }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize) {\n        return new VMPendingMessageCursor();\n    }\n","new_comment_raw":"@param tmpStorage","old_comment_raw":"@param tmpStorage","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"private StringBuilder appendIfNotNull(StringBuilder source, String addStr, String delimiter) { if (addStr != null) { if (addStr.length() == 0) { delimiter = \"\"; } return source.append(addStr).append(delimiter); } return source; }","old_code_raw":"    private String appendIfNotNull(String sourceStr, String appendStr, String delimiter) {\n        if (appendStr != null) {\n            if (appendStr.length() == 0) {\n                delimiter = \"\";\n            }\n            sourceStr += delimiter + appendStr;\n        }\n        return sourceStr;\n    }\n","new_comment_raw":"@param source Stringbuilder containing the text to append to.","old_comment_raw":"@param sourceStr The String to append to.","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":51},{"new_code_raw":"public static FileMetadata getFileMetadata(Collection<RowGroupMetadata> rowGroups) { if (rowGroups.isEmpty()) { return null; } List<StatisticsHolder> fileStatistics = new ArrayList<>(); fileStatistics.add(new StatisticsHolder<>(TableStatisticsKind.ROW_COUNT.mergeStatistics(rowGroups), TableStatisticsKind.ROW_COUNT)); RowGroupMetadata rowGroupMetadata = rowGroups.iterator().next(); TupleMetadata schema = rowGroupMetadata.getSchema(); Set<SchemaPath> columns = rowGroupMetadata.getColumnsStatistics().keySet(); MetadataInfo metadataInfo = MetadataInfo.builder().type(MetadataType.FILE).build(); return FileMetadata.builder() .tableInfo(rowGroupMetadata.getTableInfo()) .metadataInfo(metadataInfo) .path(rowGroupMetadata.getPath()) .schema(schema) .columnsStatistics(TableMetadataUtils.mergeColumnsStatistics(rowGroups, columns, PARQUET_COLUMN_STATISTICS)) .metadataStatistics(fileStatistics) .build(); }","old_code_raw":"  public static FileMetadata getFileMetadata(List<RowGroupMetadata> rowGroups) {\n    if (rowGroups.isEmpty()) {\n      return null;\n    }\n    List<StatisticsHolder> fileStatistics = new ArrayList<>();\n    fileStatistics.add(new StatisticsHolder<>(TableStatisticsKind.ROW_COUNT.mergeStatistics(rowGroups), TableStatisticsKind.ROW_COUNT));\n\n    RowGroupMetadata rowGroupMetadata = rowGroups.iterator().next();\n    TupleMetadata schema = rowGroupMetadata.getSchema();\n\n    Set<SchemaPath> columns = rowGroupMetadata.getColumnsStatistics().keySet();\n\n    MetadataInfo metadataInfo = MetadataInfo.builder().type(MetadataType.FILE).build();\n\n    return FileMetadata.builder()\n        .tableInfo(rowGroupMetadata.getTableInfo())\n        .metadataInfo(metadataInfo)\n        .path(rowGroupMetadata.getPath())\n        .schema(schema)\n        .columnsStatistics(TableMetadataUtils.mergeColumnsStatistics(rowGroups, columns, PARQUET_COLUMN_STATISTICS))\n        .metadataStatistics(fileStatistics)\n        .build();\n  }\n","new_comment_raw":"@param rowGroups collection of  RowGroupMetadata to be merged","old_comment_raw":"@param rowGroups list of RowGroupMetadata to be merged","label":1,"pre_label":0,"AST_level":7,"line_counts":24,"new_code_token_num":139},{"new_code_raw":"public static Area getClickbox(@Nonnull Client client, Model model, int orientation, int localX, int localY) { if (model == null) { return null; } List<Triangle> triangles = model.getTriangles().stream() .map(triangle -> triangle.rotate(orientation)) .collect(Collectors.toList()); List<Vertex> vertices = model.getVertices().stream() .map(v -> v.rotate(orientation)) .collect(Collectors.toList()); Area clickBox = get2DGeometry(client, triangles, orientation, localX, localY); Area visibleAABB = getAABB(client, vertices, orientation, localX, localY); if (visibleAABB == null || clickBox == null) { return null; } clickBox.intersect(visibleAABB); return clickBox; }","old_code_raw":"\tpublic static Area getClickbox(@Nonnull Client client, Model model, int orientation, int tileX, int tileY)\n\t{\n\t\tif (model == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Triangle> triangles = model.getTriangles().stream()\n\t\t\t.map(triangle -> triangle.rotate(orientation))\n\t\t\t.collect(Collectors.toList());\n\n\t\tList<Vertex> vertices = model.getVertices().stream()\n\t\t\t\t.map(v -> v.rotate(orientation))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\tArea clickBox = get2DGeometry(client, triangles, orientation, tileX, tileY);\n\t\tArea visibleAABB = getAABB(client, vertices, orientation, tileX, tileY);\n\n\t\tif (visibleAABB == null || clickBox == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tclickBox.intersect(visibleAABB);\n\t\treturn clickBox;\n\t}\n","new_comment_raw":"@param client the game client","old_comment_raw":"@param client the game client","label":0,"pre_label":1,"AST_level":9,"line_counts":27,"new_code_token_num":143},{"new_code_raw":"public static BufferedImage alphaOffset(final Image rawImg, final int offset) { BufferedImage image = toARGB(rawImg); final float offsetFloat = (float) offset; final int numComponents = image.getColorModel().getNumComponents(); final float[] scales = new float[numComponents]; final float[] offsets = new float[numComponents]; Arrays.fill(scales, 1f); Arrays.fill(offsets, 0f); offsets[numComponents - 1] = offsetFloat; return offset(image, scales, offsets); }","old_code_raw":"\tpublic static BufferedImage alphaOffset(final BufferedImage image, final int offset)\n\t{\n\t\tfinal float offsetFloat = (float) offset;\n\t\tfinal int numComponents = image.getColorModel().getNumComponents();\n\t\tfinal float[] scales = new float[numComponents];\n\t\tfinal float[] offsets = new float[numComponents];\n\n\t\tArrays.fill(scales, 1f);\n\t\tArrays.fill(offsets, 0f);\n\t\toffsets[numComponents - 1] = offsetFloat;\n\t\treturn offset(image, scales, offsets);\n\t}\n","new_comment_raw":"@param rawImg The image to be made more or less transparent.","old_comment_raw":"@param image The image to be made more or less transparent.","label":1,"pre_label":0,"AST_level":8,"line_counts":14,"new_code_token_num":97},{"new_code_raw":"public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param contentType The request's Content-Type header","old_comment_raw":"@param contentType The request's Content-Type header","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"static public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) { IStructuredTextExpert expert; if (environment == null) environment = StructuredTextEnvironment.DEFAULT; synchronized (sharedExperts) { Map experts = (Map) sharedExperts.get(type); if (experts == null) { experts = new HashMap(); \/\/ environment -> expert sharedExperts.put(type, experts); } expert = (IStructuredTextExpert) experts.get(environment); if (expert == null) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$ expert = new StructuredTextImpl(handler, environment, false); experts.put(type, expert); } } return expert; }","old_code_raw":"\tstatic public ISTextExpert getExpert(String type, STextEnvironment environment) {\n\t\tISTextExpert expert;\n\t\tif (environment == null)\n\t\t\tenvironment = STextEnvironment.DEFAULT;\n\t\tsynchronized (sharedExperts) {\n\t\t\tMap experts = (Map) sharedExperts.get(type);\n\t\t\tif (experts == null) {\n\t\t\t\texperts = new HashMap(); \/\/ environment -> expert\n\t\t\t\tsharedExperts.put(type, experts);\n\t\t\t}\n\t\t\texpert = (ISTextExpert) experts.get(environment);\n\t\t\tif (expert == null) {\n\t\t\t\tSTextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n\t\t\t\tif (handler == null)\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid type argument\"); \/\/$NON-NLS-1$\n\t\t\t\texpert = new STextImpl(handler, environment, false);\n\t\t\t\texperts.put(type, expert);\n\t\t\t}\n\t\t}\n\t\treturn expert;\n\t}\n","new_comment_raw":"@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the  StructuredTextEnvironment#DEFAULT environment should be assumed.","old_comment_raw":"@param environment the current environment, which may affect the behavior of the expert. This parameter may be specified as null, in which case the STextEnvironment#DEFAULT environment should be assumed.","label":1,"pre_label":0,"AST_level":9,"line_counts":23,"new_code_token_num":140},{"new_code_raw":"public static DataFileReadResult decompress(byte[] b, int[] keys) { InputStream stream = new InputStream(b); int compression = stream.readUnsignedByte(); int compressedLength = stream.readInt(); if (compressedLength < 0 || compressedLength > 1000000) throw new RuntimeException(\"Invalid data\"); Crc32 crc32 = new Crc32(); crc32.update(b, 0, 5); \/\/ compression + length byte[] data; int revision = -1; switch (compression) { case CompressionType.NONE: { byte[] encryptedData = new byte[compressedLength]; stream.readBytes(encryptedData, 0, compressedLength); crc32.update(encryptedData, 0, compressedLength); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } data = decryptedData; break; } case CompressionType.BZ2: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = BZip2.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } case CompressionType.GZ: { byte[] encryptedData = new byte[compressedLength + 4]; stream.readBytes(encryptedData); crc32.update(encryptedData, 0, encryptedData.length); byte[] decryptedData = decrypt(encryptedData, encryptedData.length, keys); if (stream.remaining() >= 2) { revision = stream.readUnsignedShort(); assert revision != -1; } stream = new InputStream(decryptedData); int decompressedLength = stream.readInt(); data = GZip.decompress(stream.getRemaining(), compressedLength); if (data == null) { return null; } assert data.length == decompressedLength; break; } default: throw new RuntimeException(\"Unknown decompression type\"); } DataFileReadResult res = new DataFileReadResult(); res.data = data; res.revision = revision; int length = revision != -1 ? b.length - 2 : b.length;; res.crc = crc32.getHash(); res.whirlpool = Whirlpool.getHash(b, length); res.compression = compression; return res; }","old_code_raw":"\tpublic static DataFileReadResult decompress(byte[] b)\n\t{\n\t\tInputStream stream = new InputStream(b);\n\t\t\n\t\tint compression = stream.readUnsignedByte();\n\t\tint compressedLength = stream.readInt();\n\t\tif (compressedLength < 0 || compressedLength > 1000000)\n\t\t\tthrow new RuntimeException(\"Invalid data\");\n\t\t\n\t\tbyte[] data;\n\t\tint revision;\n\t\tswitch (compression)\n\t\t{\n\t\t\tcase CompressionType.NONE:\n\t\t\t\tdata = new byte[compressedLength];\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tstream.readBytes(data, 0, compressedLength);\n\t\t\t\tbreak;\n\t\t\tcase CompressionType.BZ2:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = BZip2.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CompressionType.GZ:\n\t\t\t{\n\t\t\t\tint length = stream.readInt();\n\t\t\t\trevision = checkRevision(stream, compressedLength);\n\t\t\t\tdata = GZip.decompress(stream.getRemaining(), compressedLength);\n\t\t\t\tassert data.length == length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unknown decompression type\");\n\t\t}\n\t\t\n\t\tDataFileReadResult res = new DataFileReadResult();\n\t\tres.data = data;\n\t\tres.revision = revision;\n\t\tint length = revision != -1 ? b.length - 2 : b.length;\n\t\tres.crc = CRC32HGenerator.getHash(b, length);\n\t\tres.whirlpool = Whirlpool.getHash(b, length);\n\t\tres.compression = compression;\n\t\treturn res;\n\t}\n","new_comment_raw":"@param size size of file","old_comment_raw":"@param size expected size of file","label":1,"pre_label":0,"AST_level":10,"line_counts":104,"new_code_token_num":469},{"new_code_raw":"public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) contentType = \"application\/json\"; RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType)); } Request request = null; if(progressRequestListener != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return httpClient.newCall(request); }","old_code_raw":"  public Call buildCall(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    final String url = buildUrl(path, queryParams);\n    final Request.Builder reqBuilder = new Request.Builder().url(url);\n    processHeaderParams(headerParams, reqBuilder);\n\n    String contentType = (String) headerParams.get(\"Content-Type\");\n    \/\/ ensuring a default content type\n    if (contentType == null) contentType = \"application\/json\";\n\n    RequestBody reqBody;\n    if (!HttpMethod.permitsRequestBody(method)) {\n      reqBody = null;\n    } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n      reqBody = buildRequestBodyFormEncoding(formParams);\n    } else if (\"multipart\/form-data\".equals(contentType)) {\n      reqBody = buildRequestBodyMultipart(formParams);\n    } else if (body == null) {\n      if (\"DELETE\".equals(method)) {\n        \/\/ allow calling DELETE without sending a request body\n        reqBody = null;\n      } else {\n        \/\/ use an empty request body (for POST, PUT and PATCH)\n        reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n      }\n    } else {\n      reqBody = RequestBody.create(MediaType.parse(contentType), serialize(body, contentType));\n    }\n\n    Request request = reqBuilder.method(method, reqBody).build();\n    return httpClient.newCall(request);\n  }\n","new_comment_raw":"@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"","old_comment_raw":"@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"","label":0,"pre_label":1,"AST_level":14,"line_counts":42,"new_code_token_num":325},{"new_code_raw":"public Future<HttpResponse> executeAsync(Executor executor) { FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() { public HttpResponse call() throws Exception { return execute(); } }); executor.execute(future); return future; }","old_code_raw":"  public Future<HttpResponse> executeAsync(Executor exec) {\n    final SettableFuture<HttpResponse> future = SettableFuture.create();\n    exec.execute(new Runnable() {\n      public void run() {\n        try {\n          future.set(execute());\n        } catch (IOException ex) {\n          future.setException(ex);\n        }\n      }\n    });\n    return future;\n  }\n","new_comment_raw":"@param executor executor to run the asynchronous request","old_comment_raw":"@param exec An executor to run the synchronous HttpRequest","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":49},{"new_code_raw":"public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException { final Connection conn = connection(); final ResultSet[] resultSets = new ResultSet[multiQuery.length]; final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length]; try { for (int i = 0; i < multiQuery.length; i++) { final String query = multiQuery[i]; if (LOGGER.isTraceEnabled()) { LOGGER.trace(\"running '{}'\", query); } final PreparedStatement statement = conn.prepareStatement(query); preparedStatements[i] = statement; preparer.accept(statement); resultSets[i] = statement.executeQuery(); } if (resultConsumer != null) { resultConsumer.accept(resultSets); } } finally { for (ResultSet rs: resultSets) { if (rs != null) { try { rs.close(); } catch (Exception ei) { } } } for (PreparedStatement ps: preparedStatements) { if (ps != null) { try { ps.close(); } catch (Exception ei) { } } } } return this; }","old_code_raw":"    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, MultiResultSetConsumer resultConsumer) throws SQLException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = conn.prepareStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n            for (PreparedStatement ps: preparedStatements) {\n                if (ps != null) {\n                    try {\n                        ps.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n","new_comment_raw":"@param multiQuery the array of prepared queries","old_comment_raw":"@param multiQuery the array of prepared queries","label":0,"pre_label":1,"AST_level":10,"line_counts":43,"new_code_token_num":216},{"new_code_raw":"public CodegenProperty fromProperty(String name, Schema p) { if (p == null) { LOGGER.error(\"Unexpected missing property for name \" + name); return null; } LOGGER.debug(\"debugging fromProperty for \" + name + \" : \" + p); CodegenProperty property = CodegenModelFactory.newInstance(CodegenModelType.PROPERTY); property.name = toVarName(name); property.baseName = name; property.nameInCamelCase = camelize(property.name, false); property.description = escapeText(p.getDescription()); property.unescapedDescription = p.getDescription(); property.title = p.getTitle(); property.getter = toGetter(name); property.setter = toSetter(name); String example = toExampleValue(p); if (!\"null\".equals(example)) { property.example = example; } property.defaultValue = toDefaultValue(p); property.defaultValueWithParam = toDefaultValueWithParam(name, p); property.jsonSchema = Json.pretty(p); if (p.getReadOnly() != null) { property.isReadOnly = p.getReadOnly(); } if (p.getXml() != null) { if (p.getXml().getAttribute() != null) { property.isXmlAttribute = p.getXml().getAttribute(); } property.xmlPrefix = p.getXml().getPrefix(); property.xmlName = p.getXml().getName(); property.xmlNamespace = p.getXml().getNamespace(); } if (p.getExtensions() != null && !p.getExtensions().isEmpty()) { property.getVendorExtensions().putAll(p.getExtensions()); } String type = getSchemaType(p); if (ModelUtils.isIntegerSchema(p)) { \/\/ integer type property.isNumeric = Boolean.TRUE; if (SchemaTypeUtil.INTEGER64_FORMAT.equals(p.getFormat())) { \/\/ int64\/long format property.isLong = Boolean.TRUE; } else { \/\/ int32 format property.isInteger = Boolean.TRUE; } if (p.getMinimum() != null) { property.minimum = String.valueOf(p.getMinimum().longValue()); } if (p.getMaximum() != null) { property.maximum = String.valueOf(p.getMaximum().longValue()); } if (p.getExclusiveMinimum() != null) { property.exclusiveMinimum = p.getExclusiveMinimum(); } if (p.getExclusiveMaximum() != null) { property.exclusiveMaximum = p.getExclusiveMaximum(); } \/\/ check if any validation rule defined \/\/ exclusive* are noop without corresponding min\/max if (property.minimum != null || property.maximum != null) property.hasValidation = true; \/\/ legacy support Map<String, Object> allowableValues = new HashMap<String, Object>(); if (p.getMinimum() != null) { allowableValues.put(\"min\", p.getMinimum()); } if (p.getMaximum() != null) { allowableValues.put(\"max\", p.getMaximum()); } if (p.getEnum() != null) { List<Object> _enum = p.getEnum(); property._enum = new ArrayList<String>(); for (Object i : _enum) { property._enum.add(String.valueOf(i)); } property.isEnum = true; allowableValues.put(\"values\", _enum); } if (allowableValues.size() > 0) { property.allowableValues = allowableValues; } } else if (ModelUtils.isBooleanSchema(p)) { \/\/ boolean type property.isBoolean = true; property.getter = toBooleanGetter(name); } else if (ModelUtils.isDateSchema(p)) { \/\/ date format property.isString = false; \/\/ for backward compatibility with 2.x property.isDate = true; if (p.getEnum() != null) { List<String> _enum = p.getEnum(); property._enum = new ArrayList<String>(); for (String i : _enum) { property._enum.add(i); } property.isEnum = true; \/\/ legacy support Map<String, Object> allowableValues = new HashMap<String, Object>(); allowableValues.put(\"values\", _enum); property.allowableValues = allowableValues; } } else if (ModelUtils.isDateTimeSchema(p)) { \/\/ date-time format property.isString = false; \/\/ for backward compatibility with 2.x property.isDateTime = true; if (p.getEnum() != null) { List<String> _enum = p.getEnum(); property._enum = new ArrayList<String>(); for (String i : _enum) { property._enum.add(i); } property.isEnum = true; \/\/ legacy support Map<String, Object> allowableValues = new HashMap<String, Object>(); allowableValues.put(\"values\", _enum); property.allowableValues = allowableValues; } } else if (ModelUtils.isStringSchema(p)) { if (ModelUtils.isByteArraySchema(p)) { property.isByteArray = true; } else if (ModelUtils.isBinarySchema(p)) { property.isBinary = true; property.isFile = true; \/\/ file = binary in OAS3 } else if (ModelUtils.isFileSchema(p)) { property.isFile = true; } else if (ModelUtils.isUUIDSchema(p)) { \/\/ keep isString to true to make it backward compatible property.isString = true; property.isUuid = true; } else { property.isString = true; } property.maxLength = p.getMaxLength(); property.minLength = p.getMinLength(); property.pattern = toRegularExpression(p.getPattern()); \/\/ check if any validation rule defined if (property.pattern != null || property.minLength != null || property.maxLength != null) property.hasValidation = true; if (p.getEnum() != null) { List<String> _enum = p.getEnum(); property._enum = _enum; property.isEnum = true; \/\/ legacy support Map<String, Object> allowableValues = new HashMap<String, Object>(); allowableValues.put(\"values\", _enum); property.allowableValues = allowableValues; } } else if (ModelUtils.isNumberSchema(p)) { property.isNumeric = Boolean.TRUE; if (ModelUtils.isFloatSchema(p)) { \/\/ float property.isFloat = Boolean.TRUE; } else if (ModelUtils.isDoubleSchema(p)) { \/\/ double property.isDouble = Boolean.TRUE; } else { \/\/ type is number and without format property.isNumber = Boolean.TRUE; } if (p.getMinimum() != null) { property.minimum = String.valueOf(p.getMinimum()); } if (p.getMaximum() != null) { property.maximum = String.valueOf(p.getMaximum()); } if (p.getExclusiveMinimum() != null) { property.exclusiveMinimum = p.getExclusiveMinimum(); } if (p.getExclusiveMaximum() != null) { property.exclusiveMaximum = p.getExclusiveMaximum(); } \/\/ check if any validation rule defined \/\/ exclusive* are noop without corresponding min\/max if (property.minimum != null || property.maximum != null) property.hasValidation = true; if (p.getEnum() != null && !p.getEnum().isEmpty()) { List<Object> _enum = p.getEnum(); property._enum = new ArrayList<String>(); for (Object i : _enum) { property._enum.add(String.valueOf(i)); } property.isEnum = true; \/\/ legacy support Map<String, Object> allowableValues = new HashMap<String, Object>(); allowableValues.put(\"values\", _enum); property.allowableValues = allowableValues; } } property.datatype = getTypeDeclaration(p); property.dataFormat = p.getFormat(); property.baseType = getSchemaType(p); \/\/ this can cause issues for clients which don't support enums if (property.isEnum) { property.datatypeWithEnum = toEnumName(property); property.enumName = toEnumName(property); } else { property.datatypeWithEnum = property.datatype; } if (ModelUtils.isArraySchema(p)) { property.isContainer = true; property.isListContainer = true; property.containerType = \"array\"; property.baseType = getSchemaType(p); if (p.getXml() != null) { property.isXmlWrapped = p.getXml().getWrapped() == null ? false : p.getXml().getWrapped(); property.xmlPrefix = p.getXml().getPrefix(); property.xmlNamespace = p.getXml().getNamespace(); property.xmlName = p.getXml().getName(); } \/\/ handle inner property property.maxItems = p.getMaxItems(); property.minItems = p.getMinItems(); String itemName = null; if (p.getExtensions() != null && p.getExtensions().get(\"x-item-name\") != null) { itemName = p.getExtensions().get(\"x-item-name\").toString(); } if (itemName == null) { itemName = property.name; } CodegenProperty cp = fromProperty(itemName, ((ArraySchema) p).getItems()); updatePropertyForArray(property, cp); } else if (ModelUtils.isMapSchema(p)) { property.isContainer = true; property.isMapContainer = true; property.containerType = \"map\"; property.baseType = getSchemaType(p); property.minItems = p.getMinProperties(); property.maxItems = p.getMaxProperties(); \/\/ handle inner property CodegenProperty cp = fromProperty(\"inner\", (Schema) p.getAdditionalProperties()); updatePropertyForMap(property, cp); } else { \/\/ model \/\/ TODO revise the logic below \/\/if (StringUtils.isNotBlank(p.get$ref())) { \/\/ property.baseType = getSimpleRef(p.get$ref()); \/\/} \/\/ --END of revision setNonArrayMapProperty(property, type); } LOGGER.debug(\"debugging from property return: \" + property); return property; }","old_code_raw":"    public CodegenProperty fromProperty(String name, Property p) {\n        if (p == null) {\n            LOGGER.error(\"unexpected missing property for name \" + name);\n            return null;\n        }\n\n        CodegenProperty property = CodegenModelFactory.newInstance(CodegenModelType.PROPERTY);\n        property.name = toVarName(name);\n        property.baseName = name;\n        property.nameInCamelCase = camelize(property.name, false);\n        property.description = escapeText(p.getDescription());\n        property.unescapedDescription = p.getDescription();\n        property.title = p.getTitle();\n        property.getter = toGetter(name);\n        property.setter = toSetter(name);\n        String example = toExampleValue(p);\n        if(!\"null\".equals(example)) {\n            property.example = example;\n        }\n        property.defaultValue = toDefaultValue(p);\n        property.defaultValueWithParam = toDefaultValueWithParam(name, p);\n        property.jsonSchema = Json.pretty(p);\n        if (p.getReadOnly() != null) {\n            property.isReadOnly = p.getReadOnly();\n        }\n        if (p.getXml() != null) {\n            if (p.getXml().getAttribute() != null) {\n                property.isXmlAttribute = p.getXml().getAttribute();\n            }\n            property.xmlPrefix = p.getXml().getPrefix();\n            property.xmlName = p.getXml().getName();\n            property.xmlNamespace = p.getXml().getNamespace();\n        }\n        property.vendorExtensions = p.getVendorExtensions();\n\n        String type = getSwaggerType(p);\n        if (p instanceof AbstractNumericProperty) {\n            AbstractNumericProperty np = (AbstractNumericProperty) p;\n            if (np.getMinimum() != null) {\n                if (p instanceof BaseIntegerProperty) { \/\/ int, long\n                    property.minimum = String.valueOf(np.getMinimum().longValue());\n                } else { \/\/ double, decimal\n                    property.minimum = String.valueOf(np.getMinimum());\n                }\n            }\n            if (np.getMaximum() != null) {\n                if (p instanceof BaseIntegerProperty) { \/\/ int, long\n                    property.maximum = String.valueOf(np.getMaximum().longValue());\n                } else { \/\/ double, decimal\n                    property.maximum = String.valueOf(np.getMaximum());\n                }\n            }\n\n            if (np.getExclusiveMinimum() != null) {\n                property.exclusiveMinimum = np.getExclusiveMinimum();\n            }\n            if (np.getExclusiveMaximum() != null) {\n                property.exclusiveMaximum = np.getExclusiveMaximum();\n            }\n\n            \/\/ check if any validation rule defined\n            \/\/ exclusive* are noop without corresponding min\/max\n            if (property.minimum != null || property.maximum != null)\n                property.hasValidation = true;\n\n            \/\/ legacy support\n            Map<String, Object> allowableValues = new HashMap<String, Object>();\n            if (np.getMinimum() != null) {\n                allowableValues.put(\"min\", np.getMinimum());\n            }\n            if (np.getMaximum() != null) {\n                allowableValues.put(\"max\", np.getMaximum());\n            }\n            if(allowableValues.size() > 0) {\n                property.allowableValues = allowableValues;\n            }\n        }\n\n        if (p instanceof StringProperty) {\n            StringProperty sp = (StringProperty) p;\n            property.maxLength = sp.getMaxLength();\n            property.minLength = sp.getMinLength();\n            property.pattern = toRegularExpression(sp.getPattern());\n\n            \/\/ check if any validation rule defined\n            if (property.pattern != null || property.minLength != null || property.maxLength != null)\n                property.hasValidation = true;\n\n            property.isString = true;\n            if (sp.getEnum() != null) {\n                List<String> _enum = sp.getEnum();\n                property._enum = _enum;\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n\n        \/\/ type is integer and without format\n        if (p instanceof BaseIntegerProperty && !(p instanceof IntegerProperty) && !(p instanceof LongProperty)) {\n            BaseIntegerProperty sp = (BaseIntegerProperty) p;\n            property.isInteger = true;\n            property.isNumeric = true;\n        }\n        if (p instanceof IntegerProperty) {\n            IntegerProperty sp = (IntegerProperty) p;\n            property.isInteger = true;\n            if (sp.getEnum() != null) {\n                List<Integer> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Integer i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof LongProperty) {\n            LongProperty sp = (LongProperty) p;\n            property.isLong = true;\n            property.isNumeric = true;\n            if (sp.getEnum() != null) {\n                List<Long> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Long i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof BooleanProperty) {\n            property.isBoolean = true;\n            property.getter = toBooleanGetter(name);\n        }\n        if (p instanceof BinaryProperty) {\n            property.isBinary = true;\n        }\n        if (p instanceof FileProperty) {\n            property.isFile = true;\n        }\n        if (p instanceof UUIDProperty) {\n            property.isString =true;\n            property.isUuid = true;\n\n        }\n        if (p instanceof ByteArrayProperty) {\n            property.isByteArray = true;\n        }\n        \/\/ type is number and without format\n        if (p instanceof DecimalProperty && !(p instanceof DoubleProperty) && !(p instanceof FloatProperty)) {\n            DecimalProperty sp = (DecimalProperty) p;\n            property.isNumber = true;\n        }\n        if (p instanceof DoubleProperty) {\n            DoubleProperty sp = (DoubleProperty) p;\n            property.isDouble = true;\n            property.isNumeric = true;\n            if (sp.getEnum() != null) {\n                List<Double> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Double i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof FloatProperty) {\n            FloatProperty sp = (FloatProperty) p;\n            property.isFloat = true;\n            property.isNumeric = true;\n            if (sp.getEnum() != null) {\n                List<Float> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(Float i : _enum) {\n                    property._enum.add(i.toString());\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n\n        if (p instanceof DateProperty) {\n            DateProperty sp = (DateProperty) p;\n            property.isDate = true;\n            if (sp.getEnum() != null) {\n                List<String> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(String i : _enum) {\n                    property._enum.add(i);\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        if (p instanceof DateTimeProperty) {\n            DateTimeProperty sp = (DateTimeProperty) p;\n            property.isDateTime = true;\n            if (sp.getEnum() != null) {\n                List<String> _enum = sp.getEnum();\n                property._enum = new ArrayList<String>();\n                for(String i : _enum) {\n                    property._enum.add(i);\n                }\n                property.isEnum = true;\n\n                \/\/ legacy support\n                Map<String, Object> allowableValues = new HashMap<String, Object>();\n                allowableValues.put(\"values\", _enum);\n                property.allowableValues = allowableValues;\n            }\n        }\n        property.datatype = getTypeDeclaration(p);\n        property.dataFormat = p.getFormat();\n\n        \/\/ this can cause issues for clients which don't support enums\n        if (property.isEnum) {\n            property.datatypeWithEnum = toEnumName(property);\n            property.enumName = toEnumName(property);\n        } else {\n            property.datatypeWithEnum = property.datatype;\n        }\n\n        property.baseType = getSwaggerType(p);\n\n        if (p instanceof ArrayProperty) {\n            property.isContainer = true;\n            property.isListContainer = true;\n            property.containerType = \"array\";\n            property.baseType = getSwaggerType(p);\n            if (p.getXml() != null) {\n                property.isXmlWrapped = p.getXml().getWrapped() == null ? false : p.getXml().getWrapped();\n                property.xmlPrefix= p.getXml().getPrefix();\n                property.xmlNamespace = p.getXml().getNamespace();\n                property.xmlName = p.getXml().getName();\n            }\n            \/\/ handle inner property\n            ArrayProperty ap = (ArrayProperty) p;\n            property.maxItems = ap.getMaxItems();\n            property.minItems = ap.getMinItems();\n            String itemName = (String) p.getVendorExtensions().get(\"x-item-name\");\n            if (itemName == null) {\n                itemName = property.name;\n            }\n            CodegenProperty cp = fromProperty(itemName, ap.getItems());\n            updatePropertyForArray(property, cp);\n        } else if (p instanceof MapProperty) {\n            MapProperty ap = (MapProperty) p;\n\n            property.isContainer = true;\n            property.isMapContainer = true;\n            property.containerType = \"map\";\n            property.baseType = getSwaggerType(p);\n            property.minItems = ap.getMinProperties();\n            property.maxItems = ap.getMaxProperties();\n\n            \/\/ handle inner property\n            CodegenProperty cp = fromProperty(\"inner\", ap.getAdditionalProperties());\n            updatePropertyForMap(property, cp);\n        } else {\n            setNonArrayMapProperty(property, type);\n        }\n        return property;\n    }\n","new_comment_raw":"@param p OAS property object","old_comment_raw":"@param p Swagger property object","label":1,"pre_label":0,"AST_level":17,"line_counts":260,"new_code_token_num":1764},{"new_code_raw":"public long resolve(long baseMillis, DateTimeZone zone) { Chronology chrono = iChronology.withZone(zone); long millis = baseMillis; millis = chrono.hourOfDay().set(millis, getValue(HOUR_OF_DAY)); millis = chrono.minuteOfHour().set(millis, getValue(MINUTE_OF_HOUR)); millis = chrono.secondOfMinute().set(millis, getValue(SECOND_OF_MINUTE)); millis = chrono.millisOfSecond().set(millis, getValue(MILLIS_OF_SECOND)); return millis; }","old_code_raw":"    public long resolve(long baseMillis) {\n        long millis = baseMillis;\n        for (int i = 0; i < iFields.length; i++) {\n            millis = iFields[i].set(millis, iValues[i]);\n        }\n        return millis;\n    }\n","new_comment_raw":"@param baseMillis source of missing fields","old_comment_raw":"@param baseMillis source of missing fields","label":0,"pre_label":1,"AST_level":8,"line_counts":10,"new_code_token_num":87},{"new_code_raw":"private static boolean containsItem(Collection<String> itemCollection, String item) { return itemCollection.contains(item.toLowerCase()); }","old_code_raw":"    private static boolean containsItem(Collection itemCollection, String key) {\n        return itemCollection.contains(key.toLowerCase());\n    }\n","new_comment_raw":"@param item - Item to search for.","old_comment_raw":"@param key - Key to search for.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public Single<Void> rxUpdateUser(String username, User user) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.updateUser(username, user, fut); })); }","old_code_raw":"    public Single<Void> rxUpdateUser(String username, User body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.updateUser(username, body, fut);\n        }));\n    }\n","new_comment_raw":"@param username name that need to be deleted (required)","old_comment_raw":"@param username name that need to be deleted (required)","label":0,"pre_label":1,"AST_level":10,"line_counts":6,"new_code_token_num":41},{"new_code_raw":"public boolean isFlagSet(int flagsToCheck) { return isFlagSet(flags, flagsToCheck); }","old_code_raw":"    public boolean isFlagSet(int flag) {\n        return (flags & flag) != 0;\n    }\n","new_comment_raw":"@param flagsToCheck the flags to check","old_comment_raw":"@param flag the flag to check","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) { int value = convertText(text, locale); return set(instant, fieldIndex, values, value); }","old_code_raw":"    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {\n        int value = convertText(text, locale);\n        return set(instant, fieldIndex, values, value);\n    }\n","new_comment_raw":"@param instant the partial instant","old_comment_raw":"@param instant the partial instant","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":46},{"new_code_raw":"public Boolean fakeOuterBooleanSerialize(Boolean booleanPostBody) throws ApiException { ApiResponse<Boolean> resp = fakeOuterBooleanSerializeWithHttpInfo(booleanPostBody); return resp.getData(); }","old_code_raw":"    public Boolean fakeOuterBooleanSerialize(Boolean body) throws ApiException {\n        ApiResponse<Boolean> resp = fakeOuterBooleanSerializeWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"@param booleanPostBody Input boolean as post body (optional)","old_comment_raw":"@param body Input boolean as post body (optional)","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams, collectionQueryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) { contentType = \"application\/json\"; } RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = serialize(body, contentType); } \/\/ Associate callback with request (if not null) so interceptor can \/\/ access it when creating ProgressResponseBody reqBuilder.tag(callback); Request request = null; if (callback != null && reqBody != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return request; }","old_code_raw":"    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        \/\/ ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application\/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart\/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                \/\/ allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                \/\/ use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        Request request = null;\n\n        if(progressRequestListener != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n","new_comment_raw":"@param body The request body object","old_comment_raw":"@param body The request body object","label":0,"pre_label":1,"AST_level":14,"line_counts":48,"new_code_token_num":350},{"new_code_raw":"public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c) throws InstantiationException, IllegalAccessException { factory = new DefaultBroadcasterFactory(clazz); config = c; return factory; }","old_code_raw":"    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, BroadcasterConfig config)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz);\n        return factory;\n    }\n","new_comment_raw":"@param c An instance of  AtmosphereServlet.AtmosphereConfig","old_comment_raw":"@param config An instance of BroadcasterConfig","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":34},{"new_code_raw":"static ColTypeInfo of(MessageType schema, Type type, String[] path, int depth, List<OriginalType> parentTypes) { if (type.isPrimitive()) { PrimitiveType primitiveType = (PrimitiveType) type; int precision = 0; int scale = 0; if (primitiveType.getDecimalMetadata() != null) { precision = primitiveType.getDecimalMetadata().getPrecision(); scale = primitiveType.getDecimalMetadata().getScale(); } int repetitionLevel = schema.getMaxRepetitionLevel(path); int definitionLevel = schema.getMaxDefinitionLevel(path); return new ColTypeInfo(type.getOriginalType(), parentTypes, precision, scale, repetitionLevel, definitionLevel); } Type t = ((GroupType) type).getType(path[depth]); if (!t.isPrimitive()) { OriginalType originalType = t.getOriginalType(); if (originalType == OriginalType.MAP && !ParquetReaderUtility.isLogicalMapType(t.asGroupType())) { originalType = null; } parentTypes.add(originalType); } return of(schema, t, path, depth + 1, parentTypes); }","old_code_raw":"    static ColTypeInfo of(MessageType schema, Type type, String[] path, int depth) {\n      if (type.isPrimitive()) {\n        PrimitiveType primitiveType = (PrimitiveType) type;\n        int precision = 0;\n        int scale = 0;\n        if (primitiveType.getDecimalMetadata() != null) {\n          precision = primitiveType.getDecimalMetadata().getPrecision();\n          scale = primitiveType.getDecimalMetadata().getScale();\n        }\n\n        int repetitionLevel = schema.getMaxRepetitionLevel(path);\n        int definitionLevel = schema.getMaxDefinitionLevel(path);\n\n        return new ColTypeInfo(type.getOriginalType(), precision, scale, repetitionLevel, definitionLevel);\n      }\n      Type t = ((GroupType) type).getType(path[depth]);\n      return of(schema, t, path, depth + 1);\n    }\n","new_comment_raw":"@param length the length of the row group","old_comment_raw":"@param length the length of the row group","label":0,"pre_label":1,"AST_level":10,"line_counts":26,"new_code_token_num":190},{"new_code_raw":"public Action timedout(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { AtmosphereResourceImpl re; long l = (Long) request.getAttribute(MAX_INACTIVE); if (l == -1) { \/\/ The closedDetector closed the connection. return timedoutAction; } request.setAttribute(MAX_INACTIVE, (long) -1); \/\/ Something went wrong. if (request == null || response == null) { logger.warn(\"Invalid Request\/Response: {}\/{}\", request, response); return timedoutAction; } re = (AtmosphereResourceImpl) request.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE); if (re != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true); Broadcaster b = re.getBroadcaster(); if (b instanceof DefaultBroadcaster) { ((DefaultBroadcaster)b).broadcastOnResume(re); } if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) { re.getAtmosphereResourceEvent().setIsResumedOnTimeout( (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT)); } invokeAtmosphereHandler(re); } return timedoutAction; }","old_code_raw":"    public Action timedout(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n\n        AtmosphereResourceImpl re;\n        long l = (Long) req.getAttribute(MAX_INACTIVE);\n        if (l == -1) {\n            \/\/ The closedDetector closed the connection.\n            return timedoutAction;            \n        }\n        req.setAttribute(MAX_INACTIVE, (long)-1);\n\n        \/\/ Something went wrong.\n        if (req == null || res == null) {\n            logger.warning(\"Invalid Request\/Response: \" + req + \"\/\" + res);\n            return timedoutAction;\n        }\n\n        re = (AtmosphereResourceImpl) req.getAttribute(AtmosphereServlet.ATMOSPHERE_RESOURCE);\n\n        if (re != null) {\n            re.getAtmosphereResourceEvent().setIsResumedOnTimeout(true);\n\n            Broadcaster b = re.getBroadcaster();\n            if (b instanceof DefaultBroadcaster) {\n                ((DefaultBroadcaster)b).broadcastOnResume(re);\n            }\n\n            if (re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT) != null) {\n                re.getAtmosphereResourceEvent().setIsResumedOnTimeout(\n                        (Boolean) re.getRequest().getAttribute(AtmosphereServlet.RESUMED_ON_TIMEOUT));\n            }\n            invokeAtmosphereHandler(re);\n        }\n\n        return timedoutAction;\n    }\n","new_comment_raw":"@param request the  HttpServletRequest","old_comment_raw":"@param req the HttpServletRequest","label":1,"pre_label":0,"AST_level":13,"line_counts":37,"new_code_token_num":198},{"new_code_raw":"public QuoteAnnotator(String name, Properties props, boolean verbose) { USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + \".\" + \"singleQuotes\", \"false\")); MAX_LENGTH = Integer.parseInt(props.getProperty(name + \".\" + \"maxLength\", \"-1\")); ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"asciiQuotes\", \"false\")); ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + \".\" + \"allowEmbeddedSame\", \"false\")); SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"smartQuotes\", \"false\")); EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + \".\" + \"extractUnclosedQuotes\", \"false\")); ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"attributeQuotes\", \"true\")); VERBOSE = verbose; Timing timer = null; if (VERBOSE) { timer = new Timing(); log.info(\"Preparing quote annotator...\"); } if (ATTRIBUTE_QUOTES) quoteAttributionAnnotator = new QuoteAttributionAnnotator(props); if (VERBOSE) { timer.stop(\"done.\"); } }","old_code_raw":"  public QuoteAnnotator(Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(\"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(\"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(\"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(\"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(\"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(\"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(\"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n","new_comment_raw":"@param props Properties object that contains the customizable properties attributes.","old_comment_raw":"@param props Properties object that contains the customizable properties attributes.","label":0,"pre_label":1,"AST_level":9,"line_counts":23,"new_code_token_num":223},{"new_code_raw":"public static int numberOfLeadingZeros(long v) { \/\/ After Hacker's Delight, Figure 5-6 if (v < 0) { return 0; } if (v == 0) { return 64; } \/\/ On a 64-bit VM, the two previous tests should probably be replaced by \/\/ if (v <= 0) return ((int) (~v >> 57)) & 64; int n = 1; int i = (int) (v >>> 32); if (i == 0) { n += 32; i = (int) v; } if (i >> 16 == 0) { n += 16; i <<= 16; } if (i >> 24 == 0) { n += 8; i <<= 8; } if (i >> 28 == 0) { n += 4; i <<= 4; } if (i >> 30 == 0) { n += 2; i <<= 2; } return n - (i >>> 31); }","old_code_raw":"    public static int numberOfLeadingZeros(long lng) {\n        lng |= lng >> 1;\n        lng |= lng >> 2;\n        lng |= lng >> 4;\n        lng |= lng >> 8;\n        lng |= lng >> 16;\n        lng |= lng >> 32;\n        return bitCount(~lng);\n    }\n","new_comment_raw":"@param v the long to examine.","old_comment_raw":"@param lng the long to examine.","label":1,"pre_label":0,"AST_level":8,"line_counts":37,"new_code_token_num":179},{"new_code_raw":"public void redirectOutput(){ if (System.getenv(\"REDIRECT\") == null || !System.getenv(\"REDIRECT\").equals(\"true\")) { return; } String DEFAULT_OUT_TARGET_FILE = JStormUtils.getLogFileName(); if (DEFAULT_OUT_TARGET_FILE == null) { DEFAULT_OUT_TARGET_FILE = \"\/dev\/null\"; } else { DEFAULT_OUT_TARGET_FILE += \".out\"; } String outputFile = ConfigExtension.getWorkerRedirectOutputFile(workerData.getStormConf()); if (outputFile == null) { outputFile = DEFAULT_OUT_TARGET_FILE; }else { try { File file = new File(outputFile); if (file.exists() == false) { PathUtils.touch(outputFile); }else { if (file.isDirectory() == true) { LOG.warn(\"Failed to write \" + outputFile); outputFile = DEFAULT_OUT_TARGET_FILE; }else if (file.canWrite() == false) { LOG.warn(\"Failed to write \" + outputFile); outputFile = DEFAULT_OUT_TARGET_FILE; } } }catch(Exception e) { LOG.warn(\"Failed to touch \" + outputFile, e); outputFile = DEFAULT_OUT_TARGET_FILE; } } try { JStormUtils.redirectOutput(outputFile); }catch(Exception e) { LOG.warn(\"Failed to redirect to \" + outputFile, e); } }","old_code_raw":"\tpublic static void redirectOutput(String port) throws Exception {\n\n\t\tif (System.getenv(\"REDIRECT\") == null\n\t\t\t\t|| !System.getenv(\"REDIRECT\").equals(\"true\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tString OUT_TARGET_FILE = JStormUtils.getLogFileName();\n\t\tif (OUT_TARGET_FILE == null) {\n\t\t\tOUT_TARGET_FILE = \"\/dev\/null\";\n\t\t} else {\n\t\t\tOUT_TARGET_FILE += \".out\";\n\t\t}\n\n\t\tJStormUtils.redirectOutput(OUT_TARGET_FILE);\n\n\t}\n","new_comment_raw":"@param worker_id","old_comment_raw":"@param worker_id","label":0,"pre_label":1,"AST_level":14,"line_counts":46,"new_code_token_num":229},{"new_code_raw":"public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean body) throws ApiException { Object localVarPostBody = body; \/\/ create path and map variables String localVarPath = \"\/fake\/outer\/boolean\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"*\/*\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ApiResponse<Boolean> fakeOuterBooleanSerializeWithHttpInfo(Boolean booleanPostBody) throws ApiException {\n    Object localVarPostBody = booleanPostBody;\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/outer\/boolean\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"*\/*\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Boolean> localVarReturnType = new GenericType<Boolean>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param body Input boolean as post body (optional)","old_comment_raw":"@param booleanPostBody Input boolean as post body (optional)","label":1,"pre_label":0,"AST_level":8,"line_counts":30,"new_code_token_num":161},{"new_code_raw":"public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereConfig c) throws InstantiationException, IllegalAccessException { factory = new DefaultBroadcasterFactory(clazz, \"NEVER\", c); return factory; }","old_code_raw":"    public static BroadcasterFactory buildAndReplaceDefaultfactory(Class<? extends Broadcaster> clazz, AtmosphereServlet.AtmosphereConfig c)\n            throws InstantiationException, IllegalAccessException {\n\n        factory = new DefaultBroadcasterFactory(clazz, \"NEVER\", c);\n        return factory;\n    }\n","new_comment_raw":"@param c An instance of  AtmosphereServlet.AtmosphereConfig","old_comment_raw":"@param c An instance of AtmosphereServlet.AtmosphereConfig","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":36},{"new_code_raw":"public boolean isUpToDate(Set<Serializable> spaces, Long timestamp, SharedSessionContractImplementor session) throws CacheException { final boolean stats = factory != null && factory.getStatistics().isStatisticsEnabled(); for ( Serializable space : spaces ) { final Long lastUpdate = getLastUpdateTimestampForSpace( space, session ); if ( lastUpdate == null ) { if ( stats ) { factory.getStatistics().updateTimestampsCacheMiss(); } \/\/the last update timestamp was lost from the cache \/\/(or there were no updates since startup!) \/\/updateTimestamps.put( space, new Long( updateTimestamps.nextTimestamp() ) ); \/\/result = false; \/\/ safer } else { if ( DEBUG_ENABLED ) { LOG.debugf( \"[%s] last update timestamp: %s\", space, lastUpdate + \", result set timestamp: \" + timestamp ); } if ( stats ) { factory.getStatistics().updateTimestampsCacheHit(); } if ( lastUpdate >= timestamp ) { return false; } } } return true; }","old_code_raw":"\tpublic boolean isUpToDate(Set<Serializable> spaces, Long timestamp, SessionImplementor session) throws CacheException {\n\t\tfinal boolean stats = factory != null && factory.getStatistics().isStatisticsEnabled();\n\n\t\tfor ( Serializable space : spaces ) {\n\t\t\tfinal Long lastUpdate = getLastUpdateTimestampForSpace( space, session );\n\t\t\tif ( lastUpdate == null ) {\n\t\t\t\tif ( stats ) {\n\t\t\t\t\tfactory.getStatisticsImplementor().updateTimestampsCacheMiss();\n\t\t\t\t}\n\t\t\t\t\/\/the last update timestamp was lost from the cache\n\t\t\t\t\/\/(or there were no updates since startup!)\n\t\t\t\t\/\/updateTimestamps.put( space, new Long( updateTimestamps.nextTimestamp() ) );\n\t\t\t\t\/\/result = false; \/\/ safer\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ( DEBUG_ENABLED ) {\n\t\t\t\t\tLOG.debugf(\n\t\t\t\t\t\t\t\"[%s] last update timestamp: %s\",\n\t\t\t\t\t\t\tspace,\n\t\t\t\t\t\t\tlastUpdate + \", result set timestamp: \" + timestamp\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif ( stats ) {\n\t\t\t\t\tfactory.getStatisticsImplementor().updateTimestampsCacheHit();\n\t\t\t\t}\n\t\t\t\tif ( lastUpdate >= timestamp ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n","new_comment_raw":"@param timestamp The timestamp against which to check.","old_comment_raw":"@param timestamp The timestamp against which to check.","label":0,"pre_label":1,"AST_level":13,"line_counts":33,"new_code_token_num":189},{"new_code_raw":"private boolean searchForToggleButton(String regex, int matches) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class); if(matches == 0) matches = 1; for(ToggleButton toggleButton : toggleButtonList){ matcher = p.matcher(toggleButton.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroller.scroll(Scroller.Direction.DOWN)) { return searchForToggleButton(regex, matches); } else { if(countMatches > 0) Log.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex); countMatches = 0; return false; } }","old_code_raw":"\tprivate boolean searchForToggleButton(String search, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(ToggleButton toggleButton : toggleButtonList){\n\t\t\tmatcher = p.matcher(toggleButton.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t} \n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForToggleButton(search, matches);\n\t\t} else {\n\t\t\tif(countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n","new_comment_raw":"@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found","old_comment_raw":"@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found","label":0,"pre_label":1,"AST_level":11,"line_counts":31,"new_code_token_num":154},{"new_code_raw":"public boolean isConnected(Integer channelId) { synchronized (wsProxies) { if (wsProxies.containsKey(channelId)) { return wsProxies.get(channelId).isConnected(); } } return false; }","old_code_raw":"\tpublic boolean isConnected(HttpMessage handshakeMessage) {\n\t\tint historyId = handshakeMessage.getHistoryRef().getHistoryId();\n\t\tfor (Entry<Integer, WebSocketProxy> entry : wsProxies.entrySet()) {\n\t\t\tWebSocketProxy proxy = entry.getValue();\n\t\t\tif (historyId == proxy.getHandshakeReference().getHistoryId()) {\n\t\t\t\treturn proxy.isConnected();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@param channelId","old_comment_raw":"@param handshakeMessage","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":38},{"new_code_raw":"public ScrollableResults scroll(ScrollMode mode, Expression<?> expr) { Query query = createQuery(expr); reset(); return query.scroll(mode); }","old_code_raw":"    public ScrollableResults scroll(ScrollMode mode, Expr<?> expr) {\n        Query query = createQuery(expr);\n        reset();\n        return query.scroll(mode);\n    }\n","new_comment_raw":"@param mode","old_comment_raw":"@param mode","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":31},{"new_code_raw":"private ClientResponse makeRemoteCall(Action action, String serviceUrl) throws Throwable { String urlPath = null; Stopwatch tracer = null; ClientResponse response = null; logger.debug(\"Discovery Client talking to the server {}\", serviceUrl); try { \/\/ If the application is unknown do not register\/renew\/cancel but \/\/ refresh if ((UNKNOWN.equals(instanceInfo.getAppName()) && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta .equals(action)))) { return null; } WebResource r = discoveryApacheClient.resource(serviceUrl); String remoteRegionsToFetchStr; switch (action) { case Renew: tracer = RENEW_TIMER.start(); urlPath = \"apps\/\" + appPathIdentifier; response = r .path(urlPath) .queryParam(\"status\", instanceInfo.getStatus().toString()) .queryParam(\"lastDirtyTimestamp\", instanceInfo.getLastDirtyTimestamp().toString()) .put(ClientResponse.class); break; case Refresh: tracer = REFRESH_TIMER.start(); final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress(); urlPath = vipAddress == null ? \"apps\/\" : \"vips\/\" + vipAddress; remoteRegionsToFetchStr = remoteRegionsToFetch.get(); if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) { urlPath += \"?regions=\" + remoteRegionsToFetchStr; } response = getUrl(serviceUrl + urlPath); break; case Refresh_Delta: tracer = REFRESH_DELTA_TIMER.start(); urlPath = \"apps\/delta\"; remoteRegionsToFetchStr = remoteRegionsToFetch.get(); if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) { urlPath += \"?regions=\" + remoteRegionsToFetchStr; } response = getUrl(serviceUrl + urlPath); break; case Register: tracer = REGISTER_TIMER.start(); urlPath = \"apps\/\" + instanceInfo.getAppName(); response = r.path(urlPath) .type(MediaType.APPLICATION_JSON_TYPE) .post(ClientResponse.class, instanceInfo); break; case Cancel: tracer = CANCEL_TIMER.start(); urlPath = \"apps\/\" + appPathIdentifier; response = r.path(urlPath).delete(ClientResponse.class); \/\/ Return without during de-registration if it is not registered \/\/ already and if we get a 404 if ((!isRegisteredWithDiscovery) && (response.getStatus() == Status.NOT_FOUND .getStatusCode())) { return response; } break; } if (logger.isDebugEnabled()) { logger.debug(\"Finished a call to service url {} and url path {} with status code {}.\", new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())}); } if (isOk(action, response.getStatus())) { return response; } else { logger.warn(\"Action: \" + action + \" => returned status of \" + response.getStatus() + \" from \" + serviceUrl + urlPath); throw new RuntimeException(\"Bad status: \" + response.getStatus()); } } catch (Throwable t) { closeResponse(response); logger.warn(\"Can't get a response from \" + serviceUrl + urlPath, t); throw t; } finally { if (tracer != null) { tracer.stop(); } } }","old_code_raw":"    private ClientResponse makeRemoteCall(Action action, int serviceUrlIndex)\n            throws Throwable {\n        String urlPath = null;\n        Stopwatch tracer = null;\n        String serviceUrl = eurekaServiceUrls.get().get(serviceUrlIndex);\n        ClientResponse response = null;\n        logger.debug(\"Discovery Client talking to the server {}\", serviceUrl);\n        try {\n            \/\/ If the application is unknown do not register\/renew\/cancel but\n            \/\/ refresh\n            if ((UNKNOWN.equals(instanceInfo.getAppName())\n                    && (!Action.Refresh.equals(action)) && (!Action.Refresh_Delta\n                    .equals(action)))) {\n                return null;\n            }\n            WebResource r = discoveryApacheClient.resource(serviceUrl);\n            String remoteRegionsToFetchStr;\n            switch (action) {\n            case Renew:\n                tracer = RENEW_TIMER.start();\n                urlPath = \"apps\/\" + appPathIdentifier;\n                response = r\n                        .path(urlPath)\n                        .queryParam(\"status\",\n                                instanceInfo.getStatus().toString())\n                        .queryParam(\"lastDirtyTimestamp\",\n                                instanceInfo.getLastDirtyTimestamp().toString())\n                        .put(ClientResponse.class);\n                break;\n            case Refresh:\n                tracer = REFRESH_TIMER.start();\n                final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress();\n                urlPath = vipAddress == null ? \"apps\/\" : \"vips\/\" + vipAddress;\n                remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                    urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                }\n                response = getUrl(serviceUrl + urlPath);\n                break;\n            case Refresh_Delta:\n                tracer = REFRESH_DELTA_TIMER.start();\n                urlPath = \"apps\/delta\";\n                remoteRegionsToFetchStr = remoteRegionsToFetch.get();\n                if (!Strings.isNullOrEmpty(remoteRegionsToFetchStr)) {\n                    urlPath += \"?regions=\" + remoteRegionsToFetchStr;\n                }\n                response = getUrl(serviceUrl + urlPath);\n                break;\n            case Register:\n                tracer = REGISTER_TIMER.start();\n                urlPath = \"apps\/\" + instanceInfo.getAppName();\n                response = r.path(urlPath)\n                        .type(MediaType.APPLICATION_JSON_TYPE)\n                        .post(ClientResponse.class, instanceInfo);\n                break;\n            case Cancel:\n                tracer = CANCEL_TIMER.start();\n                urlPath = \"apps\/\" + appPathIdentifier;\n                response = r.path(urlPath).delete(ClientResponse.class);\n                \/\/ Return without during de-registration if it is not registered\n                \/\/ already and if we get a 404\n                if ((!isRegisteredWithDiscovery)\n                        && (response.getStatus() == Status.NOT_FOUND\n                                .getStatusCode())) {\n                    return response;\n                }\n                break;\n            }\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Finished a call to service url {} and url path {} with status code {}.\",\n                            new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())});\n            }\n            if (isOk(action, response.getStatus())) {\n                return response;\n            } else {\n                logger.warn(\"Action: \" + action + \"  => returned status of \"\n                        + response.getStatus() + \" from \" + serviceUrl\n                        + urlPath);\n                throw new RuntimeException(\"Bad status: \"\n                        + response.getStatus());\n            }\n        } catch (Throwable t) {\n            closeResponse(response);\n            String msg = \"Can't get a response from \" + serviceUrl + urlPath;\n            if (eurekaServiceUrls.get().size() > (++serviceUrlIndex)) {\n                logger.warn(msg, t);\n                logger.warn(\"Trying backup: \"\n                        + eurekaServiceUrls.get().get(serviceUrlIndex));\n                SERVER_RETRY_COUNTER.increment();\n                return makeRemoteCall(action, serviceUrlIndex);\n            } else {\n                ALL_SERVER_FAILURE_COUNT.increment();\n                logger.error(\n                        msg\n                                + \"\\nCan't contact any eureka nodes - possibly a security group issue?\",\n                        t);\n                throw t;\n            }\n        } finally {\n            if (tracer != null) {\n                tracer.stop();\n            }\n        }\n    }\n","new_comment_raw":"@param action the action to be performed on eureka server.","old_comment_raw":"@param action the action to be performed on eureka server. Try the fallback servers in case of problems communicating to the primary one.","label":1,"pre_label":0,"AST_level":14,"line_counts":91,"new_code_token_num":590},{"new_code_raw":"private ColumnState buildPrimitive(ContainerState parent, ColumnReadProjection colProj) { ColumnMetadata columnSchema = colProj.providedSchema(); ValueVector vector; if (!colProj.isProjected()) { \/\/ Column is not projected. No materialized backing for the column. vector = null; } else { \/\/ Create the vector for the column. vector = parent.vectorCache().addOrGet(columnSchema.schema()); \/\/ In permissive mode, the mode or precision of the vector may differ \/\/ from that requested. Update the schema to match. if (parent.vectorCache().isPermissive() && ! vector.getField().isEquivalent(columnSchema.schema())) { columnSchema = ((PrimitiveColumnMetadata) columnSchema).mergeWith(vector.getField()); } } \/\/ Create the writer. final AbstractObjectWriter colWriter = ColumnWriterFactory.buildColumnWriter( columnSchema, colProj.conversionFactory(), vector); \/\/ Build the vector state which manages the vector. VectorState vectorState; if (vector == null) { vectorState = new NullVectorState(); } else if (columnSchema.isArray()) { vectorState = new RepeatedVectorState(colWriter.array(), (RepeatedValueVector) vector); } else if (columnSchema.isNullable()) { vectorState = new NullableVectorState( colWriter, (NullableVector) vector); } else { vectorState = SimpleVectorState.vectorState(columnSchema, colWriter.events(), vector); } \/\/ Create the column state which binds the vector and writer together. return new PrimitiveColumnState(parent.loader(), colWriter, vectorState); }","old_code_raw":"  private ColumnState buildPrimitive(ContainerState parent, ColumnTransform outputCol) {\n    ProjectionType projType = outputCol.projectionType();\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    \/\/ Enforce correspondence between implied type from the projection list\n    \/\/ and the actual type of the column.\n\n    switch (projType) {\n    case ARRAY:\n      if (! columnSchema.isArray()) {\n        incompatibleProjection(projType, columnSchema);\n      }\n      break;\n    case TUPLE:\n    case TUPLE_ARRAY:\n      incompatibleProjection(projType, columnSchema);\n      break;\n    default:\n      break;\n    }\n\n    ValueVector vector;\n    if (projType == ProjectionType.UNPROJECTED) {\n\n      \/\/ Column is not projected. No materialized backing for the column.\n\n      vector = null;\n    } else {\n\n      \/\/ Create the vector for the column.\n\n      vector = parent.vectorCache().addOrGet(columnSchema.schema());\n\n      \/\/ In permissive mode, the mode or precision of the vector may differ\n      \/\/ from that requested. Update the schema to match.\n\n      if (parent.vectorCache().isPermissive() && ! vector.getField().isEquivalent(columnSchema.schema())) {\n        columnSchema = ((PrimitiveColumnMetadata) columnSchema).mergeWith(vector.getField());\n      }\n    }\n\n    \/\/ Create the writer.\n\n    final AbstractObjectWriter colWriter = ColumnWriterFactory.buildColumnWriter(\n        columnSchema, outputCol, vector);\n\n    \/\/ Build the vector state which manages the vector.\n\n    VectorState vectorState;\n    if (vector == null) {\n      vectorState = new NullVectorState();\n    } else if (columnSchema.isArray()) {\n      vectorState = new RepeatedVectorState(colWriter.array(), (RepeatedValueVector) vector);\n    } else if (columnSchema.isNullable()) {\n      vectorState = new NullableVectorState(\n          colWriter, (NullableVector) vector);\n    } else {\n      vectorState = SimpleVectorState.vectorState(columnSchema,\n            colWriter.events(), vector);\n    }\n\n    \/\/ Create the column state which binds the vector and writer together.\n\n    return new PrimitiveColumnState(parent.loader(), colWriter,\n        vectorState);\n  }\n","new_comment_raw":"@param projType implied projection type for the column","old_comment_raw":"@param projType implied projection type for the column","label":0,"pre_label":1,"AST_level":11,"line_counts":49,"new_code_token_num":275},{"new_code_raw":"public static Object increment(Object version, VersionType versionType, SharedSessionContractImplementor session) { final Object next = versionType.next( version, session ); if ( LOG.isTraceEnabled() ) { LOG.tracef( \"Incrementing: %s to %s\", versionType.toLoggableString( version, session.getFactory() ), versionType.toLoggableString( next, session.getFactory() ) ); } return next; }","old_code_raw":"\tpublic static Object increment(Object version, VersionType versionType, SessionImplementor session) {\n\t\tfinal Object next = versionType.next( version, session );\n\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\tLOG.tracef(\n\t\t\t\t\t\"Incrementing: %s to %s\",\n\t\t\t\t\tversionType.toLoggableString( version, session.getFactory() ),\n\t\t\t\t\tversionType.toLoggableString( next, session.getFactory() )\n\t\t\t);\n\t\t}\n\t\treturn next;\n\t}\n","new_comment_raw":"@param version The current version","old_comment_raw":"@param version The current version","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":75},{"new_code_raw":"public static IType createType(IASTDeclarator declarator) { IASTDeclSpecifier declSpec = null; IASTNode node = declarator.getParent(); while( node instanceof IASTDeclarator ){ declarator = (IASTDeclarator) node; node = node.getParent(); } if( node instanceof IASTParameterDeclaration ) declSpec = ((IASTParameterDeclaration) node).getDeclSpecifier(); else if( node instanceof IASTSimpleDeclaration ) declSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier(); else if( node instanceof IASTFunctionDefinition ) declSpec = ((IASTFunctionDefinition)node).getDeclSpecifier(); else if( node instanceof IASTTypeId ) declSpec = ((IASTTypeId)node).getDeclSpecifier(); boolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); IType type = null; \/\/C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \/\/members of the parameter type list for a function definition. if( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){ type = createBaseType( declSpec ); } else { type = createType( declSpec ); } type = createType( type, declarator ); if( isParameter ) { \/\/C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the \/\/type qualifiers (if any) are those specified within the [ and ] of the array type derivation if( type instanceof IArrayType ){ CArrayType at = (CArrayType) type; type = new CQualifiedPointerType( at.getType(), at.getModifier() ); } else if( type instanceof IFunctionType ) { \/\/-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\" type = new CPointerType( type ); } } return type; }","old_code_raw":"\tpublic static IType createType(IASTName name) {\n\t\tif (!(name.getParent() instanceof IASTDeclarator)) return null;\n\t\t\n\t    IASTDeclSpecifier declSpec = null;\n\t\tIASTDeclarator declarator = (IASTDeclarator) name.getParent();\n\t\t\n\t\tIASTNode node = declarator.getParent();\n\t\twhile( node instanceof IASTDeclarator ){\n\t\t\tdeclarator = (IASTDeclarator) node;\n\t\t\tnode = node.getParent();\n\t\t}\n\t\t\n\t\tif( node instanceof IASTParameterDeclaration )\n\t\t\tdeclSpec = ((IASTParameterDeclaration) node).getDeclSpecifier();\n\t\telse if( node instanceof IASTSimpleDeclaration )\n\t\t\tdeclSpec = ((IASTSimpleDeclaration)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTFunctionDefinition )\n\t\t\tdeclSpec = ((IASTFunctionDefinition)node).getDeclSpecifier();\n\t\telse if( node instanceof IASTTypeId )\n\t\t    declSpec = ((IASTTypeId)node).getDeclSpecifier();\n\t\n\t\tboolean isParameter = ( node instanceof IASTParameterDeclaration || node.getParent() instanceof ICASTKnRFunctionDeclarator ); \n\t\t\n\t\tIType type = null;\n\t\t\n\t\t\/\/C99 6.7.5.3-12 The storage class specifier for a parameter declaration is ignored unless the declared parameter is one of the \n\t\t\/\/members of the parameter type list for a function definition.\n\t\tif( isParameter && node.getParent().getParent() instanceof IASTFunctionDefinition ){\n\t\t    type = createBaseType( declSpec );\n\t\t} else {\n\t\t    type = createType( declSpec );\n\t\t}\n\t\t\n\t\ttype = createType( type, declarator );\n\t\t\n\t\t\n        if( isParameter ) {\n            \/\/C99: 6.7.5.3-7 a declaration of a parameter as \"array of type\" shall be adjusted to \"qualified pointer to type\", where the\n    \t\t\/\/type qualifiers (if any) are those specified within the [ and ] of the array type derivation\n            if( type instanceof IArrayType ){\n\t            CArrayType at = (CArrayType) type;\n\t            type = new CQualifiedPointerType( at.getType(), at.getModifier() );\n\t        } else if( type instanceof IFunctionType ) {\n\t            \/\/-8 A declaration of a parameter as \"function returning type\" shall be adjusted to \"pointer to function returning type\"\n\t            type = new CPointerType( type );\n\t        }\n        }\n        \n\t\treturn type;\n\t}\n","new_comment_raw":"@param declarator the IASTDeclarator whose IType will be created","old_comment_raw":"@param name the IASTName whose IType will be created","label":1,"pre_label":0,"AST_level":11,"line_counts":49,"new_code_token_num":347},{"new_code_raw":"public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param headerParams The header parameters","old_comment_raw":"@param headerParams The header parameters","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public Order placeOrder (Order order) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = order; \/\/ verify the required parameter 'order' is set if (order == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'order' when calling placeOrder\", new ApiException(400, \"Missing the required parameter 'order' when calling placeOrder\")); } \/\/ create path and map variables String path = \"\/store\/order\"; \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"application\/json\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params } String[] authNames = new String[] { }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class); } else { return null; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public Order placeOrder (Order body) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'body' when calling placeOrder\",\n        new ApiException(400, \"Missing the required parameter 'body' when calling placeOrder\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/store\/order\";\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n    }\n\n    String[] authNames = new String[] {  };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return (Order) ApiInvoker.deserialize(localVarResponse, \"\", Order.class);\n      } else {\n         return null;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param order order placed for purchasing the pet","old_comment_raw":"@param body order placed for purchasing the pet","label":1,"pre_label":0,"AST_level":11,"line_counts":57,"new_code_token_num":368},{"new_code_raw":"public Object nullSafeGet(ResultSet rs, String name, SharedSessionContractImplementor session, Object owner) throws SQLException { return nullSafeGet( rs, new String[] { name }, session, owner ); }","old_code_raw":"\tpublic Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner) throws SQLException {\n\t\treturn nullSafeGet( rs, new String[] { name }, session, owner );\n\t}\n","new_comment_raw":"@param persister The underlying collection persister (metadata)","old_comment_raw":"@param persister The underlying collection persister (metadata)","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":38},{"new_code_raw":"private static SemanticGraph fromProto(CoreNLPProtos.DependencyGraph proto, List<CoreLabel> sentence, String docid) { SemanticGraph graph = new SemanticGraph(); \/\/ first construct the actual nodes; keep them indexed by their index \/\/ This block is optimized as one of the places which take noticeable time \/\/ in datum caching int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for(CoreNLPProtos.DependencyGraph.Node in: proto.getNodeList()){ min = in.getIndex() < min ? in.getIndex() : min; max = in.getIndex() > max ? in.getIndex() : max; } IndexedWord[] nodes = new IndexedWord[max - min >= 0 ? max - min + 1 : 0]; for(CoreNLPProtos.DependencyGraph.Node in: proto.getNodeList()){ CoreLabel token = sentence.get(in.getIndex() - 1); \/\/ index starts at 1! IndexedWord word = new IndexedWord(docid, in.getSentenceIndex(), in.getIndex(), token); word.set(ValueAnnotation.class, word.get(TextAnnotation.class)); if(in.hasCopyAnnotation()){ word.set(CopyAnnotation.class, in.getCopyAnnotation()); } assert in.getIndex() == word.index(); nodes[in.getIndex() - min] = word; } for (IndexedWord node : nodes) { if (node != null) { graph.addVertex(node); } } \/\/ add all edges to the actual graph for(CoreNLPProtos.DependencyGraph.Edge ie: proto.getEdgeList()){ IndexedWord source = nodes[ie.getSource() - min]; assert(source != null); IndexedWord target = nodes[ie.getTarget() - min]; assert(target != null); synchronized (globalLock) { \/\/ this is not thread-safe: there are static fields in GrammaticalRelation assert ie.hasDep(); GrammaticalRelation rel = GrammaticalRelation.valueOf(ie.getDep()); graph.addEdge(source, target, rel, 1.0, ie.hasIsExtra() && ie.getIsExtra()); } } if (proto.getRootCount() > 0) { Collection<IndexedWord> roots = new ArrayList<IndexedWord>(); for(int rootI : proto.getRootList()){ roots.add(nodes[rootI - min]); } graph.setRoots(roots); } else { \/\/ Roots were not saved away \/\/ compute root nodes if non-empty if(!graph.isEmpty()){ graph.resetRoots(); } } return graph; }","old_code_raw":"  private static SemanticGraph fromProto(CoreMapProtos.DependencyGraph proto, List<CoreLabel> sentence, String docid) {\n    SemanticGraph graph = new SemanticGraph();\n\n    \/\/ first construct the actual nodes; keep them indexed by their index\n    \/\/ This block is optimized as one of the places which take noticeable time\n    \/\/ in datum caching\n    int min = Integer.MAX_VALUE;\n    int max = Integer.MIN_VALUE;\n    for(CoreMapProtos.DependencyGraph.Node in: proto.getNodeList()){\n      min = in.getIndex() < min ? in.getIndex() : min;\n      max = in.getIndex() > max ? in.getIndex() : max;\n    }\n    IndexedWord[] nodes = new IndexedWord[max - min >= 0 ? max - min + 1 : 0];\n    for(CoreMapProtos.DependencyGraph.Node in: proto.getNodeList()){\n      CoreLabel token = sentence.get(in.getIndex() - 1); \/\/ index starts at 1!\n      IndexedWord word = new IndexedWord(docid, in.getSentenceIndex(), in.getIndex(), token);\n      word.set(ValueAnnotation.class, word.get(TextAnnotation.class));\n      if(in.hasCopyAnnotation()){ word.set(CopyAnnotation.class, in.getCopyAnnotation()); }\n      assert in.getIndex() == word.index();\n      nodes[in.getIndex() - min] = word;\n    }\n    for (IndexedWord node : nodes) {\n      if (node != null) { graph.addVertex(node); }\n    }\n\n    \/\/ add all edges to the actual graph\n    for(CoreMapProtos.DependencyGraph.Edge ie: proto.getEdgeList()){\n      IndexedWord source = nodes[ie.getSource() - min];\n      assert(source != null);\n      IndexedWord target = nodes[ie.getTarget() - min];\n      assert(target != null);\n      synchronized (globalLock) {\n        \/\/ this is not thread-safe: there are static fields in GrammaticalRelation\n        assert ie.hasDep();\n        GrammaticalRelation rel = GrammaticalRelation.valueOf(ie.getDep());\n        graph.addEdge(source, target, rel, 1.0, ie.hasIsExtra() && ie.getIsExtra());\n      }\n    }\n\n    if (proto.getRootCount() > 0) {\n      Collection<IndexedWord> roots = new ArrayList<IndexedWord>();\n      for(int rootI : proto.getRootList()){\n        roots.add(nodes[rootI]);\n      }\n      graph.setRoots(roots);\n    } else {\n      \/\/ Roots were not saved away\n      \/\/ compute root nodes if non-empty\n      if(!graph.isEmpty()){\n        graph.resetRoots();\n      }\n    }\n    return graph;\n  }\n","new_comment_raw":"@param docid A docid must be supplied, as it is not saved by the serialized representation.","old_comment_raw":"@param docid A docid must be supplied, as it is not saved by the serialized representation.","label":0,"pre_label":1,"AST_level":12,"line_counts":55,"new_code_token_num":473},{"new_code_raw":"public static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) { final Type type = property.getHibernateTypeDescriptor().getExplicitType(); \/\/ we need to dirty check collections, since they can cause an owner \/\/ version number increment \/\/ we need to dirty check many-to-ones with not-found=\"ignore\" in order \/\/ to update the cache (not the database), since in this case a null \/\/ entity reference can lose information boolean alwaysDirtyCheck = type.isAssociationType() && ( (AssociationType) type ).isAlwaysDirtyChecked(); if ( property.isSimpleValue() ) { SimpleAttributeBinding simpleProperty = ( SimpleAttributeBinding ) property; return new StandardProperty( simpleProperty.getAttribute().getName(), simpleProperty.getNodeName(), type, lazyAvailable && simpleProperty.isLazy(), simpleProperty.isInsertable(), simpleProperty.isUpdatable(), simpleProperty.getGeneration() == PropertyGeneration.INSERT || simpleProperty.getGeneration() == PropertyGeneration.ALWAYS, simpleProperty.getGeneration() == PropertyGeneration.ALWAYS, simpleProperty.isNullable(), alwaysDirtyCheck || simpleProperty.isUpdatable(), simpleProperty.isOptimisticLockable(), \/\/ TODO: get cascadeStyle from simpleProperty when HHH-6355 is fixed; for now, assume NONE \/\/simpleProperty.getCascadeStyle(), CascadeStyle.NONE, \/\/ TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT \/\/simpleProperty.getFetchMode() FetchMode.DEFAULT ); } else { PluralAttributeBinding pluralProperty = ( PluralAttributeBinding ) property; return new StandardProperty( pluralProperty.getAttribute().getName(), pluralProperty.getNodeName(), type, lazyAvailable && pluralProperty.isLazy(), \/\/ TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable \/\/ pluralProperty.isInsertable(), \/\/pluralProperty.isUpdatable(), true, true, false, false, pluralProperty.isNullable(), \/\/ TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable \/\/alwaysDirtyCheck || pluralProperty.isUpdatable(), true, pluralProperty.isOptimisticLocked(), \/\/ TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE \/\/pluralProperty.getCascadeStyle(), CascadeStyle.NONE, \/\/ TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT \/\/pluralProperty.getFetchMode() FetchMode.DEFAULT ); } }","old_code_raw":"\tpublic static StandardProperty buildStandardProperty(Property property, boolean lazyAvailable) {\n\t\t\n\t\tfinal Type type = property.getValue().getType();\n\t\t\n\t\t\/\/ we need to dirty check collections, since they can cause an owner\n\t\t\/\/ version number increment\n\t\t\n\t\t\/\/ we need to dirty check many-to-ones with not-found=\"ignore\" in order \n\t\t\/\/ to update the cache (not the database), since in this case a null\n\t\t\/\/ entity reference can lose information\n\t\t\n\t\tboolean alwaysDirtyCheck = type.isAssociationType() && \n\t\t\t\t( (AssociationType) type ).isAlwaysDirtyChecked(); \n\n\t\treturn new StandardProperty(\n\t\t\t\tproperty.getName(),\n\t\t\t\tproperty.getNodeName(),\n\t\t\t\ttype,\n\t\t\t\tlazyAvailable && property.isLazy(),\n\t\t\t\tproperty.isInsertable(),\n\t\t\t\tproperty.isUpdateable(),\n\t\t        property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.getGeneration() == PropertyGeneration.ALWAYS,\n\t\t\t\tproperty.isOptional(),\n\t\t\t\talwaysDirtyCheck || property.isUpdateable(),\n\t\t\t\tproperty.isOptimisticLocked(),\n\t\t\t\tproperty.getCascadeStyle(),\n\t\t        property.getValue().getFetchMode()\n\t\t\t);\n\t}\n","new_comment_raw":"@param lazyAvailable Is property lazy loading currently available.","old_comment_raw":"@param lazyAvailable Is property lazy loading currently available.","label":0,"pre_label":1,"AST_level":9,"line_counts":66,"new_code_token_num":450},{"new_code_raw":"public Client call123testSpecialTags(Client body) throws ApiException { ApiResponse<Client> resp = call123testSpecialTagsWithHttpInfo(body); return resp.getData(); }","old_code_raw":"    public Client call123testSpecialTags(Client client) throws ApiException {\n        ApiResponse<Client> resp = call123testSpecialTagsWithHttpInfo(client);\n        return resp.getData();\n    }\n","new_comment_raw":"@param body client model (required)","old_comment_raw":"@param client client model (required)","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public Pair(String item1, String item2) { super(); this.item1 = item1; this.item2 = item2; }","old_code_raw":"        public Pair(String item_1, String item_2) {\n            super();\n            this.item_1 = item_1;\n            this.item_2 = item_2;\n        }\n","new_comment_raw":"@param apps the applications for which to compare this one.","old_comment_raw":"@param apps the applications for which to compare this one.","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":23},{"new_code_raw":"protected SourceInfo update(Long lsn, Long useconds, Long txId) { this.lsn = lsn; this.useconds = useconds; this.txId = txId; return this; }","old_code_raw":"    protected SourceInfo update(Long lsn, Long useconds, Integer txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n","new_comment_raw":"@param useconds the commit time (in microseconds since epoch) of the transaction that generated the event; may be null indicating that this information is not available","old_comment_raw":"@param useconds the commit time (in microseconds since epoch) of the transaction that generated the event; may be null indicating that this information is not available","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":30},{"new_code_raw":"private ColumnState buildSimpleList(ContainerState parent, ColumnMetadata columnSchema) { \/\/ The variant must have the one and only type. assert columnSchema.variantSchema().size() == 1; assert columnSchema.variantSchema().isSimple(); \/\/ Create the manager for the one and only column within the list. final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name())); \/\/ Create the child vector, writer and state. final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype(); final ColumnState memberState = buildColumn(listState, memberSchema); listState.setSubColumn(memberState); \/\/ Create the list vector. Contains a single type. final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(), parent.loader().allocator(), null); listVector.setChildVector(memberState.vector()); \/\/ Create the list writer: an array of the one type. final ListWriterImpl listWriter = new ListWriterImpl(columnSchema, listVector, memberState.writer()); final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter); \/\/ Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(listWriter, memberState.writer().events(), listVector); \/\/ Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listObjWriter, vectorState, listState); }","old_code_raw":"  private ColumnState buildSimpleList(ContainerState parent, ColumnReadProjection colProj) {\n    ColumnMetadata columnSchema = colProj.providedSchema();\n\n    \/\/ The variant must have the one and only type.\n\n    assert columnSchema.variantSchema().size() == 1;\n    assert columnSchema.variantSchema().isSimple();\n\n    \/\/ Create the manager for the one and only column within the list.\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()));\n\n    \/\/ Create the child vector, writer and state.\n\n    final ColumnMetadata memberSchema = columnSchema.variantSchema().listSubtype();\n    final ColumnState memberState = buildColumn(listState, memberSchema);\n    listState.setSubColumn(memberState);\n\n    \/\/ Create the list vector. Contains a single type.\n\n    final ListVector listVector = new ListVector(columnSchema.schema().cloneEmpty(),\n        parent.loader().allocator(), null);\n    listVector.setChildVector(memberState.vector());\n\n    \/\/ Create the list writer: an array of the one type.\n\n    final ListWriterImpl listWriter = new ListWriterImpl(columnSchema,\n        listVector, memberState.writer());\n    final AbstractObjectWriter listObjWriter = new ArrayObjectWriter(listWriter);\n\n    \/\/ Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(listWriter,\n        memberState.writer().events(), listVector);\n\n    \/\/ Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listObjWriter, vectorState, listState);\n  }\n","new_comment_raw":"@param colProj metadata description of the list which must contain exactly one subtype","old_comment_raw":"@param colProj metadata description of the list which must contain exactly one subtype","label":0,"pre_label":1,"AST_level":8,"line_counts":34,"new_code_token_num":257},{"new_code_raw":"protected EntityInfo getEntityInfo(EnversService enversService, String entityName) { EntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName ); boolean isRelationAudited = true; if ( entCfg == null ) { \/\/ a relation marked as RelationTargetAuditMode.NOT_AUDITED entCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName ); isRelationAudited = false; } final Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() ); return new EntityInfo( entityClass, entityName, isRelationAudited ); }","old_code_raw":"\tprotected EntityInfo getEntityInfo(AuditConfiguration verCfg, String entityName) {\n\t\tEntityConfiguration entCfg = verCfg.getEntCfg().get( entityName );\n\t\tboolean isRelationAudited = true;\n\t\tif ( entCfg == null ) {\n\t\t\t\/\/ a relation marked as RelationTargetAuditMode.NOT_AUDITED\n\t\t\tentCfg = verCfg.getEntCfg().getNotVersionEntityConfiguration( entityName );\n\t\t\tisRelationAudited = false;\n\t\t}\n\t\tfinal Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), verCfg.getClassLoaderService() );\n\t\treturn new EntityInfo( entityClass, entityName, isRelationAudited );\n\t}\n","new_comment_raw":"@param entityName Entity name.","old_comment_raw":"@param entityName Entity name.","label":0,"pre_label":1,"AST_level":9,"line_counts":12,"new_code_token_num":83},{"new_code_raw":"public Client testClientModel(Client body) throws ApiException { return testClientModelWithHttpInfo(body).getData(); }","old_code_raw":"  public Client testClientModel(Client client) throws ApiException {\n    return testClientModelWithHttpInfo(client).getData();\n      }\n","new_comment_raw":"@param body client model (required)","old_comment_raw":"@param client client model (required)","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param body The request body object","old_comment_raw":"@param body The request body object","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public long addWrapped(long instant, int years) { return add(instant, years); }","old_code_raw":"    public long addWrapped(long millis, int years) {\n        return add(millis, years);\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens, Predicate<Pair> matchingFunction){ if(tofind.length > tokens.length) return null; List<Integer> allIndices = new ArrayList<>(); boolean matched = false; int index = -1; int lastUnmatchedIndex = 0; for(int i = 0 ; i < tokens.length;){ for(int j = 0; j < tofind.length ;){ if(matchingFunction.test(new Pair(tofind[j], tokens[i]))){ index = i; i++; j++; if(j == tofind.length) { matched = true; break; } }else{ j = 0; i = lastUnmatchedIndex +1; lastUnmatchedIndex = i; index = -1; if(lastUnmatchedIndex == tokens.length) break; } if(i >= tokens.length){ index = -1; break; } } if(i == tokens.length || matched){ if(index >= 0) \/\/index = index - l1.length + 1; allIndices.add(index - tofind.length + 1); matched = false; lastUnmatchedIndex = index; \/\/break; } } \/\/get starting point return allIndices; }","old_code_raw":"  public static List<Integer> getSubListIndex(Object[] tofind, Object[] tokens, Function<Pair, Boolean> matchingFunction){\n    if(tofind.length > tokens.length)\n      return null;\n    List<Integer> allIndices = new ArrayList<>();\n    boolean matched = false;\n    int index = -1;\n    int lastUnmatchedIndex = 0;\n    for(int i = 0 ; i < tokens.length;){\n      for(int j = 0; j < tofind.length ;){\n        if(matchingFunction.apply(new Pair(tofind[j], tokens[i]))){\n          index = i;\n          i++;\n          j++;\n          if(j == tofind.length)\n          {\n            matched = true;\n            break;\n          }\n        }else{\n          j = 0;\n          i = lastUnmatchedIndex +1;\n          lastUnmatchedIndex = i;\n          index = -1;\n          if(lastUnmatchedIndex == tokens.length)\n            break;\n        }\n        if(i >= tokens.length){\n          index = -1;\n          break;\n        }\n      }\n      if(i == tokens.length || matched){\n        if(index >= 0)\n          \/\/index = index - l1.length + 1;\n          allIndices.add(index - tofind.length + 1);\n        matched = false;\n        lastUnmatchedIndex = index;\n\n        \/\/break;\n      }\n    }\n    \/\/get starting point\n\n    return allIndices;\n  }\n","new_comment_raw":"@param tofind array you want to find in tokens","old_comment_raw":"@param tofind array you want to find in tokens","label":0,"pre_label":1,"AST_level":13,"line_counts":46,"new_code_token_num":220},{"new_code_raw":"public ChatProtocol onMessage(ChatProtocol message) throws IOException { if (!users.containsKey(message.getAuthor())) { users.put(message.getAuthor(), message.getUuid()); return new ChatProtocol(message.getAuthor(), \" entered room \" + chatroomName, users.keySet(), factory.lookupAll()); } if (message.getMessage().contains(\"disconnecting\")) { users.remove(message.getAuthor()); return new ChatProtocol(message.getAuthor(), \" disconnected from room \" + chatroomName, users.keySet(), factory.lookupAll()); } message.setUsers(users.keySet()); logger.info(\"{} just send {}\", message.getAuthor(), message.getMessage()); return message; }","old_code_raw":"    public Message onMessage(Message message) throws IOException {\n\n        if (!users.contains(message.getAuthor())) {\n            users.add(message.getAuthor());\n            return new Message(message.getAuthor(), \" entered room \" + chatroomName);\n        }\n\n        logger.info(\"{} just send {}\", message.getAuthor(), message.getMessage());\n        return message;\n    }\n","new_comment_raw":"@param message an instance of  ChatProtocol ","old_comment_raw":"@param message an instance of Message","label":1,"pre_label":0,"AST_level":8,"line_counts":17,"new_code_token_num":153},{"new_code_raw":"private RectF drawBoxWithShadow(Canvas c, int width, int height) { Resources res = mContext.getResources(); float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur); float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance); float corner = res.getDimension(R.dimen.widget_preview_corner_radius); RectF bounds = new RectF(shadowBlur, shadowBlur, width - shadowBlur, height - shadowBlur - keyShadowDistance); ShadowGenerator.drawShadow(c, bounds, Color.WHITE, shadowBlur, keyShadowDistance, corner); return bounds; }","old_code_raw":"    private RectF drawBoxWithShadow(Canvas c, Paint p, int width, int height) {\n        Resources res = mContext.getResources();\n        float shadowBlur = res.getDimension(R.dimen.widget_preview_shadow_blur);\n        float keyShadowDistance = res.getDimension(R.dimen.widget_preview_key_shadow_distance);\n        float corner = res.getDimension(R.dimen.widget_preview_corner_radius);\n\n        RectF bounds = new RectF(shadowBlur, shadowBlur,\n                width - shadowBlur, height - shadowBlur - keyShadowDistance);\n        p.setColor(Color.WHITE);\n\n        \/\/ Key shadow\n        p.setShadowLayer(shadowBlur, 0, keyShadowDistance,\n                ShadowGenerator.KEY_SHADOW_ALPHA << 24);\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        \/\/ Ambient shadow\n        p.setShadowLayer(shadowBlur, 0, 0,\n                ColorUtils.setAlphaComponent(Color.BLACK, ShadowGenerator.AMBIENT_SHADOW_ALPHA));\n        c.drawRoundRect(bounds, corner, corner, p);\n\n        p.clearShadowLayer();\n        return bounds;\n    }\n","new_comment_raw":"@param preScaledWidthOut return the width of the returned bitmap","old_comment_raw":"@param preScaledWidthOut return the width of the returned bitmap","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":92},{"new_code_raw":"public boolean searchText(String regex) { boolean found = searcher.searchText(regex, 0, true); return found; }","old_code_raw":"\tpublic boolean searchText(String search) {\n\t\tboolean found = searcher.searchText(search, 0, true);\n\t\treturn found;\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"protected EntityInfo getEntityInfo(EnversService enversService, String entityName) { EntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName ); boolean isRelationAudited = true; if ( entCfg == null ) { \/\/ a relation marked as RelationTargetAuditMode.NOT_AUDITED entCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName ); isRelationAudited = false; } final Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() ); return new EntityInfo( entityClass, entityName, isRelationAudited ); }","old_code_raw":"\tprotected EntityInfo getEntityInfo(AuditConfiguration verCfg, String entityName) {\n\t\tEntityConfiguration entCfg = verCfg.getEntCfg().get( entityName );\n\t\tboolean isRelationAudited = true;\n\t\tif ( entCfg == null ) {\n\t\t\t\/\/ a relation marked as RelationTargetAuditMode.NOT_AUDITED\n\t\t\tentCfg = verCfg.getEntCfg().getNotVersionEntityConfiguration( entityName );\n\t\t\tisRelationAudited = false;\n\t\t}\n\t\tfinal Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), verCfg.getClassLoaderService() );\n\t\treturn new EntityInfo( entityClass, entityName, isRelationAudited );\n\t}\n","new_comment_raw":"@param enversService The EnversService","old_comment_raw":"@param verCfg Audit configuration.","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":83},{"new_code_raw":"public QuoteAnnotator(String name, Properties props, boolean verbose) { USE_SINGLE = Boolean.parseBoolean(props.getProperty(name + \".\" + \"singleQuotes\", \"false\")); MAX_LENGTH = Integer.parseInt(props.getProperty(name + \".\" + \"maxLength\", \"-1\")); ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"asciiQuotes\", \"false\")); ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(name + \".\" + \"allowEmbeddedSame\", \"false\")); SMART_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"smartQuotes\", \"false\")); EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(name + \".\" + \"extractUnclosedQuotes\", \"false\")); ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(name + \".\" + \"attributeQuotes\", \"true\")); VERBOSE = verbose; Timing timer = null; if (VERBOSE) { timer = new Timing(); log.info(\"Preparing quote annotator...\"); } if (ATTRIBUTE_QUOTES) quoteAttributionAnnotator = new QuoteAttributionAnnotator(props); if (VERBOSE) { timer.stop(\"done.\"); } }","old_code_raw":"  public QuoteAnnotator(Properties props, boolean verbose) {\n    USE_SINGLE = Boolean.parseBoolean(props.getProperty(\"singleQuotes\", \"false\"));\n    MAX_LENGTH = Integer.parseInt(props.getProperty(\"maxLength\", \"-1\"));\n    ASCII_QUOTES = Boolean.parseBoolean(props.getProperty(\"asciiQuotes\", \"false\"));\n    ALLOW_EMBEDDED_SAME = Boolean.parseBoolean(props.getProperty(\"allowEmbeddedSame\", \"false\"));\n    SMART_QUOTES = Boolean.parseBoolean(props.getProperty(\"smartQuotes\", \"false\"));\n    EXTRACT_UNCLOSED = Boolean.parseBoolean(props.getProperty(\"extractUnclosedQuotes\", \"false\"));\n    ATTRIBUTE_QUOTES = Boolean.parseBoolean(props.getProperty(\"attributeQuotes\", \"true\"));\n\n    VERBOSE = verbose;\n    Timing timer = null;\n    if (VERBOSE) {\n      timer = new Timing();\n      log.info(\"Preparing quote annotator...\");\n    }\n    if (ATTRIBUTE_QUOTES)\n      quoteAttributionAnnotator = new QuoteAttributionAnnotator(props);\n\n    if (VERBOSE) {\n      timer.stop(\"done.\");\n    }\n  }\n","new_comment_raw":"@param verbose whether or not to output verbose information.","old_comment_raw":"@param verbose whether or not to output verbose information.","label":0,"pre_label":1,"AST_level":9,"line_counts":23,"new_code_token_num":223},{"new_code_raw":"public static Iterable<ProviderMetadata<?, ?, ?, ?>> collocatedWith(ProviderMetadata<?, ?, ?, ?> providerMetadata, ApiType type) { return filter(all(), Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata), ProviderPredicates.type(type))); }","old_code_raw":"   public static Iterable<ProviderMetadata> collocatedWith(ProviderMetadata providerMetadata,\n            TypeToken<? extends Wrapper> contextWrappableAs) {\n      return filter(all(), Predicates.and(ProviderPredicates.intersectingIso3166Code(providerMetadata),\n               ProviderPredicates.contextWrappableAs(contextWrappableAs)));\n   }\n","new_comment_raw":"@param type the type to filter providers by","old_comment_raw":"@param contextWrappableAs the contextWrappableAs to filter providers by","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":52},{"new_code_raw":"public Struct update(Object before, Struct after, Struct source, Instant timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.UPDATE.code()); if (before != null) { struct.put(FieldName.BEFORE, before); } struct.put(FieldName.AFTER, after); if (source != null) { struct.put(FieldName.SOURCE, source); } if (timestamp != null) { struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli()); } return struct; }","old_code_raw":"    public Struct update(Object before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) {\n            struct.put(FieldName.BEFORE, before);\n        }\n        struct.put(FieldName.AFTER, after);\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp);\n        }\n        return struct;\n    }\n","new_comment_raw":"@param before the state of the record before the update; may be null","old_comment_raw":"@param before the state of the record before the update; may be null","label":0,"pre_label":1,"AST_level":7,"line_counts":16,"new_code_token_num":105},{"new_code_raw":"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param path The sub-path of the HTTP URL","old_comment_raw":"@param path The sub-path of the HTTP URL","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow) throws IOException { return runHTMLSuite(browser, browserURL, suiteURL, outputFile, timeoutInSeconds, multiWindow, \"info\"); }","old_code_raw":"    public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException {\n        return runHTMLSuite(browser, browserURL, suiteURL, outputFile,\n                timeoutInSeconds, multiWindow, \"info\");\n    }\n","new_comment_raw":"@param browserURL - the start URL for the browser","old_comment_raw":"@param browserURL - the start URL for the browser","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":46},{"new_code_raw":"public Client testSpecialTags(Client client) throws ApiException { return testSpecialTagsWithHttpInfo(client).getData(); }","old_code_raw":"  public Client testSpecialTags(Client body) throws ApiException {\n    return testSpecialTagsWithHttpInfo(body).getData();\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"private RexNode adjustCondition(LogicalProject project, SemiJoin semiJoin) { \/\/ create two RexPrograms -- the bottom one representing a \/\/ concatenation of the project and the RHS of the semijoin and the \/\/ top one representing the semijoin condition RexBuilder rexBuilder = project.getCluster().getRexBuilder(); RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory(); RelNode rightChild = semiJoin.getRight(); \/\/ for the bottom RexProgram, the input is a concatenation of the \/\/ child of the project and the RHS of the semijoin RelDataType bottomInputRowType = Join.deriveJoinRowType( project.getInput().getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder bottomProgramBuilder = new RexProgramBuilder(bottomInputRowType, rexBuilder); \/\/ add the project expressions, then add input references for the RHS \/\/ of the semijoin for (Pair<RexNode, String> pair : project.getNamedProjects()) { bottomProgramBuilder.addProject(pair.left, pair.right); } int nLeftFields = project.getInput().getRowType().getFieldCount(); List<RelDataTypeField> rightFields = rightChild.getRowType().getFieldList(); int nRightFields = rightFields.size(); for (int i = 0; i < nRightFields; i++) { final RelDataTypeField field = rightFields.get(i); RexNode inputRef = rexBuilder.makeInputRef( field.getType(), i + nLeftFields); bottomProgramBuilder.addProject(inputRef, field.getName()); } RexProgram bottomProgram = bottomProgramBuilder.getProgram(); \/\/ input rowtype into the top program is the concatenation of the \/\/ project and the RHS of the semijoin RelDataType topInputRowType = Join.deriveJoinRowType( project.getRowType(), rightChild.getRowType(), JoinRelType.INNER, typeFactory, null, semiJoin.getSystemFieldList()); RexProgramBuilder topProgramBuilder = new RexProgramBuilder( topInputRowType, rexBuilder); topProgramBuilder.addIdentity(); topProgramBuilder.addCondition(semiJoin.getCondition()); RexProgram topProgram = topProgramBuilder.getProgram(); \/\/ merge the programs and expand out the local references to form \/\/ the new semijoin condition; it now references a concatenation of \/\/ the project's child and the RHS of the semijoin RexProgram mergedProgram = RexProgramBuilder.mergePrograms( topProgram, bottomProgram, rexBuilder); return mergedProgram.expandLocalRef( mergedProgram.getCondition()); }","old_code_raw":"  private RexNode adjustCondition(ProjectRel project, SemiJoinRel semiJoin) {\n    \/\/ create two RexPrograms -- the bottom one representing a\n    \/\/ concatenation of the project and the RHS of the semijoin and the\n    \/\/ top one representing the semijoin condition\n\n    RexBuilder rexBuilder = project.getCluster().getRexBuilder();\n    RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    RelNode rightChild = semiJoin.getRight();\n\n    \/\/ for the bottom RexProgram, the input is a concatenation of the\n    \/\/ child of the project and the RHS of the semijoin\n    RelDataType bottomInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getChild().getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder bottomProgramBuilder =\n        new RexProgramBuilder(bottomInputRowType, rexBuilder);\n\n    \/\/ add the project expressions, then add input references for the RHS\n    \/\/ of the semijoin\n    for (Pair<RexNode, String> pair : project.getNamedProjects()) {\n      bottomProgramBuilder.addProject(pair.left, pair.right);\n    }\n    int nLeftFields = project.getChild().getRowType().getFieldCount();\n    List<RelDataTypeField> rightFields =\n        rightChild.getRowType().getFieldList();\n    int nRightFields = rightFields.size();\n    for (int i = 0; i < nRightFields; i++) {\n      final RelDataTypeField field = rightFields.get(i);\n      RexNode inputRef =\n          rexBuilder.makeInputRef(\n              field.getType(), i + nLeftFields);\n      bottomProgramBuilder.addProject(inputRef, field.getName());\n    }\n    RexProgram bottomProgram = bottomProgramBuilder.getProgram();\n\n    \/\/ input rowtype into the top program is the concatenation of the\n    \/\/ project and the RHS of the semijoin\n    RelDataType topInputRowType =\n        JoinRelBase.deriveJoinRowType(\n            project.getRowType(),\n            rightChild.getRowType(),\n            JoinRelType.INNER,\n            typeFactory,\n            null,\n            semiJoin.getSystemFieldList());\n    RexProgramBuilder topProgramBuilder =\n        new RexProgramBuilder(\n            topInputRowType,\n            rexBuilder);\n    topProgramBuilder.addIdentity();\n    topProgramBuilder.addCondition(semiJoin.getCondition());\n    RexProgram topProgram = topProgramBuilder.getProgram();\n\n    \/\/ merge the programs and expand out the local references to form\n    \/\/ the new semijoin condition; it now references a concatenation of\n    \/\/ the project's child and the RHS of the semijoin\n    RexProgram mergedProgram =\n        RexProgramBuilder.mergePrograms(\n            topProgram,\n            bottomProgram,\n            rexBuilder);\n\n    return mergedProgram.expandLocalRef(\n        mergedProgram.getCondition());\n  }\n","new_comment_raw":"@param semiJoin the semijoin","old_comment_raw":"@param semiJoin the semijoin","label":0,"pre_label":1,"AST_level":9,"line_counts":71,"new_code_token_num":411},{"new_code_raw":"public static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationBindingContext bindingContext) { Map<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>(); for ( ClassInfo info : bindingContext.getIndex().getKnownClasses() ) { if ( !isEntityClass( info ) ) { continue; } if ( processedClassInfos.containsKey( info ) ) { continue; } List<ClassInfo> configuredClassList = new ArrayList<ClassInfo>(); ClassInfo tmpClassInfo = info; Class<?> clazz = bindingContext.locateClassByName( tmpClassInfo.toString() ); while ( clazz != null && !clazz.equals( Object.class ) ) { tmpClassInfo = bindingContext.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) ); clazz = clazz.getSuperclass(); if ( tmpClassInfo == null ) { continue; } if ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) { List<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo ); for ( ClassInfo tmpInfo : configuredClassList ) { classInfoList.add( tmpInfo ); processedClassInfos.put( tmpInfo, classInfoList ); } break; } else { configuredClassList.add( 0, tmpClassInfo ); processedClassInfos.put( tmpClassInfo, configuredClassList ); } } } Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>(); List<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>(); for ( List<ClassInfo> classInfoList : processedClassInfos.values() ) { if ( !processedList.contains( classInfoList ) ) { hierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, bindingContext ) ); processedList.add( classInfoList ); } } return hierarchies; }","old_code_raw":"\tpublic static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext bindingContext) {\n\t\tMap<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();\n\n\t\tfor ( ClassInfo info : bindingContext.getIndex().getKnownClasses() ) {\n\t\t\tif ( !isEntityClass( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( processedClassInfos.containsKey( info ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tList<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();\n\t\t\tClassInfo tmpClassInfo = info;\n\t\t\tClass<?> clazz = bindingContext.locateClassByName( tmpClassInfo.toString() );\n\t\t\twhile ( clazz != null && !clazz.equals( Object.class ) ) {\n\t\t\t\ttmpClassInfo = bindingContext.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );\n\t\t\t\tclazz = clazz.getSuperclass();\n\t\t\t\tif ( tmpClassInfo == null ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {\n\t\t\t\t\tList<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );\n\t\t\t\t\tfor ( ClassInfo tmpInfo : configuredClassList ) {\n\t\t\t\t\t\tclassInfoList.add( tmpInfo );\n\t\t\t\t\t\tprocessedClassInfos.put( tmpInfo, classInfoList );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconfiguredClassList.add( 0, tmpClassInfo );\n\t\t\t\t\tprocessedClassInfos.put( tmpClassInfo, configuredClassList );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSet<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>();\n\t\tList<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();\n\t\tfor ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {\n\t\t\tif ( !processedList.contains( classInfoList ) ) {\n\t\t\t\thierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, bindingContext ) );\n\t\t\t\tprocessedList.add( classInfoList );\n\t\t\t}\n\t\t}\n\n\t\treturn hierarchies;\n\t}\n","new_comment_raw":"@param bindingContext The binding context, giving access to needed services and information","old_comment_raw":"@param bindingContext The binding context, giving access to needed services and information","label":0,"pre_label":1,"AST_level":13,"line_counts":49,"new_code_token_num":271},{"new_code_raw":"public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception { return addPropertiesToURI(uri.toString(), properties); }","old_code_raw":"    public static String addPropertiesToURI(URI uri, Map<String, String> props) throws Exception {\n        return addPropertiesToURI(uri.toString(), props);\n    }\n","new_comment_raw":"@param uri The URI value to append the object properties to.","old_comment_raw":"@param uri","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":29},{"new_code_raw":"public Client testClassname(Client client) throws RestClientException { Object postBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'client' when calling testClassname\"); } String path = UriComponentsBuilder.fromPath(\"\/fake_classname_test\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"api_key_query\" }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Client testClassname(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        \/\/ verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling testClassname\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"\/fake_classname_test\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"api_key_query\" };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@param client client model","old_comment_raw":"@param body client model","label":1,"pre_label":0,"AST_level":8,"line_counts":29,"new_code_token_num":203},{"new_code_raw":"public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException { long timeoutInMs = 1000 * timeoutInSeconds; server.handleHTMLRunnerResults(this); BrowserLauncherFactory blf = new BrowserLauncherFactory(server); String sessionId = Long.toString(System.currentTimeMillis() % 1000000); BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null); launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow); long now = System.currentTimeMillis(); long end = now + timeoutInMs; while (results == null && System.currentTimeMillis() < end) { AsyncExecute.sleepTight(500); } launcher.close(); if (results == null) { throw new SeleniumCommandTimedOutException(); } if (outputFile != null) { FileWriter fw = new FileWriter(outputFile); results.write(fw); fw.close(); } return results.getResult().toUpperCase(); }","old_code_raw":"    public String runHTMLSuite(String browser, String browserURL, String HTMLSuite, File outputFile, long timeoutInMs, boolean multiWindow) throws IOException {\n        server.handleHTMLRunnerResults(this);\n        BrowserLauncherFactory blf = new BrowserLauncherFactory(server);\n        String sessionId = Long.toString(System.currentTimeMillis() % 1000000);\n        BrowserLauncher launcher = blf.getBrowserLauncher(browser, sessionId, null);\n        launcher.launchHTMLSuite(HTMLSuite, browserURL, multiWindow);\n        long now = System.currentTimeMillis();\n        long end = now + timeoutInMs;\n        while (results == null && System.currentTimeMillis() < end) {\n            AsyncExecute.sleepTight(500);\n        }\n        launcher.close();\n        if (results == null) {\n            throw new SeleniumCommandTimedOutException();\n        }\n        if (outputFile != null) {\n            FileWriter fw = new FileWriter(outputFile);\n            results.write(fw);\n            fw.close();\n        }\n        \n        return results.getResult().toUpperCase();\n    }\n","new_comment_raw":"@param multiWindow TODO","old_comment_raw":"@param multiWindow TODO","label":0,"pre_label":1,"AST_level":8,"line_counts":25,"new_code_token_num":168},{"new_code_raw":"public List<NamespaceVO> findNampspaces(String appId, Env env, String clusterName) { List<NamespaceDTO> namespaces = groupAPI.findGroupsByAppAndCluster(appId, env, clusterName); if (namespaces == null || namespaces.size() == 0) { return Collections.EMPTY_LIST; } List<NamespaceVO> namespaceVOs = new LinkedList<>(); for (NamespaceDTO namespace : namespaces) { NamespaceVO namespaceVO = null; try { namespaceVO = parseNamespace(appId, env, clusterName, namespace); namespaceVOs.add(namespaceVO); } catch (Exception e) { logger.error(\"parse namespace error. app id:{}, env:{}, clusterName:{}, namespace:{}\", appId, env, clusterName, namespace.getNamespaceName(), e); return namespaceVOs; } } return namespaceVOs; }","old_code_raw":"  public List<NamespaceVO> findNampspaces(String appId, Apollo.Env env, String clusterName) {\n\n    List<NamespaceDTO> namespaces = groupAPI.findGroupsByAppAndCluster(appId, env, clusterName);\n    if (namespaces == null || namespaces.size() == 0) {\n      return Collections.EMPTY_LIST;\n    }\n\n    List<NamespaceVO> namespaceVOs = new LinkedList<>();\n    for (NamespaceDTO namespace : namespaces) {\n\n      NamespaceVO namespaceVO = null;\n      try {\n        namespaceVO = parseNamespace(appId, env, clusterName, namespace);\n        namespaceVOs.add(namespaceVO);\n      } catch (Exception e) {\n        logger.error(\"parse namespace error. app id:{}, env:{}, clusterName:{}, namespace:{}\", appId, env, clusterName,\n                     namespace.getNamespaceName(), e);\n        return namespaceVOs;\n      }\n    }\n\n    return namespaceVOs;\n  }\n","new_comment_raw":"@param appId","old_comment_raw":"@param appId","label":0,"pre_label":1,"AST_level":9,"line_counts":24,"new_code_token_num":145},{"new_code_raw":"public DataFetcher getDataFetcher(FieldCoordinates coordinates, GraphQLFieldDefinition fieldDefinition) { return getDataFetcherImpl(coordinates, fieldDefinition, dataFetcherMap, systemDataFetcherMap); }","old_code_raw":"    public DataFetcher getDataFetcher(GraphQLFieldsContainer parentType, GraphQLFieldDefinition fieldDefinition) {\n        return getDataFetcherImpl(parentType, fieldDefinition, dataFetcherMap, systemDataFetcherMap);\n    }\n","new_comment_raw":"@param coordinates the field coordinates","old_comment_raw":"@param parentType the container type","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); \/\/System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); } } return nodeList; }","old_code_raw":"  public Collection<Tree> getRelatedNodes(Tree t, Tree root, HeadFinder headFinder) {\n    Set<Tree> nodeList = new ArraySet<Tree>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        nodeList.add(m.getNode(\"target\"));\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@param t Target for finding governors of t related by this GR","old_comment_raw":"@param t Target for finding dependents of t related by this GR","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":151},{"new_code_raw":"public ScrollableResults scroll(ScrollMode mode, Expression<?> expr1, Expression<?> expr2, Expression<?>... rest) { Query query = createQuery(expr1, expr2, rest); reset(); return query.scroll(mode); }","old_code_raw":"    public ScrollableResults scroll(ScrollMode mode, Expr<?> expr1, Expr<?> expr2, Expr<?>... rest) {\n        Query query = createQuery(expr1, expr2, rest);\n        reset();\n        return query.scroll(mode);\n    }\n","new_comment_raw":"@param expr1","old_comment_raw":"@param expr1","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"private ColumnState buildUnionList(ContainerState parent, ColumnTransform outputCol) { ColumnMetadata columnSchema = outputCol.outputSchema(); \/\/ The variant must start out empty. assert columnSchema.variantSchema().size() == 0; \/\/ Create the union writer, bound to an empty list shim. final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema); unionWriter.bindShim(new EmptyListShim()); final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter); \/\/ Create the list vector. Starts with the default (dummy) data \/\/ vector which corresponds to the empty union shim above. \/\/ Don't get the list vector from the vector cache. List vectors may \/\/ have content that varies from batch to batch. Only the leaf \/\/ vectors can be cached. final ListVector listVector = new ListVector(columnSchema.schema(), parent.loader().allocator(), null); \/\/ Create the list vector state that tracks the list vector lifecycle. final ListVectorState vectorState = new ListVectorState(unionWriter, listVector); \/\/ Create the list writer: an array of unions. final AbstractObjectWriter listWriter = new ArrayObjectWriter( new ListWriterImpl(columnSchema, listVector, unionObjWriter)); \/\/ Create the manager for the columns within the list (which may or \/\/ may not be grouped into a union.) final ListState listState = new ListState(parent.loader(), parent.vectorCache().childCache(columnSchema.name()), ImpliedTupleRequest.ALL_MEMBERS); \/\/ Bind the union state to the union writer to handle column additions. unionWriter.bindListener(listState); \/\/ Assemble it all into a union column state. return new UnionColumnState(parent.loader(), listWriter, vectorState, listState); }","old_code_raw":"  private static ColumnState buildUnionList(ContainerState parent, ColumnMetadata columnSchema) {\n\n    \/\/ The variant must start out empty.\n\n    assert columnSchema.variantSchema().size() == 0;\n\n    \/\/ Create the union writer, bound to an empty list shim.\n\n    final UnionWriterImpl unionWriter = new UnionWriterImpl(columnSchema);\n    unionWriter.bindShim(new EmptyListShim());\n    final VariantObjectWriter unionObjWriter = new VariantObjectWriter(unionWriter);\n\n    \/\/ Create the list vector. Starts with the default (dummy) data\n    \/\/ vector which corresponds to the empty union shim above.\n    \/\/ Don't get the list vector from the vector cache. List vectors may\n    \/\/ have content that varies from batch to batch. Only the leaf\n    \/\/ vectors can be cached.\n\n    final ListVector listVector = new ListVector(columnSchema.schema(),\n        parent.loader().allocator(), null);\n\n    \/\/ Create the list vector state that tracks the list vector lifecycle.\n\n    final ListVectorState vectorState = new ListVectorState(unionWriter, listVector);\n\n    \/\/ Create the list writer: an array of unions.\n\n    final AbstractObjectWriter listWriter = new ArrayObjectWriter(\n        new ListWriterImpl(columnSchema, listVector, unionObjWriter));\n\n    \/\/ Create the manager for the columns within the list (which may or\n    \/\/ may not be grouped into a union.)\n\n    final ListState listState = new ListState(parent.loader(),\n        parent.vectorCache().childCache(columnSchema.name()),\n        ImpliedTupleRequest.ALL_MEMBERS);\n\n    \/\/ Bind the union state to the union writer to handle column additions.\n\n    unionWriter.bindListener(listState);\n\n    \/\/ Assemble it all into a union column state.\n\n    return new UnionColumnState(parent.loader(),\n        listWriter, vectorState, listState);\n  }\n","new_comment_raw":"@param parent the parent (tuple, union or list) that holds this list","old_comment_raw":"@param parent the parent (tuple, union or list) that holds this list","label":0,"pre_label":1,"AST_level":8,"line_counts":48,"new_code_token_num":309},{"new_code_raw":"protected SourceInfo update(Long lsn, Long useconds, Long txId) { this.lsn = lsn; this.useconds = useconds; this.txId = txId; return this; }","old_code_raw":"    protected SourceInfo update(Long lsn, Long useconds, Integer txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n","new_comment_raw":"@param lsn the position in the server WAL for a particular event; may be null indicating that this information is not available","old_comment_raw":"@param lsn the position in the server WAL for a particular event; may be null indicating that this information is not available","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":30},{"new_code_raw":"public boolean isConnected(HistoryReference handshakeRef) { int historyId = handshakeRef.getHistoryId(); synchronized (wsProxies) { for (Entry<Integer, WebSocketProxy> entry : wsProxies.entrySet()) { WebSocketProxy proxy = entry.getValue(); if (historyId == proxy.getHandshakeReference().getHistoryId()) { return proxy.isConnected(); } } } return false; }","old_code_raw":"\tpublic boolean isConnected(HttpMessage handshakeMessage) {\n\t\tint historyId = handshakeMessage.getHistoryRef().getHistoryId();\n\t\tsynchronized (wsProxies) {\n\t\t\tfor (Entry<Integer, WebSocketProxy> entry : wsProxies.entrySet()) {\n\t\t\t\tWebSocketProxy proxy = entry.getValue();\n\t\t\t\tif (historyId == proxy.getHandshakeReference().getHistoryId()) {\n\t\t\t\t\treturn proxy.isConnected();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@param handshakeRef","old_comment_raw":"@param handshakeMessage","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":66},{"new_code_raw":"public Call createUsersWithArrayInputAsync(java.util.List<User> body, ApiCallback<Void> callback) throws ApiException { Call call = createUsersWithArrayInputCall(body); apiClient.executeAsync(call, callback); return call; }","old_code_raw":"  public Call createUsersWithArrayInputAsync(List<User> body, ApiCallback<Void> callback) throws ApiException {\n    Call call = createUsersWithArrayInputCall(body);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n","new_comment_raw":"@param callback The callback to be executed when the API call finishes","old_comment_raw":"@param callback The callback to be executed when the API call finishes","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"public BooleanBuilder andAnyOf(Predicate... args) { if (args.length > 0){ and(ExpressionUtils.anyOf(args)); } return this; }","old_code_raw":"    public BooleanBuilder andAnyOf(EBoolean... args) {\n        if (args.length > 0){\n            and(anyOf(args));\n        }\n        return this;\n    }\n","new_comment_raw":"@param args","old_comment_raw":"@param args","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":29},{"new_code_raw":"public static String getConsoleIconPath(DesiredCapabilities cap, GridRegistry registry) { String name = consoleIconName(cap, registry); String path = \"org\/openqa\/grid\/images\/\"; InputStream in = Thread.currentThread().getContextClassLoader() .getResourceAsStream(path + name + \".png\"); if (in == null) { return null; } return \"\/grid\/resources\/\" + path + name + \".png\"; }","old_code_raw":"  public static String getConsoleIconPath(DesiredCapabilities cap, Registry registry) {\n    String name = consoleIconName(cap, registry);\n    String path = \"org\/openqa\/grid\/images\/\";\n    InputStream in =\n        Thread.currentThread().getContextClassLoader()\n            .getResourceAsStream(path + name + \".png\");\n    if (in == null) {\n      return null;\n    }\n    return \"\/grid\/resources\/\" + path + name + \".png\";\n  }\n","new_comment_raw":"@param registry - GridRegistry","old_comment_raw":"@param registry - Registry","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":82},{"new_code_raw":"public boolean searchButton(String regex, int expectedMinimumNumberOfMatches) { boolean found = searcher.searchWithTimeoutFor(Button.class, regex, expectedMinimumNumberOfMatches, true); return found; }","old_code_raw":"\tpublic boolean searchButton(String regex, int matches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, regex, matches, true);\n\t\treturn found;\n\t}\n","new_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found","old_comment_raw":"@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, long timeoutInSeconds, boolean multiWindow) throws IOException { return runHTMLSuite(browser, browserURL, suiteURL, outputFile, timeoutInSeconds, multiWindow, \"info\"); }","old_code_raw":"    public String runHTMLSuite(String browser, String browserURL, String suiteURL, File outputFile, int timeoutInSeconds, boolean multiWindow) throws IOException {\n        return runHTMLSuite(browser, browserURL, suiteURL, outputFile,\n                timeoutInSeconds, multiWindow, \"info\");\n    }\n","new_comment_raw":"@param outputFile - The file to which we'll output the HTML results","old_comment_raw":"@param outputFile - The file to which we'll output the HTML results","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":46},{"new_code_raw":"private boolean resolveAccount(Uri uri, ContentValues values) { String accountName = getQueryParameter(uri, RawContacts.ACCOUNT_NAME); String accountType = getQueryParameter(uri, RawContacts.ACCOUNT_TYPE); if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) { accountName = null; accountType = null; } String valueAccountName = values.getAsString(RawContacts.ACCOUNT_NAME); String valueAccountType = values.getAsString(RawContacts.ACCOUNT_TYPE); if (TextUtils.isEmpty(valueAccountName) && TextUtils.isEmpty(valueAccountType)) { values.put(RawContacts.ACCOUNT_NAME, accountName); values.put(RawContacts.ACCOUNT_TYPE, accountType); } else { if (accountName != null && !accountName.equals(valueAccountName)) { return false; } if (accountType != null && !accountType.equals(valueAccountType)) { return false; } accountName = valueAccountName; accountType = valueAccountType; } if (TextUtils.isEmpty(accountName) || TextUtils.isEmpty(accountType)) { mAccount = null; return true; } if (mAccount == null || !mAccount.name.equals(accountName) || !mAccount.type.equals(accountType)) { mAccount = new Account(accountName, accountType); } return true; }","old_code_raw":"    private boolean resolveAccount(ContentValues values, Account account) {\n        \/\/ If either is specified then both must be specified.\n        final String accountName = values.getAsString(RawContacts.ACCOUNT_NAME);\n        final String accountType = values.getAsString(RawContacts.ACCOUNT_TYPE);\n        if (!TextUtils.isEmpty(accountName) || !TextUtils.isEmpty(accountType)) {\n            final Account valuesAccount = new Account(accountName, accountType);\n            if (account != null && !valuesAccount.equals(account)) {\n                return false;\n            }\n            account = valuesAccount;\n        }\n        if (account != null) {\n            values.put(RawContacts.ACCOUNT_NAME, account.name);\n            values.put(RawContacts.ACCOUNT_TYPE, account.type);\n        }\n        return true;\n    }\n","new_comment_raw":"@param values the explicitly provided Account","old_comment_raw":"@param account the explicitly provided Account","label":1,"pre_label":0,"AST_level":8,"line_counts":43,"new_code_token_num":215},{"new_code_raw":"protected Object suspendAndGet(Object key, FlagAdapter opt, boolean suppressTimeout) throws CacheException { Transaction tx = suspend(); try { if (suppressTimeout) return cacheAdapter.getAllowingTimeout(key); else return cacheAdapter.get(key); } finally { resume(tx); } }","old_code_raw":"   protected Object suspendAndGet(Object key, Flag opt, boolean suppressTimeout) throws CacheException {\n       Transaction tx = suspend();\n       try {\n           if (suppressTimeout)\n               return CacheHelper.getAllowingTimeout(cache, key);\n           else\n               return CacheHelper.get(cache, key);\n       } finally {\n           resume(tx);\n       }\n   }\n","new_comment_raw":"@param suppressTimeout should any TimeoutException be suppressed?","old_comment_raw":"@param suppressTimeout should any TimeoutException be suppressed?","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"ScrollQuery scan(String query, BytesArray body, ScrollReader reader) throws IOException { String[] scrollInfo = client.scan(query, body); String scrollId = scrollInfo[0]; long totalSize = Long.parseLong(scrollInfo[1]); return new ScrollQuery(this, scrollId, totalSize, reader); }","old_code_raw":"    ScrollQuery scan(String query, ScrollReader reader) throws IOException {\n        String[] scrollInfo = client.scan(query);\n        String scrollId = scrollInfo[0];\n        long totalSize = Long.parseLong(scrollInfo[1]);\n        return new ScrollQuery(this, scrollId, totalSize, reader);\n    }\n","new_comment_raw":"@param reader scroll reader","old_comment_raw":"@param reader scroll reader","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":59},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, Map<String, Object> params) throws IOException { HttpResponse response = uploadFileWithRequiredFileForHttpResponse(petId, requiredFile, params); TypeReference typeRef = new TypeReference<ModelApiResponse>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, Map<String, Object> params) throws IOException {\n        HttpResponse response = uploadFileWithRequiredFileForHttpResponse(petId, file, params);\n        TypeReference typeRef = new TypeReference<ModelApiResponse>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param requiredFile file to upload","old_comment_raw":"@param file file to upload","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":56},{"new_code_raw":"private BufferedImage loadImage(int itemId, int quantity, boolean stackable) { SpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, stackable ? 1 : 0, false); return sprite.toBufferedImage(); }","old_code_raw":"\tprivate BufferedImage loadImage(int itemId, int quantity)\n\t{\n\t\tSpritePixels sprite = client.createItemSprite(itemId, quantity, 1, SpritePixels.DEFAULT_SHADOW_COLOR, 0, false);\n\t\treturn sprite.toBufferedImage();\n\t}\n","new_comment_raw":"@param itemId","old_comment_raw":"@param itemId","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":44},{"new_code_raw":"public long set(long instant, int year) { Utils.verifyValueBounds (this, year, iChronology.getMinYear(), iChronology.getMaxYear()); int dayOfYear = iChronology.dayOfYear().get(instant); int millisOfDay = iChronology.millisOfDay().get(instant); if (dayOfYear > (31 + 28)) { \/\/ after Feb 28 if (isLeap(instant)) { \/\/ Old date is Feb 29 or later. if (!iChronology.isLeapYear(year)) { \/\/ Moving to a non-leap year, Feb 29 does not exist. dayOfYear--; } } else { \/\/ Old date is Mar 01 or later. if (iChronology.isLeapYear(year)) { \/\/ Moving to a leap year, account for Feb 29. dayOfYear++; } } } instant = iChronology.getYearMonthDayMillis(year, 1, dayOfYear); instant += millisOfDay; return instant; }","old_code_raw":"    public long set(long millis, int year) {\n        super.verifyValueBounds(year, iChronology.getMinYear(), iChronology.getMaxYear());\n\n        int dayOfYear = iChronology.dayOfYear().get(millis);\n        int millisOfDay = iChronology.millisOfDay().get(millis);\n\n        if (dayOfYear > (31 + 28)) { \/\/ after Feb 28\n            if (isLeap(millis)) {\n                \/\/ Old date is Feb 29 or later.\n                if (!iChronology.isLeapYear(year)) {\n                    \/\/ Moving to a non-leap year, Feb 29 does not exist.\n                    dayOfYear--;\n                }\n            } else {\n                \/\/ Old date is Mar 01 or later.\n                if (iChronology.isLeapYear(year)) {\n                    \/\/ Moving to a leap year, account for Feb 29.\n                    dayOfYear++;\n                }\n            }\n        }\n\n        millis = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);\n        millis += millisOfDay;\n\n        return millis;\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":10,"line_counts":29,"new_code_token_num":172},{"new_code_raw":"public ItemStats getItemStats(int itemId, boolean allowNote) { ItemComposition itemComposition = getItemComposition(itemId); if (itemComposition == null || itemComposition.getName() == null || (!allowNote && itemComposition.getNote() != -1)) { return null; } return itemStats.get(canonicalize(itemId)); }","old_code_raw":"\tpublic ItemStats getItemStats(int itemId)\n\t{\n\t\tItemComposition itemComposition = getItemComposition(itemId);\n\n\t\tif (itemComposition == null || itemComposition.getName() == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\treturn itemStats.get(itemComposition.getName());\n\t}\n","new_comment_raw":"@param itemId item id","old_comment_raw":"@param itemId item id","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":61},{"new_code_raw":"public Client testClassname(Client client, Map<String, Object> params) throws IOException { HttpResponse response = testClassnameForHttpResponse(client, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public Client testClassname(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = testClassnameForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param client client model","old_comment_raw":"@param body client model","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":51},{"new_code_raw":"private ParquetTableMetadata_v4 getParquetTableMetadata(Path path, FileSystem fs) throws IOException { FileStatus fileStatus = fs.getFileStatus(path); Stopwatch watch = logger.isDebugEnabled() ? Stopwatch.createStarted() : null; List<FileStatus> fileStatuses = new ArrayList<>(); if (fileStatus.isFile()) { fileStatuses.add(fileStatus); } else { \/\/ the thing we need!? fileStatuses.addAll(DrillFileSystemUtil.listFiles(fs, path, true)); } if (watch != null) { logger.debug(\"Took {} ms to get file statuses\", watch.elapsed(TimeUnit.MILLISECONDS)); watch.reset(); watch.start(); } Map<FileStatus, FileSystem> fileStatusMap = fileStatuses.stream() .collect( java.util.stream.Collectors.toMap( Function.identity(), s -> fs, (oldFs, newFs) -> newFs, LinkedHashMap::new)); ParquetTableMetadata_v4 metadata_v4 = getParquetTableMetadata(fileStatusMap); if (watch != null) { logger.debug(\"Took {} ms to read file metadata\", watch.elapsed(TimeUnit.MILLISECONDS)); watch.stop(); } return metadata_v4; }","old_code_raw":"  private ParquetTableMetadata_v4 getParquetTableMetadata(String path, FileSystem fs) throws IOException {\n    Path p = new Path(path);\n    FileStatus fileStatus = fs.getFileStatus(p);\n    Stopwatch watch = logger.isDebugEnabled() ? Stopwatch.createStarted() : null;\n    List<FileStatus> fileStatuses = new ArrayList<>();\n    if (fileStatus.isFile()) {\n      fileStatuses.add(fileStatus);\n    } else {\n      fileStatuses.addAll(DrillFileSystemUtil.listFiles(fs, p, true));\n    }\n    if (watch != null) {\n      logger.debug(\"Took {} ms to get file statuses\", watch.elapsed(TimeUnit.MILLISECONDS));\n      watch.reset();\n      watch.start();\n    }\n\n    Map<FileStatus, FileSystem> fileStatusMap = fileStatuses.stream()\n        .collect(\n            java.util.stream.Collectors.toMap(\n                Function.identity(),\n                s -> fs,\n                (oldFs, newFs) -> newFs,\n                LinkedHashMap::new));\n\n    ParquetTableMetadata_v4 metadata_v4 = getParquetTableMetadata(fileStatusMap);\n    if (watch != null) {\n      logger.debug(\"Took {} ms to read file metadata\", watch.elapsed(TimeUnit.MILLISECONDS));\n      watch.stop();\n    }\n    return metadata_v4;\n  }\n","new_comment_raw":"@param path the path of the directory","old_comment_raw":"@param path the path of the directory","label":0,"pre_label":1,"AST_level":9,"line_counts":32,"new_code_token_num":210},{"new_code_raw":"protected boolean addCondition(StringBuilder buffer, String on) { if ( StringHelper.isNotEmpty( on ) ) { if ( !on.startsWith( \" and\" ) ) buffer.append( \" and \" ); buffer.append( on ); return true; } else { return false; } }","old_code_raw":"\tprotected boolean addCondition(StringBuffer buffer, String on) {\n\t\tif ( StringHelper.isNotEmpty( on ) ) {\n\t\t\tif ( !on.startsWith( \" and\" ) ) buffer.append( \" and \" );\n\t\t\tbuffer.append( on );\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n","new_comment_raw":"@param on The 'on' condition.","old_comment_raw":"@param on The 'on' condition.","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":56},{"new_code_raw":"public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, Annotation doc, int sentenceIndex) { if (Thread.interrupted()) { throw new RuntimeInterruptedException(); } \/\/ Get the spans for the extraction List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); List<CoreLabel> relation; if (proto.getRelationTokensCount() == 0) { \/\/ If we don't have a real span for the relation, make a dummy word relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation()))); } else { relation = proto.getRelationTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); } List<CoreLabel> object = proto.getObjectTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); \/\/ Create the extraction RelationTriple extraction; double confidence = proto.getConfidence(); if (proto.hasTree()) { SemanticGraph tree = fromProto( proto.getTree(), doc.get(SentencesAnnotation.class).get(sentenceIndex).get(TokensAnnotation.class), doc.get(DocIDAnnotation.class), Optional.of(doc)); extraction = new RelationTriple.WithTree(subject, relation, object, tree, confidence); } else { extraction = new RelationTriple(subject, relation, object, confidence); } \/\/ Tweak the extraction if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); } if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); } if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); } if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); } \/\/ Return return extraction; }","old_code_raw":"  public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, List<CoreLabel> sentence, String docid) {\n    if (Thread.interrupted()) {\n      throw new RuntimeInterruptedException();\n    }\n    \/\/ Get the spans for the extraction\n    List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(sentence::get).collect(Collectors.toList());\n    List<CoreLabel> relation;\n    if (proto.getRelationTokensCount() == 0) {  \/\/ If we don't have a real span for the relation, make a dummy word\n      relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation())));\n    } else {\n      relation = proto.getRelationTokensList().stream().map(sentence::get).collect(Collectors.toList());\n    }\n    List<CoreLabel> object = proto.getObjectTokensList().stream().map(sentence::get).collect(Collectors.toList());\n\n    \/\/ Create the extraction\n    RelationTriple extraction;\n    double confidence = proto.getConfidence();\n    if (proto.hasTree()) {\n      SemanticGraph tree = fromProto(proto.getTree(), sentence, docid);\n      extraction =  new RelationTriple.WithTree(subject, relation, object, tree, confidence);\n    } else {\n      extraction = new RelationTriple(subject, relation, object, confidence);\n    }\n\n    \/\/ Tweak the extraction\n    if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); }\n    if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); }\n    if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); }\n    if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); }\n\n    \/\/ Return\n    return extraction;\n  }\n","new_comment_raw":"@param sentenceIndex The index of the sentence this extraction should be attached to.","old_comment_raw":"@param docid The id of the document we are de-serializing.","label":1,"pre_label":0,"AST_level":13,"line_counts":44,"new_code_token_num":414},{"new_code_raw":"private static boolean shouldDelayIdentityInserts(boolean requiresImmediateIdAccess, EventSource source, EntityPersister persister) { return shouldDelayIdentityInserts( requiresImmediateIdAccess, isPartOfTransaction( source ), source.getHibernateFlushMode(), persister ); }","old_code_raw":"\tprivate static boolean shouldDelayIdentityInserts(boolean requiresImmediateIdAccess, EventSource source) {\n\t\treturn shouldDelayIdentityInserts( requiresImmediateIdAccess, isPartOfTransaction( source ), source.getHibernateFlushMode() );\n\t}\n","new_comment_raw":"@param source The session which is the source of the current event.","old_comment_raw":"@param source The session which is the source of the current event.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public Object getCache(PGraphics renderer) { if (cacheMap == null) return null; return cacheMap.get(renderer); }","old_code_raw":"  public Object getCache(Object parent) {\n    if (cacheMap == null) return null;\n    return cacheMap.get(parent);\n  }\n","new_comment_raw":"@param renderer The PGraphics renderer associated to the image","old_comment_raw":"@param parent The PGraphics object (or any object, really) associated","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public boolean isValid(Litmus litmus, Context context) { return super.isValid(litmus, context) && litmus.check(Util.isDistinct(getRowType().getFieldNames()), \"distinct field names: {}\", getRowType()); }","old_code_raw":"  public boolean isValid(Litmus litmus) {\n    return super.isValid(litmus)\n        && litmus.check(Util.isDistinct(getRowType().getFieldNames()),\n            \"distinct field names: {}\", getRowType());\n  }\n","new_comment_raw":"@param groupSet Bit set of grouping fields","old_comment_raw":"@param groupSet Bit set of grouping fields","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":50},{"new_code_raw":"public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer[] preparers, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException { final ResultSet[] resultSets = new ResultSet[multiQuery.length]; final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length]; try { for (int i = 0; i < multiQuery.length; i++) { final String query = multiQuery[i]; if (LOGGER.isTraceEnabled()) { LOGGER.trace(\"running '{}'\", query); } final PreparedStatement statement = createPreparedStatement(query); preparedStatements[i] = statement; preparers[i].accept(statement); resultSets[i] = statement.executeQuery(); } if (resultConsumer != null) { resultConsumer.accept(resultSets); } } finally { for (ResultSet rs: resultSets) { if (rs != null) { try { rs.close(); } catch (Exception ei) { } } } } return this; }","old_code_raw":"    public JdbcConnection prepareQuery(String[] multiQuery, StatementPreparer preparer, BlockingMultiResultSetConsumer resultConsumer) throws SQLException, InterruptedException {\n        final Connection conn = connection();\n        final ResultSet[] resultSets = new ResultSet[multiQuery.length];\n        final PreparedStatement[] preparedStatements = new PreparedStatement[multiQuery.length];\n\n        try {\n            for (int i = 0; i < multiQuery.length; i++) {\n                final String query = multiQuery[i];\n                if (LOGGER.isTraceEnabled()) {\n                    LOGGER.trace(\"running '{}'\", query);\n                }\n                final PreparedStatement statement = createPreparedStatement(query);\n                preparedStatements[i] = statement;\n                preparer.accept(statement);\n                resultSets[i] = statement.executeQuery();\n            }\n            if (resultConsumer != null) {\n                resultConsumer.accept(resultSets);\n            }\n        }\n        finally {\n            for (ResultSet rs: resultSets) {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    }\n                    catch (Exception ei) {\n                    }\n                }\n            }\n        }\n        return this;\n    }\n","new_comment_raw":"@param preparer the array of functions that supply arguments to the prepared statements; may not be null","old_comment_raw":"@param preparer the function that supplied arguments to the prepared statement; may not be null","label":1,"pre_label":0,"AST_level":10,"line_counts":33,"new_code_token_num":181},{"new_code_raw":"public ApiResponse<Client> call123testSpecialTagsWithHttpInfo(Client body) throws ApiException { Object localVarPostBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, \"Missing the required parameter 'body' when calling call123testSpecialTags\"); } \/\/ create path and map variables String localVarPath = \"\/another-fake\/dummy\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ApiResponse<Client> call123testSpecialTagsWithHttpInfo(Client client) throws ApiException {\n    Object localVarPostBody = client;\n    \n    \/\/ verify the required parameter 'client' is set\n    if (client == null) {\n      throw new ApiException(400, \"Missing the required parameter 'client' when calling call123testSpecialTags\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/another-fake\/dummy\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param body client model (required)","old_comment_raw":"@param client client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":204},{"new_code_raw":"public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces, Dialect dialect) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, dialect, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }","old_code_raw":"\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createSchemas, Dialect dialect) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateSchemas,\n\t\t\t\tdialect,\n\t\t\t\tnew Target() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n","new_comment_raw":"@param createNamespaces Should the schema(s)\/catalog(s) actually be created as well ( CREATE SCHEMA)?","old_comment_raw":"@param createSchemas Should the schema(s) actually be created as well ( CREATE SCHEMA)?","label":1,"pre_label":0,"AST_level":9,"line_counts":30,"new_code_token_num":92},{"new_code_raw":"public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces) { final ArrayList<String> commands = new ArrayList<String>(); doCreation( metadata, createNamespaces, new Target() { @Override public boolean acceptsImportScriptActions() { return true; } @Override public void prepare() { } @Override public void accept(String action) { commands.add( action ); } @Override public void release() { } } ); return commands; }","old_code_raw":"\tpublic List<String> generateCreationCommands(Metadata metadata, boolean createSchemas) {\n\t\tfinal ArrayList<String> commands = new ArrayList<String>();\n\t\tdoCreation(\n\t\t\t\tmetadata,\n\t\t\t\tcreateSchemas,\n\t\t\t\tnew Target() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic boolean acceptsImportScriptActions() {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void prepare() {\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void accept(String action) {\n\t\t\t\t\t\tcommands.add( action );\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void release() {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\treturn commands;\n\t}\n","new_comment_raw":"@param metadata The metadata for which to generate the creation commands.","old_comment_raw":"@param metadata The metadata for which to generate the creation commands.","label":0,"pre_label":1,"AST_level":9,"line_counts":28,"new_code_token_num":87},{"new_code_raw":"public boolean searchText(String regex, int matches, boolean scroll) { return searcher.searchText(regex, matches, scroll); }","old_code_raw":"\tpublic boolean searchText(String search, int matches, boolean scroll) {\n\t\treturn searcher.searchText(search, matches, scroll);\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"protected ArrayList<Timestamp> getTransitions(Timestamp beginning, int[] checks) { ArrayList<Timestamp> list = new ArrayList<>(); Timestamp current = beginning; list.add(current); for (int i = 1; i < checks.length; i++) { current = current.plus(1); int j = checks.length - i - 1; if ((checks[j + 1] == 0 && checks[j] > 0)) list.add(current); if ((checks[j + 1] > 0 && checks[j] == 0)) list.add(current.minus(1)); } if (list.size() % 2 == 1) list.add(current); return list; }","old_code_raw":"    protected ArrayList<Long> getTransitions(long beginning, int[] checks)\n    {\n        long day = DateUtils.millisecondsInOneDay;\n        long current = beginning;\n\n        ArrayList<Long> list = new ArrayList<>();\n        list.add(current);\n\n        for (int i = 1; i < checks.length; i++)\n        {\n            current += day;\n            int j = checks.length - i - 1;\n\n            if ((checks[j + 1] == 0 && checks[j] > 0)) list.add(current);\n            if ((checks[j + 1] > 0 && checks[j] == 0)) list.add(current - day);\n        }\n\n        if (list.size() % 2 == 1) list.add(current);\n\n        return list;\n    }\n","new_comment_raw":"@param checks the checkmarks, ordered by decresing timestamp","old_comment_raw":"@param checks the checkmarks, ordered by decresing timestamp","label":0,"pre_label":1,"AST_level":11,"line_counts":20,"new_code_token_num":138},{"new_code_raw":"public static long toMicroOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration); } \/\/ conversion to nanos is fine as TIME values won't exceed long range return ((Duration) value).toNanos() \/ 1_000; } \/\/ TODO only needed for SQL Server\/Oracle, where we don't produce Duration right away; \/\/ this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND); }","old_code_raw":"    public static long toMicroOfDay(Object value, TemporalAdjuster adjuster) {\n        \/\/ conversion to nanos is fine as TIME values won't exceed long range\n        if (value instanceof Duration) {\n            return ((Duration) value).toNanos() \/ 1_000;\n        }\n\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster != null) {\n            time = time.with(adjuster);\n        }\n        return Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MICROSECOND);\n    }\n","new_comment_raw":"@param acceptLargeValues whether to accept values less than 00:00:00 and larger than 24:00:00 or not","old_comment_raw":"@param adjuster the optional component that adjusts the local date value before obtaining the epoch day; may be null if no adjustment is necessary","label":1,"pre_label":0,"AST_level":10,"line_counts":17,"new_code_token_num":166},{"new_code_raw":"public static boolean isTransient(String entityName, Object entity, Boolean assumed, SharedSessionContractImplementor session) { if ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) { \/\/ an unfetched association can only point to \/\/ an entity that already exists in the db return false; } \/\/ let the interceptor inspect the instance to decide Boolean isUnsaved = session.getInterceptor().isTransient( entity ); if ( isUnsaved != null ) { return isUnsaved; } \/\/ let the persister inspect the instance to decide final EntityPersister persister = session.getEntityPersister( entityName, entity ); isUnsaved = persister.isTransient( entity, session ); if ( isUnsaved != null ) { return isUnsaved; } \/\/ we use the assumed value, if there is one, to avoid hitting \/\/ the database if ( assumed != null ) { return assumed; } \/\/ hit the database, afterQuery checking the session cache for a snapshot final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot( persister.getIdentifier( entity, session ), persister ); return snapshot == null; }","old_code_raw":"\tpublic static boolean isTransient(String entityName, Object entity, Boolean assumed, SessionImplementor session) {\n\t\tif ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n\t\t\t\/\/ an unfetched association can only point to\n\t\t\t\/\/ an entity that already exists in the db\n\t\t\treturn false;\n\t\t}\n\n\t\t\/\/ let the interceptor inspect the instance to decide\n\t\tBoolean isUnsaved = session.getInterceptor().isTransient( entity );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t\/\/ let the persister inspect the instance to decide\n\t\tfinal EntityPersister persister = session.getEntityPersister( entityName, entity );\n\t\tisUnsaved = persister.isTransient( entity, session );\n\t\tif ( isUnsaved != null ) {\n\t\t\treturn isUnsaved;\n\t\t}\n\n\t\t\/\/ we use the assumed value, if there is one, to avoid hitting\n\t\t\/\/ the database\n\t\tif ( assumed != null ) {\n\t\t\treturn assumed;\n\t\t}\n\n\t\t\/\/ hit the database, after checking the session cache for a snapshot\n\t\tfinal Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(\n\t\t\t\tpersister.getIdentifier( entity, session ),\n\t\t\t\tpersister\n\t\t);\n\t\treturn snapshot == null;\n\n\t}\n","new_comment_raw":"@param entityName The name of the entity","old_comment_raw":"@param entityName The name of the entity","label":0,"pre_label":1,"AST_level":8,"line_counts":35,"new_code_token_num":193},{"new_code_raw":"public boolean waitForActivity(Class<? extends Activity> activityClass, int timeout){ final long endTime = SystemClock.uptimeMillis() + timeout; Activity currentActivity = activityUtils.getCurrentActivity(false); while(SystemClock.uptimeMillis() < endTime){ if(currentActivity != null && currentActivity.getClass().equals(activityClass)) return true; currentActivity = activityUtils.getCurrentActivity(); } return false; }","old_code_raw":"\tpublic boolean waitForActivity(Class<? extends Activity> clazz, int timeout){\n\t\tfinal long endTime = SystemClock.uptimeMillis() + timeout;\n\t\tActivity currentActivity = activityUtils.getCurrentActivity(false);\n\n\t\twhile(SystemClock.uptimeMillis() < endTime){\n\t\t\tif(currentActivity != null && currentActivity.getClass().equals(clazz))\n\t\t\t\treturn true;\n\n\t\t\tcurrentActivity = activityUtils.getCurrentActivity();\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@param activityClass the class of the  Activity to wait for","old_comment_raw":"@param clazz the class of the Activity to wait for e.g. \"MyActivity\"","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":71},{"new_code_raw":"public PortletContainer createContainer( String containerName, RequiredContainerServices requiredServices) throws PortletContainerException { return createContainer(containerName, requiredServices, new DefaultOptionalContainerServices()); }","old_code_raw":"    public PortletContainer createContainer(String containerName,\r\n                                            PortletContainerServices services)\r\n        throws PortletContainerException {\r\n        return createContainer(containerName, services, new DefaultOptionalServices());\r\n   }\r\n","new_comment_raw":"@param containerName the name of the portlet container.","old_comment_raw":"@param containerName","label":1,"pre_label":0,"AST_level":6,"line_counts":10,"new_code_token_num":27},{"new_code_raw":"public long add(long instant, int years) { return getWrappedField().add(instant, years); }","old_code_raw":"    public long add(long millis, int years) {\n        return iChronology.year().add(millis, years);\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public TestSession getSession(ExternalSessionKey externalKey) { return activeTestSessions.findSessionByExternalKey(externalKey); }","old_code_raw":"  public TestSession getSession(String externalKey) {\n    return activeTestSessions.findSessionByExternalKey(externalKey);\n  }\n","new_comment_raw":"@param externalKey the external session key","old_comment_raw":"@param externalKey the external session key","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public static int toMilliOfDay(Object value, boolean acceptLargeValues) { if (value instanceof Duration) { Duration duration = (Duration) value; if (!acceptLargeValues && (duration.isNegative() || duration.compareTo(ONE_DAY) > 0)) { throw new IllegalArgumentException(\"Time values must be between 00:00:00 and 24:00:00 (inclusive): \" + duration); } \/\/ int conversion is ok for the range of TIME return (int) ((Duration) value).toMillis(); } \/\/ TODO only needed for SQL Server\/Oracle, where we don't produce Duration right away; \/\/ this should go eventually, as the conversion to LocalTime is superfluous LocalTime time = Conversions.toLocalTime(value); long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MILLISECOND); assert Math.abs(micros) < Integer.MAX_VALUE; return (int) micros; }","old_code_raw":"    public static int toMilliOfDay(Object value, TemporalAdjuster adjuster) {\n        if (value instanceof Duration) {\n            \/\/ int conversion is ok for the range of TIME\n            return (int) ((Duration) value).toMillis();\n        }\n        LocalTime time = Conversions.toLocalTime(value);\n        if (adjuster != null) {\n            time = time.with(adjuster);\n        }\n        long micros = Math.floorDiv(time.toNanoOfDay(), Conversions.NANOSECONDS_PER_MILLISECOND);\n        assert Math.abs(micros) < Integer.MAX_VALUE;\n        return (int) micros;\n    }\n","new_comment_raw":"@param acceptLargeValues whether to accept values less than 00:00:00 and larger than 24:00:00 or not","old_comment_raw":"@param adjuster the optional component that adjusts the local date value before obtaining the epoch day; may be null if no adjustment is necessary","label":1,"pre_label":0,"AST_level":10,"line_counts":19,"new_code_token_num":178},{"new_code_raw":"protected boolean canImplement(LogicalCalc rel, String relTypeName) { for (RelType relType : relTypes) { if (relType.name.equals(relTypeName)) { return relType.canImplement(rel.getProgram()); } } throw Util.newInternal(\"unknown type \" + relTypeName); }","old_code_raw":"  protected boolean canImplement(CalcRel rel, String relTypeName) {\n    for (RelType relType : relTypes) {\n      if (relType.name.equals(relTypeName)) {\n        return relType.canImplement(rel.getProgram());\n      }\n    }\n    throw Util.newInternal(\"unknown reltype \" + relTypeName);\n  }\n","new_comment_raw":"@param rel Calculation relational expression","old_comment_raw":"@param rel Calculation relational expression","label":0,"pre_label":1,"AST_level":9,"line_counts":9,"new_code_token_num":54},{"new_code_raw":"public String getLimitString(String querySqlString, boolean hasOffset) { StringBuilder sb = new StringBuilder(querySqlString.trim().toLowerCase()); int orderByIndex = sb.indexOf(\"order by\"); CharSequence orderby = orderByIndex > 0 ? sb.subSequence(orderByIndex, sb.length()) : \"ORDER BY CURRENT_TIMESTAMP\"; \/\/ Delete the order by clause at the end of the query if (orderByIndex > 0) { sb.delete(orderByIndex, orderByIndex + orderby.length()); } \/\/ HHH-5715 bug fix replaceDistinctWithGroupBy(sb); insertRowNumberFunction(sb, orderby); \/\/ Wrap the query within a with statement: sb.insert(0, \"WITH query AS (\").append(\") SELECT * FROM query \"); \/\/sb.append(\"WHERE __hibernate_row_nr__ BETWEEN \").append(offset + 1).append(\" AND \").append(limit); sb.append(\"WHERE __hibernate_row_nr__ BETWEEN ? AND ?\"); return sb.toString(); }","old_code_raw":"\tpublic String getLimitString(String querySqlString, int offset, int limit) {\n\t\tStringBuilder sb = new StringBuilder(querySqlString.trim().toLowerCase());\n\n\t\tint orderByIndex = sb.indexOf(\"order by\");\n\t\tCharSequence orderby = orderByIndex > 0 ? sb.subSequence(orderByIndex, sb.length())\n\t\t\t\t: \"ORDER BY CURRENT_TIMESTAMP\";\n\n\t\t\/\/ Delete the order by clause at the end of the query\n\t\tif (orderByIndex > 0) {\n\t\t\tsb.delete(orderByIndex, orderByIndex + orderby.length());\n\t\t}\n\n\t\t\/\/ HHH-5715 bug fix\n\t\treplaceDistinctWithGroupBy(sb);\n\n\t\tinsertRowNumberFunction(sb, orderby);\n\n\t\t\/\/ Wrap the query within a with statement:\n\t\tsb.insert(0, \"WITH query AS (\").append(\") SELECT * FROM query \");\n\t\tsb.append(\"WHERE __hibernate_row_nr__ BETWEEN \").append(offset + 1).append(\" AND \").append(limit);\n\n\t\treturn sb.toString();\n\t}\n","new_comment_raw":"@param limit Maximum number of rows to be returned by the query","old_comment_raw":"@param limit Maximum number of rows to be returned by the query","label":0,"pre_label":1,"AST_level":8,"line_counts":25,"new_code_token_num":191},{"new_code_raw":"public void addPet (Pet pet) throws ApiException { Object localVarPostBody = pet; \/\/ verify the required parameter 'pet' is set if (pet == null) { throw new ApiException(400, \"Missing the required parameter 'pet' when calling addPet\"); } \/\/ create path and map variables String localVarPath = \"\/pet\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); \/\/ form params Map<String, String> localVarFormParams = new HashMap<String, String>(); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\"; if (localVarContentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { \/\/ normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return ; } else { return ; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public void  addPet (Pet body) throws ApiException {\n    Object localVarPostBody = body;\n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n       throw new ApiException(400, \"Missing the required parameter 'body' when calling addPet\");\n    }\n\n    \/\/ create path and map variables\n    String localVarPath = \"\/pet\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> localVarFormParams = new HashMap<String, String>();\n\n\n\n    String[] localVarContentTypes = {\n      \"application\/json\",\"application\/xml\"\n    };\n    String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\";\n\n    if (localVarContentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      \n\n      localVarPostBody = localVarBuilder.build();\n    } else {\n      \/\/ normal form params\n          }\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"POST\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType);\n      if(localVarResponse != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@param pet Pet object that needs to be added to the store","old_comment_raw":"@param body Pet object that needs to be added to the store","label":1,"pre_label":0,"AST_level":8,"line_counts":47,"new_code_token_num":247},{"new_code_raw":"public Builder field(UnaryOperator<GraphQLInputObjectField.Builder> builderFunction) { assertNotNull(builderFunction, \"builderFunction should not be null\"); GraphQLInputObjectField.Builder builder = GraphQLInputObjectField.newInputObjectField(); builder = builderFunction.apply(builder); return field(builder); }","old_code_raw":"        public Builder field(BuilderFunction<GraphQLInputObjectField.Builder> builderFunction) {\n            assertNotNull(builderFunction, \"builderFunction should not be null\");\n            GraphQLInputObjectField.Builder builder = GraphQLInputObjectField.newInputObjectField();\n            builder = builderFunction.apply(builder);\n            return field(builder);\n        }\n","new_comment_raw":"@param builderFunction a supplier for the builder impl","old_comment_raw":"@param builderFunction a supplier for the builder impl","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":45},{"new_code_raw":"public int getOffsetFromLocal(long instantLocal) { return getOffset(instantLocal - getOffset(instantLocal)); }","old_code_raw":"    public int getOffsetFromLocal(long millisLocal) {\n        return getOffset(millisLocal - getOffset(millisLocal));\n    }\n","new_comment_raw":"@param instantLocal the millisecond instant, relative to this time zone, to get the offset for","old_comment_raw":"@param millisLocal the millisecond instant, relative to this time zone, to get the offset for","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, Annotation doc, int sentenceIndex) { if (Thread.interrupted()) { throw new RuntimeInterruptedException(); } \/\/ Get the spans for the extraction List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); List<CoreLabel> relation; if (proto.getRelationTokensCount() == 0) { \/\/ If we don't have a real span for the relation, make a dummy word relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation()))); } else { relation = proto.getRelationTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); } List<CoreLabel> object = proto.getObjectTokensList().stream().map(loc -> doc.get(SentencesAnnotation.class).get(loc.getSentenceIndex()).get(TokensAnnotation.class).get(loc.getTokenIndex()) ).collect(Collectors.toList()); \/\/ Create the extraction RelationTriple extraction; double confidence = proto.getConfidence(); if (proto.hasTree()) { SemanticGraph tree = fromProto( proto.getTree(), doc.get(SentencesAnnotation.class).get(sentenceIndex).get(TokensAnnotation.class), doc.get(DocIDAnnotation.class), Optional.of(doc)); extraction = new RelationTriple.WithTree(subject, relation, object, tree, confidence); } else { extraction = new RelationTriple(subject, relation, object, confidence); } \/\/ Tweak the extraction if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); } if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); } if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); } if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); } \/\/ Return return extraction; }","old_code_raw":"  public static RelationTriple fromProto(CoreNLPProtos.RelationTriple proto, List<CoreLabel> sentence, String docid) {\n    if (Thread.interrupted()) {\n      throw new RuntimeInterruptedException();\n    }\n    \/\/ Get the spans for the extraction\n    List<CoreLabel> subject = proto.getSubjectTokensList().stream().map(sentence::get).collect(Collectors.toList());\n    List<CoreLabel> relation;\n    if (proto.getRelationTokensCount() == 0) {  \/\/ If we don't have a real span for the relation, make a dummy word\n      relation = Collections.singletonList(new CoreLabel(new Word(proto.getRelation())));\n    } else {\n      relation = proto.getRelationTokensList().stream().map(sentence::get).collect(Collectors.toList());\n    }\n    List<CoreLabel> object = proto.getObjectTokensList().stream().map(sentence::get).collect(Collectors.toList());\n\n    \/\/ Create the extraction\n    RelationTriple extraction;\n    double confidence = proto.getConfidence();\n    if (proto.hasTree()) {\n      SemanticGraph tree = fromProto(proto.getTree(), sentence, docid);\n      extraction =  new RelationTriple.WithTree(subject, relation, object, tree, confidence);\n    } else {\n      extraction = new RelationTriple(subject, relation, object, confidence);\n    }\n\n    \/\/ Tweak the extraction\n    if (proto.hasIstmod()) { extraction.istmod(proto.getIstmod()); }\n    if (proto.hasPrefixBe()) { extraction.isPrefixBe(proto.getPrefixBe()); }\n    if (proto.hasSuffixBe()) { extraction.isSuffixBe(proto.getSuffixBe()); }\n    if (proto.hasSuffixOf()) { extraction.isSuffixOf(proto.getSuffixOf()); }\n\n    \/\/ Return\n    return extraction;\n  }\n","new_comment_raw":"@param doc The document we are deserializing. This document should already have a docid annotation set, if there is one.","old_comment_raw":"@param sentence The sentence the triples were extracted from.","label":1,"pre_label":0,"AST_level":13,"line_counts":44,"new_code_token_num":414},{"new_code_raw":"public ArrayList<TextView> clickInList(int line, int index, boolean longClick, int time) { line--; if(line < 0) line = 0; boolean foundList = waiter.waitForView(ListView.class, index); if (!foundList) Assert.assertTrue(\"No ListView with index \" + index + \" is available!\", false); ArrayList<View> views = new ArrayList<View>(); final ListView listView = viewFetcher.getView(ListView.class, null, index); if(listView == null) Assert.assertTrue(\"ListView is null!\", false); View view = listView.getChildAt(line); if(view != null){ views = viewFetcher.getViews(view, true); views = RobotiumUtils.removeInvisibleViews(views); clickOnScreen(view, longClick, time); } return RobotiumUtils.filterViews(TextView.class, views); }","old_code_raw":"\tpublic ArrayList<TextView> clickInList(int line, int index) {\t\n\t\tline--;\n\t\tif(line < 0)\n\t\t\tline = 0;\n\n\t\tboolean foundList = waiter.waitForView(ListView.class, index);\n\t\tif (!foundList) \n\t\t\tAssert.assertTrue(\"No ListView with index \" + index + \" is available!\", false);\n\n\t\tArrayList<View> views = new ArrayList<View>();\n\t\tfinal ListView listView = viewFetcher.getView(ListView.class, null, index);\n\t\tif(listView == null)\n\t\t\tAssert.assertTrue(\"ListView is null!\", false);\n\n\t\tView view = listView.getChildAt(line);\n\t\tif(view != null){\n\t\t\tviews = viewFetcher.getViews(view, true);\n\t\t\tviews = RobotiumUtils.removeInvisibleViews(views);\n\t\t\tclickOnScreen(view);\n\t\t}\n\t\treturn RobotiumUtils.filterViews(TextView.class, views);\n\t}\n","new_comment_raw":"@param index the index of the list. E.g. Index 1 if two lists are available","old_comment_raw":"@param index the index of the list. E.g. Index 1 if two lists are available","label":0,"pre_label":1,"AST_level":8,"line_counts":23,"new_code_token_num":160},{"new_code_raw":"public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: if (val1 == Long.MIN_VALUE) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return -val1; case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total \/ val2 != val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total; }","old_code_raw":"    public static long safeMultiply(long val1, int scalar) {\n        switch (scalar) {\n        case -1:\n            return -val1;\n        case 0:\n            return 0L;\n        case 1:\n            return val1;\n        }\n        long total = val1 * scalar;\n        if (total \/ scalar != val1) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" * \" + scalar);\n        }\n        return total;\n    }\n","new_comment_raw":"@param val2 the second value","old_comment_raw":"@param scalar the second value","label":1,"pre_label":0,"AST_level":12,"line_counts":19,"new_code_token_num":108},{"new_code_raw":"public String toInstantiationType(Schema schema) { if (ModelUtils.isMapSchema(schema)) { Schema additionalProperties = (Schema) schema.getAdditionalProperties(); String type = additionalProperties.getType(); if (null == type) { LOGGER.error(\"No Type defined for Additional Property \" + additionalProperties + \"\\n\" \/\/ + \"\\tIn Property: \" + schema); } String inner = getSchemaType(additionalProperties); return instantiationTypes.get(\"map\") + \"<String, \" + inner + \">\"; } else if (ModelUtils.isArraySchema(schema)) { ArraySchema arraySchema = (ArraySchema) schema; String inner = getSchemaType(arraySchema.getItems()); return instantiationTypes.get(\"array\") + \"<\" + inner + \">\"; } else { return null; } }","old_code_raw":"    public String toInstantiationType(Property p) {\n        if (p instanceof MapProperty) {\n            MapProperty ap = (MapProperty) p;\n            Property additionalProperties2 = ap.getAdditionalProperties();\n            String type = additionalProperties2.getType();\n            if (null == type) {\n                LOGGER.error(\"No Type defined for Additional Property \" + additionalProperties2 + \"\\n\" \/\/\n                        + \"\\tIn Property: \" + p);\n            }\n            String inner = getSwaggerType(additionalProperties2);\n            return instantiationTypes.get(\"map\") + \"<String, \" + inner + \">\";\n        } else if (p instanceof ArrayProperty) {\n            ArrayProperty ap = (ArrayProperty) p;\n            String inner = getSwaggerType(ap.getItems());\n            return instantiationTypes.get(\"array\") + \"<\" + inner + \">\";\n        } else {\n            return null;\n        }\n    }\n","new_comment_raw":"@param schema property schema","old_comment_raw":"@param p Swagger property object","label":1,"pre_label":0,"AST_level":13,"line_counts":19,"new_code_token_num":151},{"new_code_raw":"protected URL isProxied(HttpURI uri) throws MalformedURLException { \/\/ Is this a proxy request? if (isForbidden(uri)) return null; \/\/ OK return URI as untransformed URL. return new URL(uri.toString()); }","old_code_raw":"  protected URL isProxied(URI uri) throws MalformedURLException {\n    \/\/ Is this a proxy request?\n    if (isForbidden(uri))\n      return null;\n\n    \/\/ OK return URI as untransformed URL.\n    return new URL(uri.toString());\n  }\n","new_comment_raw":"@param uri The requested URI, which should include a scheme, host and port.","old_comment_raw":"@param uri The requested URI, which should include a scheme, host and port.","label":0,"pre_label":1,"AST_level":5,"line_counts":9,"new_code_token_num":47},{"new_code_raw":"public ArrayList<TextView> clickInList(int line, int listIndex) { return soloClick.clickInList(line, listIndex); }","old_code_raw":"\tpublic ArrayList<TextView> clickInList(int line, int index) {\n\treturn soloClick.clickInList(line, index);\n\t}\n","new_comment_raw":"@param listIndex the index of the list. E.g. Index 1 if two lists are available","old_comment_raw":"@param index the index of the list. E.g. Index 1 if two lists are available","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public long addWrapped(long instant, int months) { return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX)); }","old_code_raw":"    public long addWrapped(long millis, int months) {\n        return set(millis, getWrappedValue(get(millis), months, MIN, MAX));\n    }\n","new_comment_raw":"@param months the months to add (can be negative).","old_comment_raw":"@param months the months to add (can be negative).","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":33},{"new_code_raw":"public static String uniquify(String name, Set<String> nameList) { if (name == null) { name = \"EXPR$\"; } if (nameList.add(name)) { return name; } String aliasBase = name; for (int j = 0;; j++) { name = aliasBase + j; if (nameList.add(name)) { return name; } } }","old_code_raw":"    public static String uniquify(String name, Collection<String> nameList)\n    {\n        if (name == null) {\n            name = \"EXPR$\";\n        }\n        if (nameList.contains(name)) {\n            String aliasBase = name;\n            for (int j = 0;; j++) {\n                name = aliasBase + j;\n                if (!nameList.contains(name)) {\n                    break;\n                }\n            }\n        }\n        nameList.add(name);\n        return name;\n    }\n","new_comment_raw":"@param name Suggested name, may not be unique","old_comment_raw":"@param name Suggested name, may not be unique","label":0,"pre_label":1,"AST_level":8,"line_counts":17,"new_code_token_num":75},{"new_code_raw":"public static Predicate<ColumnId> excludeColumns(String columnNames) { return Predicates.excludes(columnNames, ColumnId::toString); }","old_code_raw":"    public static Predicate<ColumnId> excludeColumns(String fullyQualifiedTableNames) {\n        return Predicates.excludes(fullyQualifiedTableNames, ColumnId::toString);\n    }\n","new_comment_raw":"@param columnNames the comma-separated list of column names names to exclude; may be null or empty","old_comment_raw":"@param fullyQualifiedTableNames the comma-separated list of fully-qualified table names to exclude; may be null or empty","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean putFromLoad(SharedSessionContractImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride) throws CacheException { if ( !region.checkValid() ) { if ( TRACE_ENABLED ) { log.tracef( \"Region %s not valid\", region.getName() ); } return false; } \/\/ In theory, since putForExternalRead is already as minimal as it can \/\/ get, we shouldn't be need this check. However, without the check and \/\/ without https:\/\/issues.jboss.org\/browse\/ISPN-1986, it's impossible to \/\/ know whether the put actually occurred. Knowing this is crucial so \/\/ that Hibernate can expose accurate statistics. if ( minimalPutOverride && cache.containsKey( key ) ) { return false; } PutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp); if ( lock == null) { if ( TRACE_ENABLED ) { log.tracef( \"Put from load lock not acquired for key %s\", key ); } return false; } try { writeCache.putForExternalRead( key, value ); } finally { putValidator.releasePutFromLoadLock( key, lock); } return true; }","old_code_raw":"\tpublic boolean putFromLoad(SessionImplementor session, Object key, Object value, long txTimestamp, Object version, boolean minimalPutOverride)\n\t\t\tthrows CacheException {\n\t\tif ( !region.checkValid() ) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Region %s not valid\", region.getName() );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t\/\/ In theory, since putForExternalRead is already as minimal as it can\n\t\t\/\/ get, we shouldn't be need this check. However, without the check and\n\t\t\/\/ without https:\/\/issues.jboss.org\/browse\/ISPN-1986, it's impossible to\n\t\t\/\/ know whether the put actually occurred. Knowing this is crucial so\n\t\t\/\/ that Hibernate can expose accurate statistics.\n\t\tif ( minimalPutOverride && cache.containsKey( key ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tPutFromLoadValidator.Lock lock = putValidator.acquirePutFromLoadLock(session, key, txTimestamp);\n\t\tif ( lock == null) {\n\t\t\tif ( TRACE_ENABLED ) {\n\t\t\t\tlog.tracef( \"Put from load lock not acquired for key %s\", key );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\twriteCache.putForExternalRead( key, value );\n\t\t}\n\t\tfinally {\n\t\t\tputValidator.releasePutFromLoadLock( key, lock);\n\t\t}\n\n\t\treturn true;\n\t}\n","new_comment_raw":"@param key The item key","old_comment_raw":"@param key The item key","label":0,"pre_label":1,"AST_level":9,"line_counts":36,"new_code_token_num":226},{"new_code_raw":"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param headerParams The header parameters","old_comment_raw":"@param headerParams The header parameters","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"private String getChildSuffix(StructuralNode node, boolean performRecursiveCheck) { String resultSuffix = \"\"; String suffix = null; StructuralNode child = null; try { for (int i = 0; i < staticSuffixList.length; i++) { suffix = staticSuffixList[i]; Iterator<StructuralNode> iter = node.getChildIterator(); while (iter.hasNext()) { child = iter.next(); try { if (child.getURI().getPath().endsWith(suffix)) { return suffix; } } catch (Exception e) { } } } if (performRecursiveCheck) { Iterator<StructuralNode> iter = node.getChildIterator(); while (iter.hasNext()) { child = iter.next(); resultSuffix = getChildSuffix(child, performRecursiveCheck); if (!resultSuffix.equals(\"\")) { return resultSuffix; } } } } catch (Exception e) { } return resultSuffix; }","old_code_raw":"    private String getChildSuffix(SiteNode node, boolean performRecursiveCheck) {\n\n        String resultSuffix = \"\";\n        String suffix = null;\n        SiteNode child = null;\n        HistoryReference ref = null;\n        try {\n\n            for (int i = 0; i < staticSuffixList.length; i++) {\n                suffix = staticSuffixList[i];\n                for (int j = 0; j < node.getChildCount(); j++) {\n                    child = (SiteNode) node.getChildAt(j);\n                    ref = child.getHistoryReference();\n                    try {\n                        if (ref.getURI().getPath().endsWith(suffix)) {\n                            return suffix;\n                        }\n                    } catch (Exception e) {\n                    }\n                }\n            }\n\n            if (performRecursiveCheck) {\n                for (int j = 0; j < node.getChildCount(); j++) {\n                    resultSuffix = getChildSuffix((SiteNode) node.getChildAt(j), performRecursiveCheck);\n                    if (!resultSuffix.equals(\"\")) {\n                        return resultSuffix;\n                    }\n                }\n            }\n\n        } catch (Exception e) {\n        }\n\n        return resultSuffix;\n    }\n","new_comment_raw":"@param performRecursiveCheck True = get recursively the suffix from all the children.","old_comment_raw":"@param performRecursiveCheck True = get recursively the suffix from all the children.","label":0,"pre_label":1,"AST_level":12,"line_counts":38,"new_code_token_num":164},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); if (DEBUG) { System.err.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); for (String nodeName : m.getNodeNames()) { if (nodeName.equals(\"target\")) continue; System.err.println(\" node \" + nodeName + \": \" + m.getNode(nodeName)); } } } } return nodeList; }","old_code_raw":"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@param t Target for finding governors of t related by this GR","old_comment_raw":"@param t Target for finding dependents of t related by this GR","label":1,"pre_label":0,"AST_level":18,"line_counts":22,"new_code_token_num":200},{"new_code_raw":"protected RuntimeException handleAccessDeniedException(AccessDeniedException originalException) { ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(originalException); this.beanManager.fireEvent(exceptionToCatchEvent); \/\/the next step won't happen per default since ExceptionHandlerBroadcaster will throw the exception, \/\/because BeforeAccessDeniedExceptionHandler calls #throwOriginal \/\/but allows to suppress it via deactivating BeforeAccessDeniedExceptionHandler \/\/(or a 2nd @BeforeHandles method which overrules the default behavior \/\/(if needed) if (!exceptionToCatchEvent.isHandled()) { throw originalException; } return null; }","old_code_raw":"    private boolean handleAccessDeniedException(AccessDeniedException ade) throws AccessDeniedException\n    {\n        ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(ade);\n\n        exceptionToCatchEvent.setOptional(true);\n\n        beanManager.fireEvent(exceptionToCatchEvent);\n\n        if (!exceptionToCatchEvent.isHandled())\n        {\n            throw ade;\n        }\n\n        return false;\n    }\n","new_comment_raw":"@param originalException exception thrown by an authorizer","old_comment_raw":"@param ade The previously thrown exception representing a authorization check failure.","label":1,"pre_label":0,"AST_level":6,"line_counts":18,"new_code_token_num":95},{"new_code_raw":"public boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll) { final long endTime = System.currentTimeMillis() + TIMEOUT; while (System.currentTimeMillis() < endTime) { sleeper.sleep(); final boolean foundAnyMatchingView = searchFor(viewClass, regex, expectedMinimumNumberOfMatches, scroll); if (foundAnyMatchingView){ return true; } } return false; }","old_code_raw":"\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int matches, boolean scroll) {\n\t\tfinal long endTime = System.currentTimeMillis() + TIMEOUT;\n\n\t\twhile (System.currentTimeMillis() < endTime) {\n\t\t\tsleeper.sleep();\n\t\t\tfinal boolean foundAnyMatchingView = searchFor(viewClass, regex, matches, scroll);\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n","new_comment_raw":"@param scroll whether scrolling should be performed","old_comment_raw":"@param scroll whether scrolling should be performed","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":72},{"new_code_raw":"public static long readVLong(DrillBuf buffer, int start, int end) { buffer.readerIndex(start); byte firstByte = buffer.readByte(); int len = decodeVIntSize(firstByte); int availableBytes = (end-start); if (len == 1) { return firstByte; } else if (availableBytes < len) { throw new NumberFormatException(\"Expected \" + len + \" bytes but the buffer '\" + DrillStringUtils.toBinaryString(buffer, start, end) + \"' has \" + availableBytes + \" bytes.\"); } long longValue = 0; for (int idx = 0; idx < len-1; idx++) { byte byteValue = buffer.readByte(); longValue = longValue << 8; longValue = longValue | (byteValue & 0xFF); } return (isNegativeVInt(firstByte) ? (longValue ^ -1L) : longValue); }","old_code_raw":"    public static long readVLong(ByteBuf buffer, int start, int end) {\n      buffer.readerIndex(start);\n      byte firstByte = buffer.readByte();\n      int len = decodeVIntSize(firstByte);\n      int availableBytes = (end-start);\n      if (len == 1) {\n        return firstByte;\n      } else if (availableBytes < len) {\n        throw new NumberFormatException(\"Expected \" + len + \" bytes but the buffer '\"\n            + DrillStringUtils.toBinaryString(buffer, start, end) + \"' has  \"\n            + availableBytes + \" bytes.\");\n      }\n\n      long longValue = 0;\n      for (int idx = 0; idx < len-1; idx++) {\n        byte byteValue = buffer.readByte();\n        longValue = longValue << 8;\n        longValue = longValue | (byteValue & 0xFF);\n      }\n      return (isNegativeVInt(firstByte) ? (longValue ^ -1L) : longValue);\n    }\n","new_comment_raw":"@param buffer DrillBuf to read from","old_comment_raw":"@param buffer ByteBuf to read from","label":1,"pre_label":0,"AST_level":14,"line_counts":22,"new_code_token_num":160},{"new_code_raw":"public Call testEndpointParametersAsync(BigDecimal number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }","old_code_raw":"  public Call testEndpointParametersAsync(String number, Double _double, String string, byte[] _byte, Integer integer, Integer int32, Long int64, Float _float, byte[] binary, Date date, Date dateTime, String password, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = testEndpointParametersCall(number, _double, string, _byte, integer, int32, int64, _float, binary, date, dateTime, password, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n","new_comment_raw":"@param password None (optional)","old_comment_raw":"@param password None (optional)","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":187},{"new_code_raw":"protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, FetchedValue fetchedValue) { Field field = parameters.getField().getSingleField(); GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType(); GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field); ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef); Instrumentation instrumentation = executionContext.getInstrumentation(); InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue); InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete( instrumentationParams ); GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry(); Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables()); NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo); ExecutionStrategyParameters newParameters = parameters.transform(builder -> builder.executionStepInfo(executionStepInfo) .arguments(argumentValues) .source(fetchedValue.getFetchedValue()) .localContext(fetchedValue.getLocalContext()) .nonNullFieldValidator(nonNullableFieldValidator) ); log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), executionStepInfo.getPath()); FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters); CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue(); ctxCompleteField.onDispatched(executionResultFuture); executionResultFuture.whenComplete(ctxCompleteField::onCompleted); return fieldValueInfo; }","old_code_raw":"    protected FieldValueInfo completeField(ExecutionContext executionContext, ExecutionStrategyParameters parameters, Object fetchedValue) {\n        Field field = parameters.getField().getSingleField();\n        GraphQLObjectType parentType = (GraphQLObjectType) parameters.getExecutionStepInfo().getUnwrappedNonNullType();\n        GraphQLFieldDefinition fieldDef = getFieldDef(executionContext.getGraphQLSchema(), parentType, field);\n        ExecutionStepInfo executionStepInfo = createExecutionStepInfo(executionContext, parameters, fieldDef);\n\n        Instrumentation instrumentation = executionContext.getInstrumentation();\n        InstrumentationFieldCompleteParameters instrumentationParams = new InstrumentationFieldCompleteParameters(executionContext, parameters, fieldDef, executionStepInfo, fetchedValue);\n        InstrumentationContext<ExecutionResult> ctxCompleteField = instrumentation.beginFieldComplete(\n                instrumentationParams\n        );\n\n        GraphQLCodeRegistry codeRegistry = executionContext.getGraphQLSchema().getCodeRegistry();\n        Map<String, Object> argumentValues = valuesResolver.getArgumentValues(codeRegistry, fieldDef.getArguments(), field.getArguments(), executionContext.getVariables());\n\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, executionStepInfo);\n\n        ExecutionStrategyParameters newParameters = parameters.transform(builder ->\n                builder.executionStepInfo(executionStepInfo)\n                        .arguments(argumentValues)\n                        .source(fetchedValue)\n                        .nonNullFieldValidator(nonNullableFieldValidator)\n        );\n\n        log.debug(\"'{}' completing field '{}'...\", executionContext.getExecutionId(), executionStepInfo.getPath());\n\n        FieldValueInfo fieldValueInfo = completeValue(executionContext, newParameters);\n\n        CompletableFuture<ExecutionResult> executionResultFuture = fieldValueInfo.getFieldValue();\n        ctxCompleteField.onDispatched(executionResultFuture);\n        executionResultFuture.whenComplete(ctxCompleteField::onCompleted);\n        return fieldValueInfo;\n    }\n","new_comment_raw":"@param fetchedValue the fetched raw value","old_comment_raw":"@param fetchedValue the fetched raw value","label":0,"pre_label":1,"AST_level":9,"line_counts":35,"new_code_token_num":239},{"new_code_raw":"public static RequestQueue newRequestQueue(int threadPoolSize) { RequestQueue requestQueue = new RequestQueue(HttpRestConnection.getInstance(getContext()), threadPoolSize); requestQueue.start(); return requestQueue; }","old_code_raw":"\tpublic static RequestQueue newRequestQueue(Context context, int threadPoolSize) {\n\t\tRequestQueue requestQueue = new RequestQueue(HttpRestConnection.getInstance(context), threadPoolSize);\n\t\trequestQueue.start();\n\t\treturn requestQueue;\n\t}\n","new_comment_raw":"@param context ApplicationContext","old_comment_raw":"@param context ApplicationContext","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":34},{"new_code_raw":"public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) { int value = convertText(text, locale); return set(instant, fieldIndex, values, value); }","old_code_raw":"    public int[] set(PartialInstant instant, int fieldIndex, int[] values, String text, Locale locale) {\n        int value = convertText(text, locale);\n        return set(instant, fieldIndex, values, value);\n    }\n","new_comment_raw":"@param text the text value to set","old_comment_raw":"@param text the text value to set","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":46},{"new_code_raw":"static Folder fromXml(Launcher launcher) { return (Folder) LayoutInflater.from(launcher).inflate(R.layout.user_folder, launcher.getDragLayer(), false); }","old_code_raw":"    static Folder fromXml(Context context) {\n        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);\n    }\n","new_comment_raw":"@param context The application's context.","old_comment_raw":"@param context The application's context.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public OuterComposite fakeOuterCompositeSerialize(OuterComposite outerComposite) throws IOException { HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(outerComposite); TypeReference typeRef = new TypeReference<OuterComposite>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws IOException {\n        HttpResponse response = fakeOuterCompositeSerializeForHttpResponse(body);\n        TypeReference typeRef = new TypeReference<OuterComposite>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param outerComposite Input composite as post body","old_comment_raw":"@param body Input composite as post body","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"public String invokeAPI(String path, String method, List<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    b.append(\"?\");\n    if (queryParams != null){\n      for (Pair queryParam : queryParams){\n        if (!queryParam.getName().isEmpty()) {\n          b.append(escapeString(queryParam.getName()));\n          b.append(\"=\");\n          b.append(escapeString(queryParam.getValue()));\n          b.append(\"&\");\n        }\n      }\n    }\n\n    String querystring = b.substring(0, b.length() - 1);\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param method The request method, one of \"GET\", \"POST\", \"PUT\", and \"DELETE\"","old_comment_raw":"@param method The request method, one of \"GET\", \"POST\", \"PUT\", and \"DELETE\"","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public PMetadata getCache(PGraphics renderer) { return g.getCache(renderer); }","old_code_raw":"  public Object getCache(Object parent) {\n    return g.getCache(parent);\n  }\n","new_comment_raw":"@param renderer The PGraphics renderer associated to the image","old_comment_raw":"@param parent The PGraphics object (or any object, really) associated","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"static EventSource buildEventSource(Context context, CommonTree t) throws FlumeSpecException { ASTNODE type = ASTNODE.valueOf(t.getText()); \/\/ convert to enum switch (type) { case SOURCE: { Context ctx = new Context(context); Pair<String, List<String>> idArgs = handleArgs(t, ctx); String sourceType = idArgs.getLeft(); List<String> args = idArgs.getRight(); EventSource src = srcFactory.getSource(ctx, sourceType, args .toArray(new String[0])); if (src == null) { throw new FlumeIdException(\"Invalid source: \" + FlumeSpecGen.genEventSource(t)); } return src; } default: throw new FlumeSpecException(\"bad parse tree! Expected source but got \" + t.toStringTree()); } }","old_code_raw":"  static EventSource buildEventSource(CommonTree t) throws FlumeSpecException {\n    ASTNODE type = ASTNODE.valueOf(t.getText()); \/\/ convert to enum\n    switch (type) {\n    case SOURCE: {\n      \/\/ TODO thread context through sources\n      \/\/ Context ctx = new Context(context);\n      Context ctx = new Context();\n      Pair<String, List<String>> idArgs = handleArgs(t, ctx);\n      String sourceType = idArgs.getLeft();\n      List<String> args = idArgs.getRight();\n\n      EventSource src = srcFactory.getSource(sourceType, args\n          .toArray(new String[0]));\n      if (src == null) {\n        throw new FlumeIdException(\"Invalid source: \"\n            + FlumeSpecGen.genEventSource(t));\n      }\n      return src;\n    }\n    default:\n      throw new FlumeSpecException(\"bad parse tree! Expected source but got \"\n          + t.toStringTree());\n    }\n  }\n","new_comment_raw":"@param t","old_comment_raw":"@param t","label":0,"pre_label":1,"AST_level":12,"line_counts":24,"new_code_token_num":147},{"new_code_raw":"public ModelApiResponse uploadFileWithRequiredFile(Long petId, File requiredFile, String additionalMetadata) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new ApiException(400, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\" .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); if (additionalMetadata != null) localVarFormParams.put(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) localVarFormParams.put(\"requiredFile\", requiredFile); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"multipart\/form-data\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"petstore_auth\" }; GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {}; return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public ModelApiResponse uploadFileWithRequiredFile(Long petId, File file, String additionalMetadata) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ verify the required parameter 'file' is set\n    if (file == null) {\n      throw new ApiException(400, \"Missing the required parameter 'file' when calling uploadFileWithRequiredFile\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\/{petId}\/uploadImageWithRequiredFile\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    if (additionalMetadata != null)\n      localVarFormParams.put(\"additionalMetadata\", additionalMetadata);\nif (file != null)\n      localVarFormParams.put(\"file\", file);\n\n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"multipart\/form-data\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"petstore_auth\" };\n\n    GenericType<ModelApiResponse> localVarReturnType = new GenericType<ModelApiResponse>() {};\n    return apiClient.invokeAPI(localVarPath, \"POST\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param additionalMetadata Additional data to pass to server (optional, default to null)","old_comment_raw":"@param additionalMetadata Additional data to pass to server (optional, default to null)","label":0,"pre_label":1,"AST_level":9,"line_counts":46,"new_code_token_num":324},{"new_code_raw":"public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout) { return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout); }","old_code_raw":"\tpublic boolean waitForText(String text, int matches, long timeout)\n    {\n       return robotiumUtils.waitForText(text, matches, timeout);\n    }\n","new_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown.  0 means any number of matches","old_comment_raw":"@param matches the number of matches of text that must be shown. 0 means any number of matches","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"private ImmutableBitSet factorBitmap(ImmutableBitSet fieldRefBitmap) { ImmutableBitSet.Builder factorRefBitmap = ImmutableBitSet.builder(); for (int field : fieldRefBitmap) { int factor = findRef(field); factorRefBitmap.set(factor); } return factorRefBitmap.build(); }","old_code_raw":"  private BitSet factorBitmap(BitSet fieldRefBitmap) {\n    BitSet factorRefBitmap = new BitSet(nJoinFactors);\n    for (int field : BitSets.toIter(fieldRefBitmap)) {\n      int factor = findRef(field);\n      factorRefBitmap.set(factor);\n    }\n    return factorRefBitmap;\n  }\n","new_comment_raw":"@param fieldRefBitmap bitmap representing fields referenced","old_comment_raw":"@param fieldRefBitmap bitmap representing fields referenced","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":45},{"new_code_raw":"public long addWrapped(long instant, int years) { if (years == 0) { return instant; } \/\/ Return newly calculated millis value int thisYear = iChronology.year().get(instant); int wrappedYear = Utils.getWrappedValue (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear()); return set(instant, wrappedYear); }","old_code_raw":"    public long addWrapped(long millis, int years) {\n        if (years == 0) {\n            return millis;\n        }\n        \/\/ Return newly calculated millis value\n        int thisYear = iChronology.year().get(millis);\n        int wrappedYear = getWrappedValue\n            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());\n        return set(millis, wrappedYear);\n    }\n","new_comment_raw":"@param instant the time instant in millis to update.","old_comment_raw":"@param millis the time instant in millis to update.","label":1,"pre_label":0,"AST_level":7,"line_counts":11,"new_code_token_num":68},{"new_code_raw":"public static RelNode swap(Join join, boolean swapOuterJoins) { final JoinRelType joinType = join.getJoinType(); if (!swapOuterJoins && joinType != JoinRelType.INNER) { return null; } final RexBuilder rexBuilder = join.getCluster().getRexBuilder(); final RelDataType leftRowType = join.getLeft().getRowType(); final RelDataType rightRowType = join.getRight().getRowType(); final VariableReplacer variableReplacer = new VariableReplacer(rexBuilder, leftRowType, rightRowType); final RexNode oldCondition = join.getCondition(); RexNode condition = variableReplacer.go(oldCondition); \/\/ NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the \/\/ swap. This way, we will generate one semijoin for the original \/\/ join, and one for the swapped join, and no more. This \/\/ doesn't prevent us from seeing any new combinations assuming \/\/ that the planner tries the desired order (semijoins after swaps). Join newJoin = join.copy(join.getTraitSet(), condition, join.getRight(), join.getLeft(), joinType.swap(), join.isSemiJoinDone()); final List<RexNode> exps = RelOptUtil.createSwappedJoinExprs(newJoin, join, true); return RelOptUtil.createProject( newJoin, exps, join.getRowType().getFieldNames(), true); }","old_code_raw":"  public static RelNode swap(JoinRelBase join, boolean swapOuterJoins) {\n    final JoinRelType joinType = join.getJoinType();\n    if (!swapOuterJoins && joinType != JoinRelType.INNER) {\n      return null;\n    }\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RelDataType leftRowType = join.getLeft().getRowType();\n    final RelDataType rightRowType = join.getRight().getRowType();\n    final VariableReplacer variableReplacer =\n        new VariableReplacer(rexBuilder, leftRowType, rightRowType);\n    final RexNode oldCondition = join.getCondition();\n    RexNode condition = variableReplacer.go(oldCondition);\n\n    \/\/ NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the\n    \/\/ swap.  This way, we will generate one semijoin for the original\n    \/\/ join, and one for the swapped join, and no more.  This\n    \/\/ doesn't prevent us from seeing any new combinations assuming\n    \/\/ that the planner tries the desired order (semijoins after swaps).\n    JoinRelBase newJoin =\n        join.copy(join.getTraitSet(), condition, join.getRight(),\n            join.getLeft(), joinType.swap(), join.isSemiJoinDone());\n    final List<RexNode> exps =\n        RelOptUtil.createSwappedJoinExprs(newJoin, join, true);\n    return RelOptUtil.createProject(\n        newJoin,\n        exps,\n        join.getRowType().getFieldNames(),\n        true);\n  }\n","new_comment_raw":"@param join join to be swapped","old_comment_raw":"@param join join to be swapped","label":0,"pre_label":1,"AST_level":6,"line_counts":30,"new_code_token_num":237},{"new_code_raw":"public Activity getCurrentActivity(boolean shouldSleepFirst) { if(shouldSleepFirst){ RobotiumUtils.sleep(); inst.waitForIdleSync(); } Boolean found = false; if (activityMonitor != null) { if (activityMonitor.getLastActivity() != null) activity = activityMonitor.getLastActivity(); } for(Activity storedActivity : activityList){ if (storedActivity.getClass().getName().equals( activity.getClass().getName())) found = true; } if (found) return activity; else { activityList.add(activity); return activity; } }","old_code_raw":"\tpublic Activity getCurrentActivity(int pause) {\n\t\tif(pause > 0){\n\t\t\tRobotiumUtils.sleep(pause);\n\t\t\tinst.waitForIdleSync();\n\t\t}\n\t\tBoolean found = false;\n\t\tif (activityMonitor != null) {\n\t\t\tif (activityMonitor.getLastActivity() != null)\n\t\t\t\tactivity = activityMonitor.getLastActivity();\n\t\t}\n\t\tfor(Activity storedActivity : activityList){\n\t\t\tif (storedActivity.getClass().getName().equals(\n\t\t\t\t\tactivity.getClass().getName()))\n\t\t\t\tfound = true;\n\t\t}\n\t\tif (found)\n\t\t\treturn activity;\n\t\telse {\n\t\t\tactivityList.add(activity);\n\t\t\treturn activity;\n\t\t}\n\t}\n","new_comment_raw":"@param shouldSleepFirst whether to sleep a default pause first","old_comment_raw":"@param pause the time to pause in milliseconds","label":1,"pre_label":0,"AST_level":9,"line_counts":23,"new_code_token_num":103},{"new_code_raw":"public Iterator keyIterator() { return new KeyIterator( map.keySet().iterator() ); }","old_code_raw":"\tpublic static Iterator keyIterator(Map map) {\n\t\treturn ( (IdentityMap) map ).keyIterator();\n\t}\n","new_comment_raw":"@param map The map of entries","old_comment_raw":"@param map The map of entries","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"static protected float getFloatWithUnit(PNode element, String attribute) { String val = element.getString(attribute); return (val == null) ? 0 : parseUnitSize(val); }","old_code_raw":"  static protected float getFloatWithUnit(XMLElement element, String attribute) {\n    String val = element.getString(attribute);\n    return (val == null) ? 0 : parseUnitSize(val);\n  }\n","new_comment_raw":"@param element what to parse","old_comment_raw":"@param element what to parse","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":34},{"new_code_raw":"public static Configuration from(Map<String, String> properties) { Map<String, String> props = new HashMap<>(); if (properties != null) props.putAll(properties); return new Configuration() { @Override public String getString(String key) { return properties.get(key); } @Override public Set<String> keys() { return properties.keySet(); } @Override public String toString() { return props.toString(); } }; }","old_code_raw":"    public static Configuration from(Properties properties) {\n        Properties props = new Properties();\n        if (properties != null) props.putAll(properties);\n        return new Configuration() {\n            @Override\n            public String getString(String key) {\n                return properties.getProperty(key);\n            }\n\n            @Override\n            public Set<String> keys() {\n                return properties.stringPropertyNames();\n            }\n            \n            @Override\n            public String toString() {\n                return props.toString();\n            }\n        };\n    }\n","new_comment_raw":"@param properties the properties; may be null or empty","old_comment_raw":"@param properties the properties; may be null or empty","label":0,"pre_label":1,"AST_level":8,"line_counts":21,"new_code_token_num":92},{"new_code_raw":"public int get(long instant) { return super.get(instant) + iOffset; }","old_code_raw":"    public int get(long millis) {\n        return iField.get(millis) + iOffset;\n    }\n","new_comment_raw":"@param instant the time instant in millis to query.","old_comment_raw":"@param millis the time instant in millis to query.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"private static CorefChain fromProto(CoreNLPProtos.CorefChain proto, Annotation partialDocument) { \/\/ Get chain ID int cid = proto.getChainID(); \/\/ Get mentions Map<IntPair, Set<CorefChain.CorefMention>> mentions = new HashMap<IntPair, Set<CorefChain.CorefMention>>(); CorefChain.CorefMention representative = null; for (int i = 0; i < proto.getMentionCount(); ++i) { CoreNLPProtos.CorefChain.CorefMention mentionProto = proto.getMention(i); \/\/ Create mention StringBuilder mentionSpan = new StringBuilder(); List<CoreLabel> sentenceTokens = partialDocument.get(SentencesAnnotation.class).get(mentionProto.getSentenceIndex()).get(TokensAnnotation.class); for (int k = mentionProto.getStartIndex(); k < mentionProto.getEndIndex(); ++k) { mentionSpan.append(\" \").append(sentenceTokens.get(k).word()); } \/\/ Set the coref cluster id for the token CorefChain.CorefMention mention = new CorefChain.CorefMention( Dictionaries.MentionType.valueOf(mentionProto.getMentionType()), Dictionaries.Number.valueOf(mentionProto.getNumber()), Dictionaries.Gender.valueOf(mentionProto.getGender()), Dictionaries.Animacy.valueOf(mentionProto.getAnimacy()), mentionProto.getStartIndex() + 1, mentionProto.getEndIndex() + 1, mentionProto.getHeadIndex() + 1, cid, mentionProto.getMentionID(), mentionProto.getSentenceIndex() + 1, new IntTuple(new int[]{ mentionProto.getSentenceIndex() + 1, mentionProto.getPosition() }), mentionSpan.substring(1)); \/\/ Register mention IntPair key = new IntPair(mentionProto.getSentenceIndex() - 1, mentionProto.getHeadIndex() - 1); if (!mentions.containsKey(key)) { mentions.put(key, new HashSet<CorefChain.CorefMention>()); } mentions.get(key).add(mention); \/\/ Check for representative if (proto.hasRepresentative() && i == proto.getRepresentative()) { representative = mention; } } \/\/ Return return new CorefChain(cid, mentions, representative); }","old_code_raw":"  private static CorefChain fromProto(CoreMapProtos.CorefChain proto, Annotation partialDocument) {\n    \/\/ Get chain ID\n    int cid = proto.getChainID();\n    \/\/ Get mentions\n    Map<IntPair, Set<CorefChain.CorefMention>> mentions = new HashMap<IntPair, Set<CorefChain.CorefMention>>();\n    CorefChain.CorefMention representative = null;\n    for (int i = 0; i < proto.getMentionCount(); ++i) {\n      CoreMapProtos.CorefChain.CorefMention mentionProto = proto.getMention(i);\n      \/\/ Create mention\n      StringBuilder mentionSpan = new StringBuilder();\n      List<CoreLabel> sentenceTokens = partialDocument.get(SentencesAnnotation.class).get(mentionProto.getSentenceIndex()).get(TokensAnnotation.class);\n      for (int k = mentionProto.getStartIndex(); k < mentionProto.getEndIndex(); ++k) {\n        mentionSpan.append(\" \").append(sentenceTokens.get(k).word());\n      }\n      sentenceTokens.get(mentionProto.getHeadIndex()).set(CorefClusterIdAnnotation.class, cid);\n      CorefChain.CorefMention mention = new CorefChain.CorefMention(\n          Dictionaries.MentionType.valueOf(mentionProto.getMentionType()),\n          Dictionaries.Number.valueOf(mentionProto.getNumber()),\n          Dictionaries.Gender.valueOf(mentionProto.getGender()),\n          Dictionaries.Animacy.valueOf(mentionProto.getAnimacy()),\n          mentionProto.getStartIndex() + 1,\n          mentionProto.getEndIndex() + 1,\n          mentionProto.getHeadIndex() + 1,\n          cid,\n          mentionProto.getMentionID(),\n          mentionProto.getSentenceIndex() + 1,\n          new IntTuple(new int[]{ mentionProto.getSentenceIndex() + 1, mentionProto.getPosition() }),\n          mentionSpan.substring(1));\n      \/\/ Register mention\n      IntPair key = new IntPair(mentionProto.getSentenceIndex() - 1, mentionProto.getHeadIndex() - 1);\n      if (!mentions.containsKey(key)) { mentions.put(key, new HashSet<CorefChain.CorefMention>()); }\n      mentions.get(key).add(mention);\n      \/\/ Check for representative\n      if (proto.hasRepresentative() && i == proto.getRepresentative()) {\n        representative = mention;\n      }\n    }\n    \/\/ Return\n    return new CorefChain(cid, mentions, representative);\n  }\n","new_comment_raw":"@param partialDocument A partial document, which must contain  SentencesAnnotation and  TokensAnnotation in order to fill in the mention span strings.","old_comment_raw":"@param partialDocument A partial document, which must contain SentencesAnnotation and TokensAnnotation in order to fill in the mention span strings.","label":0,"pre_label":1,"AST_level":13,"line_counts":41,"new_code_token_num":369},{"new_code_raw":"public WebDriver frame(final String nameOrIdOrIndex) { try { \/\/ 1.) try to find frame in current window ... currentWindow = findFrame(currentWindow, nameOrIdOrIndex); } catch (NoSuchFrameException ignored) { \/\/ 2.) try to find frame in top window ... final WebWindow topWindow = currentWindow.getTopWindow(); currentWindow = findFrame(topWindow, nameOrIdOrIndex); } return HtmlUnitDriver.this; }","old_code_raw":"    public WebDriver frame(final String name) {\n      WebWindow window = currentWindow.getTopWindow();\n\n      \/\/ Walk over all parts of the frame identifier, each time looking for a frame\n      \/\/ with a name or ID matching this part of the identifier (separated by '.').\n      String[] frames = name.split(\"\\\\.\");\n      for (int i = 0; i < frames.length; ++i) {\n        final String currentFrameId = frames[i];\n        final HtmlPage page = (HtmlPage) window.getEnclosedPage();\n        \n        if (isNumericFrameIdValid(currentFrameId, page)) {\n          window = getWindowByNumericFrameId(currentFrameId, page);\n        } else {\n          \/\/ Numeric frame ID is not valid - could be either because the identifier\n          \/\/ was numeric and not valid OR the number that was given is actually a frame\n          \/\/ name, not an index.\n          \n          boolean nextFrameFound = false;\n          for (final FrameWindow frameWindow : page.getFrames()) {\n            final String frameName = frameWindow.getName();\n            final String frameId = frameWindow.getFrameElement().getId();\n            final String remainingFrameId = joinFrom(frames, i, '.');\n            if (frameName.equals(remainingFrameId) || frameId.equals(remainingFrameId)) {\n              currentWindow = frameWindow;\n              return HtmlUnitDriver.this;\n            }\n            if (frameName.equals(currentFrameId) || frameId.equals(currentFrameId)) {\n              window = frameWindow;\n              nextFrameFound = true;\n            }\n          } \/\/ End for.\n          \n          if (!nextFrameFound) {\n            throw new NoSuchFrameException(\"Cannot find frame: \" + name);\n          }\n        } \/\/ End else\n\n      } \/\/ End for\n      \n      currentWindow = window;\n      return HtmlUnitDriver.this;\n    }\n","new_comment_raw":"@param nameOrIdOrIndex Frame name, id, (zero-based) index, or a concatenation of frame identifiers that uniquely point to a specific frame.","old_comment_raw":"@param name Frame index, name or a concatenation of frame identifiers that uniquely point to a specific frame.","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":70},{"new_code_raw":"public String toDefaultValue(Schema p) { if (ModelUtils.isBooleanSchema(p)) { if (p.getDefault() != null) { return p.getDefault().toString(); } } else if (ModelUtils.isDateSchema(p)) { \/\/ TODO } else if (ModelUtils.isDateTimeSchema(p)) { \/\/ TODO } else if (ModelUtils.isNumberSchema(p)) { if (p.getDefault() != null) { return p.getDefault().toString(); } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getDefault() != null) { return p.getDefault().toString(); } } else if (ModelUtils.isStringSchema(p)) { if (p.getDefault() != null) { return \"'\" + p.getDefault() + \"'\"; } } return null; }","old_code_raw":"    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"'\" + dp.getDefault() + \"'\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n        } else if (p instanceof DateProperty) {\n            \/\/ TODO\n        } else if (p instanceof DateTimeProperty) {\n            \/\/ TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"@param p property schema","old_comment_raw":"@param p Swagger property object","label":1,"pre_label":0,"AST_level":15,"line_counts":26,"new_code_token_num":168},{"new_code_raw":"public JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, JoinType joinType, String[] columns) { JoinSequence joinSequence = createJoinSequence(); joinSequence.setUseThetaStyle( implicit ); \/\/ Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from) joinSequence.addJoin( associationType, tableAlias, joinType, columns ); return joinSequence; }","old_code_raw":"\tpublic JoinSequence createJoinSequence(boolean implicit, AssociationType associationType, String tableAlias, int joinType, String[] columns) {\n\t\tJoinSequence joinSequence = createJoinSequence();\n\t\tjoinSequence.setUseThetaStyle( implicit );\t\/\/ Implicit joins use theta style (WHERE pk = fk), explicit joins use JOIN (after from)\n\t\tjoinSequence.addJoin( associationType, tableAlias, joinType, columns );\n\t\treturn joinSequence;\n\t}\n","new_comment_raw":"@param columns The columns making up the condition of the join.","old_comment_raw":"@param columns The columns making up the condition of the join.","label":0,"pre_label":1,"AST_level":5,"line_counts":7,"new_code_token_num":71},{"new_code_raw":"public boolean remove(final BaseDownloadTask willRemoveDownload, final int removeByStatus) { boolean succeed; synchronized (list) { succeed = list.remove(willRemoveDownload); } if (succeed) { \/\/ \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af switch (removeByStatus) { case FileDownloadStatus.warn: willRemoveDownload.getDriver().notifyWarn(); break; case FileDownloadStatus.error: willRemoveDownload.getDriver().notifyError(); break; case FileDownloadStatus.paused: willRemoveDownload.getDriver().notifyPaused(); break; case FileDownloadStatus.completed: Throwable ex = null; try{ willRemoveDownload.getDriver().notifyBlockComplete(); }catch (Throwable e){ ex = e; } if (ex != null) { willRemoveDownload.setStatus(FileDownloadStatus.error); willRemoveDownload.setEx(ex); willRemoveDownload.getDriver().notifyError(); } else { willRemoveDownload.getDriver().notifyCompleted(); } break; } } else { FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload); } return succeed; }","old_code_raw":"    public boolean remove(final BaseFileDownloadInternal willRemoveDownload, final int removeByStatus) {\n        boolean succeed;\n        synchronized (list) {\n            succeed = list.remove(willRemoveDownload);\n        }\n\n        if (succeed) {\n            \/\/ \u00e6\u008a\u009b\u00e6\u00b6\u0088\u00e6\u0081\u00af\n            switch (removeByStatus) {\n                case FileDownloadStatus.warn:\n                    willRemoveDownload.getDriver().notifyWarn();\n                    break;\n                case FileDownloadStatus.error:\n                    willRemoveDownload.getDriver().notifyError();\n                    break;\n                case FileDownloadStatus.paused:\n                    willRemoveDownload.getDriver().notifyPaused();\n                    break;\n                case FileDownloadStatus.completed:\n                    Throwable ex = null;\n                    try{\n                        willRemoveDownload.getDriver().notifyBlockComplete();\n                    }catch (Throwable e){\n                        ex = e;\n                    }\n\n                    if (ex != null) {\n                        willRemoveDownload.setStatus(FileDownloadStatus.error);\n                        willRemoveDownload.setEx(ex);\n                        willRemoveDownload.getDriver().notifyError();\n                    } else {\n                        willRemoveDownload.getDriver().notifyCompleted();\n                    }\n                    break;\n            }\n\n        } else {\n            FileDownloadLog.e(this, \"remove error, not exist: %s\", willRemoveDownload);\n        }\n\n        return succeed;\n    }\n","new_comment_raw":"@param removeByStatus must remove by status  com.liulishuo.filedownloader.model.FileDownloadStatus#warn  com.liulishuo.filedownloader.model.FileDownloadStatus#paused  com.liulishuo.filedownloader.model.FileDownloadStatus#completed  com.liulishuo.filedownloader.model.FileDownloadStatus#error","old_comment_raw":"@param removeByStatus must remove by status com.liulishuo.filedownloader.model.FileDownloadStatus#warn com.liulishuo.filedownloader.model.FileDownloadStatus#paused com.liulishuo.filedownloader.model.FileDownloadStatus#completed com.liulishuo.filedownloader.model.FileDownloadStatus#error","label":0,"pre_label":1,"AST_level":11,"line_counts":43,"new_code_token_num":185},{"new_code_raw":"public Struct read(Object record, Struct source, Instant timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.READ.code()); struct.put(FieldName.AFTER, record); if (source != null) { struct.put(FieldName.SOURCE, source); } if (timestamp != null) { struct.put(FieldName.TIMESTAMP, timestamp.toEpochMilli()); } return struct; }","old_code_raw":"    public Struct read(Object record, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.READ.code());\n        struct.put(FieldName.AFTER, record);\n        if (source != null) {\n            struct.put(FieldName.SOURCE, source);\n        }\n        if (timestamp != null) {\n            struct.put(FieldName.TIMESTAMP, timestamp);\n        }\n        return struct;\n    }\n","new_comment_raw":"@param source the information about the source that was read; may be null","old_comment_raw":"@param source the information about the source that was read; may be null","label":0,"pre_label":1,"AST_level":7,"line_counts":13,"new_code_token_num":85},{"new_code_raw":"public PersistentCollection locateLoadingCollection(CollectionPersister persister, CollectionKey key) { final LoadingCollectionEntry lce = locateLoadingCollectionEntry( key ) ; if ( lce != null ) { if ( LOG.isTraceEnabled() ) { LOG.tracef( \"Returning loading collection: %s\", MessageHelper.collectionInfoString( persister, key.getKey(), getSession().getFactory() ) ); } return lce.getCollection(); } return null; }","old_code_raw":"\tpublic PersistentCollection locateLoadingCollection(CollectionPersister persister, Serializable ownerKey) {\n\t\tfinal LoadingCollectionEntry lce = locateLoadingCollectionEntry( new CollectionKey( persister, ownerKey ) );\n\t\tif ( lce != null ) {\n\t\t\tif ( LOG.isTraceEnabled() ) {\n\t\t\t\tLOG.tracef(\n\t\t\t\t\t\t\"Returning loading collection: %s\",\n\t\t\t\t\t\tMessageHelper.collectionInfoString( persister, ownerKey, getSession().getFactory() )\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn lce.getCollection();\n\t\t}\n\t\treturn null;\n\t}\n","new_comment_raw":"@param key The collection key","old_comment_raw":"@param ownerKey The owner key","label":1,"pre_label":0,"AST_level":11,"line_counts":14,"new_code_token_num":77},{"new_code_raw":"public static Transport createLocalTransport(NetworkBridgeConfiguration configuration, URI uri) throws Exception { \/\/ one end of the localbroker<->bridge transport needs to be async to allow concurrent forwards and acks return createLocalTransport(uri, !configuration.isDispatchAsync()); }","old_code_raw":"    public static Transport createLocalTransport(URI uri) throws Exception {\n        return createLocalTransport(uri, false);\n    }\n","new_comment_raw":"@param localTransport","old_comment_raw":"@param localTransport","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":47},{"new_code_raw":"public String getTypeDeclaration(Schema schema) { String oasType = getSchemaType(schema); if (typeMapping.containsKey(oasType)) { return typeMapping.get(oasType); } return oasType; }","old_code_raw":"    public String getTypeDeclaration(Property p) {\n        String swaggerType = getSwaggerType(p);\n        if (typeMapping.containsKey(swaggerType)) {\n            return typeMapping.get(swaggerType);\n        }\n        return swaggerType;\n    }\n","new_comment_raw":"@param schema property schema","old_comment_raw":"@param p Swagger Property object","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":36},{"new_code_raw":"public static Criterion between(String propertyName, Object low, Object high) { return new BetweenExpression( propertyName, low, high ); }","old_code_raw":"\tpublic static Criterion between(String propertyName, Object lo, Object hi) {\n\t\treturn new BetweenExpression( propertyName, lo, hi );\n\t}\n","new_comment_raw":"@param low The low value","old_comment_raw":"@param lo The low value","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public Call updatePetWithFormAsync(Long petId, String name, String status, final ApiCallback<Void> callback) throws ApiException { ProgressResponseBody.ProgressListener progressListener = null; ProgressRequestBody.ProgressRequestListener progressRequestListener = null; if (callback != null) { progressListener = new ProgressResponseBody.ProgressListener() { @Override public void update(long bytesRead, long contentLength, boolean done) { callback.onDownloadProgress(bytesRead, contentLength, done); } }; progressRequestListener = new ProgressRequestBody.ProgressRequestListener() { @Override public void onRequestProgress(long bytesWritten, long contentLength, boolean done) { callback.onUploadProgress(bytesWritten, contentLength, done); } }; } Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener); apiClient.executeAsync(call, callback); return call; }","old_code_raw":"  public Call updatePetWithFormAsync(String petId, String name, String status, final ApiCallback<Void> callback) throws ApiException {\n\n    ProgressResponseBody.ProgressListener progressListener = null;\n    ProgressRequestBody.ProgressRequestListener progressRequestListener = null;\n\n    if (callback != null) {\n      progressListener = new ProgressResponseBody.ProgressListener() {\n        @Override\n        public void update(long bytesRead, long contentLength, boolean done) {\n          callback.onDownloadProgress(bytesRead, contentLength, done);\n        }\n      };\n\n      progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {\n        @Override\n        public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {\n          callback.onUploadProgress(bytesWritten, contentLength, done);\n        }\n      };\n    }\n\n    Call call = updatePetWithFormCall(petId, name, status, progressListener, progressRequestListener);\n    apiClient.executeAsync(call, callback);\n    return call;\n  }\n","new_comment_raw":"@param petId ID of pet that needs to be updated (required)","old_comment_raw":"@param petId ID of pet that needs to be updated (required)","label":0,"pre_label":1,"AST_level":11,"line_counts":26,"new_code_token_num":138},{"new_code_raw":"protected List<Sentence> sentences(Properties props, Annotator tokenizer) { if (sentences == null) { Annotator ssplit = props == EMPTY_PROPS ? defaultSSplit : AnnotatorFactories.sentenceSplit(props, backend).create(); \/\/ Annotate Annotation ann = new Annotation(this.impl.getText()); tokenizer.annotate(ann); ssplit.annotate(ann); \/\/ Grok results \/\/ (docid) if (ann.containsKey(CoreAnnotations.DocIDAnnotation.class)) { impl.setDocID(ann.get(CoreAnnotations.DocIDAnnotation.class)); } \/\/ (sentences) List<CoreMap> sentences = ann.get(CoreAnnotations.SentencesAnnotation.class); this.sentences = new ArrayList<>(sentences.size()); for (CoreMap sentence : sentences) { \/\/Sentence sent = new Sentence(this, sentence); Sentence sent = new Sentence(this, this.serializer.toProtoBuilder(sentence), sentence.get(CoreAnnotations.TextAnnotation.class), defaultProps); this.sentences.add(sent); this.impl.addSentence(sent.serialize()); } } return sentences; }","old_code_raw":"  public List<Sentence> sentences(Properties props) {\n    if (sentences == null) {\n      \/\/ Get annotators\n      Annotator tokenizer = props == EMPTY_PROPS ? defaultTokenize : AnnotatorFactories.tokenize(props, backend).create();\n      Annotator ssplit = props == EMPTY_PROPS ? defaultSSplit : AnnotatorFactories.sentenceSplit(props, backend).create();\n      \/\/ Annotate\n      Annotation ann = new Annotation(this.impl.getText());\n      tokenizer.annotate(ann);\n      ssplit.annotate(ann);\n      \/\/ Grok results\n      \/\/ (docid)\n      if (ann.containsKey(CoreAnnotations.DocIDAnnotation.class)) {\n        impl.setDocID(ann.get(CoreAnnotations.DocIDAnnotation.class));\n      }\n      \/\/ (sentences)\n      List<CoreMap> sentences = ann.get(CoreAnnotations.SentencesAnnotation.class);\n      this.sentences = new ArrayList<>(sentences.size());\n      for (CoreMap sentence : sentences) {\n        \/\/Sentence sent = new Sentence(this, sentence);\n        Sentence sent = new Sentence(this, this.serializer.toProtoBuilder(sentence), sentence.get(CoreAnnotations.TextAnnotation.class));\n        this.sentences.add(sent);\n        this.impl.addSentence(sent.serialize());\n      }\n    }\n\n    \/\/ Re-computing the sentences invalidates the cached Annotation\n    synchronized (annotationPool) {\n      annotationPool.remove(this);\n    }\n    synchronized (annotationPoolKeys) {\n      annotationPoolKeys.remove(this);\n    }\n\n    return sentences;\n  }\n","new_comment_raw":"@param props The properties to use in the  edu.stanford.nlp.pipeline.WordsToSentencesAnnotator.","old_comment_raw":"@param props The properties to use in the edu.stanford.nlp.pipeline.WordsToSentencesAnnotator.","label":0,"pre_label":1,"AST_level":12,"line_counts":26,"new_code_token_num":191},{"new_code_raw":"public ApiClient setHttpClient(OkHttpClient newHttpClient) { if(!httpClient.equals(newHttpClient)) { OkHttpClient.Builder builder = newHttpClient.newBuilder(); Iterator<Interceptor> networkInterceptorIterator = httpClient.networkInterceptors().iterator(); while(networkInterceptorIterator.hasNext()) { builder.addNetworkInterceptor(networkInterceptorIterator.next()); } Iterator<Interceptor> interceptorIterator = httpClient.interceptors().iterator(); while(interceptorIterator.hasNext()) { builder.addInterceptor(interceptorIterator.next()); } this.httpClient = builder.build(); } return this; }","old_code_raw":"    public ApiClient setHttpClient(OkHttpClient httpClient) {\n        this.httpClient = httpClient.newBuilder().addInterceptor(getProgressInterceptor()).build();\n        return this;\n    }\n","new_comment_raw":"@param newHttpClient An instance of OkHttpClient","old_comment_raw":"@param httpClient An instance of OkHttpClient","label":1,"pre_label":0,"AST_level":9,"line_counts":16,"new_code_token_num":96},{"new_code_raw":"public BroadcastAction filter(Object originalMessage, Object o) { if (o instanceof String){ String message = (String)o; \/\/ Avoid re-broadcasting if (!receivedMessages.remove(message)) { try { jchannel.send(new Message(null, null, message)); } catch (ChannelException e) { logger.warn(\"failed to send message\", e); } } return new BroadcastAction(message); } else { return new BroadcastAction(o); } }","old_code_raw":"    public BroadcastAction filter(Object originalMessage, Object message) {\n        \/\/ Avoid re-broadcasting\n        if (!receivedMessages.remove(message)) {\n            try {\n                jchannel.send(new Message(null, null, new JGroupsBroadcaster.BroadcastMessage(bc.getID(), message)));\n            } catch (ChannelException e) {\n                logger.warn(\"failed to send message\", e);\n            }\n        }\n        return new BroadcastAction(message);\n    }\n","new_comment_raw":"@param o the message to broadcast.","old_comment_raw":"@param message the message to broadcast.","label":1,"pre_label":0,"AST_level":11,"line_counts":17,"new_code_token_num":98},{"new_code_raw":"public Tree apply(List<? extends HasWord> lst) { return parse(lst); }","old_code_raw":"  public Tree apply(List<? extends HasWord> words) {\n    return parse(words);\n  }\n","new_comment_raw":"@param in The input Sentence\/List\/String","old_comment_raw":"@param words The input sentence (a List of words)","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"protected void coordinateSharedCacheCleanup(SharedSessionContractImplementor session) { final BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() ); if ( session.isEventSource() ) { ( (EventSource) session ).getActionQueue().addAction( action ); } else { action.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session ); } }","old_code_raw":"\tprotected void coordinateSharedCacheCleanup(SessionImplementor session) {\n\t\tfinal BulkOperationCleanupAction action = new BulkOperationCleanupAction( session, getCustomQuery().getQuerySpaces() );\n\n\t\tif ( session.isEventSource() ) {\n\t\t\t( (EventSource) session ).getActionQueue().addAction( action );\n\t\t}\n\t\telse {\n\t\t\taction.getAfterTransactionCompletionProcess().doAfterTransactionCompletion( true, session );\n\t\t}\n\t}\n","new_comment_raw":"@param namedParams The named query parameters specified by the application.","old_comment_raw":"@param namedParams The named query parameters specified by the application.","label":0,"pre_label":1,"AST_level":8,"line_counts":11,"new_code_token_num":62},{"new_code_raw":"public Struct update(Object before, Struct after, Struct source, Long timestamp) { Struct struct = new Struct(schema); struct.put(FieldName.OPERATION, Operation.UPDATE.code()); if (before != null) struct.put(FieldName.BEFORE, before); struct.put(FieldName.AFTER, after); if (source != null) struct.put(FieldName.SOURCE, source); if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp); return struct; }","old_code_raw":"    public Struct update(Struct before, Struct after, Struct source, Long timestamp) {\n        Struct struct = new Struct(schema);\n        struct.put(FieldName.OPERATION, Operation.UPDATE.code());\n        if (before != null) struct.put(FieldName.BEFORE, before);\n        struct.put(FieldName.AFTER, after);\n        if (source != null) struct.put(FieldName.SOURCE, source);\n        if (timestamp != null) struct.put(FieldName.TIMESTAMP, timestamp);\n        return struct;\n    }\n","new_comment_raw":"@param timestamp the timestamp for this message; may be null","old_comment_raw":"@param timestamp the timestamp for this message; may be null","label":0,"pre_label":1,"AST_level":6,"line_counts":10,"new_code_token_num":96},{"new_code_raw":"public String invokeAPI(String path, String method, Set<Pair> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); Client client = getClient(); StringBuilder b = new StringBuilder(); b.append(\"?\"); if (queryParams != null){ for (Pair queryParam : queryParams){ if (!queryParam.getName().isEmpty()) { b.append(escapeString(queryParam.getName())); b.append(\"=\"); b.append(escapeString(queryParam.getValue())); b.append(\"&\"); } } } String querystring = b.substring(0, b.length() - 1); Builder builder; if (accept == null) builder = client.resource(basePath + path + querystring).getRequestBuilder(); else builder = client.resource(basePath + path + querystring).accept(accept); for(String key : headerParams.keySet()) { builder = builder.header(key, headerParams.get(key)); } for(String key : defaultHeaderMap.keySet()) { if(!headerParams.containsKey(key)) { builder = builder.header(key, defaultHeaderMap.get(key)); } } ClientResponse response = null; if(\"GET\".equals(method)) { response = (ClientResponse) builder.get(ClientResponse.class); } else if (\"POST\".equals(method)) { if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).post(ClientResponse.class, encodedFormParams); } else if (body == null) { response = builder.post(ClientResponse.class, null); } else if(body instanceof FormDataMultiPart) { response = builder.type(contentType).post(ClientResponse.class, body); } else response = builder.type(contentType).post(ClientResponse.class, serialize(body)); } else if (\"PUT\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).put(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.put(ClientResponse.class, serialize(body)); } else { response = builder.type(contentType).put(ClientResponse.class, serialize(body)); } } else if (\"DELETE\".equals(method)) { if (\"application\/x-www-form-urlencoded\".equals(contentType)) { String encodedFormParams = this .getXWWWFormUrlencodedParams(formParams); response = builder.type(contentType).delete(ClientResponse.class, encodedFormParams); } else if(body == null) { response = builder.delete(ClientResponse.class); } else { response = builder.type(contentType).delete(ClientResponse.class, serialize(body)); } } else { throw new ApiException(500, \"unknown method type \" + method); } if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) { return null; } else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) { if(response.hasEntity()) { return (String) response.getEntity(String.class); } else { return \"\"; } } else { String message = \"error\"; String respBody = null; if(response.hasEntity()) { try{ respBody = String.valueOf(response.getEntity(String.class)); message = respBody; } catch (RuntimeException e) { \/\/ e.printStackTrace(); } } throw new ApiException( response.getClientResponseStatus().getStatusCode(), message, response.getHeaders(), respBody); } }","old_code_raw":"  public String invokeAPI(String path, String method, Map<String, String> queryParams, Object body, Map<String, String> headerParams, Map<String, String> formParams, String accept, String contentType, String[] authNames) throws ApiException {\n    updateParamsForAuth(authNames, queryParams, headerParams);\n\n    Client client = getClient();\n\n    StringBuilder b = new StringBuilder();\n    for(String key : queryParams.keySet()) {\n      String value = queryParams.get(key);\n      if (value != null){\n        if(b.toString().length() == 0)\n          b.append(\"?\");\n        else\n          b.append(\"&\");\n        b.append(escapeString(key)).append(\"=\").append(escapeString(value));\n      }\n    }\n    String querystring = b.toString();\n\n    Builder builder;\n    if (accept == null)\n      builder = client.resource(basePath + path + querystring).getRequestBuilder();\n    else\n      builder = client.resource(basePath + path + querystring).accept(accept);\n\n    for(String key : headerParams.keySet()) {\n      builder = builder.header(key, headerParams.get(key));\n    }\n    for(String key : defaultHeaderMap.keySet()) {\n      if(!headerParams.containsKey(key)) {\n        builder = builder.header(key, defaultHeaderMap.get(key));\n      }\n    }\n\n    ClientResponse response = null;\n\n    if(\"GET\".equals(method)) {\n      response = (ClientResponse) builder.get(ClientResponse.class);\n    }\n    else if (\"POST\".equals(method)) {\n      if (contentType.startsWith(\"application\/x-www-form-urlencoded\")) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).post(ClientResponse.class,\n            encodedFormParams);\n      } else if (body == null) {\n        response = builder.post(ClientResponse.class, null);\n      } else if(body instanceof FormDataMultiPart) {\n        response = builder.type(contentType).post(ClientResponse.class, body);\n      }\n      else\n        response = builder.type(contentType).post(ClientResponse.class, serialize(body));\n    }\n    else if (\"PUT\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n          String encodedFormParams = this\n              .getXWWWFormUrlencodedParams(formParams);\n          response = builder.type(contentType).put(ClientResponse.class,\n              encodedFormParams);\n      } else if(body == null) {\n        response = builder.put(ClientResponse.class, serialize(body));\n      } else {\n          response = builder.type(contentType).put(ClientResponse.class, serialize(body));\n      }\n    }\n    else if (\"DELETE\".equals(method)) {\n      if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n        String encodedFormParams = this\n            .getXWWWFormUrlencodedParams(formParams);\n        response = builder.type(contentType).delete(ClientResponse.class,\n            encodedFormParams);\n      } else if(body == null) {\n        response = builder.delete(ClientResponse.class);\n      } else {\n        response = builder.type(contentType).delete(ClientResponse.class, serialize(body));\n      }\n    }\n    else {\n      throw new ApiException(500, \"unknown method type \" + method);\n    }\n\n    if(response.getClientResponseStatus() == ClientResponse.Status.NO_CONTENT) {\n      return null;\n    }\n    else if(response.getClientResponseStatus().getFamily() == Family.SUCCESSFUL) {\n      if(response.hasEntity()) {\n        return (String) response.getEntity(String.class);\n      }\n      else {\n        return \"\";\n      }\n    }\n    else {\n      String message = \"error\";\n      String respBody = null;\n      if(response.hasEntity()) {\n        try{\n          respBody = String.valueOf(response.getEntity(String.class));\n          message = respBody;\n        }\n        catch (RuntimeException e) {\n          \/\/ e.printStackTrace();\n        }\n      }\n      throw new ApiException(\n                response.getClientResponseStatus().getStatusCode(),\n                message,\n                response.getHeaders(),\n                respBody);\n    }\n  }\n","new_comment_raw":"@param authNames The authentications to apply","old_comment_raw":"@param authNames The authentications to apply","label":0,"pre_label":1,"AST_level":16,"line_counts":113,"new_code_token_num":736},{"new_code_raw":"public static DiscoveryTransport createTransport(CompositeTransport compositeTransport, CompositeData compositeData, Map<String, String> parameters) throws IOException { DiscoveryTransport transport = new DiscoveryTransport(compositeTransport); IntrospectionSupport.setProperties(transport, parameters); transport.setParameters(parameters); URI discoveryAgentURI = compositeData.getComponents()[0]; DiscoveryAgent discoveryAgent = DiscoveryAgentFactory.createDiscoveryAgent(discoveryAgentURI); transport.setDiscoveryAgent(discoveryAgent); return transport; }","old_code_raw":"    public static DiscoveryTransport createTransport(CompositeTransport compositeTransport, CompositeData compositeData) throws IOException {                \n        DiscoveryTransport transport = new DiscoveryTransport(compositeTransport);\n        \n        Map<String, String> parameters = new HashMap<String, String>(compositeData.getParameters());\n        IntrospectionSupport.setProperties(transport, parameters);\n        transport.setParameters(parameters);\n        \n        URI discoveryAgentURI = compositeData.getComponents()[0];\n        DiscoveryAgent discoveryAgent = DiscoveryAgentFactory.createDiscoveryAgent(discoveryAgentURI);\n        transport.setDiscoveryAgent(discoveryAgent);\n        return transport;\n    }\n","new_comment_raw":"@param compositeData used to apply parameters to this transport","old_comment_raw":"@param compositeData used to apply parameters to this transport","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":70},{"new_code_raw":"public boolean validate(Configuration config, ValidationOutput problems) { Validator typeValidator = validatorForType(type); int errors = 0; if (typeValidator != null) errors += typeValidator.validate(config, this, problems); if (validator != null) errors += validator.validate(config, this, problems); return errors == 0; }","old_code_raw":"    public boolean validate(Configuration config, Consumer<String> problems) {\n        return validator == null ? true : validator.validate(config, this, problems) == 0;\n    }\n","new_comment_raw":"@param config the field values keyed by their name; may not be null","old_comment_raw":"@param config the field values keyed by their name; may not be null","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":63},{"new_code_raw":"public String toDefaultValue(Schema p) { if (p instanceof StringSchema) { StringSchema dp = (StringSchema) p; if (dp.getDefault() != null) { return \"@\\\"\" + dp.getDefault() + \"\\\"\"; } } else if (p instanceof BooleanSchema) { BooleanSchema dp = (BooleanSchema) p; if (dp.getDefault() != null) { if (dp.getDefault().toString().equalsIgnoreCase(\"false\")) return \"@(NO)\"; else return \"@(YES)\"; } } else if (p instanceof DateSchema) { \/\/ TODO } else if (p instanceof DateTimeSchema) { \/\/ TODO } else if (p instanceof NumberSchema) { NumberSchema dp = (NumberSchema) p; if (dp.getDefault() != null) { return \"@\" + dp.getDefault().toString(); } } else if (p instanceof IntegerSchema) { IntegerSchema dp = (IntegerSchema) p; if (dp.getDefault() != null) { return \"@\" + dp.getDefault().toString(); } } return null; }","old_code_raw":"    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateProperty) {\n            \/\/ TODO\n        } else if (p instanceof DateTimeProperty) {\n            \/\/ TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"@param p Swagger schema object","old_comment_raw":"@param p Swagger property object","label":1,"pre_label":0,"AST_level":15,"line_counts":33,"new_code_token_num":219},{"new_code_raw":"protected SourceInfo update(Long lsn, Long useconds, Long txId) { this.lsn = lsn; this.useconds = useconds; this.txId = txId; return this; }","old_code_raw":"    protected SourceInfo update(Long lsn, Long useconds, Integer txId) {\n        this.lsn = lsn;\n        this.useconds = useconds;\n        this.txId = txId;\n        return this;\n    }\n","new_comment_raw":"@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available","old_comment_raw":"@param txId the ID of the transaction that generated the transaction; may be null if this information nis not available","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":30},{"new_code_raw":"private RexNode convertUsing(SqlValidatorNamespace leftNamespace, SqlValidatorNamespace rightNamespace, List<String> nameList) { final List<RexNode> list = Lists.newArrayList(); for (String name : nameList) { List<RexNode> operands = new ArrayList<>(); int offset = 0; for (SqlValidatorNamespace n : ImmutableList.of(leftNamespace, rightNamespace)) { final RelDataType rowType = n.getRowType(); final RelDataTypeField field = catalogReader.field(rowType, name); operands.add(rexBuilder.makeInputRef(field.getType(), offset + field.getIndex())); offset += rowType.getFieldList().size(); } list.add(rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, operands)); } return RexUtil.composeConjunction(rexBuilder, list, false); }","old_code_raw":"    private RexNode convertUsing(RelNode leftRel, RelNode rightRel, List<String> nameList) {\n        final List<RexNode> list = Lists.newArrayList();\n        for (String name : nameList) {\n            final RelDataType leftRowType = leftRel.getRowType();\n            RelDataTypeField leftField = catalogReader.field(leftRowType, name);\n            RexNode left = rexBuilder.makeInputRef(leftField.getType(), leftField.getIndex());\n            final RelDataType rightRowType = rightRel.getRowType();\n            RelDataTypeField rightField = catalogReader.field(rightRowType, name);\n            RexNode right = rexBuilder.makeInputRef(rightField.getType(), leftRowType.getFieldList().size() + rightField.getIndex());\n            RexNode equalsCall = rexBuilder.makeCall(SqlStdOperatorTable.EQUALS, left, right);\n            list.add(equalsCall);\n        }\n        return RexUtil.composeConjunction(rexBuilder, list, false);\n    }\n","new_comment_raw":"@param rightNamespace Namespace of right input to join","old_comment_raw":"@param rightRel Right input to the join","label":1,"pre_label":0,"AST_level":11,"line_counts":16,"new_code_token_num":134},{"new_code_raw":"public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ApiCallback callback) throws ApiException { updateParamsForAuth(authNames, queryParams, headerParams); final String url = buildUrl(path, queryParams, collectionQueryParams); final Request.Builder reqBuilder = new Request.Builder().url(url); processHeaderParams(headerParams, reqBuilder); String contentType = (String) headerParams.get(\"Content-Type\"); \/\/ ensuring a default content type if (contentType == null) { contentType = \"application\/json\"; } RequestBody reqBody; if (!HttpMethod.permitsRequestBody(method)) { reqBody = null; } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) { reqBody = buildRequestBodyFormEncoding(formParams); } else if (\"multipart\/form-data\".equals(contentType)) { reqBody = buildRequestBodyMultipart(formParams); } else if (body == null) { if (\"DELETE\".equals(method)) { \/\/ allow calling DELETE without sending a request body reqBody = null; } else { \/\/ use an empty request body (for POST, PUT and PATCH) reqBody = RequestBody.create(MediaType.parse(contentType), \"\"); } } else { reqBody = serialize(body, contentType); } \/\/ Associate callback with request (if not null) so interceptor can \/\/ access it when creating ProgressResponseBody reqBuilder.tag(callback); Request request = null; if (callback != null && reqBody != null) { ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, callback); request = reqBuilder.method(method, progressRequestBody).build(); } else { request = reqBuilder.method(method, reqBody).build(); } return request; }","old_code_raw":"    public Request buildRequest(String path, String method, List<Pair> queryParams, List<Pair> collectionQueryParams, Object body, Map<String, String> headerParams, Map<String, Object> formParams, String[] authNames, ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {\n        updateParamsForAuth(authNames, queryParams, headerParams);\n\n        final String url = buildUrl(path, queryParams, collectionQueryParams);\n        final Request.Builder reqBuilder = new Request.Builder().url(url);\n        processHeaderParams(headerParams, reqBuilder);\n\n        String contentType = (String) headerParams.get(\"Content-Type\");\n        \/\/ ensuring a default content type\n        if (contentType == null) {\n            contentType = \"application\/json\";\n        }\n\n        RequestBody reqBody;\n        if (!HttpMethod.permitsRequestBody(method)) {\n            reqBody = null;\n        } else if (\"application\/x-www-form-urlencoded\".equals(contentType)) {\n            reqBody = buildRequestBodyFormEncoding(formParams);\n        } else if (\"multipart\/form-data\".equals(contentType)) {\n            reqBody = buildRequestBodyMultipart(formParams);\n        } else if (body == null) {\n            if (\"DELETE\".equals(method)) {\n                \/\/ allow calling DELETE without sending a request body\n                reqBody = null;\n            } else {\n                \/\/ use an empty request body (for POST, PUT and PATCH)\n                reqBody = RequestBody.create(MediaType.parse(contentType), \"\");\n            }\n        } else {\n            reqBody = serialize(body, contentType);\n        }\n\n        Request request = null;\n\n        if(progressRequestListener != null && reqBody != null) {\n            ProgressRequestBody progressRequestBody = new ProgressRequestBody(reqBody, progressRequestListener);\n            request = reqBuilder.method(method, progressRequestBody).build();\n        } else {\n            request = reqBuilder.method(method, reqBody).build();\n        }\n\n        return request;\n    }\n","new_comment_raw":"@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"","old_comment_raw":"@param method The request method, one of \"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\", \"PATCH\" and \"DELETE\"","label":0,"pre_label":1,"AST_level":14,"line_counts":48,"new_code_token_num":350},{"new_code_raw":"public boolean searchText(String regex, int expectedMinimumNumberOfMatches, boolean scroll) { return searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, scroll); }","old_code_raw":"\tpublic boolean searchText(String regex, int matches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, regex, matches, scroll);\n\t}\n","new_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found","old_comment_raw":"@param matches the number of matches expected to be found. 0 matches means that one or more matches are expected to be found","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"static EventSource buildEventSource(Context context, CommonTree t) throws FlumeSpecException { ASTNODE type = ASTNODE.valueOf(t.getText()); \/\/ convert to enum switch (type) { case SOURCE: { Context ctx = new Context(context); Pair<String, List<String>> idArgs = handleArgs(t, ctx); String sourceType = idArgs.getLeft(); List<String> args = idArgs.getRight(); EventSource src = srcFactory.getSource(ctx, sourceType, args .toArray(new String[0])); if (src == null) { throw new FlumeIdException(\"Invalid source: \" + FlumeSpecGen.genEventSource(t)); } return src; } default: throw new FlumeSpecException(\"bad parse tree! Expected source but got \" + t.toStringTree()); } }","old_code_raw":"  static EventSource buildEventSource(CommonTree t) throws FlumeSpecException {\n    ASTNODE type = ASTNODE.valueOf(t.getText()); \/\/ convert to enum\n    switch (type) {\n    case SOURCE: {\n      \/\/ TODO thread context through sources\n      \/\/ Context ctx = new Context(context);\n      Context ctx = new Context();\n      Pair<String, List<String>> idArgs = handleArgs(t, ctx);\n      String sourceType = idArgs.getLeft();\n      List<String> args = idArgs.getRight();\n\n      EventSource src = srcFactory.getSource(sourceType, args\n          .toArray(new String[0]));\n      if (src == null) {\n        throw new FlumeIdException(\"Invalid source: \"\n            + FlumeSpecGen.genEventSource(t));\n      }\n      return src;\n    }\n    default:\n      throw new FlumeSpecException(\"bad parse tree! Expected source but got \"\n          + t.toStringTree());\n    }\n  }\n","new_comment_raw":"@param ctx","old_comment_raw":"@param ctx","label":0,"pre_label":1,"AST_level":12,"line_counts":24,"new_code_token_num":147},{"new_code_raw":"public UnitOfWorkAspect newAspect(Map<String, SessionFactory> sessionFactories) { return new UnitOfWorkAspect(sessionFactories); }","old_code_raw":"    public UnitOfWorkAspect newAspect(ImmutableMap<String, SessionFactory> sessionFactories) {\n        return new UnitOfWorkAspect(sessionFactories);\n    }\n","new_comment_raw":"@param sessionFactories","old_comment_raw":"@param sessionFactories","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"private static RestClient connect(List<HttpHost> hosts, String pathPrefix) { Objects.requireNonNull(hosts, \"hosts or coordinates\"); Preconditions.checkArgument(!hosts.isEmpty(), \"no ES hosts specified\"); RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[hosts.size()])); if (pathPrefix != null && !pathPrefix.isEmpty()) { builder.setPathPrefix(pathPrefix); } return builder.build(); }","old_code_raw":"  private static RestClient connect(List<HttpHost> hosts) {\n\n    Objects.requireNonNull(hosts, \"hosts or coordinates\");\n    Preconditions.checkArgument(!hosts.isEmpty(), \"no ES hosts specified\");\n\n    return RestClient.builder(hosts.toArray(new HttpHost[hosts.size()])).build();\n  }\n","new_comment_raw":"@param hosts list of ES HTTP Hosts to connect to","old_comment_raw":"@param hosts list of ES HTTP Hosts to connect to","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":89},{"new_code_raw":"public static SDOGeometry join(SDOGeometry[] sdoElements) { final SDOGeometry sdoCollection = new SDOGeometry(); if ( sdoElements == null || sdoElements.length == 0 ) { sdoCollection.setGType( new SDOGType( 2, 0, TypeGeometry.COLLECTION ) ); } else { final SDOGeometry firstElement = sdoElements[0]; final int dim = firstElement.getGType().getDimension(); final int lrsDim = firstElement.getGType().getLRSDimension(); sdoCollection.setGType( new SDOGType( dim, lrsDim, TypeGeometry.COLLECTION ) ); int ordinatesOffset = 1; for ( int i = 0; i < sdoElements.length; i++ ) { final ElemInfo element = sdoElements[i].getInfo(); final Double[] ordinates = sdoElements[i].getOrdinates().getOrdinateArray(); if ( element != null && element.getSize() > 0 ) { final int shift = ordinatesOffset - element.getOrdinatesOffset( 0 ); shiftOrdinateOffset( element, shift ); sdoCollection.addElement( element ); sdoCollection.addOrdinates( ordinates ); ordinatesOffset += ordinates.length; } } } return sdoCollection; }","old_code_raw":"\tpublic static SDOGeometry join(SDOGeometry[] SDOElements) {\n\t\tSDOGeometry SDOCollection = new SDOGeometry();\n\t\tif ( SDOElements == null || SDOElements.length == 0 ) {\n\t\t\tSDOCollection.setGType(\n\t\t\t\t\tnew SDOGType(\n\t\t\t\t\t\t\t2, 0,\n\t\t\t\t\t\t\tTypeGeometry.COLLECTION\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\telse {\n\t\t\tSDOGeometry firstElement = SDOElements[0];\n\t\t\tint dim = firstElement.getGType().getDimension();\n\t\t\tint lrsDim = firstElement.getGType().getLRSDimension();\n\t\t\tSDOCollection.setGType(\n\t\t\t\t\tnew SDOGType(\n\t\t\t\t\t\t\tdim, lrsDim,\n\t\t\t\t\t\t\tTypeGeometry.COLLECTION\n\t\t\t\t\t)\n\t\t\t);\n\t\t\tint ordinatesOffset = 1;\n\t\t\tfor ( int i = 0; i < SDOElements.length; i++ ) {\n\t\t\t\tElemInfo element = SDOElements[i].getInfo();\n\t\t\t\tDouble[] ordinates = SDOElements[i].getOrdinates()\n\t\t\t\t\t\t.getOrdinateArray();\n\t\t\t\tif ( element != null && element.getSize() > 0 ) {\n\t\t\t\t\tint shift = ordinatesOffset\n\t\t\t\t\t\t\t- element.getOrdinatesOffset( 0 );\n\t\t\t\t\tshiftOrdinateOffset( element, shift );\n\t\t\t\t\tSDOCollection.addElement( element );\n\t\t\t\t\tSDOCollection.addOrdinates( ordinates );\n\t\t\t\t\tordinatesOffset += ordinates.length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn SDOCollection;\n\t}\n","new_comment_raw":"@param sdoElements The SDO_geometries to join into an SDO Geometry Collection","old_comment_raw":"@param SDOElements","label":1,"pre_label":0,"AST_level":13,"line_counts":26,"new_code_token_num":195},{"new_code_raw":"public int compareTo(ReadableInstant other) { if (this == other) { return 0; } long otherMillis = other.getMillis(); long thisMillis = getMillis(); \/\/ cannot do (thisMillis - otherMillis) as can overflow if (thisMillis == otherMillis) { return 0; } if (thisMillis < otherMillis) { return -1; } else { return 1; } }","old_code_raw":"    public int compareTo(Object instant) {\n        if (this == instant) {\n            return 0;\n        }\n        \n        ReadableInstant otherInstant = (ReadableInstant) instant;\n        \n        long otherMillis = otherInstant.getMillis();\n        long thisMillis = getMillis();\n        \n        \/\/ cannot do (thisMillis - otherMillis) as can overflow\n        if (thisMillis == otherMillis) {\n            return 0;\n        }\n        if (thisMillis < otherMillis) {\n            return -1;\n        } else {\n            return 1;\n        }\n    }\n","new_comment_raw":"@param other a readable instant to check against","old_comment_raw":"@param instant a readable instant to check against","label":1,"pre_label":0,"AST_level":6,"line_counts":19,"new_code_token_num":71},{"new_code_raw":"public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) { return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout, scroll); }","old_code_raw":"\t\n\tpublic boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) {\n\t\treturn robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout, scroll);\n    }\n","new_comment_raw":"@param minimumNumberOfMatches the minimum number of text matches that are expected to be shown.  0 means any number of matches","old_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches of text that must be shown. 0 means any number of matches","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":31},{"new_code_raw":"public Client testSpecialTags(Client client) throws ApiException { Object localVarPostBody = client; \/\/ verify the required parameter 'client' is set if (client == null) { throw new ApiException(400, \"Missing the required parameter 'client' when calling testSpecialTags\"); } \/\/ create path and map variables String localVarPath = \"\/another-fake\/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client testSpecialTags(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testSpecialTags\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/another-fake\/dummy\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@param client client model (required)","old_comment_raw":"@param body client model (required)","label":1,"pre_label":0,"AST_level":8,"line_counts":35,"new_code_token_num":219},{"new_code_raw":"public boolean highlightNode(ASTGenerator astGenerator){ if (!(Node instanceof SimpleName)) { return false; } SimpleName nodeName = (SimpleName) Node; try { \/\/TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline() int javaLineNumber = getLineNumber(nodeName); int pdeOffs[] = astGenerator.errorCheckerService .calculateTabIndexAndLineNumber(javaLineNumber); PlainDocument javaSource = new PlainDocument(); javaSource.insertString(0, astGenerator.errorCheckerService.sourceCode, null); Element lineElement = javaSource.getDefaultRootElement() .getElement(javaLineNumber-1); if(lineElement == null) { Messages.log(lineNumber + \" line element null while highlighting \" + nodeName); return false; } String javaLine = javaSource.getText(lineElement.getStartOffset(), lineElement.getEndOffset() - lineElement.getStartOffset()); astGenerator.editor.getSketch().setCurrentCode(pdeOffs[0]); String pdeLine = astGenerator.editor.getLineText(pdeOffs[1]); String lookingFor = nodeName.toString(); Messages.log(lookingFor + \", \" + nodeName.getStartPosition()); Messages.log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\" + lineElement.getEndOffset()); Messages.log(pdeOffs[1] + \" PL \" + pdeLine); if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) { Messages.loge(\"Logical error in highLightNode(). Please file a bug report.\"); return false; } OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine); int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition() - lineElement.getStartOffset(), nodeName.getLength()); if (highlightStart == -1) { Messages.loge(\"Logical error in highLightNode() during offset matching. \" + \"Please file a bug report.\"); return false; } int lso = astGenerator.editor.getTextArea().getLineStartOffset(pdeOffs[1]); highlightStart += lso; astGenerator.editor.setSelection(highlightStart, highlightStart + nodeName.getLength()); \/* \/\/ First find the name in the java line, and marks its index Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\"); Matcher matcher = toFind.matcher(javaLine); int count = 0, index = 0; int lsto = lineElement.getStartOffset(); while(matcher.find()){ count++; \/\/log(matcher.start() + lsto); if(lsto + matcher.start() == nodeName.getStartPosition()) break; } log(\"count=\" + count); index = 0; \/\/ find the same name in the pde line by its index and get its offsets matcher = toFind.matcher(pdeLine); while(matcher.find()){ count--; if(count == 0){ log(\"Found on pde line lso: \" + matcher.start()); index = matcher.end(); break; } } log(\"pde lso \" + (index - lookingFor.length())); int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]); astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso + index); *\/ return true; } catch (BadLocationException e) { Messages.loge(\"BLE in highLightNode() for \" + nodeName); e.printStackTrace(); } return false; }","old_code_raw":"  public boolean highlightNode(JavaEditor editor){\n    if (!(node instanceof SimpleName)) {\n      return false;\n    }\n    SimpleName nodeName = (SimpleName) node;\n    try {\n      \/\/TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline()\n      int javaLineNumber = getLineNumber(nodeName);\n      int pdeOffs[] = editor.getErrorChecker().calculateTabIndexAndLineNumber(javaLineNumber);\n      PlainDocument javaSource = new PlainDocument();\n      javaSource.insertString(0, editor.getErrorChecker().lastCodeCheckResult.sourceCode, null);\n      Element lineElement = javaSource.getDefaultRootElement()\n          .getElement(javaLineNumber-1);\n      if(lineElement == null) {\n        Messages.log(lineNumber + \" line element null while highlighting \" + nodeName);\n        return false;\n      }\n\n      String javaLine = javaSource.getText(lineElement.getStartOffset(),\n                                           lineElement.getEndOffset()\n                                               - lineElement.getStartOffset());\n      editor.getSketch().setCurrentCode(pdeOffs[0]);\n      String pdeLine = editor.getLineText(pdeOffs[1]);\n      String lookingFor = nodeName.toString();\n      Messages.log(lookingFor + \", \" + nodeName.getStartPosition());\n      Messages.log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\"\n          + lineElement.getEndOffset());\n      Messages.log(pdeOffs[1] + \" PL \" + pdeLine);\n      if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) {\n        Messages.loge(\"Logical error in highLightNode(). Please file a bug report.\");\n        return false;\n      }\n\n      OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine);\n      int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition()\n                                  - lineElement.getStartOffset(),\n                              nodeName.getLength());\n      if (highlightStart == -1) {\n        Messages.loge(\"Logical error in highLightNode() during offset matching. \" +\n        \t\t\"Please file a bug report.\");\n        return false;\n      }\n      int lso = editor.getTextArea().getLineStartOffset(pdeOffs[1]);\n      highlightStart += lso;\n      editor.setSelection(highlightStart, highlightStart\n          + nodeName.getLength());\n      \/*\n      \/\/ First find the name in the java line, and marks its index\n      Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\");\n      Matcher matcher = toFind.matcher(javaLine);\n      int count = 0, index = 0;\n      int lsto = lineElement.getStartOffset();\n      while(matcher.find()){\n        count++;\n        \/\/log(matcher.start() + lsto);\n        if(lsto + matcher.start() == nodeName.getStartPosition())\n          break;\n      }\n      log(\"count=\" + count);\n      index = 0;\n      \/\/ find the same name in the pde line by its index and get its offsets\n      matcher = toFind.matcher(pdeLine);\n      while(matcher.find()){\n        count--;\n        if(count == 0){\n          log(\"Found on pde line lso: \" + matcher.start());\n          index = matcher.end();\n          break;\n        }\n      }\n      log(\"pde lso \" + (index - lookingFor.length()));\n\n      int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]);\n      astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso\n          + index);\n      *\/\n      return true;\n\n    } catch (BadLocationException e) {\n      Messages.loge(\"BLE in highLightNode() for \" + nodeName);\n      e.printStackTrace();\n    }\n    return false;\n  }\n","new_comment_raw":"@param astGenerator","old_comment_raw":"@param editor","label":1,"pre_label":0,"AST_level":12,"line_counts":86,"new_code_token_num":638},{"new_code_raw":"public <V extends Visitor<? super X>> V visit(V visitor) { for (X x : this) { visitor.visit(x); } return visitor; }","old_code_raw":"    public <P extends Visitor<? super X>> P visit(P predicate)\n    {\n        for (X x : this) {\n            predicate.visit(x);\n        }\n\n        return predicate;\n    }\n","new_comment_raw":"@param visitor  Visitor to apply","old_comment_raw":"@param predicate Visitor to apply","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":33},{"new_code_raw":"public Single<Order> rxPlaceOrder(Order order) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.placeOrder(order, fut); })); }","old_code_raw":"    public Single<Order> rxPlaceOrder(Order body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.placeOrder(body, fut);\n        }));\n    }\n","new_comment_raw":"@param order order placed for purchasing the pet (required)","old_comment_raw":"@param body order placed for purchasing the pet (required)","label":1,"pre_label":0,"AST_level":10,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"private static RestClient connect(List<HttpHost> hosts) { Objects.requireNonNull(hosts, \"hosts or coordinates\"); Preconditions.checkArgument(!hosts.isEmpty(), \"no ES hosts specified\"); return RestClient.builder(hosts.toArray(new HttpHost[hosts.size()])).build(); }","old_code_raw":"  private static RestClient connect(Map<String, Integer> coordinates) {\n    Objects.requireNonNull(coordinates, \"coordinates\");\n    Preconditions.checkArgument(!coordinates.isEmpty(), \"no ES coordinates specified\");\n    final Set<HttpHost> set = new LinkedHashSet<>();\n    for (Map.Entry<String, Integer> entry: coordinates.entrySet()) {\n      set.add(new HttpHost(entry.getKey(), entry.getValue()));\n    }\n\n    return RestClient.builder(set.toArray(new HttpHost[0])).build();\n  }\n","new_comment_raw":"@param hosts list of ES HTTP Hosts to connect to","old_comment_raw":"@param coordinates list of hostname\/port to connect to","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":61},{"new_code_raw":"public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) { setCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName ); return this; }","old_code_raw":"\tpublic Configuration setCacheConcurrencyStrategy(String clazz, String concurrencyStrategy)\n\t\t\tthrows MappingException {\n\t\tsetCacheConcurrencyStrategy( clazz, concurrencyStrategy, clazz );\n\t\treturn this;\n\t}\n","new_comment_raw":"@param concurrencyStrategy The cache strategy to use","old_comment_raw":"@param concurrencyStrategy","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"protected BroadcastAction filter(AtmosphereResource<?,?> r, Object message, Object originalMessage) { BroadcastAction transformed = new BroadcastAction(originalMessage); for (PerRequestBroadcastFilter mf : perRequestFilters) { synchronized (mf) { transformed = mf.filter(r, message, transformed.message()); if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) { return transformed; } } } return transformed; }","old_code_raw":"    protected BroadcastAction filter(HttpServletRequest request, HttpServletResponse response, Object object) {\n        BroadcastAction transformed = new BroadcastAction(object);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            synchronized (mf) {\n                transformed = mf.filter(request, response, transformed.message());\n                if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT) {\n                    return transformed;\n                }\n            }\n        }\n        return transformed;\n    }\n","new_comment_raw":"@param r  AtmosphereResource","old_comment_raw":"@param request javax.servlet.http.HttpServletRequest","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":77},{"new_code_raw":"public long getMessageCount(String destinationName) { if (null == brokerService) { throw new IllegalStateException(\"BrokerService has not yet been created - was before() called?\"); } \/\/ TODO: Figure out how to do this for Topics Destination destination = getDestination(destinationName); if (destination == null) { throw new RuntimeException(\"Failed to find destination: \" + destinationName); } \/\/ return destination.getMessageStore().getMessageCount(); return destination.getDestinationStatistics().getMessages().getCount(); }","old_code_raw":"    public int getMessageCount(String fullDestinationName) throws Exception {\n        final int QUEUE_TYPE = 1;\n        final int TOPIC_TYPE = 2;\n\n        if (null == brokerService) {\n            throw new IllegalStateException(\"BrokerService has not yet been created - was before() called?\");\n        }\n\n        int destinationType = QUEUE_TYPE;\n        String destinationName = fullDestinationName;\n\n        if (fullDestinationName.startsWith(\"queue:\")) {\n            destinationName = fullDestinationName.substring(fullDestinationName.indexOf(':') + 1);\n        } else if (fullDestinationName.startsWith(\"topic:\")) {\n            destinationType = TOPIC_TYPE;\n            destinationName = fullDestinationName.substring(fullDestinationName.indexOf(':') + 1);\n        }\n\n        int messageCount = -1;\n        boolean foundDestination = false;\n        for (Destination destination : brokerService.getBroker().getDestinationMap().values()) {\n            String tmpName = destination.getName();\n            if (tmpName.equalsIgnoreCase(destinationName)) {\n                switch (destinationType) {\n                    case QUEUE_TYPE:\n                        if (destination instanceof Queue) {\n                            messageCount = destination.getMessageStore().getMessageCount();\n                            foundDestination = true;\n                        }\n                        break;\n                    case TOPIC_TYPE:\n                        if (destination instanceof Topic) {\n                            messageCount = destination.getMessageStore().getMessageCount();\n                            foundDestination = true;\n                        }\n                        break;\n                    default:\n                        \/\/ Should never see this\n                        log.error(\"Type didn't match: {}\", destination.getClass().getName());\n                }\n            }\n            if (foundDestination) {\n                break;\n            }\n        }\n\n        if (!foundDestination) {\n            log.warn(\"Didn't find destination {} in broker {}\", fullDestinationName, getBrokerName());\n        }\n\n        return messageCount;\n    }\n","new_comment_raw":"@param destinationName the full name of the JMS Destination","old_comment_raw":"@param fullDestinationName the full name of the JMS Destination","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":101},{"new_code_raw":"public BroadcastAction filter(Object originalMessage, Object message) { \/\/ Avoid re-broadcasting if (!receivedMessages.remove(message)) { try { jchannel.send(new Message(null, null, (Serializable)message)); } catch (ChannelException e) { logger.warn(\"failed to send message\", e); } } return new BroadcastAction(message); }","old_code_raw":"    public BroadcastAction filter(Object originalMessage, Object o) {\n        if (o instanceof String){\n            String message = (String)o;\n            \/\/ Avoid re-broadcasting\n            if (!receivedMessages.remove(message)) {\n                try {\n                    jchannel.send(new Message(null, null, message));\n                } catch (ChannelException e) {\n                    logger.warn(\"failed to send message\", e);\n                }\n            }\n            return new BroadcastAction(message);\n        } else {\n            return new BroadcastAction(o);\n        }\n    }\n","new_comment_raw":"@param message the message to broadcast.","old_comment_raw":"@param o the message to broadcast.","label":1,"pre_label":0,"AST_level":10,"line_counts":12,"new_code_token_num":76},{"new_code_raw":"public boolean searchText(String text, int minimumNumberOfMatches) { boolean found = searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, true); return found; }","old_code_raw":"\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, true);\n\t\treturn found;\n\t}\n","new_comment_raw":"@param minimumNumberOfMatches the minimum number of matches expected to be found.  0 matches means that one or more matches are expected to be found","old_comment_raw":"@param expectedMinimumNumberOfMatches the minimum number of matches expected to be found. 0 matches means that one or more matches are expected to be found","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public List<WebElement> apply(WebDriver driver) { WebElement current = findElement(parent, driver); List<WebElement> allChildren = current.findElements(childLocator); \/\/ The original code only checked the first element. Fair enough. if (!allChildren.isEmpty() && allChildren.get(0).isDisplayed()) { return allChildren; } return null; }","old_code_raw":"      public List<WebElement> apply(WebDriver webDriver) {\n        Boolean displayed = false;\n        Boolean exists = false;\n        try {\n          exists = findElement(locator, webDriver).findElements(sub_locator).size() > 0;\n          displayed =\n            findElement(locator, webDriver).findElement(sub_locator).isDisplayed();\n        } catch (Exception e) {\n          int i = 0;\n        }\n        return (exists && displayed) ?\n               findElement(locator, webDriver).findElements(sub_locator) :\n               null;\n      }\n","new_comment_raw":"@param childLocator used to find the ultimate child element.","old_comment_raw":"@param sub_locator used to find child element. For example td By.xpath(\".\/tr\/td\")","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":66},{"new_code_raw":"public Single<Void> rxUpdateUser(String username, User user) { return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> { delegate.updateUser(username, user, fut); })); }","old_code_raw":"    public Single<Void> rxUpdateUser(String username, User body) {\n        return Single.create(new io.vertx.rx.java.SingleOnSubscribeAdapter<>(fut -> {\n            delegate.updateUser(username, body, fut);\n        }));\n    }\n","new_comment_raw":"@param user Updated user object (required)","old_comment_raw":"@param body Updated user object (required)","label":1,"pre_label":0,"AST_level":10,"line_counts":6,"new_code_token_num":41},{"new_code_raw":"public boolean searchText(String regex, int matches, boolean scroll) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForText(regex, matches, scroll) && now < endTime) { now = System.currentTimeMillis(); } if(now < endTime) return true; else return false; }","old_code_raw":"\tpublic boolean searchText(String search, int matches, boolean scroll) {\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForText(search, matches, scroll) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        if(now < endTime)\n        \treturn true;\n        else\n        \treturn false;\n\t}\n","new_comment_raw":"@param regex the text to search for. The parameter will be interpreted as a regular expression.","old_comment_raw":"@param search the string to be searched. The parameter will be interpreted as a regular expression.","label":1,"pre_label":0,"AST_level":7,"line_counts":13,"new_code_token_num":65},{"new_code_raw":"public long findBestMatchCuboid(long cuboid) { return findBestMatchCuboid1(cuboid); }","old_code_raw":"    public long findBestMatchCuboid(long child) {\n        long parent = getOnTreeParent(child);\n        while (parent > 0) {\n            if (cubeDesc.getAllCuboids().contains(parent)) {\n                break;\n            }\n            parent = getOnTreeParent(parent);\n        }\n\n        if (parent <= 0) {\n            throw new IllegalStateException(\"Can't find valid parent for Cuboid \" + child);\n        }\n        return parent;\n    }\n","new_comment_raw":"@param cuboid an on-tree cuboid","old_comment_raw":"@param child an on-tree cuboid","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public Client testClientModel(Client client, Map<String, Object> params) throws IOException { HttpResponse response = testClientModelForHttpResponse(client, params); TypeReference typeRef = new TypeReference<Client>() {}; return apiClient.getObjectMapper().readValue(response.getContent(), typeRef); }","old_code_raw":"    public Client testClientModel(Client body, Map<String, Object> params) throws IOException {\n        HttpResponse response = testClientModelForHttpResponse(body, params);\n        TypeReference typeRef = new TypeReference<Client>() {};\n        return apiClient.getObjectMapper().readValue(response.getContent(), typeRef);\n    }\n","new_comment_raw":"@param client client model","old_comment_raw":"@param body client model","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":51},{"new_code_raw":"public boolean waitForActivity(Class<? extends Activity> activityClass){ return waiter.waitForActivity(activityClass, TIMEOUT); }","old_code_raw":"    public boolean waitForActivity(Class<? extends Activity> clazz){\n        return waiter.waitForActivity(clazz, TIMEOUT);\n    }\n","new_comment_raw":"@param activityClass the class of the  Activity to wait for","old_comment_raw":"@param clazz the class of the Activity to wait for e.g. \"MyActivity\"","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) { try { return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class}) .newInstance(config); } catch (final Exception e) { logger.warn(\"Failed to create AsyncSupport class: {}, error: {}\", targetClass, e); return null; \/\/ All callers are expected to handle null return value } }","old_code_raw":"    public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) {\n        try {\n            return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class})\n                    .newInstance(config);\n        } catch (final Exception e) {\n            logger.error(\"Failed to create comet support class: {}, error: {}\", targetClass, e);\n            logger.error(\"Switching to BlockingIO\");\n\n            return new BlockingIOCometSupport(config);\n        }\n    }\n","new_comment_raw":"@return an instance of the specified class or null if the class cannot be instantiated","old_comment_raw":"@return an instance of the specified class","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":83},{"new_code_raw":"public ExecutionInfo getParent() { return parentInfo; }","old_code_raw":"    public ExecutionInfo getParent() {\n        return parentType;\n    }\n","new_comment_raw":"@return the parent type information","old_comment_raw":"@return the parent type information","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public DateTime withField(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"Field must not be null\"); } long instant = fieldType.getField(getChronology()).set(getMillis(), value); return withMillis(instant); }","old_code_raw":"    public DateTime withField(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            return this;\n        }\n        long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n        return withMillis(instant);\n    }\n","new_comment_raw":"@return a copy of this datetime with the field set","old_comment_raw":"@return a copy of this datetime with the field set","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":56},{"new_code_raw":"public ICursor getCursor() { return cursor; }","old_code_raw":"public Cursor getCursor() {\n    return cursor;\n}","new_comment_raw":"@return the {@link ICursor} backing this SquidCursor. If you are on Android and you need to pass this object across process boundaries, and if this SquidCursor was obtained from a SquidDatabase, you can safely cast the object returned by this method to an Android cursor","old_comment_raw":"@return the {@link Cursor} backing this SquidCursor","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public Client testClassname(Client body) throws ApiException { ApiResponse<Client> localVarResp = testClassnameWithHttpInfo(body); return localVarResp.getData(); }","old_code_raw":"    public Client testClassname(Client body) throws ApiException {\n        ApiResponse<Client> resp = testClassnameWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"@return Client","old_comment_raw":"@return Client","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) { return FileDownloadServiceProxy.getImpl().setTaskCompleted(taskAtomList); }","old_code_raw":"    public boolean setTaskCompleted(String url, String path, long totalBytes) {\n        return FileDownloadServiceProxy.getImpl().setTaskCompleted(url, path, totalBytes);\n    }\n","new_comment_raw":"@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in  com.liulishuo.filedownloader.services.FileDownloadMgr#obtainCompletedTaskModel(String, String, long) will receive false, and non of them would be updated to DB.","old_comment_raw":"@return Whether is successful to set the task completed. If the path not exist will be false; If the length of the file in path is not equal to totalBytes will be false; If the task with url and path is downloading will be false. Otherwise will be true.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public static Date fromISODateString(String isoDateString) throws Exception { DateTimeFormatter parser = ISODateTimeFormat.dateTimeParser(); DateTime dateTime = DateTime.parse(isoDateString, parser); return dateTime.toDate(); }","old_code_raw":"    public static Date fromISODateString(String isoDateString)\n            throws Exception {\n        SimpleDateFormat f = new SimpleDateFormat(FORMAT_DATE_ISO, Locale.getDefault());\n        Date date;\n\n        f.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        try {\n            date = f.parse(isoDateString);\n            return date;\n        } catch (ParseException e) {\n        }\n\n        f = new SimpleDateFormat(FORMAT_DATE_ISO_MSEC, Locale.getDefault());\n        f.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        try {\n            date = f.parse(isoDateString);\n            return date;\n        } catch (ParseException e) {\n        }\n\n        f = new SimpleDateFormat(FORMAT_DATE_ISO_MSEC_UTC, Locale.getDefault());\n        f.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        try {\n            date = f.parse(isoDateString);\n            return date;\n        } catch (ParseException e) {\n        }\n\n        throw new ParseException(\"Unparseable date: \" + isoDateString, 0);\n    }\n","new_comment_raw":"@return the date","old_comment_raw":"@return the date","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"private ZapTextArea getTxtEncode() { if (txtEncode == null) { txtEncode = new ZapTextArea(); txtEncode.setLineWrap(true); txtEncode.setFont(new java.awt.Font(\"Courier New\", java.awt.Font.PLAIN, 12)); txtEncode.addMouseListener(new java.awt.event.MouseAdapter() { public void mousePressed(java.awt.event.MouseEvent e) { if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { \/\/ right mouse button view.getPopupMenu().show(e.getComponent(), e.getX(), e.getY()); } } }); } return txtEncode; }","old_code_raw":"\tprivate JTextArea getTxtEncode() {\n\t\tif (txtEncode == null) {\n\t\t\ttxtEncode = new JTextArea();\n\t\t\ttxtEncode.setLineWrap(true);\n\t\t\ttxtEncode.setFont(new java.awt.Font(\"Courier New\", java.awt.Font.PLAIN, 12));\n\t\t\ttxtEncode.addMouseListener(new java.awt.event.MouseAdapter() {   \n\t\t\t\tpublic void mousePressed(java.awt.event.MouseEvent e) {    \n\t          \t\tif ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {  \/\/ right mouse button\n\t            \t\tview.getPopupMenu().show(e.getComponent(), e.getX(), e.getY());\n\t            \t}\n\t\t\t\t} \n\n\t\t\t\n\t\t\t});\n\n\t\t}\n\t\treturn txtEncode;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":14,"line_counts":19,"new_code_token_num":120},{"new_code_raw":"public ImageView getImage(int index) { return getView(ImageView.class, index); }","old_code_raw":"\tpublic ImageView getImage(int index) {\n\t\tArrayList<ImageView> imageList = getCurrentViews(ImageView.class);\n\t\tImageView imageView = null;\n\t\ttry{\n\t\t\timageView = imageList.get(index);\n\t\t}catch (IndexOutOfBoundsException e){\n\t\t\tAssert.assertTrue(\"No image view with index \" + index + \" is found\", false);\n\t\t}\n\t\treturn imageView;\n\t}\n","new_comment_raw":"@return the  ImageView with a specified index or  null if index is invalid","old_comment_raw":"@return the ImageView with a specified index or null if index is invalid","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"private Color invertBgColor() { if (currentColor_.defaultColor()) { if (!inverted_) clazzes_.add(INVERSE_BG_STYLE); return new Color(); } else if (currentColor_.isExtended()) { clazzes_.add(Color.clazzForColorIndex(currentColor_.code(), true)); return new Color(true, currentColor_.code()); } else if (currentColor_.code() >= FOREGROUND_MIN && currentColor_.code() <= FOREGROUND_MAX) { int newBg = currentColor_.code() + (BACKGROUND_MIN - FOREGROUND_MIN); clazzes_.add(BACKGROUND_STYLE + Integer.toString(newBg - BACKGROUND_MIN)); return new Color(false, newBg); } else { int newBg = currentColor_.code() + (BACKGROUND_INTENSE_MIN - FOREGROUND_INTENSE_MIN); clazzes_.add(BACKGROUND_STYLE + Integer.toString(newBg + NUM - BACKGROUND_INTENSE_MIN)); return new Color(false, newBg); } }","old_code_raw":"private int invertBgColor() {\n    if (currentColor_.defaultColor()) {\n        if (!inverted_)\n            clazzes_.add(INVERSE_BG_STYLE);\n        return Color.DEFAULT_COLOR;\n    } else if (currentColor_.code() >= FOREGROUND_MIN && currentColor_.code() <= FOREGROUND_MAX) {\n        int newBg = currentColor_.code() + (BACKGROUND_MIN - FOREGROUND_MIN);\n        clazzes_.add(BACKGROUND_STYLE + Integer.toString(newBg - BACKGROUND_MIN));\n        return newBg;\n    } else {\n        int newBg = currentColor_.code() + (BACKGROUND_INTENSE_MIN - FOREGROUND_INTENSE_MIN);\n        clazzes_.add(BACKGROUND_STYLE + Integer.toString(newBg + NUM - BACKGROUND_INTENSE_MIN));\n        return newBg;\n    }\n}","new_comment_raw":"@return new background color based on the foreground color","old_comment_raw":"@return new background color based on the supplied foreground color","label":1,"pre_label":0,"AST_level":13,"line_counts":18,"new_code_token_num":165},{"new_code_raw":"protected Project getRightChild(RelOptRuleCall call) { return call.rel(2); }","old_code_raw":"  protected ProjectRelBase getRightChild(RelOptRuleCall call) {\n    return call.rel(2);\n  }\n","new_comment_raw":"@return LogicalProject corresponding to the right child","old_comment_raw":"@return ProjectRel corresponding to the right child","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public boolean isOperatedOn(Object entity) { if ( entity == null ) { throw new NullPointerException( \"null entities are not supported by \" + getClass().getName() ); } return entityToOperatedOnFlagMap.get( entity ); }","old_code_raw":"\tpublic boolean isOperatedOn(Object entity) {\n\t\tif ( entity == null ) {\n\t\t\tthrow new NullPointerException( \"null entities are not supported by \" + getClass().getName() );\n\t\t}\n\t\treturn ( ( Boolean ) entityToOperatedOnFlagMap.get( entity ) ).booleanValue();\n\t}\n","new_comment_raw":"@return true if the listener is performing the operation on the specified entity.","old_comment_raw":"@return true if the listener is performing the operation on the specified entity.","label":0,"pre_label":1,"AST_level":9,"line_counts":7,"new_code_token_num":44},{"new_code_raw":"public final AudioInputStream getSoundChallenge() { return this.challenge; }","old_code_raw":"public final Sound getSoundChallenge() {\n    return this.challenge;\n}","new_comment_raw":"@return an AudioInputStream","old_comment_raw":"@return a Line","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public String convertToSQL92(List<String> tokens) { StringBuilder selector = new StringBuilder(); boolean isFirstToken = true; for (Iterator i = tokens.iterator(); i.hasNext(); ) { String token = i.next().toString(); if (token.matches(\"^[^=]*='.*[\\\\*\\\\?].*'$\")) { token = token.replace('?', '_') .replace('*', '%') .replaceFirst(\"=\", \" LIKE \"); } if (isFirstToken) { isFirstToken = false; } else { selector.append(\" AND \"); } selector.append('(') .append(token) .append(')'); } return selector.toString(); }","old_code_raw":"    public String convertToSQL92(List<String> tokens) {\n        String selector = \"\";\n\n        \/\/ Convert to message selector\n        for (Iterator i = tokens.iterator(); i.hasNext(); ) {\n            selector = selector + \"(\" + i.next().toString() + \") AND \";\n        }\n\n        \/\/ Remove last AND and replace '*' with '%'\n        if (!selector.equals(\"\")) {\n            selector = selector.substring(0, selector.length() - 5);\n            selector = selector.replace('*', '%');\n        }\n        return selector;\n    }\n","new_comment_raw":"@return SQL-92 string of that query.","old_comment_raw":"@return SQL-92 string of that query.","label":0,"pre_label":1,"AST_level":11,"line_counts":23,"new_code_token_num":153},{"new_code_raw":"public double get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public double get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public MetadataBuilder getMetadataBuilder(StandardServiceRegistry serviceRegistry) { MetadataBuilderImpl defaultBuilder = new MetadataBuilderImpl( this, serviceRegistry ); return getCustomBuilderOrDefault( defaultBuilder ); }","old_code_raw":"\tpublic MetadataBuilder getMetadataBuilder(StandardServiceRegistry serviceRegistry) {\n\t\treturn new MetadataBuilderImpl( this, serviceRegistry );\n\t}\n","new_comment_raw":"@return The built metadata.","old_comment_raw":"@return The built metadata.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public String getDocumentPath() { if (this.path == null) { final Document doc = getDocument(); try { this.path = doc != null ? doc.getPath() : getPublication().getDocumentBuilder().getLocator(this.factory, this.webappUrl).getPath(); } catch (final Exception e) { throw new RuntimeException(e); } } return this.path; }","old_code_raw":"public String getDocumentPath() {\n    return getPublication().getPathMapper().getPath(getDocument().getUUID(), getDocument().getLanguage());\n}","new_comment_raw":"@return A string.","old_comment_raw":"@return a <code>File<code> value","label":1,"pre_label":0,"AST_level":12,"line_counts":11,"new_code_token_num":73},{"new_code_raw":"private ZapTextArea getTxtDecode() { if (txtDecode == null) { txtDecode = new ZapTextArea(); txtDecode.setLineWrap(true); txtDecode.setFont(new java.awt.Font(\"Courier New\", java.awt.Font.PLAIN, 12)); } return txtDecode; }","old_code_raw":"\tprivate JTextArea getTxtDecode() {\n\t\tif (txtDecode == null) {\n\t\t\ttxtDecode = new JTextArea();\n\t\t\ttxtDecode.setLineWrap(true);\n\t\t\ttxtDecode.setFont(new java.awt.Font(\"Courier New\", java.awt.Font.PLAIN, 12));\n\t\t}\n\t\treturn txtDecode;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":10,"line_counts":9,"new_code_token_num":51},{"new_code_raw":"public static ImageRequestBuilder fromRequest(ImageRequest imageRequest) { return ImageRequestBuilder.newBuilderWithSource(imageRequest.getSourceUri()) .setImageDecodeOptions(imageRequest.getImageDecodeOptions()) .setBytesRange(imageRequest.getBytesRange()) .setCacheChoice(imageRequest.getCacheChoice()) .setLocalThumbnailPreviewsEnabled(imageRequest.getLocalThumbnailPreviewsEnabled()) .setLowestPermittedRequestLevel(imageRequest.getLowestPermittedRequestLevel()) .setPostprocessor(imageRequest.getPostprocessor()) .setProgressiveRenderingEnabled(imageRequest.getProgressiveRenderingEnabled()) .setRequestPriority(imageRequest.getPriority()) .setResizeOptions(imageRequest.getResizeOptions()) .setRequestListener(imageRequest.getRequestListener()) .setRotationOptions(imageRequest.getRotationOptions()) .setShouldDecodePrefetches(imageRequest.shouldDecodePrefetches()); }","old_code_raw":"  public static ImageRequestBuilder fromRequest(ImageRequest imageRequest) {\n    return ImageRequestBuilder.newBuilderWithSource(imageRequest.getSourceUri())\n        .setImageDecodeOptions(imageRequest.getImageDecodeOptions())\n        .setBytesRange(imageRequest.getBytesRange())\n        .setCacheChoice(imageRequest.getCacheChoice())\n        .setLocalThumbnailPreviewsEnabled(imageRequest.getLocalThumbnailPreviewsEnabled())\n        .setLowestPermittedRequestLevel(imageRequest.getLowestPermittedRequestLevel())\n        .setPostprocessor(imageRequest.getPostprocessor())\n        .setProgressiveRenderingEnabled(imageRequest.getProgressiveRenderingEnabled())\n        .setRequestPriority(imageRequest.getPriority())\n        .setResizeOptions(imageRequest.getResizeOptions())\n        .setRequestListener(imageRequest.getRequestListener())\n        .setRotationOptions(imageRequest.getRotationOptions());\n  }\n","new_comment_raw":"@return a new request builder instance","old_comment_raw":"@return a new request builder instance","label":0,"pre_label":1,"AST_level":6,"line_counts":16,"new_code_token_num":104},{"new_code_raw":"public static HashMap getXmlRpcWorkflowInstancePage(WorkflowInstancePage page) { HashMap pageHash = new HashMap(); pageHash.put(STR, String.valueOf(page.getTotalPages())); pageHash.put(STR, String.valueOf(page.getPageNum())); pageHash.put(STR, String.valueOf(page.getPageSize())); pageHash.put(STR, getXmlRpcWorkflowInstances(page.getPageWorkflows())); return pageHash; }","old_code_raw":"public static Hashtable getXmlRpcWorkflowInstancePage(WorkflowInstancePage page) {\n    Hashtable pageHash = new Hashtable();\n    pageHash.put(STR, String.valueOf(page.getTotalPages()));\n    pageHash.put(STR, String.valueOf(page.getPageNum()));\n    pageHash.put(STR, String.valueOf(page.getPageSize()));\n    pageHash.put(STR, getXmlRpcWorkflowInstances(page.getPageWorkflows()));\n    return pageHash;\n}","new_comment_raw":"@return A {@link HashMap} representation of a {@link WorkflowInstancePage}.","old_comment_raw":"@return A {@link Hashtable} representation of a {@link WorkflowInstancePage}.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":79},{"new_code_raw":"public Button getButton(String text) { return viewFetcher.getView(Button.class, text, false); }","old_code_raw":"\tpublic Button getButton(String text)\n\t{\n\t\treturn viewFetcher.getView(Button.class, text);\n\t}\n","new_comment_raw":"@return the  Button that shows the given text","old_comment_raw":"@return the Button that shows the given text","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":21},{"new_code_raw":"public static Set<String> getDeclaredInstanceFields(Class<?> clazz) { List<Class<? extends Annotation>> excludedAnnotations = new ArrayList<Class<? extends Annotation>>(); excludedAnnotations.add(PodamExclude.class); return getDeclaredInstanceFields(clazz, excludedAnnotations); }","old_code_raw":"\tpublic static Set<String> getDeclaredInstanceFields(Class<?> clazz, List<Class<? extends Annotation>> excludeAnnotations) {\n\t\tSet<String> classFields = new HashSet<String>();\n\n\t\twhile (clazz != null) {\n\t\t\tField[] declaredFields = clazz.getDeclaredFields();\n\t\t\tfor (Field field : declaredFields) {\n\t\t\t\t\/\/ If users wanted to skip this field, we grant their wishes\n\t\t\t\tif (containsAnyAnnotation(field, excludeAnnotations)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint modifiers = field.getModifiers();\n\t\t\t\tif (!Modifier.isStatic(modifiers)) {\n\n\t\t\t\t\tclassFields.add(field.getName());\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tclazz = clazz.getSuperclass();\n\t\t}\n\n\t\treturn classFields;\n\t}\n","new_comment_raw":"@return Set of a class declared field names.","old_comment_raw":"@return Set of a class declared field names.","label":0,"pre_label":1,"AST_level":10,"line_counts":6,"new_code_token_num":42},{"new_code_raw":"public static double logAdd(double lx, double ly) { double max, negDiff; if (lx > ly) { max = lx; negDiff = ly - lx; } else { max = ly; negDiff = lx - ly; } return (max == Double.NEGATIVE_INFINITY || negDiff < -LOGTOLERANCE) ? max : \/\/ max + Math.log(1 + Math.exp(negDiff)); }","old_code_raw":"  public static double logAdd(double lx, double ly) {\n    double max, negDiff;\n    if (lx > ly) {\n      max = lx;\n      negDiff = ly - lx;\n    } else {\n      max = ly;\n      negDiff = lx - ly;\n    }\n    if (max == Double.NEGATIVE_INFINITY) {\n      return max;\n    } else if (negDiff < -LOGTOLERANCE) {\n      return max;\n    } else {\n      return max + Math.log(1.0 + Math.exp(negDiff));\n    }\n  }\n","new_comment_raw":"@return  log(exp(lx) + exp(ly))","old_comment_raw":"@return log(exp(lx) + exp(ly))","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":74},{"new_code_raw":"public ModuleJarClassLoader getLoader() { return loader; }","old_code_raw":"public ModuleClassLoader getLoader() {\n    return loader;\n}","new_comment_raw":"@return ModuleJarClassLoader","old_comment_raw":"@return ModuleClassLoader","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public boolean hasReminder() { return reminder != null; }","old_code_raw":"public boolean hasReminder() {\n    return (reminderHour != null && reminderMin != null);\n}","new_comment_raw":"@return true if habit has reminder, false otherwise","old_comment_raw":"@return true if habit has reminder","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public EDecimal<Double> div(Expr<D> right) { return ODecimal.create(Double.class, Ops.DIV, this, right); }","old_code_raw":"    public ENumber<Double> div(Expr<D> right) {\n        return ONumber.create(Double.class, Ops.DIV, this, right);\n    }\n","new_comment_raw":"@return this \/ right","old_comment_raw":"@return this \/ right","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public List<SqlTypeName> getTypeNames() { switch (this) { case CHARACTER: return SqlTypeName.charTypes; case BINARY: return SqlTypeName.binaryTypes; case NUMERIC: return SqlTypeName.numericTypes; case DATE: return ImmutableList.of(SqlTypeName.DATE); case TIME: return ImmutableList.of(SqlTypeName.TIME); case TIMESTAMP: return ImmutableList.of(SqlTypeName.TIMESTAMP); case BOOLEAN: return SqlTypeName.booleanTypes; case INTERVAL_YEAR_MONTH: return ImmutableList.of(SqlTypeName.INTERVAL_YEAR_MONTH); case INTERVAL_DAY_TIME: return ImmutableList.of(SqlTypeName.INTERVAL_DAY_TIME); case STRING: return SqlTypeName.stringTypes; case APPROXIMATE_NUMERIC: return SqlTypeName.approxTypes; case EXACT_NUMERIC: return SqlTypeName.exactTypes; case INTEGER: return SqlTypeName.intTypes; case DATETIME: return SqlTypeName.datetimeTypes; case DATETIME_INTERVAL: return SqlTypeName.intervalTypes; case MULTISET: return ImmutableList.of(SqlTypeName.MULTISET); case ARRAY: return ImmutableList.of(SqlTypeName.ARRAY); case MAP: return ImmutableList.of(SqlTypeName.MAP); case NULL: return ImmutableList.of(SqlTypeName.NULL); case ANY: return SqlTypeName.allTypes; case CURSOR: return ImmutableList.of(SqlTypeName.CURSOR); case COLUMN_LIST: return ImmutableList.of(SqlTypeName.COLUMN_LIST); default: throw new IllegalArgumentException(); } }","old_code_raw":"  public List<SqlTypeName> getTypeNames() {\n    return typeNames;\n  }\n","new_comment_raw":"@return collection of  SqlTypeNames included in this family","old_comment_raw":"@return collection of SqlTypeNames included in this family","label":0,"pre_label":1,"AST_level":7,"line_counts":51,"new_code_token_num":220},{"new_code_raw":"public GremlinPipeline<S, Map<String, Object>> map() { return this.add(new PropertyMapPipe()); }","old_code_raw":"public T map() {\n    return this.add(new PropertyMapPipe());\n}","new_comment_raw":"@return the extended Pipeline","old_comment_raw":"@return the extended FluentPipeline","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":23},{"new_code_raw":"public JSONObject getMainCharacterForUserInGuild(User user, Guild guild) { JSONObject character = null; HttpUrl url = new HttpUrl.Builder().scheme(STR).host(getBot().getBotSettings().getProperty(STR)).addPathSegments(STR + user.getId() + STR + guild.getId()).build(); Request request = new Request.Builder().url(url).build(); try { Response response = client.newCall(request).execute(); JSONObject jsonObject = new JSONObject(response.body().source()); character = jsonObject.length() > NUM ? jsonObject : null; } catch (IOException e) { e.printStackTrace(); } return character; }","old_code_raw":"public String getMainCharacterForUserInGuild(User user, Guild guild) {\n    MongoCollection<Document> collection = getBot().getMongoDatabase().getCollection(MONGO_WOW_CHARACTERS_COLLECTION);\n    Document document = collection.find(and(eq(STR, user.getId()), eq(STR, guild.getId()))).first();\n    return document != null ? document.getString(STR) : null;\n}","new_comment_raw":"@return The region\/realm\/name of the main character of a user. Returns null if not found.","old_comment_raw":"@return The name of the main character of a user. Returns null if not found.","label":1,"pre_label":0,"AST_level":10,"line_counts":13,"new_code_token_num":129},{"new_code_raw":"public Builder host(String host) { this.host = host; return this; }","old_code_raw":"public static Builder host(final String host) {\n    return builder().host(host);\n}","new_comment_raw":"@return Builder","old_comment_raw":"@return ping host","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"protected static WebcamDriver findDriver(String[] drivers) { if (LOG.isInfoEnabled()) { StringBuffer sb = new StringBuffer(); for (int i = 0; i < drivers.length; i++) { sb.append(drivers[i]).append(i < drivers.length - 1 ? \", \" : \"\"); } LOG.info(\"Searching for one of the webcam drivers [\" + sb.toString() + \"]\"); } for (String name : drivers) { Class<?> clazz = null; try { clazz = Class.forName(\"com.github.sarxos.webcam.ds.\" + name); } catch (ClassNotFoundException e) { continue; } LOG.info(\"Webcam driver has been found: \" + name); try { return (WebcamDriver) clazz.newInstance(); } catch (InstantiationException e) { throw new RuntimeException(e); } catch (IllegalAccessException e) { throw new RuntimeException(e); } } LOG.error(\"Webcam driver has not been found! Please add one to the classpath!\"); throw new WebcamException(\"No webcam driver available\"); }","old_code_raw":"\tprotected static WebcamDriver findDriver(String[] drivers) {\n\n\t\tif (LOG.isInfoEnabled()) {\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tfor (int i = 0; i < drivers.length; i++) {\n\t\t\t\tsb.append(drivers[i]).append(i < drivers.length - 1 ? \", \" : \"\");\n\t\t\t}\n\t\t\tLOG.info(\"Searching for one of the webcam drivers [\" + sb.toString() + \"]\");\n\t\t}\n\n\t\tfor (String name : drivers) {\n\n\t\t\tString pkgname = \"com.github.sarxos.webcam.ds.\" + name;\n\n\t\t\tWebcamDriver driver = null;\n\t\t\tClass<?>[] classes = WebcamDriverUtils.getClasses(pkgname, true);\n\n\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(\"Searching for classes in \" + pkgname + \", found \" + classes.length);\n\t\t\t}\n\n\t\t\tif (classes.length == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (Class<?> clazz : classes) {\n\t\t\t\tif (WebcamDriver.class.isAssignableFrom(clazz)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdriver = (WebcamDriver) clazz.newInstance();\n\t\t\t\t\t} catch (InstantiationException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLOG.info(\"Webcam driver has been found: \" + name);\n\n\t\t\treturn driver;\n\t\t}\n\n\t\tLOG.error(\"Webcam driver has not been found! Please add one to the classpath!\");\n\n\t\tthrow new WebcamException(\"No webcam driver available\");\n\t}\n","new_comment_raw":"@return Driver if found or throw exception","old_comment_raw":"@return Driver if found or throw exception","label":0,"pre_label":1,"AST_level":13,"line_counts":36,"new_code_token_num":221},{"new_code_raw":"public long getId() { return id; }","old_code_raw":"public long getId() {\n    return id_category;\n}","new_comment_raw":"@return the id","old_comment_raw":"@return the id_category","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) { if (fieldType == null) { throw new IllegalArgumentException(\"Field type must not be null\"); } return append0(new TextField(fieldType, iLocale, true)); }","old_code_raw":"    public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        DateTimeField field = fieldType.getField(iChronoUTC);\n        return append0(new TextField(iChrono, field, iLocale, true));\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":44},{"new_code_raw":"@SuppressWarnings(STR) public ObjectName getExchangeObjectName(String virtualHostName, String exchange) { AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = STR + virtualHostName + STR + exchange + STR; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(STR, objectNames); _test.assertEquals(STR + exchange + STR, NUM, objectNames.size()); ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(STR + objectName); return objectName; }","old_code_raw":"public ObjectName getExchangeObjectName(String virtualHostName, String exchange) {\n    AllObjects allObject = new AllObjects(_mbsc);\n    allObject.querystring = STR + virtualHostName + STR + exchange + STR;\n    Set<ObjectName> objectNames = allObject.returnObjects();\n    _test.assertNotNull(STR, objectNames);\n    _test.assertEquals(STR + exchange + STR, NUM, objectNames.size());\n    return objectNames.iterator().next();\n}","new_comment_raw":"@return the ObjectName for the given Exchange on the VirtualHost","old_comment_raw":"@return the ObjectName for the given exchange on the test VirtualHost.","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":94},{"new_code_raw":"public List<ArrayList<TaggedWord>> process(List<? extends List<? extends HasWord>> sentences) { List<ArrayList<TaggedWord>> taggedSentences = new ArrayList<ArrayList<TaggedWord>>(); TestSentence testSentence = new TestSentence(this); for (List<? extends HasWord> sentence : sentences) { taggedSentences.add(testSentence.tagSentence(sentence, false)); } return taggedSentences; }","old_code_raw":"  public List<List<TaggedWord>> process(List<? extends List<? extends HasWord>> sentences) {\n    List<List<TaggedWord>> taggedSentences = Generics.newArrayList();\n\n    TestSentence testSentence = new TestSentence(this);\n    for (List<? extends HasWord> sentence : sentences) {\n      taggedSentences.add(testSentence.tagSentence(sentence, false));\n    }\n    return taggedSentences;\n  }\n","new_comment_raw":"@return A List of Sentence of TaggedWord (final generification cannot be listed due to lack of complete generification of super classes)","old_comment_raw":"@return A List of Sentence of TaggedWord","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":63},{"new_code_raw":"public Collection<InMemoryJob> getAllJobs() { return new ArrayList<>(jobs.values()); }","old_code_raw":"        public Collection<InMemoryJob> getAllJobs() {\n            return new ArrayList<InMemoryJob>(jobs.values());\n        }\n","new_comment_raw":"@return a Collection containing all the managed jobs for this task.","old_comment_raw":"@return a Collection containing all the managed jobs for this task.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public FeatureService createFeatureService() { return createFeatureService(defaultEndpointUrl); }","old_code_raw":"public FeatureService createFeatureService() {\n    return createFeatureService(defaultServerUrl);\n}","new_comment_raw":"@return a new feature service with the default endpoint URL","old_comment_raw":"@return a new feature service with the default server URL","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public ExtensionHandler getExtensionHandler() { return generatorContext.getExtensionHandler(); }","old_code_raw":"public ExtensionHandler getExtensionHandler() {\n    return extensionHandler;\n}","new_comment_raw":"@return the extension handler used by the DOMTreeManager.","old_comment_raw":"@return the extension handler used by this SVGGraphics2D instance","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public static ExpectedCondition<Boolean> titleContains(final String title) { return new ExpectedCondition<Boolean>() { private String currentTitle = \"\"; public Boolean apply(WebDriver driver) { currentTitle = driver.getTitle(); return currentTitle != null && currentTitle.contains(title); } @Override public String toString() { return String.format(\"title to contain \\\"%s\\\". Current title: \\\"%s\\\"\", title, currentTitle); } }; }","old_code_raw":"  public static ExpectedCondition<Boolean> titleContains(final String title) {\n    return new ExpectedCondition<Boolean>() {\n      public Boolean apply(WebDriver driver) {\n        String currentTitle = driver.getTitle();\n        return currentTitle == null ? false : currentTitle.contains(title);\n      }\n\n      @Override\n      public String toString() {\n        return \"title to contain \" + title;\n      }\n    };\n  }\n","new_comment_raw":"@return true when the title matches, false otherwise","old_comment_raw":"@return true when the title matches, false otherwise","label":0,"pre_label":1,"AST_level":9,"line_counts":16,"new_code_token_num":93},{"new_code_raw":"public CacheStatisticsImpl createCacheStatIfAbsent(String name) { CacheStatisticsImpl statistics = new CacheStatisticsImpl(); CacheStatisticsImpl temp = this.statistics.putIfAbsent(name, statistics); if (temp != null) { statistics = temp; } return statistics; }","old_code_raw":"public CacheStatisticsImpl createCacheStatIfAbsent(String name) {\n    if (!statistics.containsKey(name)) {\n        statistics.putIfAbsent(name, new CacheStatisticsImpl());\n    }\n    return statistics.get(name);\n}","new_comment_raw":"@return {@link CacheStatisticsImpl} or an empty statistics if not enabled.","old_comment_raw":"@return {@link CacheStatisticsImpl}.","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":41},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 6: { return getEllipsis(); } case 8: break; case 4: { return getNext(false); } case 9: break; case 7: { if ( ! removeProMarker) { return getNext(false); } } case 10: break; case 2: { return getNewline(); } case 11: break; case 5: { return getNext(true); } case 12: break; case 3: { } case 13: break; case 1: { System.err.printf(\"Untokenizable: %s%n\", yytext()); return getNext(true); } case 14: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { System.err.printf(\"Untokenizable: %s%n\", yytext());\n\t      return getNext(true);\n          }\n        case 9: break;\n        case 2: \n          { if (tokenizeNLs) {\n                return getNext(NEWLINE_TOKEN, yytext());\n              }\n          }\n        case 10: break;\n        case 3: \n          { \n          }\n        case 11: break;\n        case 4: \n          { return getNext(false);\n          }\n        case 12: break;\n        case 5: \n          { return getNext(true);\n          }\n        case 13: break;\n        case 6: \n          { return getEllipsis();\n          }\n        case 14: break;\n        case 7: \n          { if (! removeProMarker) return getNext(false);\n          }\n        case 15: break;\n        case 8: \n          { if (removeProMarker) {\n                if ( ! removeSegMarker) {\n                  return getNext(\"-\", yytext());\n                }\n              } else {\n                return getNext(false);\n              }\n          }\n        case 16: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":115,"new_code_token_num":431},{"new_code_raw":"@Override public Optional<TYPE> first() { Iterator<TYPE> resultIterator = first(NUM).iterator(); return resultIterator.hasNext() ? Optional.of(resultIterator.next()) : Optional.empty(); }","old_code_raw":"@Override\npublic Optional<TYPE> first() {\n    Optional result = Optional.empty();\n    List<TYPE> list = first(NUM).asList();\n    if (!list.isEmpty()) {\n        result = Optional.of(list.get(NUM));\n    }\n    return result;\n}","new_comment_raw":"@return an Optional containing the first object of this Iterable","old_comment_raw":"@return an option of the first object of the iteration","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":41},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 35: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 50: break; case 8: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 51: break; case 19: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 52: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; \/\/ try to work around an apparent jflex bug where it \/\/ gets a space at the token end by getting \/\/ wrong the length of the trailing context. while (yylength() > 0) { char last = yycharat(yylength()-1); if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) { yypushback(1); } else { break; } } if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 53: break; case 15: { return handleQuotes(yytext(), false); } case 54: break; case 32: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), false); } case 55: break; case 24: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 56: break; case 30: \/\/ lookahead expression with fixed lookahead length yypushback(1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 57: break; case 44: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNormalizedAmpNext(); } case 58: break; case 31: { return getNormalizedAmpNext(); } case 59: break; case 34: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 60: break; case 48: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return getNext(); } case 61: break; case 40: \/\/ lookahead expression with fixed lookahead length yypushback(2); { return getNext(); } case 62: break; case 38: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 13; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 63: break; case 37: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 11; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 12; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 64: break; case 4: { return getNext(); } case 65: break; case 21: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(); } case 66: break; case 46: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 67: break; case 23: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 68: break; case 6: { if (normalizeOtherBrackets) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 69: break; case 7: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 70: break; case 28: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 71: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 72: break; case 43: { yypushback(2) ; return getNext(); } case 73: break; case 25: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 74: break; case 18: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 75: break; case 49: { String txt = yytext(); if (normalizeSpace) { \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 76: break; case 45: { yypushback(3) ; return getNext(); } case 77: break; case 22: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return handleQuotes(yytext(), true); } case 78: break; case 2: { if (normalizeOtherBrackets) { return getNext(openparen, yytext()); } else { return getNext(); } } case 79: break; case 36: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 80: break; case 20: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 81: break; case 17: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 82: break; case 11: { return handleEllipsis(yytext()); } case 83: break; case 33: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 84: break; case 13: { return normalizeFractions(yytext()); } case 85: break; case 14: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(); } } case 86: break; case 41: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 9; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 10; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 87: break; case 10: { if (invertible) { prevWordAfter.append(yytext()); } } case 88: break; case 3: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 89: break; case 42: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 90: break; case 12: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 91: break; case 27: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 92: break; case 9: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 93: break; case 29: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 94: break; case 26: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 95: break; case 1: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } LOGGER.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { LOGGER.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: LOGGER.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 96: break; case 39: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 97: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 98: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 34: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 49: break;\n        case 8: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 50: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 51: break;\n        case 46: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          \/\/ try to work around an apparent jflex bug where it\n                          \/\/ gets a space at the token end by getting\n                          \/\/ wrong the length of the trailing context.\n                          while (yylength() > 0) {\n                            char last = yycharat(yylength()-1);\n                            if (last == ' ' || last == '\\t' || (last >= '\\n' && last <= '\\r' || last == '\\u0085')) {\n                              yypushback(1);\n                            } else {\n                              break;\n                            }\n                          }\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 52: break;\n        case 15: \n          { return handleQuotes(yytext(), false);\n          }\n        case 53: break;\n        case 31: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 54: break;\n        case 21: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 55: break;\n        case 43: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 56: break;\n        case 30: \n          { return getNormalizedAmpNext();\n          }\n        case 57: break;\n        case 33: \n          { String txt = yytext();\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n          }\n        case 58: break;\n        case 47: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 4;\n          { return getNext();\n          }\n        case 59: break;\n        case 39: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 60: break;\n        case 37: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 13;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 61: break;\n        case 36: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 11;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 12;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 62: break;\n        case 4: \n          { return getNext();\n          }\n        case 63: break;\n        case 22: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 64: break;\n        case 45: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 65: break;\n        case 24: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 66: break;\n        case 6: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 67: break;\n        case 7: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 68: break;\n        case 28: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 69: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 70: break;\n        case 42: \n          { yypushback(2) ; return getNext();\n          }\n        case 71: break;\n        case 25: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 72: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 73: break;\n        case 48: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            \/\/ txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 74: break;\n        case 44: \n          { yypushback(3) ; return getNext();\n          }\n        case 75: break;\n        case 23: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 76: break;\n        case 2: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 77: break;\n        case 35: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 78: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 79: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 80: break;\n        case 11: \n          { return handleEllipsis(yytext());\n          }\n        case 81: break;\n        case 32: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n          }\n        case 82: break;\n        case 13: \n          { return normalizeFractions(yytext());\n          }\n        case 83: break;\n        case 14: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 84: break;\n        case 40: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 9;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 10;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 85: break;\n        case 10: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 86: break;\n        case 3: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 87: break;\n        case 41: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                               yytext());\n          }\n        case 88: break;\n        case 12: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 89: break;\n        case 27: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 90: break;\n        case 9: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 91: break;\n        case 29: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 92: break;\n        case 26: \n          { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 93: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 94: break;\n        case 38: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 95: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 96: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":625,"new_code_token_num":3731},{"new_code_raw":"public int decodable(QpidByteBuffer in) { return (in.remaining() >= NUM) ? NUM : NUM - in.remaining(); }","old_code_raw":"public boolean decodable(MarkableDataInput in) throws IOException {\n    return (in.available() >= NUM);\n}","new_comment_raw":"@return number of extra octets of data required data to decode the PI frame fully","old_comment_raw":"@return true if we have enough data to decode the PI frame fully, false if more data is required","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":27},{"new_code_raw":"public boolean isChecked(String locator) { return (Boolean) seleneseMethods.get(\"isChecked\").apply(driver, locator); }","old_code_raw":"  public boolean isChecked(String locator) {\n    return elementFinder.findElement(driver, locator)\n        .isSelected();\n  }\n","new_comment_raw":"@return true if the checkbox is checked, false otherwise","old_comment_raw":"@return true if the checkbox is checked, false otherwise","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public Sentence cased() { return new Sentence(this.docFn, impl.build(), Document.EMPTY_PROPS); }","old_code_raw":"  public Sentence cased() {\n    this.defaultProps = Document.EMPTY_PROPS;\n    return this;\n  }\n","new_comment_raw":"@return A new sentence with the default properties swapped out.","old_comment_raw":"@return This same sentence, but with the default properties swapped out.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public String format(int indentFactor) { StringWriter sw = new StringWriter(); synchronized (sw.getBuffer()) { return this.writeInternal(sw, indentFactor, 0).toString(); } }","old_code_raw":"  public String format(int indentFactor) {\n    StringWriter sw = new StringWriter();\n    synchronized (sw.getBuffer()) {\n      return this.write(sw, indentFactor, 0).toString();\n    }\n  }\n","new_comment_raw":"@return a printable, displayable, transmittable representation of the object, beginning with [&nbsp;(left bracket) and ending with ]&nbsp;(right bracket).","old_comment_raw":"@return a printable, displayable, transmittable representation of the object, beginning with [&nbsp;(left bracket) and ending with ]&nbsp;(right bracket).","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":39},{"new_code_raw":"private ZapMenuItem getMenuHelpAbout() { if (menuHelpAbout == null) { menuHelpAbout = new ZapMenuItem(\"menu.help.about\"); menuHelpAbout.addActionListener(new java.awt.event.ActionListener() { @Override public void actionPerformed(java.awt.event.ActionEvent e) { AboutDialog dialog = new AboutDialog(View.getSingleton().getMainFrame(), true); dialog.setVisible(true); } }); } return menuHelpAbout; }","old_code_raw":"\tprivate JMenuItem getMenuHelpAbout() {\n\t\tif (menuHelpAbout == null) {\n\t\t\tmenuHelpAbout = new JMenuItem();\n\t\t\t\/\/ ZAP: Rebrand\n\t\t\tmenuHelpAbout.setText(Constant.messages.getString(\"menu.help.about\")); \/\/ ZAP: i18n\n\t\t\tmenuHelpAbout.addActionListener(new java.awt.event.ActionListener() { \n\n\t\t\t\t@Override\n\t\t\t\tpublic void actionPerformed(java.awt.event.ActionEvent e) {    \n\n\t\t\t\t\tAboutDialog dialog = new AboutDialog(View.getSingleton().getMainFrame(), true);\n\t\t\t\t\tdialog.setVisible(true);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t\treturn menuHelpAbout;\n\t}\n","new_comment_raw":"@return javax.swing.ZapMenuItem","old_comment_raw":"@return javax.swing.JMenuItem","label":1,"pre_label":0,"AST_level":13,"line_counts":15,"new_code_token_num":78},{"new_code_raw":"public boolean searchEditText(String text) { return searcher.searchWithTimeoutFor(EditText.class, text, 1, true, false); }","old_code_raw":"\tpublic boolean searchEditText(String text) {\n\t\tboolean found = searcher.searchWithTimeoutFor(EditText.class, text, 1, true, false);\n\t\treturn found;\n\t}\n","new_comment_raw":"@return  true if an  EditText with the given text is found or  false if it is not found","old_comment_raw":"@return true if an EditText with the given text is found or false if it is not found","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public Map<String, String> getAdditionalHttpHeaders() { return additionalHttpHeaders == null ? null : Collections.unmodifiableMap(additionalHttpHeaders); }","old_code_raw":"public Map<String, String> getAdditionalHttpHeaders() {\n    return Collections.unmodifiableMap(additionalHttpHeaders);\n}","new_comment_raw":"@return A read-only view of the additionalHttpHeaders, or null if none are set.","old_comment_raw":"@return A read-only view of the additionalHttpHeaders.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":22},{"new_code_raw":"public HBaseResponse getHTableInfo(String tableName) throws IOException { HBaseResponse hr = htableInfoCache.getIfPresent(tableName); if (null != hr) { return hr; } hr = new HBaseResponse(); if (\"hbase\".equals(getConfig().getMetadataUrl().getScheme())) { try { \/\/ use reflection to isolate NoClassDef errors when HBase is not available hr = (HBaseResponse) Class.forName(\"org.apache.kylin.rest.service.HBaseInfoUtil\")\/\/ .getMethod(\"getHBaseInfo\", new Class[] { String.class, KylinConfig.class })\/\/ .invoke(null, tableName, this.getConfig()); } catch (Throwable e) { throw new IOException(e); } } htableInfoCache.put(tableName, hr); return hr; }","old_code_raw":"    public HBaseResponse getHTableInfo(String tableName) throws IOException, ExecutionException {\n        return htableInfoCache.get(tableName);\n    }\n","new_comment_raw":"@return The HBaseResponse object contains table size, region count. null if error happens","old_comment_raw":"@return The HBaseResponse object contains table size, region count. null if error happens","label":0,"pre_label":1,"AST_level":14,"line_counts":22,"new_code_token_num":147},{"new_code_raw":"public WireType getWireType() { return queue.wireType(); }","old_code_raw":"public WireType getWireType() {\n    return wireType;\n}","new_comment_raw":"@return the queue wire type","old_comment_raw":"@return the wireType","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public String getShortName(long instant, Locale locale) { if (locale == null) { locale = Locale.getDefault(); } String nameKey = getNameKey(instant); if (nameKey == null) { return iID; } String name = cNameProvider.getShortName(locale, iID, nameKey); if (name != null) { return name; } return printTimeZone(getOffset(instant)); }","old_code_raw":"    public String getShortName(long instant, Locale locale) {\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        String nameKey = getNameKey(instant);\n        if (nameKey == null) {\n            return iID;\n        }\n        String name = cNameProvider.getShortName(locale, iID, nameKey);\n        if (name != null) {\n            return name;\n        }\n        return offsetFormatter().print(instant, this);\n    }\n","new_comment_raw":"@return the human-readable short name in the specified locale","old_comment_raw":"@return the human-readable short name in the specified locale","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":74},{"new_code_raw":"public LockMode getAliasSpecificLockMode(String alias) { if ( aliasSpecificLockModes == null ) { return null; } return (LockMode) aliasSpecificLockModes.get( alias ); }","old_code_raw":"\tpublic LockMode getAliasSpecificLockMode(String alias) {\n\t\treturn (LockMode) aliasSpecificLockModes.get( alias );\n\t}\n","new_comment_raw":"@return The explicit lock mode for that alias.","old_comment_raw":"@return The explicit lock mode for that alias.","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":29},{"new_code_raw":"public String getMatches() { StringBuilder sb = new StringBuilder(); for (int i = NUM, sz = list.getModel().getSize(); i < sz; i++) { Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree(); sb.append(t.pennString()); sb.append(STR); } return sb.toString(); }","old_code_raw":"public StringBuffer getMatches() {\n    StringBuffer sb = new StringBuffer();\n    for (int i = NUM; i < list.getModel().getSize(); i++) {\n        Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree();\n        sb.append(t.pennString());\n        sb.append(STR);\n    }\n    return sb;\n}","new_comment_raw":"@return String filled with the Penn treebank forms of all trees in the matches panel","old_comment_raw":"@return StringBuffer filled with the penn treebank forms of all trees in the matches panel","label":1,"pre_label":0,"AST_level":10,"line_counts":9,"new_code_token_num":78},{"new_code_raw":"public static boolean hasPermissions(Context context, String... perms) { \/\/ Always return true for SDK < M, let the system deal with the permissions if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) { Log.w(TAG, \"hasPermissions: API version < M, returning true by default\"); return true; } for (String perm : perms) { boolean hasPerm = (ContextCompat.checkSelfPermission(context, perm) == PackageManager.PERMISSION_GRANTED); if (!hasPerm) { return false; } } return true; }","old_code_raw":"    public static boolean hasPermissions(Context context, String... perms) {\n        for (String perm : perms) {\n            boolean hasPerm = (ContextCompat.checkSelfPermission(context, perm) == PackageManager.PERMISSION_GRANTED);\n            if (!hasPerm) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n","new_comment_raw":"@return true if all permissions are already granted, false if at least one permission is not yet granted.","old_comment_raw":"@return true if all permissions are already granted, false if at least one permission is not yet granted.","label":0,"pre_label":1,"AST_level":9,"line_counts":18,"new_code_token_num":98},{"new_code_raw":"protected AuthenticationInfo doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) { ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy(); AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token); if (log.isDebugEnabled()) { log.debug(STR + realms.size() + STR); } for (Realm realm : realms) { if (realm.supports(token)) { if (log.isDebugEnabled()) { log.debug(STR + token + STR + STR + realm + STR); } AuthenticationInfo info = null; Throwable t = null; try { info = realm.getAuthenticationInfo(token); } catch (Throwable throwable) { t = throwable; if (log.isTraceEnabled()) { String msg = STR + realm + STR; log.trace(msg, t); } } aggregate = strategy.afterAttempt(realm, token, info, aggregate, t); } else { if (log.isDebugEnabled()) { log.debug(STR + realm + STR + STR + token + STR); } } } aggregate = strategy.afterAllAttempts(token, aggregate); return aggregate; }","old_code_raw":"protected Account doMultiRealmAuthentication(Collection<? extends Realm> realms, AuthenticationToken token) {\n    ModularAuthenticationStrategy strategy = getModularAuthenticationStrategy();\n    Account aggregate = strategy.beforeAllAttempts(realms, token);\n    if (log.isDebugEnabled()) {\n        log.debug(STR + realms.size() + STR);\n    }\n    for (Realm realm : realms) {\n        if (realm.supports(token)) {\n            if (log.isDebugEnabled()) {\n                log.debug(STR + token + STR + STR + realm + STR);\n            }\n            aggregate = strategy.beforeAttempt(realm, token, aggregate);\n            Account account = null;\n            Throwable t = null;\n            try {\n                account = realm.getAccount(token);\n            } catch (Throwable throwable) {\n                t = throwable;\n                if (log.isTraceEnabled()) {\n                    String msg = STR + realm + STR;\n                    log.trace(msg, t);\n                }\n            }\n            aggregate = strategy.afterAttempt(realm, token, account, aggregate, t);\n        } else {\n            if (log.isDebugEnabled()) {\n                log.debug(STR + realm + STR + STR + token + STR);\n            }\n        }\n    }\n    aggregate = strategy.afterAllAttempts(token, aggregate);\n    return aggregate;\n}","new_comment_raw":"@return an aggregated AuthenticationInfo instance representing account data across all the successfully consulted realms.","old_comment_raw":"@return an aggregated Account instance representing account data across all the successfully consulted realms.","label":1,"pre_label":0,"AST_level":16,"line_counts":32,"new_code_token_num":205},{"new_code_raw":"public Double getNdv(SchemaPath col) { \/\/ Stats might not have materialized because of errors. if (!materialized) { return null; } Long ndvCol = ndv.get(col); \/\/ Ndv estimation techniques like HLL may over-estimate, hence cap it at rowCount if (ndvCol != null) { return (double) Math.min(ndvCol, rowCount); } return null; }","old_code_raw":"  public Double getNdv(SchemaPath col) {\n    \/\/ Stats might not have materialized because of errors.\n    if (!materialized) {\n      return null;\n    }\n    Long ndvCol = ndv.get(col);\n    \/\/ Ndv estimation techniques like HLL may over-estimate, hence cap it at rowCount\n    if (ndvCol != null) {\n      return Math.min(ndvCol, rowCount);\n    }\n    return null;\n  }\n","new_comment_raw":"@return approximate count distinct of the column, if available. NULL otherwise.","old_comment_raw":"@return approximate count distinct of the column, if available. NULL otherwise.","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":77},{"new_code_raw":"public static Value astFromValue(Object value, GraphQLType type) { if (value == null) { return null; } if (isNonNull(type)) { return handleNonNull(value, (GraphQLNonNull) type); } \/\/ Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but \/\/ the value is not an array, convert the value using the list's item type. if (isList(type)) { return handleList(value, (GraphQLList) type); } \/\/ Populate the fields of the input object by creating ASTs from each value \/\/ in the JavaScript object according to the fields in the input type. if (type instanceof GraphQLInputObjectType) { return handleInputObject(value, (GraphQLInputObjectType) type); } if (!(type instanceof GraphQLScalarType || type instanceof GraphQLEnumType)) { throw new AssertException(\"Must provide Input Type, cannot use: \" + type.getClass()); } \/\/ Since value is an internally represented value, it must be serialized \/\/ to an externally represented value before converting into an AST. final Object serialized = serialize(type, value); if (isNullish(serialized)) { return null; } \/\/ Others serialize based on their corresponding JavaScript scalar types. if (serialized instanceof Boolean) { return BooleanValue.newBooleanValue().value((Boolean) serialized).build(); } String stringValue = serialized.toString(); \/\/ numbers can be Int or Float values. if (serialized instanceof Number) { return handleNumber(stringValue); } if (serialized instanceof String) { \/\/ Enum types use Enum literals. if (type instanceof GraphQLEnumType) { return EnumValue.newEnumValue().name(stringValue).build(); } \/\/ ID types can use Int literals. if (type == Scalars.GraphQLID && stringValue.matches(\"^[0-9]+$\")) { return IntValue.newIntValue().value(new BigInteger(stringValue)).build(); } \/\/ String types are just strings but JSON'ised return StringValue.newStringValue().value(stringValue).build(); } throw new AssertException(\"'Cannot convert value to AST: \" + serialized); }","old_code_raw":"    public static Value astFromValue(Object value, GraphQLType type) {\n        if (value == null) {\n            return null;\n        }\n\n        if (isNonNull(type)) {\n            return handleNonNull(value, (GraphQLNonNull) type);\n        }\n\n        \/\/ Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n        \/\/ the value is not an array, convert the value using the list's item type.\n        if (isList(type)) {\n            return handleList(value, (GraphQLList) type);\n        }\n\n        \/\/ Populate the fields of the input object by creating ASTs from each value\n        \/\/ in the JavaScript object according to the fields in the input type.\n        if (type instanceof GraphQLInputObjectType) {\n            return handleInputObject(value, (GraphQLInputObjectType) type);\n        }\n\n        if (!(type instanceof GraphQLScalarType || type instanceof GraphQLEnumType)) {\n            throw new AssertException(\"Must provide Input Type, cannot use: \" + type.getClass());\n        }\n\n        \/\/ Since value is an internally represented value, it must be serialized\n        \/\/ to an externally represented value before converting into an AST.\n        final Object serialized = serialize(type, value);\n        if (isNullish(serialized)) {\n            return null;\n        }\n\n        \/\/ Others serialize based on their corresponding JavaScript scalar types.\n        if (serialized instanceof Boolean) {\n            return BooleanValue.newBooleanValue().value((Boolean) serialized).build();\n        }\n\n        String stringValue = serialized.toString();\n        \/\/ numbers can be Int or Float values.\n        if (serialized instanceof Number) {\n            return handleNumber(stringValue);\n        }\n\n        if (serialized instanceof String) {\n            \/\/ Enum types use Enum literals.\n            if (type instanceof GraphQLEnumType) {\n                return EnumValue.newEnumValue().name(stringValue).build();\n            }\n\n            \/\/ ID types can use Int literals.\n            if (type == Scalars.GraphQLID && stringValue.matches(\"^[0-9]+$\")) {\n                return IntValue.newIntValue().value(new BigInteger(stringValue)).build();\n            }\n\n            \/\/ String types are just strings but JSON'ised\n            return StringValue.newStringValue().value(jsonStringify(stringValue)).build();\n        }\n\n        throw new AssertException(\"'Cannot convert value to AST: \" + serialized);\n    }\n","new_comment_raw":"@return a graphql language ast  Value","old_comment_raw":"@return a grapql language ast Value","label":1,"pre_label":0,"AST_level":11,"line_counts":61,"new_code_token_num":422},{"new_code_raw":"public static boolean isWebpNativelySupported(ImageFormat webpFormat) { switch (webpFormat) { case WEBP_SIMPLE: \/\/ Simple WebPs are supported on Android 4.0+ return Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH; case WEBP_LOSSLESS: case WEBP_EXTENDED: case WEBP_EXTENDED_WITH_ALPHA: return WebpSupportStatus.sIsExtendedWebpSupported; case WEBP_ANIMATED: return false; default: Preconditions.checkArgument(false); return false; } }","old_code_raw":"  public static boolean isWebpNativelySupported(ImageFormat webpFormat) {\n    switch (webpFormat) {\n      case WEBP_SIMPLE: \/\/ Simple WebPs are supported on Android 4.0+\n        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH;\n      case WEBP_LOSSLESS:\n      case WEBP_EXTENDED:\n      case WEBP_EXTENDED_WITH_ALPHA:\n        return mIsExtendedWebpSupported;\n      case WEBP_ANIMATED:\n        return false;\n      default:\n        Preconditions.checkArgument(false);\n        return false;\n    }\n  }\n","new_comment_raw":"@return true if given type of WebP is supported natively by the framework","old_comment_raw":"@return true if given type of WebP is supported natively by the framework","label":0,"pre_label":1,"AST_level":7,"line_counts":16,"new_code_token_num":68},{"new_code_raw":"public ObjectMapper build(JsonFactory factory) { return configure(new ObjectMapper(factory)); }","old_code_raw":"    public ObjectMapper build(JsonFactory factory) {\n        final ObjectMapper mapper = new ObjectMapper(factory);\n\n        for (Module module : modules) {\n            mapper.registerModule(module);\n        }\n\n        for (Map.Entry<MapperFeature, Boolean> entry : mapperFeatures.entrySet()) {\n            mapper.configure(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<DeserializationFeature, Boolean> entry : deserializationFeatures.entrySet()) {\n            mapper.configure(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<SerializationFeature, Boolean> entry : serializationFeatures.entrySet()) {\n            mapper.configure(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<JsonGenerator.Feature, Boolean> entry : generatorFeatures.entrySet()) {\n            mapper.getFactory().configure(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<JsonParser.Feature, Boolean> entry : parserFeatures.entrySet()) {\n            mapper.getFactory().configure(entry.getKey(), entry.getValue());\n        }\n\n        for (Map.Entry<JsonFactory.Feature, Boolean> entry : factoryFeatures.entrySet()) {\n            mapper.getFactory().configure(entry.getKey(), entry.getValue());\n        }\n\n        if (annotationIntrospector != null) {\n            mapper.setAnnotationIntrospector(annotationIntrospector);\n        }\n\n        if (dateFormat != null) {\n            mapper.setDateFormat(dateFormat);\n        }\n\n        if (defaultTyping != null) {\n            mapper.setDefaultTyping(defaultTyping);\n        }\n\n        if (filters != null) {\n            mapper.setFilters(filters);\n        }\n\n        if (handlerInstantiator != null) {\n            mapper.setHandlerInstantiator(handlerInstantiator);\n        }\n\n        if (injectableValues != null) {\n            mapper.setInjectableValues(injectableValues);\n        }\n\n        if (locale != null) {\n            mapper.setLocale(locale);\n        }\n\n        if (mixinAnnotations != null) {\n            mapper.setMixInAnnotations(mixinAnnotations);\n        }\n\n        if (nodeFactory != null) {\n            mapper.setNodeFactory(nodeFactory);\n        }\n\n        if (propertyNamingStrategy != null) {\n            mapper.setPropertyNamingStrategy(propertyNamingStrategy);\n        }\n\n        if (serializationInclusion != null) {\n            mapper.setSerializationInclusion(serializationInclusion);\n        }\n\n        if (serializerFactory != null) {\n            mapper.setSerializerFactory(serializerFactory);\n        }\n\n        if (serializerProvider != null) {\n            mapper.setSerializerProvider(serializerProvider);\n        }\n\n        if (subtypeResolver != null) {\n            mapper.setSubtypeResolver(subtypeResolver);\n        }\n\n        if (timeZone != null) {\n            mapper.setTimeZone(timeZone);\n        }\n\n        if (typeFactory != null) {\n            mapper.setTypeFactory(typeFactory);\n        }\n\n        for (Map.Entry<PropertyAccessor, JsonAutoDetect.Visibility> rule : visibilityRules.entrySet()) {\n            mapper.setVisibility(rule.getKey(), rule.getValue());\n        }\n\n        if (visibilityChecker != null) {\n            mapper.setVisibilityChecker(visibilityChecker);\n        }\n\n\n        return mapper;\n    }\n","new_comment_raw":"@return a configured  ObjectMapper instance","old_comment_raw":"@return a configured ObjectMapper instance","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public static String addPropertiesToURI(URI uri, Map<String, String> properties) throws Exception { return addPropertiesToURI(uri.toString(), properties); }","old_code_raw":"public static String addPropertiesToURI(URI uri, Map<String, String> props) throws Exception {\n    return addPropertiesToURI(uri.toString(), props);\n}","new_comment_raw":"@return a new String value that is the original URI with the added bean properties.","old_comment_raw":"@return uri with properties on","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":29},{"new_code_raw":"public ArrayList<ListView> getCurrentListViews() { return getCurrentViews(ListView.class); }","old_code_raw":"\tpublic ArrayList<ListView> getCurrentListViews() {\n\t\tArrayList<ListView> listViews = new ArrayList<ListView>();\n\t\tArrayList<View> viewList = getViews();\n\t\tfor(View view : viewList){\n\t\t\tif (view instanceof android.widget.ListView)\n\t\t\t\tlistViews.add((ListView) view);\n\t\t}\n\t\treturn listViews;\n\t}\n","new_comment_raw":"@return a  List of the  ListViews contained in the current  Activity","old_comment_raw":"@return a List of the ListViews contained in the current Activity","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"@ManagedAttribute(description = STR) public long getAggregationCount() { return aggregationCount.longValue(); }","old_code_raw":"public LongAdder getAggregationCount() {\n    return aggregationCount;\n}","new_comment_raw":"@return the total number of aggregation executions","old_comment_raw":"@return the aggregationCount","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"private boolean match(Way w1, Way w2) { if (w1.id == NUM || w2.id == NUM) { if (w1.nodes.size() != w2.nodes.size()) return false; Iterator<Node> it = w1.nodes.iterator(); for (Node n : w2.nodes) if (!match(n, it.next())) return false; return true; } return w1.id == w2.id; }","old_code_raw":"private boolean match(Segment ls1, Segment ls2) {\n    if (ls1.id == ls2.id && ls1.id != NUM)\n        return true;\n    if (ls1.incomplete || ls2.incomplete)\n        return false;\n    return match(ls1.from, ls2.from) && match(ls1.to, ls2.to);\n}","new_comment_raw":"@return Whether the ways match (in sense of \"be mergable\").","old_comment_raw":"@return Whether the segments matches (in sense of \"be mergable\").","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":84},{"new_code_raw":"public SortedSet<String> getUsedNames() { return Collections.unmodifiableSortedSet(mUsedNames); }","old_code_raw":"public SimpleArrayMap<String, String> getUsedNames() {\n    return mUsedNames;\n}","new_comment_raw":"@return An alphabetically sorted list of all of the names that have already been used. This list is not modifiable, but is backed by the real list and will stay updated.","old_comment_raw":"@return A list of all of the names that have already been used.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":15},{"new_code_raw":"public CustomFuture<RECEIVE> send(SEND messageToSend, ByteBuf... dataBodies) { final CustomMessage customMessage = CustomMessage.newBuilder() .setMessage(ByteString.copyFrom(send.serializeToSend(messageToSend))) .setType(messageTypeId) .build(); final SyncCustomMessageSender b = new SyncCustomMessageSender(customMessage, dataBodies); manager.runCommand(b); DrillRpcFuture<CustomMessage> innerFuture = b.getFuture(); return new CustomFuture<RECEIVE>(receive, innerFuture); }","old_code_raw":"    public CustomFuture<RECEIVE> send(SEND messageToSend, ByteBuf... dataBodies) {\n      final CustomMessage customMessage = CustomMessage.newBuilder()\n          .setMessage(messageToSend.toByteString())\n          .setType(messageTypeId)\n          .build();\n      final SyncCustomMessageSender b = new SyncCustomMessageSender(customMessage, dataBodies);\n      manager.runCommand(b);\n      DrillRpcFuture<CustomMessage> innerFuture = b.getFuture();\n      return new CustomFuture<RECEIVE>(parser, innerFuture);\n    }\n","new_comment_raw":"@return The CustomFuture that can be used to wait for the response.","old_comment_raw":"@return The CustomFuture that can be used to wait for the response.","label":0,"pre_label":1,"AST_level":9,"line_counts":11,"new_code_token_num":75},{"new_code_raw":"public boolean supports(AuthenticationToken token) { if (log.isInfoEnabled()) { log.info(STR + STR); } return token != null && getAuthenticationTokenClass().isAssignableFrom(token.getClass()); }","old_code_raw":"public boolean supports(Class tokenClass) {\n    return getAuthenticationTokenClass().isAssignableFrom(tokenClass);\n}","new_comment_raw":"@return true if this authentication realm can process the submitted token instance of the class, false otherwise.","old_comment_raw":"@return true if this authentication realm \"understands\" how to process submissions for the submitted token instances of the class, false otherwise.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":43},{"new_code_raw":"public HBaseResponse getHTableInfo(String tableName) throws IOException { \/\/ Get HBase storage conf. String hbaseUrl = KylinConfig.getInstanceFromEnv().getStorageUrl(); Configuration hconf = HadoopUtil.newHBaseConfiguration(hbaseUrl); HTable table = null; HBaseResponse hr = null; long tableSize = 0; int regionCount = 0; try { table = new HTable(hconf, tableName); HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table); Map<byte[], Long> sizeMap = cal.getRegionSizeMap(); for (long s : sizeMap.values()) { tableSize += s; } regionCount = sizeMap.size(); \/\/ Set response. hr = new HBaseResponse(); hr.setTableSize(tableSize); hr.setRegionCount(regionCount); } finally { if (null != table) { table.close(); } } return hr; }","old_code_raw":"    public HBaseResponse getHTableInfo(String tableName) throws IOException {\n        if (htableInfoCache.containsKey(tableName)) {\n            return htableInfoCache.get(tableName);\n        }\n\n        Configuration hconf = HBaseConnection.getCurrentHBaseConfiguration();\n        HTable table = null;\n        HBaseResponse hr = null;\n        long tableSize = 0;\n        int regionCount = 0;\n\n        try {\n            table = new HTable(hconf, tableName);\n\n            HBaseRegionSizeCalculator cal = new HBaseRegionSizeCalculator(table);\n            Map<byte[], Long> sizeMap = cal.getRegionSizeMap();\n\n            for (long s : sizeMap.values()) {\n                tableSize += s;\n            }\n\n            regionCount = sizeMap.size();\n\n            \/\/ Set response.\n            hr = new HBaseResponse();\n            hr.setTableSize(tableSize);\n            hr.setRegionCount(regionCount);\n        } finally {\n            if (null != table) {\n                table.close();\n            }\n        }\n\n        htableInfoCache.put(tableName, hr);\n\n        return hr;\n    }\n","new_comment_raw":"@return The HBaseResponse object contains table size, region count. null if error happens.","old_comment_raw":"@return The HBaseResponse object contains table size, region count. null if error happens.","label":0,"pre_label":1,"AST_level":8,"line_counts":35,"new_code_token_num":146},{"new_code_raw":"public int getIndexOf(Object object) { int index = tableModel.getUsers().indexOf(object); if (index < 0 && customUsers != null) return ArrayUtils.indexOf(customUsers, object); return index; }","old_code_raw":"\t\tpublic int getIndexOf(Object object) {\n\t\t\treturn tableModel.getUsers().indexOf(object);\n\t\t}\n","new_comment_raw":"@return The index of the specified element in the model's item list, or -1 if it wasn't found","old_comment_raw":"@return The index of the specified element in the model's item list.","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":42},{"new_code_raw":"public int getMaximumValue(PartialInstant instant, int[] values) { return getWrappedField().getMaximumValue(instant, values) + 1; }","old_code_raw":"    public int getMaximumValue(PartialInstant instant) {\n        return getWrappedField().getMaximumValue(instant) + 1;\n    }\n","new_comment_raw":"@return the maximum value","old_comment_raw":"@return the maximum value","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public ReadWritableInstantFieldProperty dayOfMonth() { return new ReadWritableInstantFieldProperty(this, getChronology().dayOfMonth()); }","old_code_raw":"    public MutableDateTimeFieldProperty dayOfMonth() {\n        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());\n    }\n","new_comment_raw":"@return the day of month property","old_comment_raw":"@return the day of month property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public ReadWritableInstantFieldProperty era() { return new ReadWritableInstantFieldProperty(this, getChronology().era()); }","old_code_raw":"    public MutableDateTimeFieldProperty era() {\n        return new MutableDateTimeFieldProperty(this, getChronology().era());\n    }\n","new_comment_raw":"@return the era property","old_comment_raw":"@return the era property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public static boolean isNetworkAvailable(NetType netType) { getConnectivityManager(); return isConnected(netType, sConnectivityManager.getActiveNetworkInfo()); }","old_code_raw":"    public static boolean isNetworkAvailable(NetType netType) {\n        getConnectivityManager();\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            Network[] networkArray = sConnectivityManager.getAllNetworks();\n            for (Network network : networkArray) {\n                NetworkInfo networkInfo = sConnectivityManager.getNetworkInfo(network);\n                if (isConnected(netType, networkInfo)) return true;\n            }\n        } else {\n            NetworkInfo[] networkInfoArray = sConnectivityManager.getAllNetworkInfo();\n            for (NetworkInfo networkInfo : networkInfoArray) {\n                if (isConnected(netType, networkInfo)) return true;\n            }\n        }\n        return false;\n    }\n","new_comment_raw":"@return Connection state return true, otherwise it returns false.","old_comment_raw":"@return Connection state return true, otherwise it returns false.","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public Definition emit(Class cls, String allowedMethods) throws Exception { this.cls = cls; this.allowedMethods = allowedMethods; String name = cls.getName(); name = name.substring(name.lastIndexOf(STR) + NUM); setServiceName(name); return emit(); }","old_code_raw":"public Document emit(Class cls, String allowedMethods) throws Exception {\n    this.cls = cls;\n    this.allowedMethods = allowedMethods;\n    String name = cls.getName();\n    name = name.substring(name.lastIndexOf(STR) + NUM);\n    setServiceName(name);\n    return emit();\n}","new_comment_raw":"@return WSDL <code>Definition<\/code>","old_comment_raw":"@return WSDL <code>Document<\/code>","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":52},{"new_code_raw":"public boolean isValid(boolean fail) { if (!super.isValid(fail)) { assert !fail; return false; } if (!RexUtil.compatibleTypes( exps, getRowType(), true)) { assert !fail; return false; } RexChecker checker = new RexChecker( getInput().getRowType(), fail); for (RexNode exp : exps) { exp.accept(checker); } if (checker.getFailureCount() > 0) { assert !fail; return false; } if (!Util.isDistinct(rowType.getFieldNames())) { assert !fail : rowType; return false; } \/\/CHECKSTYLE: IGNORE 1 if (false && !Util.isDistinct( Functions.adapt( exps, new Function1<RexNode, Object>() { public Object apply(RexNode a0) { return a0.toString(); } }))) { \/\/ Projecting the same expression twice is usually a bad idea, \/\/ because it may create expressions downstream which are equivalent \/\/ but which look different. We can't ban duplicate projects, \/\/ because we need to allow \/\/ \/\/ SELECT a, b FROM c UNION SELECT x, x FROM z assert !fail : exps; return false; } return true; }","old_code_raw":"  public boolean isValid(boolean fail) {\n    if (!super.isValid(fail)) {\n      assert !fail;\n      return false;\n    }\n    if (!RexUtil.compatibleTypes(\n        exps,\n        getRowType(),\n        true)) {\n      assert !fail;\n      return false;\n    }\n    RexChecker checker =\n        new RexChecker(\n            getInput().getRowType(), fail);\n    for (RexNode exp : exps) {\n      exp.accept(checker);\n    }\n    if (checker.getFailureCount() > 0) {\n      assert !fail;\n      return false;\n    }\n    if (collationList == null) {\n      assert !fail;\n      return false;\n    }\n    if (!collationList.isEmpty()\n        && collationList.get(0)\n        != traitSet.getTrait(RelCollationTraitDef.INSTANCE)) {\n      assert !fail;\n      return false;\n    }\n    if (!Util.isDistinct(rowType.getFieldNames())) {\n      assert !fail : rowType;\n      return false;\n    }\n    \/\/CHECKSTYLE: IGNORE 1\n    if (false && !Util.isDistinct(\n        Functions.adapt(\n            exps,\n            new Function1<RexNode, Object>() {\n              public Object apply(RexNode a0) {\n                return a0.toString();\n              }\n            }))) {\n      \/\/ Projecting the same expression twice is usually a bad idea,\n      \/\/ because it may create expressions downstream which are equivalent\n      \/\/ but which look different. We can't ban duplicate projects,\n      \/\/ because we need to allow\n      \/\/\n      \/\/  SELECT a, b FROM c UNION SELECT x, x FROM z\n      assert !fail : exps;\n      return false;\n    }\n    return true;\n  }\n","new_comment_raw":"@return List of (expression, name) pairs","old_comment_raw":"@return List of (expression, name) pairs","label":0,"pre_label":1,"AST_level":10,"line_counts":47,"new_code_token_num":244},{"new_code_raw":"public Single<Bitmap> cropAsSingle(final Uri sourceUri) { return Single.fromCallable(new Callable<Bitmap>() { @Override public Bitmap call() throws Exception { if (sourceUri != null) mSourceUri = sourceUri; return cropImage(); } }).doOnSubscribe(new Consumer<Disposable>() { @Override public void accept(@NonNull Disposable disposable) throws Exception { mIsCropping.set(true); } }).doFinally(new Action() { @Override public void run() throws Exception { mIsCropping.set(false); } }); }","old_code_raw":"  public Single<Bitmap> cropAsSingle() {\n    return Single.fromCallable(new Callable<Bitmap>() {\n\n      @Override public Bitmap call() throws Exception {\n        return cropImage();\n      }\n    }).doOnSubscribe(new Consumer<Disposable>() {\n      @Override public void accept(@NonNull Disposable disposable) throws Exception {\n        mIsCropping.set(true);\n      }\n    }).doFinally(new Action() {\n      @Override public void run() throws Exception {\n        mIsCropping.set(false);\n      }\n    });\n  }\n","new_comment_raw":"@return Single of cropping image","old_comment_raw":"@return Single of cropping image","label":0,"pre_label":1,"AST_level":10,"line_counts":18,"new_code_token_num":106},{"new_code_raw":"private boolean waitUntilResume(Runnable run, boolean deletePreviousRunnables) { if (mPaused) { Log.i(TAG, \"Deferring update until onResume\"); if (deletePreviousRunnables) { while (mBindOnResumeCallbacks.remove(run)) { } } mBindOnResumeCallbacks.add(run); return true; } else { return false; } }","old_code_raw":"    private boolean waitUntilResume(Runnable run) {\n        return waitUntilResume(run, false);\n    }\n","new_comment_raw":"@return true if we are currently paused. The caller might be able to skip some work in that case since we will come back again.","old_comment_raw":"@return true if we are currently paused. The caller might be able to skip some work","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":62},{"new_code_raw":"public OuterComposite executeAs(Function<Response, Response> handler) { Type type = new TypeToken<OuterComposite>(){}.getType(); return execute(handler).as(type); }","old_code_raw":"        public OuterComposite executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<OuterComposite>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n","new_comment_raw":"@return OuterComposite","old_comment_raw":"@return OuterComposite","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public int track(IProgressMonitor monitor) throws CoreException, OperationCanceledException { long currentTime = System.currentTimeMillis(); long totalTime = currentTime + timeout; CloudFoundryServerBehaviour behaviour = cloudServer.getBehaviour(); String appName = appModule.getDeployedApplicationName(); printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_STARTING_TRACKING, appName), appModule); int state = IServer.STATE_UNKNOWN; while (state != IServer.STATE_STARTED && state != IServer.STATE_STOPPED && currentTime < totalTime) { if (monitor != null && monitor.isCanceled()) { String error = NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_CHECK_CANCELED, appName); printlnToConsole(error, appModule); throw new OperationCanceledException(error); } CloudApplication cloudApp = behaviour.getCloudApplication(appName, monitor); ApplicationStats applicationStats = behaviour.getApplicationStats(appName, monitor); if (cloudApp == null) { String error = NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_NOT_EXISTS, appName); printlnToConsole(error, appModule); throw CloudErrorUtil.toCoreException(error); } else { state = CloudFoundryApplicationModule.getCloudState(cloudApp, applicationStats); try { Thread.sleep(WAIT_TIME); } catch (InterruptedException e) { } currentTime = System.currentTimeMillis(); } } String runningStateMessage = state == IServer.STATE_STARTED ? NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_RUNNING, appName) : NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_NOT_RUNNING, appName); printlnToConsole(runningStateMessage, appModule); return state; }","old_code_raw":"public int track(IProgressMonitor monitor) throws CoreException {\n    long currentTime = System.currentTimeMillis();\n    long totalTime = currentTime + timeout;\n    CloudFoundryApplicationModule appModule = cloudServer.getBehaviour().updateModuleWithAllCloudInfo(appName, monitor);\n    printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_STARTING_TRACKING, appName), appModule);\n    int state = appModule.getState();\n    while (state != IServer.STATE_STARTED && state != IServer.STATE_STOPPED && currentTime < totalTime) {\n        appModule = cloudServer.getBehaviour().updateModuleWithAllCloudInfo(appName, monitor);\n        if (appModule == null || appModule.getApplication() == null) {\n            printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_NOT_EXISTS, appName), appModule);\n            return IServer.STATE_UNKNOWN;\n        }\n        if (monitor != null && monitor.isCanceled()) {\n            printlnToConsole(NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_CHECK_CANCELED, appName), appModule);\n            return IServer.STATE_UNKNOWN;\n        }\n        state = appModule.getState();\n        try {\n            Thread.sleep(WAIT_TIME);\n        } catch (InterruptedException e) {\n        }\n        currentTime = System.currentTimeMillis();\n    }\n    String runningStateMessage = state == IServer.STATE_STARTED ? NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_RUNNING, appName) : NLS.bind(Messages.ApplicationInstanceStartingTracker_APPLICATION_IS_NOT_RUNNING, appName);\n    printlnToConsole(runningStateMessage, appModule);\n    return state;\n}","new_comment_raw":"@return One of the following application running states: {@link IServer#STATE_STARTED}, {@link IServer#STATE_STOPPED}, {@link IServer#STATE_UNKNOWN}","old_comment_raw":"@return One of the following application running states: {@link IServer#STATE_STARTED}, {@link IServer#STATE_STARTING}, {@link IServer#STATE_STOPPED}, {@link IServer#STATE_STOPPING}, {@link IServer#STATE_UNKNOWN}","label":1,"pre_label":0,"AST_level":10,"line_counts":32,"new_code_token_num":237},{"new_code_raw":"protected Object convertTimeToNanosPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return NanoTime.toNanoOfDay(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimeToNanosPastMidnight(Column column, Field fieldDefn, Object data) {\n        if ( data == null ) return null;\n        try {\n            return NanoTime.toNanoOfDay(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":82},{"new_code_raw":"public Iterable<RelNode> getRels() { return new Iterable<RelNode>() { public Iterator<RelNode> iterator() { return Linq4j.asEnumerable(set.rels) .where( new Predicate1<RelNode>() { public boolean apply(RelNode v1) { return v1.getTraitSet().subsumes(traitSet); } }) .iterator(); } }; }","old_code_raw":"    public Iterable<RelNode> getRels() {\n        return new Iterable<RelNode>() {\n            public Iterator<RelNode> iterator() {\n                return Linq4j.asEnumerable(set.rels)\n                    .where(\n                        new Predicate1<RelNode>() {\n                            public boolean apply(RelNode v1) {\n                                return v1.getTraitSet().equals(traitSet);\n                            }\n                        })\n                    .iterator();\n            }\n        };\n    }\n","new_comment_raw":"@return all the rels in the subset","old_comment_raw":"@return all the rels in the subset","label":0,"pre_label":1,"AST_level":14,"line_counts":15,"new_code_token_num":65},{"new_code_raw":"public RepositoryMethodMetadata lookupMethod(RepositoryMetadata repositoryMetadata, Method method) { return repositoryMetadata.getMethodsMetadata().get(method); }","old_code_raw":"public RepositoryMethodMetadata lookupMethod(Class<?> repoClass, Method method) {\n    return lookupComponent(repoClass).getMethodsMetadata().get(method);\n}","new_comment_raw":"@return A {@link RepositoryMethodMetadata}.","old_comment_raw":"@return A {@link RepositoryMethodMetadataInitializer} corresponding to the method parameter.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":22},{"new_code_raw":"public String toString() { return String.format(\"%s:%s:%s%s%s%s\", path, volume.getPath(), accessMode.toString(), secMode != SELContext.none ? \",\" + secMode.toString() : \"\", noCopy != null ? \",nocopy\" : \"\", propagationMode != PropagationMode.DEFAULT_MODE ? \",\" + propagationMode.toString() : \"\"); }","old_code_raw":"    public String toString() {\n        return String.format(\"%s:%s:%s%s\",\n                path,\n                volume.getPath(),\n                accessMode.toString(),\n                secMode != SELContext.none ? \",\" + secMode.toString() : \"\");\n    }\n","new_comment_raw":"@return a string representation of this  Bind","old_comment_raw":"@return a string representation of this Bind","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":87},{"new_code_raw":"public int getClientY() { if (null != details) { return details.getClientY(); } else { return -NUM; } }","old_code_raw":"public int getClientY() {\n    return details.getClientY();\n}","new_comment_raw":"@return The mouse cursor y position or -1 if unknown","old_comment_raw":"@return The mouse cursor y position","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":28},{"new_code_raw":"@GET public Set<CassandraInstance> findAll() { return service.findAll(); }","old_code_raw":"@GET\npublic List<CassandraInstance> findAll() {\n    return service.findAll();\n}","new_comment_raw":"@return the set of Cassandra instances","old_comment_raw":"@return the list of Cassandra instances","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"private HttpPanelResponse getResponsePanel() { if (responsePanel == null) { responsePanel = new HttpPanelResponse(false, extension, httpMessage); } return responsePanel; }","old_code_raw":"\tpublic HttpPanel getResponsePanel() {\n\t\tif (responsePanel == null) {\n\t\t\tresponsePanel = new HttpPanel(false);\n\t\t}\n\t\treturn responsePanel;\n\t}\n","new_comment_raw":"@return org.parosproxy.paros.view.HttpPanel","old_comment_raw":"@return org.parosproxy.paros.view.HttpPanel","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":28},{"new_code_raw":"public LocalTime withMaximumValue() { return setCopy(getMaximumValue()); }","old_code_raw":"        public LocalTime withMaximumValue() {\n            return withValue(getMaximumValue());\n        }\n","new_comment_raw":"@return a copy of the LocalTime with this field set to its maximum","old_comment_raw":"@return a copy of the LocalTime with this field set to its maximum","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public String[] checkAllWords(String words) { List<String> misspelledWords = new ArrayList<String>(); StringWordTokenizer tokenizer = new StringWordTokenizer(words); while (tokenizer.hasMoreWords()) { String word = tokenizer.nextWord(); if (!isWordCorrect(word, tokenizer.isNewSentence())) { misspelledWords.add(word); } } return misspelledWords.toArray(new String[NUM]); }","old_code_raw":"public String[] checkAllWords(String words) {\n    List<String> misspeltWords = new ArrayList<String>();\n    StringWordTokenizer tokenizer = new StringWordTokenizer(words);\n    while (tokenizer.hasMoreWords()) {\n        String word = tokenizer.nextWord();\n        if (!isWordCorrect(word, tokenizer.isNewSentence())) {\n            misspeltWords.add(word);\n        }\n    }\n    return misspeltWords.toArray(new String[NUM]);\n}","new_comment_raw":"@return string array of misspelled words","old_comment_raw":"@return string array of misspelt words","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":76},{"new_code_raw":"public static UserAdapter createUserSpinnerAdapter(UserManager userManager, Context context) { List<UserHandle> userProfiles = userManager.getUserProfiles(); if (userProfiles.size() < NUM) { return null; } UserHandle myUserHandle = new UserHandle(UserHandle.myUserId()); userProfiles.remove(myUserHandle); userProfiles.add(NUM, myUserHandle); return createUserAdapter(userManager, context, userProfiles); }","old_code_raw":"public static UserSpinnerAdapter createUserSpinnerAdapter(UserManager userManager, Context context) {\n    List<UserHandle> userProfiles = userManager.getUserProfiles();\n    if (userProfiles.size() < NUM) {\n        return null;\n    }\n    UserHandle myUserHandle = new UserHandle(UserHandle.myUserId());\n    userProfiles.remove(myUserHandle);\n    userProfiles.add(NUM, myUserHandle);\n    ArrayList<UserDetails> userDetails = new ArrayList<UserDetails>(userProfiles.size());\n    final int count = userProfiles.size();\n    for (int i = NUM; i < count; i++) {\n        userDetails.add(new UserDetails(userProfiles.get(i), userManager, context));\n    }\n    return new UserSpinnerAdapter(context, userDetails);\n}","new_comment_raw":"@return a {@link UserAdapter} or null if there is only one profile.","old_comment_raw":"@return a {@link UserSpinnerAdapter} or null if there is only one profile.","label":1,"pre_label":0,"AST_level":6,"line_counts":10,"new_code_token_num":69},{"new_code_raw":"public ReadWritableInstantFieldProperty millisOfDay() { return new ReadWritableInstantFieldProperty(this, getChronology().millisOfDay()); }","old_code_raw":"    public MutableDateTimeFieldProperty millisOfDay() {\n        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());\n    }\n","new_comment_raw":"@return the millis of day property","old_comment_raw":"@return the millis of day property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) { return appendDecimal(DateTimeFieldType.clockhourOfHalfday(), minDigits, 2); }","old_code_raw":"    public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {\n        return appendDecimal(iChronoUTC.clockhourOfHalfday(), minDigits, 2);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public ExecutionStepInfo changeTypeWithPreservedNonNull(GraphQLType newType) { assertTrue(!GraphQLTypeUtil.isNonNull(newType), \"newType can't be non null\"); if (isNonNullType()) { return new ExecutionStepInfo(GraphQLNonNull.nonNull(newType), fieldDefinition, field, path, this.parent, arguments, directives); } else { return new ExecutionStepInfo(newType, fieldDefinition, field, path, this.parent, arguments, directives); } }","old_code_raw":"    public ExecutionStepInfo changeTypeWithPreservedNonNull(GraphQLType newType) {\n        assertTrue(!GraphQLTypeUtil.isNonNull(newType), \"newType can't be non null\");\n        if (isNonNullType()) {\n            return new ExecutionStepInfo(GraphQLNonNull.nonNull(newType), fieldDefinition, field, path, this.parent, arguments);\n        } else {\n            return new ExecutionStepInfo(newType, fieldDefinition, field, path, this.parent, arguments);\n        }\n    }\n","new_comment_raw":"@return a new type info with the same","old_comment_raw":"@return a new type info with the same","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":84},{"new_code_raw":"public String getInitParameter(String name) { try { return framework.getServletConfig().getInitParameter(name); } catch (Throwable ex) { \/\/ Don't fail if Tomcat crash on startup with an NPE return null; } }","old_code_raw":"    public String getInitParameter(String name) {\n        try {\n        \tString value=framework.getServletConfig().getInitParameter(name);\n        \tif(value==null && useServletContextParameters) {\n        \t\tvalue=framework.getServletContext().getInitParameter(name);\n        \t}\n        \treturn value;\n        } catch (Throwable ex) {\n            \/\/ Don't fail if Tomcat crash on startup with an NPE\n            return null;\n        }\n    }\n","new_comment_raw":"@return the list of init params defined in web.xml or application.xml","old_comment_raw":"@return the value for the init parameter if defined","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":46},{"new_code_raw":"public boolean preloadBundle(Bundle bundle) { return true; }","old_code_raw":"public boolean preloadBundle(Bundle bundle) {\n    return false;\n}","new_comment_raw":"@return true: can load the bundle, false: cannot","old_comment_raw":"@return true: can launch bundle, false: otherwise","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public VisualItem findItem(Point p) { Point2D p2 = (m_itransform == null ? p : m_itransform.transform(p, m_tmpPoint)); synchronized (m_registry) { Iterator items = m_registry.getItemsReversed(); while (items.hasNext()) { VisualItem vi = (VisualItem) items.next(); Renderer r = vi.getRenderer(); if (r != null && r.locatePoint(p2, vi)) { return vi; } } } return null; }","old_code_raw":"public GraphItem findItem(Point p) {\n    Point2D p2 = (m_itransform == null ? p : m_itransform.transform(p, m_tmpPoint));\n    synchronized (m_registry) {\n        Iterator items = m_registry.getItemsReversed();\n        while (items.hasNext()) {\n            GraphItem gi = (GraphItem) items.next();\n            Renderer r = gi.getRenderer();\n            if (r != null && r.locatePoint(p2, gi)) {\n                return gi;\n            }\n        }\n    }\n    return null;\n}","new_comment_raw":"@return the VisualItem located at the given point, if any","old_comment_raw":"@return the GraphItem located at the given point, if any","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":88},{"new_code_raw":"public VariationService createVariationService() { return createVariationService(defaultEndpointUrl); }","old_code_raw":"public VariationService createVariationService() {\n    return createVariationService(defaultServerUrl);\n}","new_comment_raw":"@return a new variation service with the default endpoint URL","old_comment_raw":"@return a new variation service with the default server URL","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"static boolean isAllNulls(ColumnStatistics stat, long rowCount) { Preconditions.checkArgument(rowCount >= 0, String.format(\"negative rowCount %d is not valid\", rowCount)); return ColumnStatisticsKind.NULLS_COUNT.getFrom(stat) == rowCount; }","old_code_raw":"  static boolean isAllNulls(ColumnStatistics stat, long rowCount) {\n    Preconditions.checkArgument(rowCount >= 0, String.format(\"negative rowCount %d is not valid\", rowCount));\n    return (long) stat.getStatistic(ColumnStatisticsKind.NULLS_COUNT) == rowCount;\n  }\n","new_comment_raw":"@return true if all rows are null, false otherwise","old_comment_raw":"@return true if all rows are null, false otherwise","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":44},{"new_code_raw":"public ParameterMetadata getSQLParameterMetadata(final String query) { ParameterMetadata value = parameterMetadataCache.get( query ); if ( value == null ) { value = buildParameterMetadata( query ); parameterMetadataCache.putIfAbsent( query, value ); } return value; }","old_code_raw":"\tpublic ParameterMetadata getSQLParameterMetadata(String query) {\n\t\tParameterMetadata metadata = ( ParameterMetadata ) sqlParamMetadataCache.get( query );\n\t\tif ( metadata == null ) {\n\t\t\tmetadata = buildNativeSQLParameterMetadata( query );\n\t\t\tsqlParamMetadataCache.put( query, metadata );\n\t\t}\n\t\treturn metadata;\n\t}\n","new_comment_raw":"@return The parameter metadata","old_comment_raw":"@return The parameter metadata","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":42},{"new_code_raw":"public boolean searchText(String text, int minimumNumberOfMatches, boolean scroll) { return searcher.searchWithTimeoutFor(TextView.class, text, minimumNumberOfMatches, scroll); }","old_code_raw":"\tpublic boolean searchText(String regex, int expectedMinimumNumberOfMatches, boolean scroll) {\n\t\treturn searcher.searchWithTimeoutFor(TextView.class, regex, expectedMinimumNumberOfMatches, scroll);\n\t}\n","new_comment_raw":"@return  true if text string is found a given number of times and  false if the text string is not found","old_comment_raw":"@return true if regex string is found a given number of times and false if the regex string is not found","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"protected int getCustomColumnIndex(int columnIndex) { Integer customColumnIndex = cacheColumnIdxToIdxCustomColumnsOnly.get(columnIndex); if (customColumnIndex != null) { return customColumnIndex; } return -1; }","old_code_raw":"    protected int getCustomColumnIndex(int columnIndex) {\n        Integer customColumnIndex = cacheColumnIdxToIdxCustomColumnsOnly.get(Integer.valueOf(columnIndex));\n        if (customColumnIndex != null) {\n            return customColumnIndex.intValue();\n        }\n        return -1;\n    }\n","new_comment_raw":"@return the custom column index as if no default columns existed or -1 if not a custom column.","old_comment_raw":"@return the custom column index as if no default columns existed or -1 if not a custom column.","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":32},{"new_code_raw":"public String getLCS(String strA, String strB) { return algC(strA.length(), strB.length(), strA, strB); }","old_code_raw":"    public String getLCS(String strA, String strB) {\n        if (\"\".equals(strA)) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        algC(sb, strA.length(), strB.length(), strA, strB);\n        return sb.toString();\n    }\n","new_comment_raw":"@return the Longest Common Subsequence of strA and strB","old_comment_raw":"@return the Longest Common Subsequence of strA and strB","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public DateTimeField[] getFields() { DateTimeField[] result = new DateTimeField[getFieldSize()]; for (int i = 0; i < result.length; i++) { result[i] = getField(i); } return result; }","old_code_raw":"    public DateTimeField[] getFields() {\n        return (DateTimeField[]) iFields.clone();\n    }\n","new_comment_raw":"@return the fields supported in an array that may be altered, largest to smallest","old_comment_raw":"@return the fields supported (cloned), largest to smallest","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":49},{"new_code_raw":"public boolean hasUnresolvedEntityInsertActions() { return unresolvedInsertions != null && !unresolvedInsertions.isEmpty(); }","old_code_raw":"\tpublic boolean hasUnresolvedEntityInsertActions() {\n\t\treturn !unresolvedInsertions.isEmpty();\n\t}\n","new_comment_raw":"@return true, if there are unresolved entity insert actions that depend on non-nullable associations with a transient entity; false, otherwise","old_comment_raw":"@return true, if there are unresolved entity insert actions that depend on non-nullable associations with a transient entity; false, otherwise","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public String getEnumString() { if (enumString == null) { return null; } return enumString.value(); }","old_code_raw":"  public EnumStringEnum getEnumString() {\n    return enumString;\n  }\n","new_comment_raw":"@return enumString","old_comment_raw":"@return enumString","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { System.err.printf(\"Untokenizable: %s%n\", yytext()); return getNext(true); } case 9: break; case 2: { return getNewline(); } case 10: break; case 3: { } case 11: break; case 4: { return getNext(false); } case 12: break; case 5: { return getNext(true); } case 13: break; case 6: { return getEllipsis(); } case 14: break; case 7: { if (! removeProMarker) return getNext(false); } case 15: break; case 8: { if (removeProMarker) { if ( ! removeSegMarker) { return getNext(\"-\", yytext()); } } else { return getNext(false); } } case 16: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { System.err.printf(\"Untokenizable: %s%n\", yytext());\n\t      return getNext(true);\n          }\n        case 8: break;\n        case 2: \n          { return getNewline();\n          }\n        case 9: break;\n        case 3: \n          { \n          }\n        case 10: break;\n        case 4: \n          { return getNext(false);\n          }\n        case 11: break;\n        case 5: \n          { return getNext(true);\n          }\n        case 12: break;\n        case 6: \n          { return getEllipsis();\n          }\n        case 13: break;\n        case 7: \n          { if (removeProMarker) {\n                if ( ! removeSegMarker) {\n                  return getNext(\"-\", yytext());\n                }\n              } else {\n                return getNext(false);\n              }\n          }\n        case 14: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":129,"new_code_token_num":503},{"new_code_raw":"public SqlSelect getSourceSelect() { return sourceSelect; }","old_code_raw":"  public SqlSelect getSourceSelect() {\n    return (SqlSelect) operands[SOURCE_SELECT_OPERAND];\n  }\n","new_comment_raw":"@return the source SELECT for the data to be updated","old_comment_raw":"@return the source SELECT for the data to be updated","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public static String getColumnName(String elementType) { if (elementType.equals(ELEMENTTYPE_Organization)) return STR; else if (elementType.equals(ELEMENTTYPE_Account)) return I_C_ValidCombination.COLUMNNAME_Account_ID; else if (elementType.equals(ELEMENTTYPE_BPartner)) return I_C_ValidCombination.COLUMNNAME_C_BPartner_ID; else if (elementType.equals(ELEMENTTYPE_Product)) return I_C_ValidCombination.COLUMNNAME_M_Product_ID; else if (elementType.equals(ELEMENTTYPE_Activity)) return I_C_ValidCombination.COLUMNNAME_C_Activity_ID; else if (elementType.equals(ELEMENTTYPE_LocationFrom)) return I_C_ValidCombination.COLUMNNAME_C_LocFrom_ID; else if (elementType.equals(ELEMENTTYPE_LocationTo)) return I_C_ValidCombination.COLUMNNAME_C_LocTo_ID; else if (elementType.equals(ELEMENTTYPE_Campaign)) return I_C_ValidCombination.COLUMNNAME_C_Campaign_ID; else if (elementType.equals(ELEMENTTYPE_OrgTrx)) return I_C_ValidCombination.COLUMNNAME_AD_OrgTrx_ID; else if (elementType.equals(ELEMENTTYPE_Project)) return I_C_ValidCombination.COLUMNNAME_C_Project_ID; else if (elementType.equals(ELEMENTTYPE_SalesRegion)) return I_C_ValidCombination.COLUMNNAME_C_SalesRegion_ID; else if (elementType.equals(ELEMENTTYPE_UserList1)) return I_C_ValidCombination.COLUMNNAME_User1_ID; else if (elementType.equals(ELEMENTTYPE_UserList2)) return I_C_ValidCombination.COLUMNNAME_User2_ID; else if (elementType.equals(ELEMENTTYPE_UserElement1)) return I_C_ValidCombination.COLUMNNAME_UserElement1_ID; else if (elementType.equals(ELEMENTTYPE_UserElement2)) return I_C_ValidCombination.COLUMNNAME_UserElement2_ID; return STR; }","old_code_raw":"public static String getColumnName(String elementType) {\n    if (elementType.equals(ELEMENTTYPE_Organization))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_Account))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_BPartner))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_Product))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_Activity))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_LocationFrom))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_LocationTo))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_Campaign))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_OrgTrx))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_Project))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_SalesRegion))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_UserList1))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_UserList2))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_UserElement1))\n        return STR;\n    else if (elementType.equals(ELEMENTTYPE_UserElement2))\n        return STR;\n    return STR;\n}","new_comment_raw":"@return column name or \"\" if not found","old_comment_raw":"@return column name","label":1,"pre_label":0,"AST_level":19,"line_counts":33,"new_code_token_num":206},{"new_code_raw":"@VisibleForTesting protected URL createPluginUrl() { try { URL urlForPlugin = new URL(STR + location); gdd.diag(gdd.getLit(STR) + STR + urlForPlugin.toString()); return (urlForPlugin); } catch (MalformedURLException e) { gdd.log.severe(gdd.getLit(STR) + STR + location + STR + e); throw new StopExecutionException(null); } }","old_code_raw":"@VisibleForTesting\nprotected URL createPluginUrl() {\n    URL urlForPlugin = null;\n    try {\n        urlForPlugin = new URL(STR + location);\n        gdd.diag(gdd.getLit(STR) + STR + urlForPlugin.toString());\n    } catch (MalformedURLException e) {\n        gdd.log.severe(gdd.getLit(STR) + STR + location + STR + e);\n        throw new StopExecutionException(null);\n    }\n    return (urlForPlugin);\n}","new_comment_raw":"@return a valid URL, if all went well.","old_comment_raw":"@return a valid URL, if all went well; else null;","label":1,"pre_label":0,"AST_level":12,"line_counts":11,"new_code_token_num":77},{"new_code_raw":"public Method getMethod() { return method; }","old_code_raw":"public int getMethod() {\n    return method;\n}","new_comment_raw":"@return the request method","old_comment_raw":"@return The integer value of the method","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public static PartitionMetadata getPartitionMetadata(SchemaPath partitionColumn, List<FileMetadata> files, String tableName) { Set<Path> locations = new HashSet<>(); Set<SchemaPath> columns = new HashSet<>(); for (FileMetadata file : files) { columns.addAll(file.getColumnsStatistics().keySet()); locations.add(file.getLocation()); } Map<String, Object> partStatistics = new HashMap<>(); partStatistics.put(TableStatisticsKind.ROW_COUNT.getName(), TableStatisticsKind.ROW_COUNT.mergeStatistics(files)); return new PartitionMetadata(partitionColumn, files.iterator().next().getSchema(), mergeColumnsStatistics(files, columns, PARQUET_STATISTICS, null), partStatistics, locations, tableName, -1); }","old_code_raw":"  public static PartitionMetadata getPartitionMetadata(SchemaPath partitionColumn, List<FileMetadata> files, String tableName) {\n    Set<Path> locations = new HashSet<>();\n    Set<SchemaPath> columns = new HashSet<>();\n\n    for (FileMetadata file : files) {\n      columns.addAll(file.getColumnsStatistics().keySet());\n      locations.add(file.getLocation());\n    }\n\n    Map<String, Object> partStatistics = new HashMap<>();\n    partStatistics.put(TableStatisticsKind.ROW_COUNT.getName(), TableStatisticsKind.ROW_COUNT.mergeStatistics(files));\n\n    return new PartitionMetadata(partitionColumn, files.iterator().next().getSchema(),\n        mergeColumnsStatistics(files, columns, PARQUET_STATISTICS), partStatistics, locations, tableName, -1);\n  }\n","new_comment_raw":"@return  PartitionMetadata instance","old_comment_raw":"@return PartitionMetadata instance","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":128},{"new_code_raw":"public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\"); } \/\/ verify the required parameter 'requiredFile' is set if (requiredFile == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\"); } \/\/ create path and map variables final Map<String, Object> uriVariables = new HashMap<String, Object>(); uriVariables.put(\"petId\", petId); String path = apiClient.expandPath(\"\/fake\/{petId}\/uploadImageWithRequiredFile\", uriVariables); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); if (additionalMetadata != null) formParams.add(\"additionalMetadata\", additionalMetadata); if (requiredFile != null) formParams.add(\"requiredFile\", new FileSystemResource(requiredFile)); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"multipart\/form-data\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"petstore_auth\" }; ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public ResponseEntity<ModelApiResponse> uploadFileWithRequiredFileWithHttpInfo(Long petId, File requiredFile, String additionalMetadata) throws RestClientException {\n        Object postBody = null;\n        \n        \/\/ verify the required parameter 'petId' is set\n        if (petId == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'petId' when calling uploadFileWithRequiredFile\");\n        }\n        \n        \/\/ verify the required parameter 'requiredFile' is set\n        if (requiredFile == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'requiredFile' when calling uploadFileWithRequiredFile\");\n        }\n        \n        \/\/ create path and map variables\n        final Map<String, Object> uriVariables = new HashMap<String, Object>();\n        uriVariables.put(\"petId\", petId);\n        String path = apiClient.expandPath(\"\/fake\/{petId}\/uploadImageWithRequiredFile\", uriVariables);\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        if (additionalMetadata != null)\n            formParams.add(\"additionalMetadata\", additionalMetadata);\n        if (requiredFile != null)\n            formParams.add(\"requiredFile\", new FileSystemResource(requiredFile));\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"multipart\/form-data\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<ModelApiResponse> returnType = new ParameterizedTypeReference<ModelApiResponse>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@return ResponseEntity&lt;ModelApiResponse&gt;","old_comment_raw":"@return ResponseEntity&lt;ModelApiResponse&gt;","label":0,"pre_label":1,"AST_level":8,"line_counts":43,"new_code_token_num":336},{"new_code_raw":"public static EventDeserializationFailureHandlingMode parse(String value) { if (value == null) return null; value = value.trim(); for (EventDeserializationFailureHandlingMode option : EventDeserializationFailureHandlingMode.values()) { if (option.getValue().equalsIgnoreCase(value)) return option; } return null; }","old_code_raw":"        public static SecureConnectionMode parse(String value, String defaultValue) {\n            SecureConnectionMode mode = parse(value);\n            if (mode == null && defaultValue != null) mode = parse(defaultValue);\n            return mode;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found","old_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":53},{"new_code_raw":"public double getRotZ() { return Math.toDegrees(mOrientation.getRotationZ()); }","old_code_raw":"public double getRotZ() {\n    return mOrientation.getRotationZ();\n}","new_comment_raw":"@return double The pitch Euler angle in degrees.","old_comment_raw":"@return double The pitch Euler angle.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"private AvaticaServerConfiguration buildSpnegoConfiguration(Builder b) { final String principal = b.kerberosPrincipal; final String realm = b.kerberosRealm; final DoAsRemoteUserCallback callback = b.remoteUserCallback; return new AvaticaServerConfiguration() { @Override public AuthenticationType getAuthenticationType() { return AuthenticationType.SPNEGO; } @Override public String getKerberosRealm() { return realm; } @Override public String getKerberosPrincipal() { return principal; } @Override public boolean supportsImpersonation() { return null != callback; } @Override public <T> T doAsRemoteUser(String remoteUserName, String remoteAddress, Callable<T> action) throws Exception { return callback.doAsRemoteUser(remoteUserName, remoteAddress, action); } @Override public String[] getAllowedRoles() { return null; } @Override public String getHashLoginServiceRealm() { return null; } @Override public String getHashLoginServiceProperties() { return null; } }; }","old_code_raw":"    private AvaticaServerConfiguration buildSpnegoConfiguration(Builder b) {\n      final String principal = b.kerberosPrincipal;\n      final String realm = b.kerberosRealm;\n      final DoAsRemoteUserCallback callback = b.remoteUserCallback;\n      return new AvaticaServerConfiguration() {\n\n        @Override public AuthenticationType getAuthenticationType() {\n          return AuthenticationType.SPNEGO;\n        }\n\n        @Override public String getKerberosRealm() {\n          return realm;\n        }\n\n        @Override public String getKerberosPrincipal() {\n          return principal;\n        }\n\n        @Override public boolean supportsImpersonation() {\n          return null != callback;\n        }\n\n        @Override public <T> T doAsRemoteUser(String remoteUserName, String remoteAddress,\n            Callable<T> action) throws Exception {\n          return callback.doAsRemoteUser(remoteUserName, remoteAddress, action);\n        }\n      };\n    }\n","new_comment_raw":"@return A configuration instance.","old_comment_raw":"@return A configuration instance.","label":0,"pre_label":1,"AST_level":9,"line_counts":41,"new_code_token_num":156},{"new_code_raw":"private ZapTextArea getTxtSkipURL() { if (txtSkipURL == null) { txtSkipURL = new ZapTextArea(); txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11)); if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) { txtSkipURL.setSize(new java.awt.Dimension(290,52)); } } return txtSkipURL; }","old_code_raw":"    private JTextArea getTxtSkipURL() {\n        if (txtSkipURL == null) {\n            txtSkipURL = new JTextArea();\n            txtSkipURL.setFont(new java.awt.Font(\"Default\", java.awt.Font.PLAIN, 11));\n    \t    if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {\n    \t    \ttxtSkipURL.setSize(new java.awt.Dimension(290,52));\n    \t    }\n        }\n        return txtSkipURL;\n    }\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextArea","label":1,"pre_label":0,"AST_level":12,"line_counts":11,"new_code_token_num":77},{"new_code_raw":"protected static Serializable deserializeTimestampV2(int meta, ByteArrayInputStream inputStream) throws IOException { long epochSecond = bigEndianLong(inputStream.read(4), 0, 4); int nanoSeconds = deserializeFractionalSecondsInNanos(meta, inputStream); return ZonedDateTime.ofInstant(Instant.ofEpochSecond(epochSecond, nanoSeconds), ZoneId.systemDefault()); }","old_code_raw":"    protected static Serializable deserializeTimestampV2(int meta, ByteArrayInputStream inputStream) throws IOException {\n        long epochSecond = bigEndianLong(inputStream.read(4), 0, 4);\n        int nanoSeconds = deserializeFractionalSecondsInNanos(meta, inputStream);\n        LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(epochSecond, nanoSeconds, ZoneOffset.UTC);\n        return ZonedDateTime.of(localDateTime, ZoneId.systemDefault());\n    }\n","new_comment_raw":"@return the  OffsetDateTime object","old_comment_raw":"@return the OffsetDateTime object","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":57},{"new_code_raw":"public static MRequisitionLine[] forC_OrderLine_ID(Properties ctx, int C_OrderLine_ID, String trxName) { final String whereClause = COLUMNNAME_C_OrderLine_ID + STR; List<MRequisitionLine> list = new Query(ctx, MRequisitionLine.Table_Name, whereClause, trxName).setParameters(new Object[] { C_OrderLine_ID }).list(); return list.toArray(new MRequisitionLine[list.size()]); }","old_code_raw":"public static MRequisitionLine forC_OrderLine_ID(Properties ctx, int C_OrderLine_ID, String trxName) {\n    final String whereClause = COLUMNNAME_C_OrderLine_ID + STR;\n    return new Query(ctx, MRequisitionLine.Table_Name, whereClause, trxName).setParameters(new Object[] { C_OrderLine_ID }).firstOnly();\n}","new_comment_raw":"@return array of Requisition Line(s)","old_comment_raw":"@return Requisition Line","label":1,"pre_label":0,"AST_level":9,"line_counts":5,"new_code_token_num":68},{"new_code_raw":"public static Tree UCPtransform(Tree t) { if (t == null) { return null; } Tree firstChild = t.firstChild(); if (firstChild != null) { List<Pair<TregexPattern,TsurgeonPattern>> ops = Generics.newArrayList(); for (int i = 0; i < operations.length; i++) { for (TregexPattern pattern : matchPatterns[i]) { ops.add(Generics.newPair(pattern, operations[i])); } } return Tsurgeon.processPatternsOnTree(ops, t); } else { return t; } }","old_code_raw":"  public static Tree UCPtransform(Tree t) {\n    if (t == null) {\n      return null;\n    }\n    return Tsurgeon.processPattern(ucpRenameTregex, ucpRenameTsurgeon, t);\n  }\n","new_comment_raw":"@return t transformed","old_comment_raw":"@return t transformed","label":0,"pre_label":1,"AST_level":14,"line_counts":20,"new_code_token_num":104},{"new_code_raw":"public short getRed() { return data[getFirst1DIndex()]; }","old_code_raw":"public short getRed(final int i) {\n    return data[get1DIndex(i)];\n}","new_comment_raw":"@return red value in the first position","old_comment_raw":"@return red value in given position","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":15},{"new_code_raw":"public static String deprocess(String str) { if ((str == null) || (str.length() <= NUM)) return str; STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; StringBuffer buf = new StringBuffer(); int strLen = str.length(); for (int i = NUM; i < strLen; i++) { char c = str.charAt(i); switch(c) { case LRM: continue; case LRE: continue; case PDF: continue; default: buf.append(c); } } return buf.toString(); }","old_code_raw":"public static String deprocess(String str) {\n    if ((str == null) || (str.length() <= NUM) || !isProcessingNeeded())\n        return str;\n    StringBuffer buf = new StringBuffer();\n    int strLen = str.length();\n    for (int i = NUM; i < strLen; i++) {\n        char c = str.charAt(i);\n        switch(c) {\n            case LRM:\n                continue;\n            case LRE:\n                continue;\n            case PDF:\n                continue;\n            default:\n                buf.append(c);\n        }\n    }\n    return buf.toString();\n}","new_comment_raw":"@return string without directional formatting characters","old_comment_raw":"@return string with no directional formatting characters.","label":1,"pre_label":0,"AST_level":9,"line_counts":23,"new_code_token_num":125},{"new_code_raw":"private boolean isLockFree(InetSocketAddress address) throws IOException { try { lockSocket.bind(address); return true; } catch (BindException e) { return false; } catch (SocketException e) { return false; } }","old_code_raw":"  private boolean isLockFree(InetSocketAddress address) throws IOException {\n    try {\n      lockSocket.bind(address);\n      return true;\n    } catch (BindException e) {\n      return false;\n    }\n  }\n","new_comment_raw":"@return true if the lock is locked; false if it is not","old_comment_raw":"@return true if the lock is locked; false if it is not","label":0,"pre_label":1,"AST_level":6,"line_counts":11,"new_code_token_num":43},{"new_code_raw":"public APIResult validate(HttpServletRequest request, String type, Boolean skipDryRun) { try { return validate(request.getInputStream(), type, skipDryRun); } catch (IOException e) { LOG.error(STR, request, e); throw FalconWebException.newException(e, Response.Status.BAD_REQUEST); } }","old_code_raw":"public APIResult validate(HttpServletRequest request, String type, Boolean skipDryRun) {\n    try {\n        EntityType entityType = EntityType.getEnum(type);\n        Entity entity = deserializeEntity(request, entityType);\n        validate(entity);\n        if (entity.getEntityType().isSchedulable()) {\n            Set<String> clusters = EntityUtil.getClustersDefinedInColos(entity);\n            for (String cluster : clusters) {\n                try {\n                    getWorkflowEngine().dryRun(entity, cluster, skipDryRun);\n                } catch (FalconException e) {\n                    throw new FalconException(STR + cluster, e);\n                }\n            }\n        }\n        return new APIResult(APIResult.Status.SUCCEEDED, STR + entityType + STR + entity.getName());\n    } catch (Throwable e) {\n        LOG.error(STR, type, e);\n        throw FalconWebException.newException(e, Response.Status.BAD_REQUEST);\n    }\n}","new_comment_raw":"@return APIResult -Succeeded or Failed","old_comment_raw":"@return APIResule -Succeeded or Failed","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":59},{"new_code_raw":"protected Object convertBigInt(Column column, Field fieldDefn, Object data) { if (data == null) return null; if (data instanceof Long) return data; if (data instanceof Number) { Number value = (Number) data; return new Long(value.longValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? LONG_TRUE : LONG_FALSE; } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertBigInt(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof Long) return data;\n        if (data instanceof Integer) return new Long(((Integer) data).longValue());\n        if (data instanceof Short) return new Long(((Short) data).longValue());\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":0,"pre_label":1,"AST_level":8,"line_counts":13,"new_code_token_num":90},{"new_code_raw":"protected Tree determineNonTrivialHead(Tree t, Tree parent) { String motherCat = tlp.basicCategory(t.label().value()); if (DEBUG) { System.err.println(\"At \" + motherCat + \", my parent is \" + parent); } if (motherCat.equals(\"SBARQ\")) { \/\/ TODO: if we have it set to keep copula as the head, should we \/\/ forget about these relations and just return the copula? for (TregexPattern pattern : headOfCopulaTregex) { TregexMatcher matcher = pattern.matcher(t); if (matcher.matchesAt(t)) { return matcher.getNode(\"head\"); } } \/\/ if none of the above patterns match, use the standard method } \/\/ do VPs with auxiliary as special case if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) { Tree[] kids = t.children(); \/\/ try to find if there is an auxiliary verb if (DEBUG) { System.err.println(\"Semantic head finder: at VP\"); System.err.println(\"Class is \" + t.getClass().getName()); t.pennPrint(System.err); \/\/System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries)); } \/\/ looks for auxiliaries if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) { \/\/ String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"}; \/\/ Including NP etc seems okay for copular sentences but is \/\/ problematic for other auxiliaries, like 'he has an answer' \/\/ But maybe doing ADJP is fine! String[] how = { \"left\", \"VP\", \"ADJP\" }; Tree pti = traverseLocate(kids, how, false); if (DEBUG) { System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti); } if (pti != null) { return pti; \/\/ } else { \/\/ System.err.println(\"------\"); \/\/ System.err.println(\"SemanticHeadFinder failed to reassign head for\"); \/\/ t.pennPrint(System.err); \/\/ System.err.println(\"------\"); } } \/\/ looks for copular verbs if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) { String[] how; if (motherCat.equals(\"SQ\")) { how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"}; } else { how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"}; } Tree pti = traverseLocate(kids, how, false); \/\/ don't allow a temporal to become head if (pti != null && pti.label() != null && pti.label().value().contains(\"-TMP\")) { pti = null; } \/\/ In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative) if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) { boolean foundAnotherNp = false; for (Tree kid : kids) { if (kid == pti) { break; } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) { foundAnotherNp = true; break; } } if ( ! foundAnotherNp) { pti = null; } } if (DEBUG) { System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti); } if (pti != null) { return pti; } else { if (DEBUG) { System.err.println(\"------\"); System.err.println(\"SemanticHeadFinder failed to reassign head for\"); t.pennPrint(System.err); System.err.println(\"------\"); } } } } Tree hd = super.determineNonTrivialHead(t, parent); \/* ---- \/\/ This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out \/\/ Heuristically repair punctuation heads Tree[] hdChildren = hd.children(); if (hdChildren != null && hdChildren.length > 0 && hdChildren[0].isLeaf()) { if (tlp.isPunctuationWord(hdChildren[0].label().value())) { Tree[] tChildren = t.children(); if (DEBUG) { System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label()); } for (int i = tChildren.length - 1; i >= 0; i--) { if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) { hd = tChildren[i]; if (DEBUG) { System.err.printf(\"New head of %s is %s%n\", hd.label(), hd.children()[0].label()); } break; } } } } *\/ if (DEBUG) { System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd); } return hd; }","old_code_raw":"  protected Tree determineNonTrivialHead(Tree t, Tree parent) {\n    String motherCat = tlp.basicCategory(t.label().value());\n\n    if (DEBUG) {\n      System.err.println(\"At \" + motherCat + \", my parent is \" + parent);\n    }\n\n    \/\/ do VPs with auxiliary as special case\n    if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) {\n      Tree[] kids = t.children();\n      \/\/ try to find if there is an auxiliary verb\n\n      if (DEBUG) {\n        System.err.println(\"Semantic head finder: at VP\");\n        System.err.println(\"Class is \" + t.getClass().getName());\n        t.pennPrint(System.err);\n        \/\/System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries));\n      }\n\n      \/\/ looks for auxiliaries\n      if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) {\n        \/\/ String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"};\n        \/\/ Including NP etc seems okay for copular sentences but is\n        \/\/ problematic for other auxiliaries, like 'he has an answer'\n        \/\/ But maybe doing ADJP is fine!\n        String[] how = { \"left\", \"VP\", \"ADJP\" };\n        Tree pti = traverseLocate(kids, how, false);\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        \/\/ } else {\n          \/\/ System.err.println(\"------\");\n          \/\/ System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n          \/\/ t.pennPrint(System.err);\n          \/\/ System.err.println(\"------\");\n        }\n      }\n\n      \/\/ looks for copular verbs\n      if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {\n        String[] how;\n        if (motherCat.equals(\"SQ\")) {\n          how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        } else {\n          how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        }\n        Tree pti = traverseLocate(kids, how, false);\n        \/\/ don't allow a temporal to become head\n        if (pti != null && pti.label() != null && pti.label().value().contains(\"-TMP\")) {\n          pti = null;\n        }\n        \/\/ In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)\n        if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) {\n            boolean foundAnotherNp = false;\n            for (Tree kid : kids) {\n              if (kid == pti) {\n                break;\n              } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) {\n                foundAnotherNp = true;\n                break;\n              }\n            }\n          if ( ! foundAnotherNp) {\n            pti = null;\n          }\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          if (DEBUG) {\n            System.err.println(\"------\");\n            System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n            t.pennPrint(System.err);\n            System.err.println(\"------\");\n          }\n        }\n      }\n    }\n\n    Tree hd = super.determineNonTrivialHead(t, parent);\n\n    \/* ----\n    \/\/ This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out\n    \/\/ Heuristically repair punctuation heads\n    Tree[] hdChildren = hd.children();\n    if (hdChildren != null && hdChildren.length > 0 &&\n        hdChildren[0].isLeaf()) {\n      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {\n         Tree[] tChildren = t.children();\n         if (DEBUG) {\n           System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label());\n         }\n         for (int i = tChildren.length - 1; i >= 0; i--) {\n           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {\n             hd = tChildren[i];\n             if (DEBUG) {\n               System.err.printf(\"New head of %s is %s%n\", hd.label(), hd.children()[0].label());\n             }\n             break;\n           }\n         }\n      }\n    }\n    *\/\n\n    if (DEBUG) {\n      System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd);\n    }\n    return hd;\n  }\n","new_comment_raw":"@return The parse tree that is the head","old_comment_raw":"@return The parse tree that is the head","label":0,"pre_label":1,"AST_level":16,"line_counts":130,"new_code_token_num":1161},{"new_code_raw":"public List<UserItems> get() { return mUserItemList != null ? Collections.unmodifiableList(mUserItemList) : null; }","old_code_raw":"    public List<UserItem> get() {\n        return mUserItemList != null ? Collections.unmodifiableList(mUserItemList) : null;\n    }\n","new_comment_raw":"@return Unmodifiable user item list, or  null.","old_comment_raw":"@return Unmodifiable user item list, or null.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public String knownGtidSet() { AtomicReference<String> gtidSetStr = new AtomicReference<String>(); try { jdbc.query(\"SHOW MASTER STATUS\", rs -> { if (rs.next() && rs.getMetaData().getColumnCount() > 4) { gtidSetStr.set(rs.getString(5));\/\/ GTID set, may be null, blank, or contain a GTID set } }); } catch (SQLException e) { throw new ConnectException(\"Unexpected error while connecting to MySQL and looking at GTID mode: \", e); } String result = gtidSetStr.get(); return result != null ? result : \"\"; }","old_code_raw":"    public String knownGtidSet() {\n        AtomicReference<String> gtidSetStr = new AtomicReference<String>();\n        try {\n            jdbc.query(\"SHOW MASTER STATUS\", rs -> {\n                if (rs.next()) {\n                    gtidSetStr.set(rs.getString(5));\/\/ GTID set, may be null, blank, or contain a GTID set\n                }\n            });\n        } catch (SQLException e) {\n            throw new ConnectException(\"Unexpected error while connecting to MySQL and looking at GTID mode: \", e);\n        }\n\n        return gtidSetStr.get();\n    }\n","new_comment_raw":"@return the string representation of MySQL's GTID sets; never null but an empty string if the server does not use GTIDs","old_comment_raw":"@return the string representation of MySQL's GTID sets.","label":1,"pre_label":0,"AST_level":12,"line_counts":16,"new_code_token_num":125},{"new_code_raw":"private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) { final List<BatchResponse> responseList = new ArrayList<>(requestList.size()); final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList); checkList.clear(); if(batchRequestNodes.isEmpty()) { final BatchResponse response = new BatchResponse(); ErrorInfo ex = ErrorHandler.handler(new ClientDetailsNotFoundException()); response.setStatusCode(500); response.setBody(ex.getMessage()); responseList.add(response) ; return responseList ; } for (BatchRequestNode rootNode : batchRequestNodes) { final BatchRequest rootRequest = rootNode.getRequest(); final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build()); final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo); responseList.add(rootResponse); responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo)); } Collections.sort(responseList, new Comparator<BatchResponse>() { @Override public int compare(BatchResponse source, BatchResponse testee) { return source.getRequestId().compareTo(testee.getRequestId()); } }); checkList = responseList; return responseList; }","old_code_raw":"    private List<BatchResponse> handleBatchRequests(final List<BatchRequest> requestList, final UriInfo uriInfo) {\n\n        final List<BatchResponse> responseList = new ArrayList<>(requestList.size());\n\n        final List<BatchRequestNode> batchRequestNodes = this.resolutionHelper.getDependingRequests(requestList);\n        checkList.clear();\n\n        for (BatchRequestNode rootNode : batchRequestNodes) {\n            final BatchRequest rootRequest = rootNode.getRequest();\n            final CommandStrategy commandStrategy = this.strategyProvider.getCommandStrategy(CommandContext\n                    .resource(rootRequest.getRelativeUrl()).method(rootRequest.getMethod()).build());\n            final BatchResponse rootResponse = commandStrategy.execute(rootRequest, uriInfo);\n\n            responseList.add(rootResponse);\n            responseList.addAll(this.processChildRequests(rootNode, rootResponse, uriInfo));\n        }\n\n        Collections.sort(responseList, new Comparator<BatchResponse>() {\n\n            @Override\n            public int compare(BatchResponse source, BatchResponse testee) {\n                return source.getRequestId().compareTo(testee.getRequestId());\n            }\n        });\n\n        checkList = responseList;\n        return responseList;\n\n    }\n","new_comment_raw":"@return List","old_comment_raw":"@return List","label":0,"pre_label":1,"AST_level":11,"line_counts":37,"new_code_token_num":219},{"new_code_raw":"public SendFileTransfer dccSendFile(File file, User reciever, int timeout) throws IOException { return dccHandler.sendFile(file, reciever, timeout); }","old_code_raw":"public DccFileTransfer dccSendFile(File file, User reciever, int timeout) throws IOException {\n    if (file == null)\n        throw new IllegalArgumentException(STR);\n    if (reciever == null)\n        throw new IllegalArgumentException(STR);\n    DccFileTransfer transfer = new DccFileTransfer(this, file, reciever, timeout);\n    transfer.doSend(true);\n    return transfer;\n}","new_comment_raw":"@return When the transfer is finished returns the {@link SendFileTransfer} used","old_comment_raw":"@return The DccFileTransfer that can be used to monitor this transfer.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":28},{"new_code_raw":"public boolean isClosing(){ return closing.get(); }","old_code_raw":"    public boolean isClosing(){\n        return closing;\n    }\n","new_comment_raw":"@return Returns the closing.","old_comment_raw":"@return Returns the closing.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public String getMatchedSentences() { StringBuilder sb = new StringBuilder(); for (int i = 0, sz = list.getModel().getSize(); i < sz; i++) { String t = list.getModel().getElementAt(i).getLabel().getText(); sb.append(t); sb.append(\"\\n\"); } return sb.toString(); }","old_code_raw":"  public StringBuffer getMatchedSentences() {\n    StringBuffer sb = new StringBuffer();\n    for(int i = 0; i < list.getModel().getSize(); i++) {\n      String t = ((TreeFromFile) list.getModel().getElementAt(i)).getLabel().getText();\n      sb.append(t);\n      sb.append(\"\\n\");\n    }\n    return sb;\n  }\n","new_comment_raw":"@return String filled with the plain text form of all sentences in the matches panel","old_comment_raw":"@return StringBuffer filled with the plain text form of all sentences in the matches panel","label":1,"pre_label":0,"AST_level":9,"line_counts":10,"new_code_token_num":76},{"new_code_raw":"public int getUniformLocation(String name) { \/\/ return gl.glGetUniformLocation(programObject, name); return pgl.getUniformLocation(programObject, name); }","old_code_raw":"  public int getUniformLocation(String name) {\n    return (gl.glGetUniformLocation(programObject, name));\n  }\n","new_comment_raw":"@return int","old_comment_raw":"@return int","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":29},{"new_code_raw":"public final List<ModuleReference> getDependentModulesRecursively(final ModuleReference ref) throws Exception { return getDependentModulesRecursively(ref, new ArrayList<ModuleReference>()); }","old_code_raw":"public synchronized final List<String> getDependentModulesRecursively(final String id) throws Exception {\n    final List<String> res = new ArrayList<String>();\n    for (final String depModule : getDependentModules(id)) {\n        res.add(depModule);\n        res.addAll(this.getDependentModulesRecursively(depModule));\n    }\n    Collections.reverse(res);\n    return res;\n}","new_comment_raw":"@return the modules needing <code>ref<\/code> (excluding it), in uninstallation order (i.e. the first item isn't depended on).","old_comment_raw":"@return the modules needing <code>id<\/code> (excluding it), in uninstallation order (i.e. the first item isn't depended on).","label":1,"pre_label":0,"AST_level":8,"line_counts":3,"new_code_token_num":26},{"new_code_raw":"public Pet getPetById (Long petId) throws ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\"); } \/\/ create path and map variables String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); final String[] accepts = { \"application\/json\", \"application\/xml\" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"petstore_auth\", \"api_key\" }; TypeRef returnType = new TypeRef<Pet>() {}; return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"  public Pet getPetById (Long petId) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    final String[] accepts = {\n      \"application\/json\", \"application\/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    if(contentType.startsWith(\"multipart\/form-data\")) {\n      boolean hasFields = false;\n      FormDataMultiPart mp = new FormDataMultiPart();\n      \n      if(hasFields)\n        postBody = mp;\n    }\n    else {\n      \n    }\n\n    try {\n      String[] authNames = new String[] { \"api_key\", \"petstore_auth\" };\n      String response = apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames);\n      if(response != null){\n        return (Pet) apiClient.deserialize(response, \"\", Pet.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@return Pet","old_comment_raw":"@return Pet","label":0,"pre_label":1,"AST_level":9,"line_counts":41,"new_code_token_num":253},{"new_code_raw":"public View waitForView(View view, int timeout, boolean scroll, boolean checkIsShown){ if(view == null) return null; long endTime = SystemClock.uptimeMillis() + timeout; while (SystemClock.uptimeMillis() < endTime) { final boolean foundAnyMatchingView = searcher.searchFor(view); if(checkIsShown && foundAnyMatchingView && !view.isShown()){ sleeper.sleep(); View identicalView = viewFetcher.getIdenticalView(view); if(identicalView != null && !view.equals(identicalView)){ view = identicalView; } continue; } if (foundAnyMatchingView){ return view; } if(scroll) scroller.scrollDown(); sleeper.sleep(); } return null; }","old_code_raw":"\tpublic View waitForView(View view, int timeout, boolean scroll, boolean checkIsShown){\n\n\t\tif(view == null)\n\t\t\treturn null;\n\n\t\tlong endTime = SystemClock.uptimeMillis() + timeout;\n\n\t\twhile (SystemClock.uptimeMillis() < endTime) {\n\t\t\t\n\t\t\tif(checkIsShown && view != null && view.isShown()){\n\t\t\t\treturn view;\n\t\t\t}\n\t\t\t\n\t\t\tfinal boolean foundAnyMatchingView = searcher.searchFor(view);\n\n\t\t\tif (foundAnyMatchingView){\n\t\t\t\treturn view;\n\t\t\t}\n\t\t\t\n\t\t\tView identicalView = viewFetcher.getIdenticalView(view);\n\t\t\tif(identicalView != null && !view.equals(identicalView)){\n\t\t\t\tview = identicalView;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\n\t\t\tif(scroll) \n\t\t\t\tscroller.scrollDown();\n\t\t\t\n\t\t\tsleeper.sleep();\n\t\t}\n\t\treturn null;\n\t}\n","new_comment_raw":"@return  true if view is shown and  false if it is not shown before the timeout","old_comment_raw":"@return true if view is shown and false if it is not shown before the timeout","label":0,"pre_label":1,"AST_level":11,"line_counts":33,"new_code_token_num":130},{"new_code_raw":"static protected String valueToString(Object value) { if (value == null || value.equals(null)) { return \"null\"; } \/\/ if (value instanceof JSONString) { \/\/ Object object; \/\/ try { \/\/ object = ((JSONString)value).toJSONString(); \/\/ } catch (Exception e) { \/\/ throw new RuntimeException(e); \/\/ } \/\/ if (object instanceof String) { \/\/ return (String)object; \/\/ } \/\/ throw new RuntimeException(\"Bad value from toJSONString: \" + object); \/\/ } if (value instanceof Number) { return numberToString((Number) value); } if (value instanceof Boolean || value instanceof JSONObject || value instanceof JSONArray) { return value.toString(); } if (value instanceof Map) { return new JSONObject(value).toString(); } if (value instanceof Collection) { return new JSONArray(value).toString(); } if (value.getClass().isArray()) { return new JSONArray(value).toString(); } return quote(value.toString()); }","old_code_raw":"  static protected String valueToString(Object value) {\n    if (value == null || value.equals(null)) {\n      return \"null\";\n    }\n\/\/    if (value instanceof JSONString) {\n\/\/      Object object;\n\/\/      try {\n\/\/        object = ((JSONString)value).toJSONString();\n\/\/      } catch (Exception e) {\n\/\/        throw new RuntimeException(e);\n\/\/      }\n\/\/      if (object instanceof String) {\n\/\/        return (String)object;\n\/\/      }\n\/\/      throw new RuntimeException(\"Bad value from toJSONString: \" + object);\n\/\/    }\n    if (value instanceof Number) {\n      return numberToString((Number) value);\n    }\n    if (value instanceof Boolean || value instanceof JSONObject ||\n      value instanceof JSONArray) {\n      return value.toString();\n    }\n    if (value instanceof Map) {\n      return new JSONObject((Map)value).toString();\n    }\n    if (value instanceof Collection) {\n      return new JSONArray((Collection)value).toString();\n    }\n    if (value.getClass().isArray()) {\n      return new JSONArray(value).toString();\n    }\n    return quote(value.toString());\n  }\n","new_comment_raw":"@return a printable, displayable, transmittable representation of the object, beginning with &nbsp;(left brace) and ending with &nbsp;(right brace).","old_comment_raw":"@return a printable, displayable, transmittable representation of the object, beginning with &nbsp;(left brace) and ending with &nbsp;(right brace).","label":0,"pre_label":1,"AST_level":8,"line_counts":35,"new_code_token_num":229},{"new_code_raw":"public AnsiClazzes processCode(String code) { if (code == null || code.length() < 2) return null; if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm') return null; if (code.length() == 2) { clazzes_.clear(); \/\/ CSIm is equivalent to CSI0m, which is 'reset' blockClazzes_.clear(); return null; } int extendedColor = 0; boolean extendedMarkerSeen = false; boolean extendedRGBMarkerSeen = false; int extendedRGBColorsSeen = 0; String[] tokens = code.substring(2, code.length() - 1).split(\";\"); for (String token : tokens) { int codeVal = StringUtil.parseInt(token, -1); if (codeVal == -1) continue; if (extendedColor > 0) { if (!extendedMarkerSeen && !extendedRGBMarkerSeen) { if (codeVal == EXT_BY_INDEX) { extendedMarkerSeen = true; continue; } else if (codeVal == EXT_BY_RGB) { extendedRGBMarkerSeen = true; extendedRGBColorsSeen = 0; } else { \/\/ unknown extended color format; hard to recover so \/\/ just reset back to defaults and return clazzes_.clear(); blockClazzes_.clear(); return null; } } else { \/\/ We don't support colors specified via RGB, but parse the \/\/ sequence then ignore it in case there are supported \/\/ sequences after it if (extendedRGBMarkerSeen) { extendedRGBColorsSeen++; if (extendedRGBColorsSeen == 3 \/*red, green, blue*\/) { extendedColor = 0; extendedRGBMarkerSeen = false; extendedRGBColorsSeen = 0; } } else { if (extendedColor == FOREGROUND_EXT) { if (codeVal >= 0 && codeVal <= 255) { currentColor_.setExtended(codeVal); resetForeground(); clazzes_.add(Color.clazzForColorIndex(codeVal, false \/*background*\/)); } } else { if (codeVal >= 0 && codeVal <= 255) { currentBgColor_.setExtended(codeVal); resetBackground(); clazzes_.add(Color.clazzForColorIndex(codeVal, true \/*background*\/)); } } extendedColor = 0; extendedMarkerSeen = false; } } } else if (codeVal == RESET) { inverted_ = false; currentColor_.reset(); currentBgColor_.reset(); clazzes_.clear(); blockClazzes_.clear(); } else if (codeVal == BOLD) { clazzes_.add(BOLD_STYLE); } else if (codeVal == BLURRED) { \/\/ NYI clazzes_.add(BLURRED_STYLE); } else if (codeVal == BOLD_BLURRED_OFF) { clazzes_.remove(BOLD_STYLE); \/\/ NYI clazzes_.remove(BLURRED_STYLE); } else if (codeVal == ITALIC) { clazzes_.add(ITALIC_STYLE); } else if (codeVal == ITALIC_OFF) { clazzes_.remove(ITALIC_STYLE); } else if (codeVal == UNDERLINE) { clazzes_.add(UNDERLINE_STYLE); } else if (codeVal == UNDERLINE_OFF) { clazzes_.remove(UNDERLINE_STYLE); } else if (codeVal == BLINKSLOW || codeVal == BLINKFAST) { clazzes_.add(BLINK_STYLE); } else if (codeVal == BLINK_OFF) { clazzes_.remove(BLINK_STYLE); } else if (codeVal == INVERSE) { if (!inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = true; } } else if (codeVal == INVERSE_OFF) { if (inverted_) { resetForeground(); resetBackground(); Color newFg = invertFgColor(); Color newBg = invertBgColor(); currentColor_ = newFg; currentBgColor_ = newBg; inverted_ = false; } } else if (codeVal == HIDDEN) { clazzes_.add(HIDDEN_STYLE); } else if (codeVal == HIDDEN_OFF) { clazzes_.remove(HIDDEN_STYLE); } else if (codeVal == STRIKETHROUGH) { clazzes_.add(STRIKETHROUGH_STYLE); } else if (codeVal == STRIKETHROUGH_OFF) { clazzes_.remove(STRIKETHROUGH_STYLE); } else if (Color.isFgColorCode(codeVal)) { currentColor_.setCode(codeVal); resetForeground(); clazzes_.add(clazzForColor(codeVal)); } else if (Color.isBgColorCode(codeVal)) { currentBgColor_ = new Color(false, codeVal); resetBackground(); clazzes_.add(clazzForBgColor(codeVal)); } else if (codeVal == RESET_FOREGROUND) { currentColor_.reset(); resetForeground(); } else if (codeVal == RESET_BACKGROUND) { currentBgColor_.reset(); resetBackground(); } else if (codeVal == FOREGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == BACKGROUND_EXT) { extendedColor = codeVal; extendedMarkerSeen = false; } else if (codeVal == FONT_NINE) { blockClazzes_.add(FONT_NINE_STYLE); } else if (codeVal == DEFAULT_FONT || (codeVal >= FONT_ONE && codeVal <= FONT_EIGHT)) { blockClazzes_.remove(FONT_NINE_STYLE); } else { \/\/ ignore all others } } return getStyles(); }","old_code_raw":"   public String processCode(String code)\n   {\n      if (code == null || code.length() < 2)\n         return null;\n      if (code.charAt(0) != '\\033' && code.charAt(code.length() - 1) != 'm')\n         return null;\n      if (code.length() == 2)\n      {\n         clazzes_.clear(); \/\/ CSIm is equivalent to CSI0m, which is 'reset'\n         return null;\n      }\n      \n      int extendedColor = 0;\n      boolean extendedMarkerSeen = false;\n      boolean extendedRGBMarkerSeen = false;\n      int extendedRGBColorsSeen = 0;\n      \n      String[] tokens = code.substring(2, code.length() - 1).split(\";\");\n      for (String token : tokens)\n      {\n         int codeVal = StringUtil.parseInt(token,  -1);\n         if (codeVal == -1)\n            continue;\n\n         if (extendedColor > 0)\n         {\n            if (!extendedMarkerSeen && !extendedRGBMarkerSeen)\n            {\n               if (codeVal == EXT_BY_INDEX)\n               {\n                  extendedMarkerSeen = true;\n                  continue;\n               }\n               else if (codeVal == EXT_BY_RGB)\n               {\n                  extendedRGBMarkerSeen = true;\n                  extendedRGBColorsSeen = 0;\n               }\n               else\n               {\n                  \/\/ unknown extended color format; hard to recover so\n                  \/\/ just reset back to defaults and return\n                  clazzes_.clear();\n                  return null;\n               }\n            }\n            else\n            {\n               \/\/ We don't support colors specified via RGB, but parse the\n               \/\/ sequence then ignore it in case there are supported \n               \/\/ sequences after it\n               if (extendedRGBMarkerSeen)\n               {\n                  extendedRGBColorsSeen++;\n                  if (extendedRGBColorsSeen == 3 \/*red, green, blue*\/)\n                  {\n                     extendedColor = 0;\n                     extendedRGBMarkerSeen = false;\n                     extendedRGBColorsSeen = 0;\n                  }\n               }\n               else \n               {\n                  if (extendedColor == FOREGROUND_EXT)\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentColor_.setExtended(codeVal);\n                        resetForeground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              false \/*background*\/));\n                     }\n                  }\n                  else\n                  {\n                     if (codeVal >= 0 && codeVal <= 255)\n                     {\n                        currentBgColor_.setExtended(codeVal);\n                        resetBackground();\n                        clazzes_.add(Color.clazzForColorIndex(codeVal, \n                              true \/*background*\/));\n                     }\n                  }\n                  extendedColor = 0;\n                  extendedMarkerSeen = false;\n               }\n            }\n         }\n         else if (codeVal == RESET)\n         {\n            inverted_ = false;\n            currentColor_.reset();\n            currentBgColor_.reset();\n            clazzes_.clear();\n         }\n         else if (codeVal == BOLD)\n         {\n            clazzes_.add(BOLD_STYLE);\n         }\n         else if (codeVal == BLURRED)\n         {\n            \/\/ NYI clazzes_.add(BLURRED_STYLE);\n         }\n         else if (codeVal == BOLD_BLURRED_OFF)\n         {\n            clazzes_.remove(BOLD_STYLE);\n            \/\/ NYI clazzes_.remove(BLURRED_STYLE);\n         }\n         else if (codeVal == ITALIC)\n         {\n            clazzes_.add(ITALIC_STYLE);\n         }\n         else if (codeVal == ITALIC_OFF)\n         {\n            clazzes_.remove(ITALIC_STYLE);\n         }\n         else if (codeVal == UNDERLINE)\n         {\n            clazzes_.add(UNDERLINE_STYLE);\n         }\n         else if (codeVal == UNDERLINE_OFF)\n         {\n            clazzes_.remove(UNDERLINE_STYLE);\n         }\n         else if (codeVal == BLINKSLOW || codeVal == BLINKFAST)\n         {\n            clazzes_.add(BLINK_STYLE);\n         }\n         else if (codeVal == BLINK_OFF)\n         {\n            clazzes_.remove(BLINK_STYLE);\n         }\n         else if (codeVal == INVERSE)\n         {\n            if (!inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = true;\n            }\n         }\n         else if (codeVal == INVERSE_OFF)\n         {\n            if (inverted_)\n            {\n               resetForeground();\n               resetBackground();\n               Color newFg = invertFgColor();\n               Color newBg = invertBgColor();\n               currentColor_ = newFg;\n               currentBgColor_ = newBg;\n               inverted_ = false;\n            }\n         }\n         else if (codeVal == HIDDEN)\n         {\n            clazzes_.add(HIDDEN_STYLE);\n         }\n         else if (codeVal == HIDDEN_OFF)\n         {\n            clazzes_.remove(HIDDEN_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH)\n         {\n            clazzes_.add(STRIKETHROUGH_STYLE);\n         }\n         else if (codeVal == STRIKETHROUGH_OFF)\n         {\n            clazzes_.remove(STRIKETHROUGH_STYLE);\n         }\n         else if (Color.isFgColorCode(codeVal))\n         {\n            currentColor_.setCode(codeVal);\n            resetForeground();\n            clazzes_.add(clazzForColor(codeVal));\n         }\n         else if (Color.isBgColorCode(codeVal))\n         {\n            currentBgColor_ = new Color(false, codeVal);\n            resetBackground();\n            clazzes_.add(clazzForBgColor(codeVal));\n         }\n         else if (codeVal == RESET_FOREGROUND)\n         {\n            currentColor_.reset();\n            resetForeground();\n         }\n         else if (codeVal == RESET_BACKGROUND)\n         {\n            currentBgColor_.reset();\n            resetBackground();\n         }\n         else if (codeVal == FOREGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else if (codeVal == BACKGROUND_EXT)\n         {\n           extendedColor = codeVal;\n           extendedMarkerSeen = false;\n         }\n         else\n         {\n            \/\/ ignore all others\n         }\n      }\n      return getStyle();\n   }\n","new_comment_raw":"@return AnsiClazzes, containing both span-level and block-level styles","old_comment_raw":"@return Clazzes or null if no color classes were applied","label":1,"pre_label":0,"AST_level":33,"line_counts":226,"new_code_token_num":895},{"new_code_raw":"public SchemaCompatibilityType getCompatibility() { return mCompatibilityType; }","old_code_raw":"    public SchemaCompatibilityType getCompatibility() {\n      return mCompatibility;\n    }\n","new_comment_raw":"@return a SchemaCompatibilityType instance, always non-null","old_comment_raw":"@return a SchemaCompatibilityType instance, always non-null","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public float getReal() { return (float) getFirstValue(); }","old_code_raw":"public float getReal(final int i) {\n    return (float) getFirstValue(i);\n}","new_comment_raw":"@return item in first position","old_comment_raw":"@return item in given position","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":15},{"new_code_raw":"public static boolean containsLimit0(RelNode rel) { FindLimit0Visitor visitor = new FindLimit0Visitor(); rel.accept(visitor); if (!visitor.isContains()) { return false; } final FindHardDistributionScans hdVisitor = new FindHardDistributionScans(); rel.accept(hdVisitor); \/\/ Can't optimize limit 0 if the query contains a table which has hard distribution requirement. return !hdVisitor.contains(); }","old_code_raw":"  public static boolean containsLimit0(RelNode rel) {\n    FindLimit0Visitor visitor = new FindLimit0Visitor();\n    rel.accept(visitor);\n    return visitor.isContains();\n  }\n","new_comment_raw":"@return true if the root portion of the tree contains LIMIT(0)","old_comment_raw":"@return true if the root portion of the tree contains LIMIT(0)","label":0,"pre_label":1,"AST_level":6,"line_counts":14,"new_code_token_num":76},{"new_code_raw":"public Throwable getException() { return getCause(); }","old_code_raw":"public Throwable getException() {\n    return cause;\n}","new_comment_raw":"@return The result of calling <code>getCause()<\/code>.","old_comment_raw":"@return the nested exception or <code>null<\/code> if there is no nested exception.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public static PathFilter mergeFilters(final PathFilter... filters) { if (filters.length == 0) { return DUMMY_FILTER; } return path -> Stream.of(filters).allMatch(filter -> filter.accept(path)); }","old_code_raw":"  public static PathFilter mergeFilters(final PathFilter... filters) {\n    if (filters.length == 0) {\n      return DUMMY_FILTER;\n    }\n\n    return new PathFilter() {\n      @Override\n      public boolean accept(Path path) {\n        for (PathFilter filter : filters) {\n          if (!filter.accept(path)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    };\n  }\n","new_comment_raw":"@return one filter that combines all given filters","old_comment_raw":"@return one filter that combines all given filters","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":41},{"new_code_raw":"public short getBlue() { return data[getFirst1DIndex() + NUM]; }","old_code_raw":"public short getBlue(final int i) {\n    return data[get1DIndex(i) + NUM];\n}","new_comment_raw":"@return blue value in the first position","old_comment_raw":"@return blue value in given position","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public int getTerminalCount() { return activeTerminalToolbarButton_.terminalCount(); }","old_code_raw":"public int getTerminalCount() {\n    return terminalSessionsPanel_.getWidgetCount();\n}","new_comment_raw":"@return number of terminals in the dropdown","old_comment_raw":"@return number of terminals hosted by the pane","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"@SuppressWarnings(STR) public double getReal() { return (double) getFirstValue(); }","old_code_raw":"@SuppressWarnings(STR)\npublic double getReal(final int i) {\n    return (double) getFirstValue(i);\n}","new_comment_raw":"@return item in first position","old_comment_raw":"@return item in given position","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"private Timestamp[] getTimeframe() { Timestamp oldest = Timestamp.ZERO.plus(1000000); Timestamp newest = Timestamp.ZERO; for (Habit h : selectedHabits) { if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null) continue; Timestamp currOld = h.getRepetitions().getOldest().getTimestamp(); Timestamp currNew = h.getRepetitions().getNewest().getTimestamp(); oldest = currOld.isOlderThan(oldest) ? oldest : currOld; newest = currNew.isNewerThan(newest) ? newest : currNew; } return new Timestamp[]{oldest, newest}; }","old_code_raw":"    private long[] getTimeframe()\n    {\n        long oldest = Long.MAX_VALUE;\n        long newest = -1;\n        for (Habit h : selectedHabits)\n        {\n            if(h.getRepetitions().getOldest() == null || h.getRepetitions().getNewest() == null)\n                continue;\n            long currOld = h.getRepetitions().getOldest().getTimestamp();\n            long currNew = h.getRepetitions().getNewest().getTimestamp();\n            oldest = currOld > oldest ? oldest : currOld;\n            newest = currNew < newest ? newest : currNew;\n        }\n        return new long[]{oldest, newest};\n    }\n","new_comment_raw":"@return the timeframe containing the oldest timestamp and the newest timestamp","old_comment_raw":"@return the timeframe containing the oldest timestamp and the newest timestamp","label":0,"pre_label":1,"AST_level":9,"line_counts":16,"new_code_token_num":114},{"new_code_raw":"private byte[] marshalAggregatorValues(long superstep) { if (superstep == INPUT_SUPERSTEP) { return new byte[NUM]; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); DataOutputStream output = new DataOutputStream(outputStream); for (Entry<String, AggregatorWrapper<Writable>> entry : getAggregatorMap().entrySet()) { if (entry.getValue().isChanged()) { try { output.writeUTF(entry.getKey()); entry.getValue().getCurrentAggregatedValue().write(output); } catch (IOException e) { throw new IllegalStateException(STR + STR + entry.getKey(), e); } } } if (LOG.isInfoEnabled()) { LOG.info(STR); } return outputStream.toByteArray(); }","old_code_raw":"private JSONArray marshalAggregatorValues(long superstep) {\n    JSONArray aggregatorArray = new JSONArray();\n    if ((superstep == INPUT_SUPERSTEP) || (aggregatorInUse.size() == NUM)) {\n        return aggregatorArray;\n    }\n    for (String name : aggregatorInUse) {\n        try {\n            Aggregator<Writable> aggregator = getAggregatorMap().get(name);\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            DataOutput output = new DataOutputStream(outputStream);\n            aggregator.getAggregatedValue().write(output);\n            JSONObject aggregatorObj = new JSONObject();\n            aggregatorObj.put(AGGREGATOR_NAME_KEY, name);\n            aggregatorObj.put(AGGREGATOR_CLASS_NAME_KEY, aggregator.getClass().getName());\n            aggregatorObj.put(AGGREGATOR_VALUE_KEY, Base64.encodeBytes(outputStream.toByteArray()));\n            aggregatorArray.put(aggregatorObj);\n            if (LOG.isInfoEnabled()) {\n                LOG.info(STR + STR + aggregatorObj + STR + aggregator.getAggregatedValue() + STR);\n            }\n        } catch (JSONException e) {\n            throw new IllegalStateException(STR + STR + name, e);\n        } catch (IOException e) {\n            throw new IllegalStateException(STR + STR + name, e);\n        }\n    }\n    if (LOG.isInfoEnabled()) {\n        LOG.info(STR + STR + aggregatorArray);\n    }\n    aggregatorInUse.clear();\n    return aggregatorArray;\n}","new_comment_raw":"@return Byte array of the aggreagtor values","old_comment_raw":"@return JSON array of the aggreagtor values","label":1,"pre_label":0,"AST_level":13,"line_counts":21,"new_code_token_num":138},{"new_code_raw":"boolean shouldShowSelector() { return ((hasFocus() && !isInTouchMode()) || touchModeDrawsInPressedState()) && ( mBeginClick ) ; }","old_code_raw":"    boolean shouldShowSelector() {\n        return (hasFocus() && !isInTouchMode()) || touchModeDrawsInPressedState();\n    }\n","new_comment_raw":"@return True if the selector should be shown","old_comment_raw":"@return True if the selector should be shown","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"SQLException getBatchCounts(ArrayList counts, SQLException sqlEx) { Integer lastCount = JtdsStatement.SUCCESS_NO_INFO; try { checkOpen(); while (!endOfResponse) { nextToken(); if (currentToken.isResultSet()) { throw new SQLException(Messages.get(STR), STR); } switch(currentToken.token) { case TDS_DONE_TOKEN: if ((currentToken.status & DONE_ERROR) != NUM || lastCount == JtdsStatement.EXECUTE_FAILED) { if (connection.getServerType() == Driver.SYBASE) { counts.add(JtdsStatement.EXECUTE_FAILED); } } else { if (currentToken.isUpdateCount()) { counts.add(new Integer(currentToken.updateCount)); } else { counts.add(lastCount); } } lastCount = JtdsStatement.SUCCESS_NO_INFO; break; case TDS_DONEINPROC_TOKEN: if ((currentToken.status & DONE_ERROR) != NUM) { lastCount = JtdsStatement.EXECUTE_FAILED; } else if (currentToken.isUpdateCount()) { lastCount = new Integer(currentToken.updateCount); } break; case TDS_DONEPROC_TOKEN: if ((currentToken.status & DONE_ERROR) != NUM || lastCount == JtdsStatement.EXECUTE_FAILED) { if (connection.getServerType() == Driver.SYBASE) { counts.add(JtdsStatement.EXECUTE_FAILED); } } else { counts.add(lastCount); } lastCount = JtdsStatement.SUCCESS_NO_INFO; break; } } messages.checkErrors(); } catch (SQLException e) { if (sqlEx != null) { sqlEx.setNextException(e); } else { sqlEx = e; } } finally { while (!endOfResponse) { try { nextToken(); } catch (SQLException ex) { if (sqlEx != null) { sqlEx.setNextException(ex); } else { sqlEx = ex; } } } } return sqlEx; }","old_code_raw":"int[] getBatchCounts() throws BatchUpdateException {\n    ArrayList counts = new ArrayList();\n    Integer lastCount = JtdsStatement.SUCCESS_NO_INFO;\n    BatchUpdateException batchEx = null;\n    try {\n        checkOpen();\n        while (!endOfResponse) {\n            nextToken();\n            if (currentToken.isResultSet()) {\n                throw new SQLException(Messages.get(STR), STR);\n            }\n            switch(currentToken.token) {\n                case TDS_DONE_TOKEN:\n                    if ((currentToken.status & DONE_ERROR) != NUM) {\n                        counts.add(JtdsStatement.EXECUTE_FAILED);\n                    } else {\n                        if (currentToken.isUpdateCount()) {\n                            counts.add(new Integer(currentToken.updateCount));\n                        } else {\n                            counts.add(lastCount);\n                        }\n                    }\n                    lastCount = JtdsStatement.SUCCESS_NO_INFO;\n                    break;\n                case TDS_DONEINPROC_TOKEN:\n                    if ((currentToken.status & DONE_ERROR) != NUM) {\n                        lastCount = JtdsStatement.EXECUTE_FAILED;\n                    } else if (currentToken.isUpdateCount()) {\n                        lastCount = new Integer(currentToken.updateCount);\n                    }\n                    break;\n                case TDS_DONEPROC_TOKEN:\n                    if ((currentToken.status & DONE_ERROR) != NUM) {\n                        counts.add(JtdsStatement.EXECUTE_FAILED);\n                    } else {\n                        counts.add(lastCount);\n                    }\n                    lastCount = JtdsStatement.SUCCESS_NO_INFO;\n                    break;\n            }\n        }\n        messages.checkErrors();\n    } catch (SQLException e) {\n        int[] results = new int[counts.size()];\n        for (int i = NUM; i < results.length; i++) {\n            results[i] = ((Integer) counts.get(i)).intValue();\n        }\n        batchEx = new BatchUpdateException(e.getMessage(), e.getSQLState(), e.getErrorCode(), results);\n        throw batchEx;\n    } finally {\n        while (!endOfResponse) {\n            try {\n                nextToken();\n            } catch (SQLException ex) {\n                if (batchEx != null) {\n                    batchEx.setNextException(ex);\n                }\n            }\n        }\n    }\n    int[] results = new int[counts.size()];\n    for (int i = NUM; i < results.length; i++) {\n        results[i] = ((Integer) counts.get(i)).intValue();\n    }\n    return results;\n}","new_comment_raw":"@return updated <code>SQLException<\/code> or <code>null<\/code> if no error has yet occured","old_comment_raw":"@return the update counts as an <code>int[]<\/code>","label":1,"pre_label":0,"AST_level":15,"line_counts":65,"new_code_token_num":313},{"new_code_raw":"public int getHours() { return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX); }","old_code_raw":"    public int getHours() {\n        return getPeriodType().getHours(this);\n    }\n","new_comment_raw":"@return the number of hours in the period, zero if unsupported","old_comment_raw":"@return the number of hours in the period, zero if unsupported","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public MethodInfo createMethod(MemberID memberID, String[] argNames) { return createMethod(memberID, argNames, null); }","old_code_raw":"public MethodInfo createMethod(Signature signature, String[] argNames) {\n    return createMethod(signature, argNames, null);\n}","new_comment_raw":"@return the new method or an existing method with that memberID.","old_comment_raw":"@return the new method or an existing method with that signature.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":24},{"new_code_raw":"public static List<Point> convexHull(List<Point> points) { int[] xs = new int[points.size()]; int[] ys = new int[xs.length]; for (int i = 0; i < xs.length; i++) { Point p = points.get(i); xs[i] = p.getX(); ys[i] = p.getY(); } SimplePolygon poly = convexHull(xs, ys); if (poly == null) { return null; } return poly.toRuneLitePointList(); }","old_code_raw":"\tpublic static List<Point> convexHull(List<Point> points)\n\t{\n\t\tif (points.size() < 3)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tList<Point> ch = new ArrayList<>();\n\n\t\t\/\/ find the left most point\n\t\tPoint left = findLeftMost(points);\n\n\t\t\/\/ current point we are on\n\t\tPoint current = left;\n\n\t\tdo\n\t\t{\n\t\t\tch.add(current);\n\t\t\tassert ch.size() <= points.size() : \"hull has more points than graph\";\n\t\t\tif (ch.size() > points.size())\n\t\t\t{\n\t\t\t\t\/\/ Just to make sure we never somehow get stuck in this loop\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t\/\/ the next point - all points are to the right of the\n\t\t\t\/\/ line between current and next\n\t\t\tPoint next = null;\n\n\t\t\tfor (Point p : points)\n\t\t\t{\n\t\t\t\tif (next == null)\n\t\t\t\t{\n\t\t\t\t\tnext = p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlong cp = crossProduct(current, p, next);\n\t\t\t\tif (cp > 0 || (cp == 0 && current.distanceTo(p) > current.distanceTo(next)))\n\t\t\t\t{\n\t\t\t\t\tnext = p;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ Points can be null if they are behind or very close to the camera.\n\t\t\tif (next == null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcurrent = next;\n\t\t}\n\t\twhile (current != left);\n\n\t\treturn ch;\n\t}\n","new_comment_raw":"@return list containing the points part of the convex hull","old_comment_raw":"@return list containing the points part of the convex hull","label":0,"pre_label":1,"AST_level":9,"line_counts":20,"new_code_token_num":103},{"new_code_raw":"public LookupService createLookupService() { return createLookupService(defaultEndpointUrl); }","old_code_raw":"public LookupService createLookupService() {\n    return createLookupService(defaultServerUrl);\n}","new_comment_raw":"@return a new lookup service with the default endpoint URL","old_comment_raw":"@return a new lookup service with the default server URL","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public boolean searchText(String regex, int matches, boolean scroll) { return searcher.searchText(regex, matches, scroll); }","old_code_raw":"\tpublic boolean searchText(String search, int matches, boolean scroll) {\n\t\treturn searcher.searchText(search, matches, scroll);\n\t}\n","new_comment_raw":"@return  true if regex string is found a given number of times and  false if the regex string is not found","old_comment_raw":"@return true if search string is found a given number of times and false if the search string is not found","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public List<IndexedWord> topologicalSort() { return graph.topologicalSort(); }","old_code_raw":"  public List<IndexedWord> topologicalSort() {\n    List<IndexedWord> result = Generics.newArrayList();\n    Set<IndexedWord> temporary = wordMapFactory.newSet();\n    Set<IndexedWord> permanent = wordMapFactory.newSet();\n    for (IndexedWord vertex : vertexSet()) {\n      if (!temporary.contains(vertex)) {\n        topologicalSortHelper(vertex, temporary, permanent, result);\n      }\n    }\n    Collections.reverse(result);\n    return result;\n  }\n","new_comment_raw":"@return A sorted list of the vertices","old_comment_raw":"@return A sorted list of the vertices","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public boolean scrollUpList(int listIndex) { return scrollList(listIndex, Direction.UP); }","old_code_raw":"\tpublic boolean scrollUpList(int listIndex)\n\t{\n\t\treturn scrollList(listIndex, UP);\n\t}\n","new_comment_raw":"@return  true if more scrolling can be done","old_comment_raw":"@return true if more scrolling can be done","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":18},{"new_code_raw":"private ConnectionContainer upsertObjects(Environment context) { if (context.ids.isPresent()) { throw new BadRequestException(STR); } if (!context.data.isPresent()) { throw new BadRequestException(STR); } Class<?> entityClass; EntityDictionary dictionary = context.requestScope.getDictionary(); if (context.isRoot()) { entityClass = dictionary.getEntityClass(context.field.getName()); } else { entityClass = dictionary.getParameterizedType(context.parentResource.getResourceClass(), context.field.getName()); } Optional<Entity> parentEntity; if (!context.isRoot()) { parentEntity = Optional.of(new Entity(Optional.empty(), null, context.parentResource.getResourceClass(), context.requestScope)); } else { parentEntity = Optional.empty(); } LinkedHashSet<Entity> entitySet = new LinkedHashSet<>(); for (Map<String, Object> input : context.data.get()) { entitySet.add(new Entity(parentEntity, input, entityClass, context.requestScope)); } for (Entity entity : entitySet) { graphWalker(entity, (e) -> upsertObject(context, e)); } for (Entity entity : entitySet) { graphWalker(entity, this::updateRelationship); if (!context.isRoot()) { context.parentResource.addRelation(context.field.getName(), entity.toPersistentResource()); } } String entityName = dictionary.getJsonAliasFor(entityClass); Set<PersistentResource> resources = entitySet.stream().map(Entity::toPersistentResource).collect(Collectors.toCollection(LinkedHashSet::new)); return new ConnectionContainer(resources, Optional.empty(), entityName); }","old_code_raw":"private Set<PersistentResource> upsertObjects(Environment context) {\n    if (context.ids.isPresent()) {\n        throw new BadRequestException(STR);\n    }\n    if (!context.data.isPresent()) {\n        throw new BadRequestException(STR);\n    }\n    Class<?> entityClass;\n    EntityDictionary dictionary = context.requestScope.getDictionary();\n    if (context.isRoot()) {\n        entityClass = dictionary.getEntityClass(context.field.getName());\n    } else {\n        entityClass = dictionary.getParameterizedType(context.parentResource.getResourceClass(), context.field.getName());\n    }\n    Optional<Entity> parentEntity;\n    if (!context.isRoot()) {\n        parentEntity = Optional.of(new Entity(Optional.empty(), null, context.parentResource.getResourceClass(), context.requestScope));\n    } else {\n        parentEntity = Optional.empty();\n    }\n    LinkedHashSet<Entity> entitySet = new LinkedHashSet<>();\n    for (Map<String, Object> input : context.data.get()) {\n        entitySet.add(new Entity(parentEntity, input, entityClass, context.requestScope));\n    }\n    for (Entity entity : entitySet) {\n        graphWalker(entity, this::upsertObject);\n    }\n    for (Entity entity : entitySet) {\n        graphWalker(entity, this::updateRelationship);\n        if (!context.isRoot()) {\n            context.parentResource.addRelation(context.field.getName(), entity.toPersistentResource());\n        }\n    }\n    return entitySet.stream().map(Entity::toPersistentResource).collect(Collectors.toCollection(LinkedHashSet::new));\n}","new_comment_raw":"@return Connection object.","old_comment_raw":"@return list of {@link PersistentResource} objects","label":1,"pre_label":0,"AST_level":9,"line_counts":37,"new_code_token_num":303},{"new_code_raw":"public Field withDefault(BooleanSupplier defaultValueGenerator) { return new Field(name(), displayName(), type(), width, description(), importance(), dependents, defaultValueGenerator::getAsBoolean, validator, recommender); }","old_code_raw":"    public Field withDefault(BooleanSupplier defaultValueGenerator) {\n        return Field.create(name(), description(), defaultValueGenerator);\n    }\n","new_comment_raw":"@return the new field; never null","old_comment_raw":"@return the new field; never null","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":47},{"new_code_raw":"public Lock readLock() { return getGraph().getLock().readLock(); }","old_code_raw":"public Lock readLock() {\n    if (getGraph() instanceof LockableMGraph) {\n        return ((LockableMGraph) getGraph()).getLock().readLock();\n    }\n    return new FakeLock();\n}","new_comment_raw":"@return a ReadLock if the underlying ImmutableGraph is a LockableGraph it returns its lock, otherwise null","old_comment_raw":"@return a ReadLock if the underlying Graph is a LockableMGraph it returns its lock, otherwise null","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public static InetAddress guessPrimaryNetworkAddress(boolean preferIPv4) throws SocketException { final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces(); if (interfaces != null) { for (NetworkInterface interf : Collections.list(interfaces)) { if (!interf.isLoopback() && interf.isUp()) { for (InetAddress addr : Collections.list(interf.getInetAddresses())) { if (preferIPv4 && addr instanceof Inet4Address) { return addr; } if (!preferIPv4 && addr instanceof Inet6Address) { return addr; } } } } } return InetAddress.getLoopbackAddress(); }","old_code_raw":"public static InetAddress guessPrimaryNetworkAddress() throws SocketException {\n    final Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\n    if (interfaces != null) {\n        for (NetworkInterface interf : Collections.list(interfaces)) {\n            if (!interf.isLoopback() && interf.isUp()) {\n                for (InetAddress addr : Collections.list(interf.getInetAddresses())) {\n                    if (addr instanceof Inet4Address) {\n                        return addr;\n                    }\n                }\n            }\n        }\n    }\n    return InetAddress.getLoopbackAddress();\n}","new_comment_raw":"@return The primary {@link InetAddress} of the primary network interface or the loopback address as fallback.","old_comment_raw":"@return The primary {@link java.net.InetAddress} of the primary network interface or the loopback address as fallback.","label":1,"pre_label":0,"AST_level":14,"line_counts":18,"new_code_token_num":109},{"new_code_raw":"public List<ScoredObject<Tree>> getKBestParses(int k) { if (parseSkipped) { return null; } if (bparser != null && parseSucceeded) { \/\/The getKGoodParses seems to be broken, so just return the best parse Tree binaryTree = bparser.getBestParse(); Tree tree = debinarizer.transformTree(binaryTree); if (op.nodePrune) { NodePruner np = new NodePruner(pparser, debinarizer); tree = np.prune(tree); } tree = subcategoryStripper.transformTree(tree); restoreOriginalWords(tree); double score = dparser.getBestScore(); ScoredObject<Tree> so = new ScoredObject<>(tree, score); List<ScoredObject<Tree>> trees = new ArrayList<>(1); trees.add(so); return trees; } else if (pparser != null && pparser.hasParse() && fallbackToPCFG) { return this.getKBestPCFGParses(k); } else if (dparser != null && dparser.hasParse()) { \/\/ && fallbackToDG \/\/ The dependency parser doesn't support k-best parse extraction, so just \/\/ return the best parse Tree tree = this.getBestDependencyParse(true); double score = dparser.getBestScore(); ScoredObject<Tree> so = new ScoredObject<>(tree, score); List<ScoredObject<Tree>> trees = new ArrayList<>(1); trees.add(so); return trees; } else { throw new NoSuchParseException(); } }","old_code_raw":"  public List<ScoredObject<Tree>> getKBestParses(int k) {\n    if (parseSkipped) {\n      return null;\n    }\n    if (bparser != null && parseSucceeded) {\n     return this.getKGoodFactoredParses(k);\n    } else if (pparser != null && pparser.hasParse() && fallbackToPCFG) {\n      return this.getKBestPCFGParses(k);\n    } else if (dparser != null && dparser.hasParse()) { \/\/ && fallbackToDG\n      \/\/ The dependency parser doesn't support k-best parse extraction, so just\n      \/\/ return the best parse\n      Tree tree = this.getBestDependencyParse(true);\n      double score = dparser.getBestScore();\n      ScoredObject<Tree> so = new ScoredObject<>(tree, score);\n      List<ScoredObject<Tree>> trees = new ArrayList<>(1);\n      trees.add(so);\n      return trees;\n    } else {\n      throw new NoSuchParseException();\n    }\n  }\n","new_comment_raw":"@return A list of scored trees","old_comment_raw":"@return A list of scored trees","label":0,"pre_label":1,"AST_level":12,"line_counts":37,"new_code_token_num":256},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { \/\/ prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\"); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" + \/\/ prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\"); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 73: break; case 2: { return getNext(\"<\", yytext()); } case 74: break; case 3: { return getNext(); } case 75: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 76: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\"); prevWordAfter.append(yytext()); } } case 77: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 78: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 79: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 80: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 81: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 82: break; case 11: { return getNext(\">\", yytext()); } case 83: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 84: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 85: break; case 14: { return handleEllipsis(yytext()); } case 86: break; case 15: { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much! String tok = yytext(); \/* A THING can contain quote like O'Malley *\/ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 87: break; case 16: { return normalizeFractions(yytext()); } case 88: break; case 17: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 89: break; case 18: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 90: break; case 19: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 91: break; case 20: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 92: break; case 21: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 93: break; case 22: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 94: break; case 23: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 95: break; case 24: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 96: break; case 25: { if (invertible) { prevWordAfter.append(yytext()); } } case 97: break; case 26: { return getNext(\"\\u2022\", yytext()); } case 98: break; case 27: { return getNext(\"\\u2122\", yytext()); } case 99: break; case 28: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 100: break; case 29: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 101: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {REDAUX} (2nd) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 102: break; case 31: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 103: break; case 32: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 104: break; case 33: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 105: break; case 34: { breakByHyphens(yytext()); if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + removeSoftHyphens(yytext())); } return getNext(removeSoftHyphens(yytext()), yytext()); } case 106: break; case 35: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 107: break; case 36: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 108: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 109: break; case 38: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 110: break; case 39: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 111: break; case 40: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { String tok = yytext(); \/* invert single quote - often but not always right *\/ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 112: break; case 41: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 113: break; case 42: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 114: break; case 43: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} (2nd) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 115: break; case 44: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 116: break; case 45: { return getNormalizedAmpNext(); } case 117: break; case 46: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 118: break; case 47: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 119: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 120: break; case 49: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 121: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 122: break; case 51: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 123: break; case 52: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 124: break; case 53: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 125: break; case 54: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 126: break; case 55: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 127: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 128: break; case 57: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 129: break; case 58: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 130: break; case 59: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = removeSoftHyphens(tok); if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); } return getNext(norm, tok); } case 131: break; case 60: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 132: break; case 61: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 133: break; case 62: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 134: break; case 63: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 135: break; case 64: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 136: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 137: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 138: break; case 67: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 139: break; case 68: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 140: break; case 69: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 141: break; case 70: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); } return getNext(txt, yytext()); } case 142: break; case 71: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 143: break; case 72: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 144: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            \/\/ prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            \/\/         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 73: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 74: break;\n          case 3: \n            { return getNext();\n            }\n          case 75: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 76: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                    \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 77: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 78: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 79: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 80: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 81: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 82: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 83: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 84: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 85: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 86: break;\n          case 15: \n            { String tok = yytext();\n                  \/* A THING can contain quote like O'Malley *\/\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 87: break;\n          case 16: \n            { return normalizeFractions(yytext());\n            }\n          case 88: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 89: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 90: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 91: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 92: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 93: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 25: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 97: break;\n          case 26: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 98: break;\n          case 27: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 99: break;\n          case 28: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 100: break;\n          case 29: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 101: break;\n          case 30: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2nd) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 102: break;\n          case 31: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 103: break;\n          case 32: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 104: break;\n          case 33: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 105: break;\n          case 34: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + removeSoftHyphens(yytext())); }\n                  return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 106: break;\n          case 35: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 107: break;\n          case 36: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 108: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 109: break;\n          case 38: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 110: break;\n          case 39: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 111: break;\n          case 40: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);\n            { String tok = yytext();\n                               \/* invert single quote - often but not always right *\/\n                               String norm = handleQuotes(tok, true);\n                               if (DEBUG) { logger.info(\"Used single straight quote to recognize \" + tok + \" as \" + norm +\n                                                        \"; probablyLeft=\" + true); }\n                               return getNext(norm, tok);\n            }\n          case 112: break;\n          case 41: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 113: break;\n          case 42: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 114: break;\n          case 43: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2nd) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 115: break;\n          case 44: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 116: break;\n          case 45: \n            { return getNormalizedAmpNext();\n            }\n          case 117: break;\n          case 46: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 118: break;\n          case 47: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 119: break;\n          case 48: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 120: break;\n          case 49: \n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 121: break;\n          case 50: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 122: break;\n          case 51: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 123: break;\n          case 52: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 124: break;\n          case 53: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 125: break;\n          case 54: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 126: break;\n          case 55: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 127: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 128: break;\n          case 57: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 129: break;\n          case 58: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 130: break;\n          case 59: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { breakByHyphens(yytext());\n                  return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 131: break;\n          case 60: \n            { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 132: break;\n          case 61: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 133: break;\n          case 62: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 134: break;\n          case 63: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 135: break;\n          case 64: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 136: break;\n          case 65: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 137: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 138: break;\n          case 67: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 139: break;\n          case 68: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 140: break;\n          case 69: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 141: break;\n          case 70: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 142: break;\n          case 71: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 143: break;\n          case 72: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 144: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":19,"line_counts":1045,"new_code_token_num":7160},{"new_code_raw":"public Mono<Client> call123testSpecialTags(Client body) throws RestClientException { Object postBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling call123testSpecialTags\"); } String path = UriComponentsBuilder.fromPath(\"\/another-fake\/dummy\").build().toUriString(); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"application\/json\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {}; return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public Mono<Client> call123testSpecialTags(Client body) throws RestClientException {\n        Object postBody = body;\n        \n        \/\/ verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling call123testSpecialTags\");\n        }\n        \n        String path = UriComponentsBuilder.fromPath(\"\/another-fake\/dummy\").build().toUriString();\n        \n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<Client> returnType = new ParameterizedTypeReference<Client>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PATCH, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@return Client","old_comment_raw":"@return Client","label":0,"pre_label":1,"AST_level":8,"line_counts":30,"new_code_token_num":221},{"new_code_raw":"public LSN restart() throws BabuDBException { if (!this.stopped) throw new BabuDBException(ErrorCode.IO_ERROR, STR); databaseManager.reset(); dbCheckptr = new CheckpointerImpl(this); LSN dbLsn = null; LSN zero = new LSN(NUM, NUM); for (Database dbRaw : databaseManager.getDatabaseList()) { DatabaseImpl db = (DatabaseImpl) dbRaw; LSN onDisk = db.getLSMDB().getOndiskLSN(); if (dbLsn == null && !onDisk.equals(zero)) dbLsn = onDisk; else if (dbLsn != null) { if (!onDisk.equals(zero) && !dbLsn.equals(onDisk)) throw new RuntimeException(STR + dbLsn.toString() + STR + db.getLSMDB().getOndiskLSN().toString()); } } if (dbLsn == null) { dbLsn = new LSN(NUM, NUM); } else { dbLsn = new LSN(dbLsn.getViewId(), dbLsn.getSequenceNo() + NUM); } Logging.logMessage(Logging.LEVEL_INFO, this, STR); LSN nextLSN = replayLogs(dbLsn); if (dbLsn.compareTo(nextLSN) > NUM) { nextLSN = dbLsn; } Logging.logMessage(Logging.LEVEL_INFO, this, STR + nextLSN); try { logger = new DiskLogger(configuration.getDbLogDir(), nextLSN.getViewId(), nextLSN.getSequenceNo() + NUM, configuration.getSyncMode(), configuration.getPseudoSyncWait(), configuration.getMaxQueueLength() * configuration.getNumThreads()); logger.start(); } catch (IOException ex) { throw new BabuDBException(ErrorCode.IO_ERROR, STR, ex); } worker = new LSMDBWorker[configuration.getNumThreads()]; for (int i = NUM; i < configuration.getNumThreads(); i++) { worker[i] = new LSMDBWorker(logger, i, (configuration.getPseudoSyncWait() > NUM), configuration.getMaxQueueLength(), replicationManager); worker[i].start(); } dbCheckptr.init(logger, configuration.getCheckInterval(), configuration.getMaxLogfileSize()); dbCheckptr.start(); Logging.logMessage(Logging.LEVEL_INFO, this, STR + STR + BABUDB_VERSION + STR); this.stopped = false; return new LSN(nextLSN.getViewId(), nextLSN.getSequenceNo()); }","old_code_raw":"public LSN restart() throws BabuDBException {\n    databaseManager.reset();\n    dbCheckptr = new CheckpointerImpl(this);\n    LSN dbLsn = null;\n    LSN zero = new LSN(NUM, NUM);\n    for (Database dbRaw : databaseManager.getDatabaseList()) {\n        DatabaseImpl db = (DatabaseImpl) dbRaw;\n        LSN onDisk = db.getLSMDB().getOndiskLSN();\n        if (dbLsn == null && !onDisk.equals(zero))\n            dbLsn = onDisk;\n        else if (dbLsn != null) {\n            if (!onDisk.equals(zero) && !dbLsn.equals(onDisk))\n                throw new RuntimeException(STR + dbLsn.toString() + STR + db.getLSMDB().getOndiskLSN().toString());\n        }\n    }\n    if (dbLsn == null) {\n        dbLsn = new LSN(NUM, NUM);\n    } else {\n        dbLsn = new LSN(dbLsn.getViewId(), dbLsn.getSequenceNo() + NUM);\n    }\n    Logging.logMessage(Logging.LEVEL_INFO, this, STR);\n    LSN nextLSN = replayLogs(dbLsn);\n    if (dbLsn.compareTo(nextLSN) > NUM) {\n        nextLSN = dbLsn;\n    }\n    Logging.logMessage(Logging.LEVEL_INFO, this, STR + nextLSN);\n    try {\n        logger = new DiskLogger(configuration.getDbLogDir(), nextLSN.getViewId(), nextLSN.getSequenceNo() + NUM, configuration.getSyncMode(), configuration.getPseudoSyncWait(), configuration.getMaxQueueLength() * configuration.getNumThreads());\n        logger.start();\n    } catch (IOException ex) {\n        throw new BabuDBException(ErrorCode.IO_ERROR, STR, ex);\n    }\n    worker = new LSMDBWorker[configuration.getNumThreads()];\n    for (int i = NUM; i < configuration.getNumThreads(); i++) {\n        worker[i] = new LSMDBWorker(logger, i, (configuration.getPseudoSyncWait() > NUM), configuration.getMaxQueueLength(), replicationManager);\n        worker[i].start();\n    }\n    dbCheckptr.init(logger, configuration.getCheckInterval(), configuration.getMaxLogfileSize());\n    dbCheckptr.start();\n    Logging.logMessage(Logging.LEVEL_INFO, this, STR + BABUDB_VERSION + STR);\n    return new LSN(nextLSN.getViewId(), nextLSN.getSequenceNo() - NUM);\n}","new_comment_raw":"@return the next LSN.","old_comment_raw":"@return the latest loaded LSN.","label":1,"pre_label":0,"AST_level":14,"line_counts":45,"new_code_token_num":417},{"new_code_raw":"public String getEval(String script) { script = String.format(\"return eval(%s);\", script); return String.valueOf(((JavascriptExecutor) driver).executeScript(script)); }","old_code_raw":"  public String getEval(String script) {\n    return String.valueOf(((JavascriptExecutor) driver).executeScript(script));\n  }\n","new_comment_raw":"@return the results of evaluating the snippet","old_comment_raw":"@return the results of evaluating the snippet","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":42},{"new_code_raw":"public static MatchFinder anyOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (finder.matches(element)) { return true; } } return false; } @Override public String toString() { return STR + Joiner.on(STR).join(finders) + STR; } }; }","old_code_raw":"public static ElementMatcher anyOf(final ElementMatcher... matchers) {\n    return new ElementMatcher() {\n\n        @Override\n        public boolean matches(UiElement element) {\n            for (ElementMatcher matcher : matchers) {\n                if (matcher.matches(element)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public String toString() {\n            return STR + Joiner.on(STR).join(matchers) + STR;\n        }\n    };\n}","new_comment_raw":"@return a finder that is the logical disjunction of given finders","old_comment_raw":"@return a matcher that is the logical disjunction of given matchers","label":1,"pre_label":0,"AST_level":11,"line_counts":19,"new_code_token_num":79},{"new_code_raw":"public List<Expression> translateList(List<? extends RexNode> operandList) { return translateList(operandList, EnumUtils.internalTypes(operandList)); }","old_code_raw":"  public List<Expression> translateList(List<? extends RexNode> operandList) {\n    return translateList(operandList, null);\n  }\n","new_comment_raw":"@return translated expressions","old_comment_raw":"@return translated expressions","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(\"<\", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext(\">\", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { return getNext(removeFromNumber(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(\"\\u2022\", yytext()); } case 90: break; case 25: { return getNext(\"\\u2122\", yytext()); } case 91: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 98: break; case 33: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 102: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 114: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 127: break; case 62: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 131: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 67: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 68: break;\n          case 3: \n            { return getNext();\n            }\n          case 69: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 70: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n            }\n          case 71: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 72: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 73: break;\n          case 8: \n            { return handleQuotes(yytext(), false);\n            }\n          case 74: break;\n          case 9: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 75: break;\n          case 10: \n            { return getNext(\">\", yytext());\n            }\n          case 76: break;\n          case 11: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 77: break;\n          case 12: \n            { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n            }\n          case 78: break;\n          case 13: \n            { return handleEllipsis(yytext());\n            }\n          case 79: break;\n          case 14: \n            { return normalizeFractions(yytext());\n            }\n          case 80: break;\n          case 15: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n\t\t\t  } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 81: break;\n          case 16: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 82: break;\n          case 17: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 18: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 84: break;\n          case 19: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 85: break;\n          case 20: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 21: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 87: break;\n          case 22: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 88: break;\n          case 23: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 89: break;\n          case 24: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 90: break;\n          case 25: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 91: break;\n          case 26: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 92: break;\n          case 27: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 93: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), true);\n            }\n          case 94: break;\n          case 29: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 95: break;\n          case 30: \n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 96: break;\n          case 31: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 97: break;\n          case 32: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 98: break;\n          case 33: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 99: break;\n          case 34: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 100: break;\n          case 35: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 101: break;\n          case 36: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);\n            { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n            }\n          case 102: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), false);\n            }\n          case 103: break;\n          case 38: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 104: break;\n          case 39: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      String newText = yytext();\n                      return getNext(newText, newText);\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, txt);\n            }\n          case 105: break;\n          case 40: \n            { return getNormalizedAmpNext();\n            }\n          case 106: break;\n          case 41: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 107: break;\n          case 42: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 108: break;\n          case 43: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 109: break;\n          case 44: \n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 110: break;\n          case 45: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 111: break;\n          case 46: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 47: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 113: break;\n          case 48: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 114: break;\n          case 49: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 115: break;\n          case 50: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 116: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 117: break;\n          case 52: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 118: break;\n          case 53: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 54: \n            { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 120: break;\n          case 55: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 121: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 122: break;\n          case 57: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 123: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 124: break;\n          case 59: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 125: break;\n          case 60: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 126: break;\n          case 61: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 127: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 128: break;\n          case 63: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 129: break;\n          case 64: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 130: break;\n          case 65: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":19,"line_counts":965,"new_code_token_num":6267},{"new_code_raw":"public ArrayList<ScrollView> getCurrentScrollViews() { return getCurrentViews(ScrollView.class); }","old_code_raw":"\tpublic ArrayList<ScrollView> getCurrentScrollViews() {\n\t\tArrayList<ScrollView> scrollViews = new ArrayList<ScrollView>();\n\t\tArrayList<View> viewList = getViews();\n\t\tfor(View view : viewList){\n\t\t\tif (view instanceof android.widget.ScrollView)\n\t\t\t\tscrollViews.add((ScrollView) view);\n\t\t}\n\t\treturn scrollViews;\n\t}\n","new_comment_raw":"@return a  List of the  ScrollViews contained in the current  Activity","old_comment_raw":"@return a List of the ScrollViews contained in the current Activity","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public int _offsetToX(int line, int offset) { return super._offsetToX(line, offset) + LEFT_GUTTER; }","old_code_raw":"  public int _offsetToX(int line, int offset) {\n    return super._offsetToX(line, offset) + getGutterWidth();\n  }\n","new_comment_raw":"@return the horizontal position","old_comment_raw":"@return the horizontal position","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public GremlinPipeline<S, Vertex> inV() { return this.add(new InVertexPipe()); }","old_code_raw":"public T inV() {\n    return this.add(new InVertexPipe());\n}","new_comment_raw":"@return the extended Pipeline","old_comment_raw":"@return the extended FluentPipeline","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":20},{"new_code_raw":"public int compareTo(IndexedWord w) { if (this.equals(IndexedWord.NO_WORD)) { if (w.equals(IndexedWord.NO_WORD)) { return 0; } else { return -1; } } if (w.equals(IndexedWord.NO_WORD)) { return 1; } String docID = this.getString(CoreAnnotations.DocIDAnnotation.class); int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class)); if (docComp != 0) return docComp; int sentComp = sentIndex() - w.sentIndex(); if (sentComp != 0) return sentComp; int indexComp = index() - w.index(); if (indexComp != 0) return indexComp; return copyCount() - w.copyCount(); }","old_code_raw":"  public int compareTo(IndexedWord w) {\n    if (this.equals(IndexedWord.NO_WORD)) {\n      if (w.equals(IndexedWord.NO_WORD)) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n    if (w.equals(IndexedWord.NO_WORD)) {\n      return 1;\n    }\n\n    String docID = this.getString(CoreAnnotations.DocIDAnnotation.class);\n    int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class));\n    if (docComp != 0) return docComp;\n\n    int sentComp = sentIndex() - w.sentIndex();\n    if (sentComp != 0) return sentComp;\n\n    return index() - w.index();\n  }\n","new_comment_raw":"@return Whether this is less than w or not in the ordering","old_comment_raw":"@return Whether this is less than w or not in the ordering","label":0,"pre_label":1,"AST_level":8,"line_counts":25,"new_code_token_num":138},{"new_code_raw":"private boolean validate(RexNode first, RexNode second) { return first instanceof RexCall && second instanceof RexCall; }","old_code_raw":"  private boolean validate(RexNode first, RexNode second) {\n    if (first == null || second == null) {\n      return false;\n    }\n    if (!(first instanceof RexCall)\n        || !(second instanceof RexCall)) {\n      return false;\n    }\n    return true;\n  }\n","new_comment_raw":"@return whether input usage pattern is supported","old_comment_raw":"@return true, if input usage pattern is supported. Otherwise, false.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public JoinInfo analyzeCondition() { return joinInfo; }","old_code_raw":"  public JoinInfo analyzeCondition() {\n    return JoinInfo.of(left, right, condition);\n  }\n","new_comment_raw":"@return Analyzed join condition","old_comment_raw":"@return Analyzed join condition","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public static ExternalSessionKey fromJsonResponseBody(String responseBody) { try { JsonObject json = new JsonParser().parse(responseBody).getAsJsonObject(); if (json.has(\"sessionId\") && !json.get(\"sessionId\").isJsonNull()) { return new ExternalSessionKey(json.get(\"sessionId\").getAsString()); } \/\/ W3C response if (json.has(\"value\") && json.get(\"value\").isJsonObject()) { JsonObject value = json.getAsJsonObject(\"value\"); if (value.has(\"sessionId\") && !value.get(\"sessionId\").isJsonNull()) { return new ExternalSessionKey(value.get(\"sessionId\").getAsString()); } } } catch (JsonSyntaxException e) { return null; } return null; }","old_code_raw":"  public static ExternalSessionKey fromJsonResponseBody(String responseBody) {\n    try {\n      JsonObject json = new JsonParser().parse(responseBody).getAsJsonObject();\n      if (json.has(\"sessionId\") && !json.get(\"sessionId\").isJsonNull()) {\n        return new ExternalSessionKey(json.get(\"sessionId\").getAsString());\n      }\n\n      \/\/ W3C response\n      if (json.has(\"value\") && json.get(\"value\").isJsonObject()) {\n        JsonObject value = json.getAsJsonObject(\"value\");\n        if (value.has(\"sessionId\") && !value.get(\"sessionId\").isJsonNull()) {\n          return new ExternalSessionKey(json.get(\"sessionId\").getAsString());\n        }\n      }\n    } catch (JsonSyntaxException e) {\n      return null;\n    }\n\n    return null;\n  }\n","new_comment_raw":"@return the extracted ExternalKey, or null if one was not found.","old_comment_raw":"@return the extracted ExternalKey, or null if one was not found.","label":0,"pre_label":1,"AST_level":11,"line_counts":21,"new_code_token_num":160},{"new_code_raw":"private NaturalLogicRelation project(NaturalLogicRelation input, Monotonicity mono, MonotonicityType type) { switch (input) { case EQUIVALENCE: return NaturalLogicRelation.EQUIVALENCE; case FORWARD_ENTAILMENT: switch (mono) { case MONOTONE: return NaturalLogicRelation.FORWARD_ENTAILMENT; case ANTITONE: return NaturalLogicRelation.REVERSE_ENTAILMENT; case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } case REVERSE_ENTAILMENT: switch (mono) { case MONOTONE: return NaturalLogicRelation.REVERSE_ENTAILMENT; case ANTITONE: return NaturalLogicRelation.FORWARD_ENTAILMENT; case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } case NEGATION: switch (type) { case NONE: return NaturalLogicRelation.INDEPENDENCE; case ADDITIVE: switch (mono) { case MONOTONE: return NaturalLogicRelation.COVER; case ANTITONE: return NaturalLogicRelation.ALTERNATION; case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } case MULTIPLICATIVE: switch (mono) { case MONOTONE: return NaturalLogicRelation.ALTERNATION; case ANTITONE: return NaturalLogicRelation.COVER; case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } break; case BOTH: return NaturalLogicRelation.NEGATION; } break; case ALTERNATION: switch (mono) { case MONOTONE: switch (type) { case NONE: case ADDITIVE: return NaturalLogicRelation.INDEPENDENCE; case MULTIPLICATIVE: case BOTH: return NaturalLogicRelation.ALTERNATION; } case ANTITONE: switch (type) { case NONE: case ADDITIVE: return NaturalLogicRelation.INDEPENDENCE; case MULTIPLICATIVE: case BOTH: return NaturalLogicRelation.COVER; } case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } case COVER: switch (mono) { case MONOTONE: switch (type) { case NONE: case MULTIPLICATIVE: return NaturalLogicRelation.INDEPENDENCE; case ADDITIVE: case BOTH: return NaturalLogicRelation.COVER; } case ANTITONE: switch (type) { case NONE: case MULTIPLICATIVE: return NaturalLogicRelation.INDEPENDENCE; case ADDITIVE: case BOTH: return NaturalLogicRelation.ALTERNATION; } case NONMONOTONE: case INVALID: return NaturalLogicRelation.INDEPENDENCE; } case INDEPENDENCE: return NaturalLogicRelation.INDEPENDENCE; } throw new IllegalStateException(\"[should not happen!] Projection table is incomplete for \" + mono + \" : \" + type + \" on relation \" + input); }","old_code_raw":"  private NaturalLogicRelation project(NaturalLogicRelation input, Monotonicity mono, MonotonicityType type) {\n    switch (input) {\n      case EQUIVALENT:\n        return NaturalLogicRelation.EQUIVALENT;\n      case FORWARD_ENTAILMENT:\n        switch (mono) {\n          case MONOTONE:\n            return NaturalLogicRelation.FORWARD_ENTAILMENT;\n          case ANTITONE:\n            return NaturalLogicRelation.REVERSE_ENTAILMENT;\n          case NONMONOTONE:\n          case INVALID:\n            return NaturalLogicRelation.INDEPENDENCE;\n        }\n      case REVERSE_ENTAILMENT:\n        switch (mono) {\n          case MONOTONE:\n            return NaturalLogicRelation.REVERSE_ENTAILMENT;\n          case ANTITONE:\n            return NaturalLogicRelation.FORWARD_ENTAILMENT;\n          case NONMONOTONE:\n          case INVALID:\n            return NaturalLogicRelation.INDEPENDENCE;\n        }\n      case NEGATION:\n        switch (type) {\n          case NONE:\n            return NaturalLogicRelation.INDEPENDENCE;\n          case ADDITIVE:\n            switch (mono) {\n              case MONOTONE:\n                return NaturalLogicRelation.COVER;\n              case ANTITONE:\n                return NaturalLogicRelation.ALTERNATION;\n              case NONMONOTONE:\n              case INVALID:\n                return NaturalLogicRelation.INDEPENDENCE;\n            }\n          case MULTIPLICATIVE:\n            switch (mono) {\n              case MONOTONE:\n                return NaturalLogicRelation.ALTERNATION;\n              case ANTITONE:\n                return NaturalLogicRelation.COVER;\n              case NONMONOTONE:\n              case INVALID:\n                return NaturalLogicRelation.INDEPENDENCE;\n            }\n            break;\n          case BOTH:\n            return NaturalLogicRelation.NEGATION;\n        }\n        break;\n      case ALTERNATION:\n        switch (mono) {\n          case MONOTONE:\n            switch (type) {\n              case NONE:\n              case ADDITIVE:\n                return NaturalLogicRelation.INDEPENDENCE;\n              case MULTIPLICATIVE:\n              case BOTH:\n                return NaturalLogicRelation.ALTERNATION;\n            }\n          case ANTITONE:\n            switch (type) {\n              case NONE:\n              case ADDITIVE:\n                return NaturalLogicRelation.INDEPENDENCE;\n              case MULTIPLICATIVE:\n              case BOTH:\n                return NaturalLogicRelation.COVER;\n            }\n          case NONMONOTONE:\n          case INVALID:\n            return NaturalLogicRelation.INDEPENDENCE;\n        }\n      case COVER:\n        switch (mono) {\n          case MONOTONE:\n            switch (type) {\n              case NONE:\n              case MULTIPLICATIVE:\n                return NaturalLogicRelation.INDEPENDENCE;\n              case ADDITIVE:\n              case BOTH:\n                return NaturalLogicRelation.COVER;\n            }\n          case ANTITONE:\n            switch (type) {\n              case NONE:\n              case MULTIPLICATIVE:\n                return NaturalLogicRelation.INDEPENDENCE;\n              case ADDITIVE:\n              case BOTH:\n                return NaturalLogicRelation.ALTERNATION;\n            }\n          case NONMONOTONE:\n          case INVALID:\n            return NaturalLogicRelation.INDEPENDENCE;\n        }\n      case INDEPENDENCE:\n        return NaturalLogicRelation.INDEPENDENCE;\n    }\n    throw new IllegalStateException(\"[should not happen!] Projection table is incomplete for \" + mono + \" : \" + type + \" on relation \" + input);\n  }\n","new_comment_raw":"@return The projected relation, once passed through an operator with the given specifications.","old_comment_raw":"@return The projected relation, once passed through an operator with the given specifications.","label":0,"pre_label":1,"AST_level":10,"line_counts":107,"new_code_token_num":382},{"new_code_raw":"public String toDefaultValue(Schema p) { if (ModelUtils.isDateSchema(p)) { \/\/ TODO } else if (ModelUtils.isDateTimeSchema(p)) { \/\/ TODO } else if (ModelUtils.isNumberSchema(p)) { if (p.getDefault() != null) { return \"@\" + p.getDefault().toString(); } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getDefault() != null) { return \"@\" + p.getDefault().toString(); } } else if (ModelUtils.isStringSchema(p)) { if (p.getDefault() != null) { return \"@\\\"\" + (String) p.getDefault() + \"\\\"\"; } } else if (ModelUtils.isBooleanSchema(p)) { if (p.getDefault() != null) { if (p.getDefault().toString().equalsIgnoreCase(\"false\")) return \"@(NO)\"; else return \"@(YES)\"; } } return null; }","old_code_raw":"    public String toDefaultValue(Property p) {\n        if (p instanceof StringProperty) {\n            StringProperty dp = (StringProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\\\"\" + dp.getDefault() + \"\\\"\";\n            }\n        } else if (p instanceof BooleanProperty) {\n            BooleanProperty dp = (BooleanProperty) p;\n            if (dp.getDefault() != null) {\n                if (dp.getDefault().toString().equalsIgnoreCase(\"false\"))\n                    return \"@(NO)\";\n                else\n                    return \"@(YES)\";\n            }\n        } else if (p instanceof DateProperty) {\n            \/\/ TODO\n        } else if (p instanceof DateTimeProperty) {\n            \/\/ TODO\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return \"@\" + dp.getDefault().toString();\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"@return string presentation of the default value of the schema","old_comment_raw":"@return string presentation of the default value of the property","label":1,"pre_label":0,"AST_level":15,"line_counts":29,"new_code_token_num":206},{"new_code_raw":"public int getStack(int k) { int nStack = getStackSize(); return (k >= 0 && k < nStack) ? stack.get(nStack - 1 - k) : Config.NONEXIST; }","old_code_raw":"  public int getStack(int k) {\n    int nStack = getStackSize();\n    return (k >= 0 && k < nStack) ? stack.get(nStack - 1 - k) : CONST.NONEXIST;\n  }\n","new_comment_raw":"@return Sentence index or  Config#NONEXIST if stack doesn't have an element at this index","old_comment_raw":"@return Sentence index or CONST#NONEXIST if stack doesn't have an element at this index","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":38},{"new_code_raw":"public ServerAddress address() { return execute(\"get replica set primary\", primary -> { ReplicaSetStatus rsStatus = primary.getReplicaSetStatus(); if (rsStatus != null) { return rsStatus.getMaster(); } else { return null; } }); }","old_code_raw":"        public ServerAddress address() {\n            AtomicReference<ServerAddress> address = new AtomicReference<>();\n            execute(\"get replica set primary\", primary -> {\n                ReplicaSetStatus rsStatus = primary.getReplicaSetStatus();\n                if (rsStatus != null) {\n                    address.set(rsStatus.getMaster());\n                }\n            });\n            return address.get();\n        }\n","new_comment_raw":"@return the address of the replica set's primary node, or  null if there is currently no primary","old_comment_raw":"@return the address of the replica set's primary node, or null if there is currently no primary","label":0,"pre_label":1,"AST_level":9,"line_counts":12,"new_code_token_num":50},{"new_code_raw":"private static boolean isStylusButtonPressed(MotionEvent event) { return event.getToolType(0) == MotionEvent.TOOL_TYPE_STYLUS && ((event.getButtonState() & MotionEvent.BUTTON_SECONDARY) == MotionEvent.BUTTON_SECONDARY); }","old_code_raw":"    public static boolean isStylusButtonPressed(MotionEvent event) {\n        return event.getToolType(0) == MotionEvent.TOOL_TYPE_STYLUS\n                && event.isButtonPressed(MotionEvent.BUTTON_SECONDARY);\n    }\n","new_comment_raw":"@return Whether a stylus button press occurred.","old_comment_raw":"@return Whether a stylus button press occurred.","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":34},{"new_code_raw":"private Object convertToDuration(Column column, String value) { return Duration.between(LocalTime.MIN, LocalTime.from(timeFormat(column.length()).parse(value))); }","old_code_raw":"    private Object convertToDuration(Column column, String value) {\n        String timeFormat = timeFormat(column.length());\n        return Duration.between(LocalTime.MIN, LocalTime.from(DateTimeFormatter.ofPattern(timeFormat).parse(value)));\n    }\n","new_comment_raw":"@return the converted value;","old_comment_raw":"@return the converted value;","label":0,"pre_label":1,"AST_level":8,"line_counts":4,"new_code_token_num":36},{"new_code_raw":"public static DefaultMetaBroadcaster metaBroadcaster() { return metaBroadcaster; }","old_code_raw":"public static MetaBroadcaster metaBroadcaster() {\n    return metaBroadcaster;\n}","new_comment_raw":"@return the {@link DefaultMetaBroadcaster}","old_comment_raw":"@return the {@link org.atmosphere.cpr.MetaBroadcaster}","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"protected Object convertDateToEpochDaysAsDate(Column column, Field fieldDefn, Object data) { \/\/ epoch is the fallback value return convertValue(column, fieldDefn, data, new java.util.Date(0L), (r) -> { try { int epochDay = Date.toEpochDay(data, adjuster); long epochMillis = TimeUnit.DAYS.toMillis(epochDay); r.deliver(new java.util.Date(epochMillis)); } catch (IllegalArgumentException e) { logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(), fieldDefn.schema(), data.getClass(), data); } }); }","old_code_raw":"    protected Object convertDateToEpochDaysAsDate(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return new java.util.Date(0L); \/\/ return epoch\n        }\n        try {\n            int epochDay = Date.toEpochDay(data, adjuster);\n            long epochMillis = TimeUnit.DAYS.toMillis(epochDay);\n            return new java.util.Date(epochMillis);\n        } catch (IllegalArgumentException e) {\n            logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(),\n                        fieldDefn.schema(), data.getClass(), data);\n            return null;\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":12,"line_counts":14,"new_code_token_num":132},{"new_code_raw":"public Options includeSchemaDefintion(boolean flag) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, flag, this.includeDirectives, this.useAstDefinitions, this.comparatorRegistry); }","old_code_raw":"        public Options includeSchemaDefintion(boolean flag) {\n            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, flag, this.includeDirectives, this.comparatorRegistry);\n        }\n","new_comment_raw":"@return options","old_comment_raw":"@return options","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public TextView waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) { return waitForText(TextView.class, text, expectedMinimumNumberOfMatches, timeout, scroll, false, true); }","old_code_raw":"\tpublic TextView waitForText(String text, int expectedMinimumNumberOfMatches, long timeout)\n\t{\n\t\treturn waitForText(text, expectedMinimumNumberOfMatches, timeout, true);\n\t}\n","new_comment_raw":"@return  true if text is found and  false if it is not found before the timeout","old_comment_raw":"@return true if text is found and false if it is not found before the timeout","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":37},{"new_code_raw":"public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) { try { return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[] { AtmosphereConfig.class }).newInstance(config); } catch (final Exception e) { logger.warn(STR, targetClass, e); return null; } }","old_code_raw":"public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) {\n    try {\n        return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[] { AtmosphereConfig.class }).newInstance(config);\n    } catch (final Exception e) {\n        logger.error(STR, targetClass, e);\n        logger.error(STR);\n        return new BlockingIOCometSupport(config);\n    }\n}","new_comment_raw":"@return an instance of the specified class or null if the class cannot be instantiated","old_comment_raw":"@return an instance of the specified class","label":1,"pre_label":0,"AST_level":10,"line_counts":8,"new_code_token_num":58},{"new_code_raw":"public Observable<ConnectivityStatus> observeConnectivity(final Context context) { final IntentFilter filter = new IntentFilter(); filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION); return Observable.create(new Observable.OnSubscribe<ConnectivityStatus>() { @Override public void call(final Subscriber<? super ConnectivityStatus> subscriber) { final BroadcastReceiver receiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final ConnectivityStatus newStatus = getConnectivityStatus(context, checkInternet); \/\/ we need to perform check below, \/\/ because after going off-line, onReceive() is called twice if (newStatus != status) { status = newStatus; subscriber.onNext(newStatus); } } }; context.registerReceiver(receiver, filter); subscriber.add(unsubscribeInUiThread(new Action0() { @Override public void call() { context.unregisterReceiver(receiver); } })); } }).defaultIfEmpty(ConnectivityStatus.OFFLINE); }","old_code_raw":"  public Observable<ConnectivityStatus> observeConnectivity(final Context context) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);\n\n    return Observable.create(new Observable.OnSubscribe<ConnectivityStatus>() {\n      @Override public void call(final Subscriber<? super ConnectivityStatus> subscriber) {\n        final BroadcastReceiver receiver = new BroadcastReceiver() {\n          @Override public void onReceive(Context context, Intent intent) {\n            final ConnectivityStatus newStatus = getConnectivityStatus(context);\n\n            \/\/ we need to perform check below,\n            \/\/ because after going off-line, onReceive() is called twice\n            if (newStatus != status) {\n              status = newStatus;\n              subscriber.onNext(newStatus);\n            }\n          }\n        };\n\n        context.registerReceiver(receiver, filter);\n\n        subscriber.add(unsubscribeInUiThread(new Action0() {\n          @Override public void call() {\n            context.unregisterReceiver(receiver);\n          }\n        }));\n      }\n    }).defaultIfEmpty(ConnectivityStatus.OFFLINE);\n  }\n","new_comment_raw":"@return RxJava Observable with ConnectivityStatus","old_comment_raw":"@return RxJava Observable with ConnectivityStatus","label":0,"pre_label":1,"AST_level":15,"line_counts":30,"new_code_token_num":172},{"new_code_raw":"private int executeSUCommands(String[] commands) throws EShellExecException { int ret = NUM; File rootFolder = new File(mRootOfWorkPath); File workingFolder = new File(rootFolder, TEMP_FOLDER); String workingFolderPath = workingFolder.getAbsolutePath(); if (!workingFolder.exists() && !workingFolder.mkdir()) { throw (new EShellExecException(STR)); } broadcastProgress(NUM, STR + workingFolder.getAbsolutePath()); try { Utils.extractExecutableAsset(this, ANDROID_BOOTMGR, workingFolderPath, true); Utils.extractExecutableAsset(this, ANDROID_LOOP_MOUNT, workingFolderPath, true); Utils.extractExecutableAsset(this, ARCHIVE_MASTER_ASC, workingFolderPath, false); Utils.extractExecutableAsset(this, ARCHIVE_MASTER, workingFolderPath, false); Utils.extractExecutableAsset(this, BUSYBOX, workingFolderPath, true); Utils.extractExecutableAsset(this, GPG, workingFolderPath, true); Utils.extractExecutableAsset(this, TAR, workingFolderPath, true); Utils.extractExecutableAsset(this, UPDATE_SCRIPT, workingFolderPath, true); Utils.extractExecutableAsset(this, U_REBOOT_APP_ASC, workingFolderPath, false); Utils.extractExecutableAsset(this, U_REBOOT_APP, workingFolderPath, false); Utils.extractExecutableAsset(this, UPGRADECHECKER, workingFolderPath, true); } catch (IOException e) { throw (new EShellExecException(STR)); } mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, STR); try { Process process = Runtime.getRuntime().exec(STR, null, workingFolder); DataOutputStream os = new DataOutputStream(process.getOutputStream()); os.writeBytes(STR); os.writeBytes(STR); os.writeBytes(String.format(STR, workingFolder.getAbsolutePath())); os.writeBytes(String.format(STR, workingFolder.getAbsolutePath())); for (String cmd : commands) { Log.d(TAG, STR + cmd + STR); os.writeBytes(cmd + STR); os.writeBytes(STR); } os.writeBytes(String.format(STR, workingFolder.getAbsolutePath())); os.writeBytes(STR); os.flush(); int read = NUM; byte[] buff = new byte[NUM]; InputStream is = process.getInputStream(); InputStream es = process.getErrorStream(); boolean running = true; boolean scriptExecuted = false; do { while (is.available() > NUM) { read = is.read(buff); if (read <= NUM) { break; } scriptExecuted = true; String seg = new String(buff, NUM, read); Log.i(TAG, STR + seg); broadcastProgress(-NUM, seg); } while (es.available() > NUM) { read = es.read(buff); if (read <= NUM) { break; } scriptExecuted = true; String seg = new String(buff, NUM, read); if (seg.startsWith(STR)) { mTotalSize += PROGRESS_MKSWAP_ADJUSTMENT + PROGRESS_SWAP_CREATION_ADJUSTMENT; } else { mProgress++; if (mTotalSize > NUM && mLastSignalledProgress < (mProgress * NUM \/ mTotalSize)) { mLastSignalledProgress = (int) (mProgress * NUM \/ mTotalSize); broadcastProgress(mLastSignalledProgress, null); } } Log.i(TAG, STR + seg); } try { ret = process.exitValue(); Log.d(TAG, STR + ret); if (!scriptExecuted) { throw new EShellExecException(STR); } running = false; } catch (IllegalThreadStateException e) { try { Thread.sleep(NUM); } catch (Exception ex) { } } } while (running); } catch (IOException e) { throw (new EShellExecException(STR + e.getMessage())); } finally { if (mWakeLock != null && mWakeLock.isHeld()) { mWakeLock.release(); } } return ret; }","old_code_raw":"private int executeSUCommands(Intent result, String resultExtraText, String[] commands) {\n    File rootFolder = new File(mRootOfWorkPath);\n    File workingFolder = new File(rootFolder, TEMP_FOLDER);\n    if (!workingFolder.exists() && !workingFolder.mkdir()) {\n        result.putExtra(resultExtraText, STR);\n        return -NUM;\n    }\n    try {\n        Utils.extractExecutableAsset(this, UPDATE_SCRIPT, workingFolder.toString(), true);\n        Utils.extractExecutableAsset(this, ANDROID_LOOP_MOUNT, workingFolder.toString(), true);\n        Utils.extractExecutableAsset(this, ANDROID_BOOTMGR, workingFolder.toString(), true);\n    } catch (IOException e) {\n        e.printStackTrace();\n        result.putExtra(resultExtraText, STR);\n        return -NUM;\n    }\n    mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, STR);\n    try {\n        Process process = Runtime.getRuntime().exec(STR, null, workingFolder);\n        DataOutputStream os = new DataOutputStream(process.getOutputStream());\n        os.writeBytes(STR);\n        for (String c : commands) {\n            Log.v(TAG, STR + c);\n            os.writeBytes(String.format(STR, workingFolder.getAbsolutePath()));\n            os.writeBytes(c);\n        }\n        os.writeBytes(String.format(STR, workingFolder.getAbsolutePath()));\n        os.writeBytes(STR);\n        os.flush();\n        int read = NUM;\n        byte[] buff = new byte[NUM];\n        InputStream is = process.getInputStream();\n        InputStream es = process.getErrorStream();\n        boolean running = true;\n        boolean scriptExecuted = false;\n        do {\n            while (is.available() > NUM) {\n                read = is.read(buff);\n                if (read <= NUM) {\n                    break;\n                }\n                scriptExecuted = true;\n                String seg = new String(buff, NUM, read);\n                Log.i(TAG, STR + seg);\n                broadcastProgress(-NUM, seg);\n            }\n            while (es.available() > NUM) {\n                read = es.read(buff);\n                if (read <= NUM) {\n                    break;\n                }\n                scriptExecuted = true;\n                String seg = new String(buff, NUM, read);\n                Log.i(TAG, STR + seg);\n            }\n            try {\n                int ret = process.exitValue();\n                Log.v(TAG, STR + ret);\n                if (ret == NUM || !scriptExecuted) {\n                    result.putExtra(resultExtraText, STR);\n                    return -NUM;\n                } else if (ret != NUM) {\n                    result.putExtra(resultExtraText, STR);\n                    return -NUM;\n                }\n                running = false;\n            } catch (IllegalThreadStateException e) {\n                try {\n                    Thread.sleep(NUM);\n                } catch (Exception ex) {\n                }\n            }\n        } while (running);\n    } catch (IOException e) {\n        e.printStackTrace();\n        result.putExtra(resultExtraText, STR);\n        return -NUM;\n    } finally {\n        if (mWakeLock != null && mWakeLock.isHeld()) {\n            mWakeLock.release();\n        }\n    }\n    return NUM;\n}","new_comment_raw":"@return shell script exit value.","old_comment_raw":"@return 0 for success and -1 for fail","label":1,"pre_label":0,"AST_level":17,"line_counts":98,"new_code_token_num":691},{"new_code_raw":"public ApiResponse<byte[]> petPetIdtestingByteArraytrueGetWithHttpInfo(Long petId) throws ApiException { Call call = petPetIdtestingByteArraytrueGetCall(petId, null, null); Type localVarReturnType = new TypeToken<byte[]>(){}.getType(); return apiClient.execute(call, localVarReturnType); }","old_code_raw":"  public ApiResponse<byte[]> petPetIdtestingByteArraytrueGetWithHttpInfo(Long petId) throws ApiException {\n    Call call = petPetIdtestingByteArraytrueGetCall(petId, null, null);\n    Type returnType = new TypeToken<byte[]>(){}.getType();\n    return apiClient.execute(call, returnType);\n  }\n","new_comment_raw":"@return ApiResponse","old_comment_raw":"@return ApiResponse","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":49},{"new_code_raw":"protected Object convertInteger(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; } if (data instanceof Integer) return data; if (data instanceof Number) { Number value = (Number) data; return new Integer(value.intValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? INTEGER_TRUE : INTEGER_FALSE; } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertInteger(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof Integer) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Integer(value.intValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? INTEGER_TRUE : INTEGER_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":19,"new_code_token_num":118},{"new_code_raw":"public ArrayList<View> getViews() { try { return ensureArrayListOrNull(viewFetcher.getViews()); } catch (Exception e) { e.printStackTrace(); return null; } }","old_code_raw":"\tpublic ArrayList<View> getViews() {\n\t\treturn ensureArrayListOrNull(viewFetcher.getViews());\n\t}\n","new_comment_raw":"@return a  List of the  Views located in the current  Activity","old_comment_raw":"@return a List of the Views located in the current Activity","label":0,"pre_label":1,"AST_level":6,"line_counts":9,"new_code_token_num":35},{"new_code_raw":"public final int getPeekHeight() { return mPeekHeightAuto ? PEEK_HEIGHT_AUTO : mPeekHeight; }","old_code_raw":"public final int getPeekHeight() {\n    return mPeekHeight;\n}","new_comment_raw":"@return The height of the collapsed bottom sheet in pixels, or {@link #PEEK_HEIGHT_AUTO} if the sheet is configured to peek automatically at 16:9 ratio keyline","old_comment_raw":"@return The height of the collapsed bottom sheet.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":15},{"new_code_raw":"Tuple2<Boolean, String> setFwkMetadata(String name, String sqlExpr, boolean createTable) throws SQLException { if (Boolean.getBoolean(NOAUTO_CREATE_METADATA)) return Tuple2.create(false, null); final SQLSystem sys = getServer().getSQLSystem(); final SQLSyntax syntax = sys.getSyntax(); final SQLDataSource ds = this.getDBSystemRoot().getDataSource(); synchronized (this.getTreeMutex()) { final boolean shouldRefresh; if (createTable && !this.contains(METADATA_TABLENAME)) { final SQLCreateMoveableTable create = getCreateMetadata(syntax); ds.execute(create.asString(getDBRoot().getName())); shouldRefresh = true; } else { shouldRefresh = false; } final Tuple2<Boolean, String> res; if (createTable || this.contains(METADATA_TABLENAME)) { final List<String> queries = new ArrayList<String>(); final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME); final String where = STR + SQLBase.quoteIdentifier(STR) + STR + getBase().quoteString(name); queries.add(STR + tableName.quote() + where); final String returning = sys == SQLSystem.POSTGRESQL ? STR + SQLBase.quoteIdentifier(STR) : STR; final String ins = syntax.getInsertOne(tableName, Arrays.asList(STR, STR), getBase().quoteString(name), sqlExpr) + returning; queries.add(ins); final List<? extends ResultSetHandler> handlers; if (returning.length() == NUM) { queries.add(STR + SQLBase.quoteIdentifier(STR) + STR + tableName.quote() + where); handlers = Arrays.asList(null, null, SQLDataSource.SCALAR_HANDLER); } else { handlers = Arrays.asList(null, SQLDataSource.SCALAR_HANDLER); } final List<?> ress = SQLUtils.executeMultiple(getDBSystemRoot(), queries, handlers); res = Tuple2.create(true, (String) ress.get(ress.size() - NUM)); } else { res = Tuple2.create(false, null); } if (shouldRefresh) this.fetchTable(METADATA_TABLENAME); return res; } }","old_code_raw":"boolean setFwkMetadata(String name, String value, boolean createTable) throws SQLException {\n    if (Boolean.getBoolean(NOAUTO_CREATE_METADATA))\n        return false;\n    synchronized (this.getTreeMutex()) {\n        final boolean shouldRefresh;\n        if (createTable && !this.contains(METADATA_TABLENAME)) {\n            final SQLCreateMoveableTable create = getCreateMetadata(getServer().getSQLSystem().getSyntax());\n            this.getBase().getDataSource().execute(create.asString(getDBRoot().getName()));\n            shouldRefresh = true;\n        } else\n            shouldRefresh = false;\n        final boolean res;\n        if (createTable || this.contains(METADATA_TABLENAME)) {\n            final SQLName tableName = new SQLName(this.getBase().getName(), this.getName(), METADATA_TABLENAME);\n            final String del = SQLSelect.quote(STR, tableName, STR, name);\n            final String ins = SQLSelect.quote(STR, tableName, STR, STR, name, value);\n            SQLUtils.executeAtomic(this.getBase().getDataSource(), new SQLFactory<Object>() {\n\n                public Object create() throws SQLException {\n                    getBase().getDataSource().execute(del);\n                    getBase().getDataSource().execute(ins);\n                    return null;\n                }\n            });\n            res = true;\n        } else\n            res = false;\n        if (shouldRefresh)\n            this.fetchTable(METADATA_TABLENAME);\n        return res;\n    }\n}","new_comment_raw":"@return <code>true<\/code> if the value was set, <code>false<\/code> otherwise ; the new value (<code>null<\/code> if the value wasn't set, i.e. if the value cannot be <code>null<\/code> the boolean isn't needed).","old_comment_raw":"@return <code>true<\/code> if the value was set, <code>false<\/code> otherwise.","label":1,"pre_label":0,"AST_level":15,"line_counts":41,"new_code_token_num":387},{"new_code_raw":"public ChromeDriverService build() { if (port == 0) { port = PortProber.findFreePort(); } checkState(exe != null, \"Path to the chromedriver executable not specified\"); try { return new ChromeDriverService(exe, port, environment, logFile); } catch (IOException e) { throw new WebDriverException(e); } }","old_code_raw":"    public ChromeDriverService build() {\n      if (port == 0) {\n        port = PortProber.findFreePort();\n      }\n\n      checkState(exe != null, \"Path to the chromedriver executable not specified\");\n\n      try {\n        return new ChromeDriverService(exe, port, environment);\n      } catch (IOException e) {\n        throw new WebDriverException(e);\n      }\n    }\n","new_comment_raw":"@return The new binary.","old_comment_raw":"@return The new binary.","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":67},{"new_code_raw":"public String toLoggableString(Object value, SessionFactoryImplementor factory) { if ( value == null ) { return \"null\"; } final EntityPersister persister = getAssociatedEntityPersister( factory ); if ( !persister.getEntityTuplizer().isInstance( value ) ) { \/\/ it should be the id type... if ( persister.getIdentifierType().getReturnedClass().isInstance( value ) ) { return associatedEntityName + \"#\" + value; } } final StringBuilder result = new StringBuilder().append( associatedEntityName ); if ( persister.hasIdentifierProperty() ) { final Serializable id; if ( value instanceof HibernateProxy ) { HibernateProxy proxy = (HibernateProxy) value; id = proxy.getHibernateLazyInitializer().getIdentifier(); } else { id = persister.getIdentifier( value ); } result.append( '#' ) .append( persister.getIdentifierType().toLoggableString( id, factory ) ); } return result.toString(); }","old_code_raw":"\tpublic String toLoggableString(Object value, SessionFactoryImplementor factory) {\n\t\tif ( value == null ) {\n\t\t\treturn \"null\";\n\t\t}\n\n\t\tEntityPersister persister = getAssociatedEntityPersister( factory );\n\t\tStringBuilder result = new StringBuilder().append( associatedEntityName );\n\n\t\tif ( persister.hasIdentifierProperty() ) {\n\t\t\tfinal Serializable id;\n\t\t\tif ( value instanceof HibernateProxy ) {\n\t\t\t\tHibernateProxy proxy = (HibernateProxy) value;\n\t\t\t\tid = proxy.getHibernateLazyInitializer().getIdentifier();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid = persister.getIdentifier( value );\n\t\t\t}\n\n\t\t\tresult.append( '#' )\n\t\t\t\t\t.append( persister.getIdentifierType().toLoggableString( id, factory ) );\n\t\t}\n\n\t\treturn result.toString();\n\t}\n","new_comment_raw":"@return The loggable string.","old_comment_raw":"@return The loggable string.","label":0,"pre_label":1,"AST_level":10,"line_counts":32,"new_code_token_num":165},{"new_code_raw":"public OutEdges<I, E> unwrap() { if (currentEdge != null) { newEdges.add(currentEdge); currentEdge = null; } while (oldEdgesIterator.hasNext()) { newEdges.add(oldEdgesIterator.next()); } return newEdges; }","old_code_raw":"public VertexEdges<I, E> unwrap() {\n    if (currentEdge != null) {\n        newEdges.add(currentEdge);\n        currentEdge = null;\n    }\n    while (oldEdgesIterator.hasNext()) {\n        newEdges.add(oldEdgesIterator.next());\n    }\n    return newEdges;\n}","new_comment_raw":"@return The new {@link OutEdges} data structure.","old_comment_raw":"@return The new {@link VertexEdges} data structure.","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":48},{"new_code_raw":"public String getName() { return name == null ? \"null\" : name.toUpperCase(); }","old_code_raw":"    public String getName() {\n        return name.toUpperCase();\n    }\n","new_comment_raw":"@return the name","old_comment_raw":"@return the name","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"@Override public Object put(Object value) { return put(null, value); }","old_code_raw":"@Override\npublic Object put(Object value) {\n    return put(value, false);\n}","new_comment_raw":"@return {@link #put(String, Object)}","old_comment_raw":"@return {@link #put(String, boolean)}","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"private boolean zzRefill() throws java.io.IOException { \/* first: make room (if you can) *\/ if (zzStartRead > 0) { zzEndRead += zzFinalHighSurrogate; zzFinalHighSurrogate = 0; System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead-zzStartRead); \/* translate stored positions *\/ zzEndRead-= zzStartRead; zzCurrentPos-= zzStartRead; zzMarkedPos-= zzStartRead; zzStartRead = 0; } \/* is the buffer big enough? *\/ if (zzCurrentPos >= zzBuffer.length - zzFinalHighSurrogate) { \/* if not: blow it up *\/ char newBuffer[] = new char[zzBuffer.length*2]; System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length); zzBuffer = newBuffer; zzEndRead += zzFinalHighSurrogate; zzFinalHighSurrogate = 0; } \/* fill the buffer with new input *\/ int requested = zzBuffer.length - zzEndRead; int numRead = zzReader.read(zzBuffer, zzEndRead, requested); \/* not supposed to occur according to specification of java.io.Reader *\/ if (numRead == 0) { throw new java.io.IOException(\"Reader returned 0 characters. See JFlex examples for workaround.\"); } if (numRead > 0) { zzEndRead += numRead; \/* If numRead == requested, we might have requested to few chars to encode a full Unicode character. We assume that a Reader would otherwise never return half characters. *\/ if (numRead == requested) { if (Character.isHighSurrogate(zzBuffer[zzEndRead - 1])) { --zzEndRead; zzFinalHighSurrogate = 1; } } \/* potentially more input available *\/ return false; } \/* numRead < 0 ==> end of stream *\/ return true; }","old_code_raw":"  private boolean zzRefill() throws java.io.IOException {\n\n    \/* first: make room (if you can) *\/\n    if (zzStartRead > 0) {\n      System.arraycopy(zzBuffer, zzStartRead,\n                       zzBuffer, 0,\n                       zzEndRead-zzStartRead);\n\n      \/* translate stored positions *\/\n      zzEndRead-= zzStartRead;\n      zzCurrentPos-= zzStartRead;\n      zzMarkedPos-= zzStartRead;\n      zzStartRead = 0;\n    }\n\n    \/* is the buffer big enough? *\/\n    if (zzCurrentPos >= zzBuffer.length) {\n      \/* if not: blow it up *\/\n      char newBuffer[] = new char[zzCurrentPos*2];\n      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);\n      zzBuffer = newBuffer;\n    }\n\n    \/* finally: fill the buffer with new input *\/\n    int numRead = zzReader.read(zzBuffer, zzEndRead,\n                                            zzBuffer.length-zzEndRead);\n\n    if (numRead > 0) {\n      zzEndRead+= numRead;\n      return false;\n    }\n    \/\/ unlikely but not impossible: read 0 characters, but not at end of stream    \n    if (numRead == 0) {\n      int c = zzReader.read();\n      if (c == -1) {\n        return true;\n      } else {\n        zzBuffer[zzEndRead++] = (char) c;\n        return false;\n      }     \n    }\n\n    \/\/ numRead < 0\n    return true;\n  }\n","new_comment_raw":"@return false, iff there was new input.","old_comment_raw":"@return false, iff there was new input.","label":0,"pre_label":1,"AST_level":12,"line_counts":54,"new_code_token_num":309},{"new_code_raw":"public StringExpression substring(Expression<Integer> beginIndex, Expression<Integer> endIndex) { return StringOperation.create(Ops.SUBSTR_2ARGS, mixin, beginIndex, endIndex); }","old_code_raw":"    public StringExpression substring(Expression<Integer> beginIndex, Expression<Integer> endIndex) {\n        return StringOperation.create(Ops.SUBSTR_2ARGS, this, beginIndex, endIndex);\n    }\n","new_comment_raw":"@return this.substring(beginIndex, endIndex)","old_comment_raw":"@return this.substring(beginIndex, endIndex)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public static TimestampedEntry parseTimestampedEntry(InputStream in) { TimestampedEntry timestampedEntry = new TimestampedEntry(); timestampedEntry.timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH); int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH); timestampedEntry.entryType = Ct.LogEntryType.valueOf(entryType); Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder(); if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) { int length = (int) readNumber(in, NUM); ByteString x509 = ByteString.copyFrom(readFixedLength(in, length)); signedEntryBuilder.setX509(x509); } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) { Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder(); byte[] arr = readFixedLength(in, NUM); preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr)); arr = readFixedLength(in, NUM); int length = (int) readNumber(in, NUM); preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length))); preCertBuilder.build(); signedEntryBuilder.setPrecert(preCertBuilder); } else { throw new SerializationException(String.format(STR, entryType)); } timestampedEntry.signedEntry = signedEntryBuilder.build(); return timestampedEntry; }","old_code_raw":"public static Ct.TimestampedEntry parseTimestampedEntry(InputStream in) {\n    Ct.TimestampedEntry.Builder timestampedEntry = Ct.TimestampedEntry.newBuilder();\n    long timestamp = readNumber(in, CTConstants.TIMESTAMP_LENGTH);\n    timestampedEntry.setTimestamp(timestamp);\n    int entryType = (int) readNumber(in, CTConstants.LOG_ENTRY_TYPE_LENGTH);\n    timestampedEntry.setEntryType(Ct.LogEntryType.valueOf(entryType));\n    Ct.SignedEntry.Builder signedEntryBuilder = Ct.SignedEntry.newBuilder();\n    if (entryType == Ct.LogEntryType.X509_ENTRY_VALUE) {\n        int length = (int) readNumber(in, NUM);\n        ByteString x509 = ByteString.copyFrom(readFixedLength(in, length));\n        signedEntryBuilder.setX509(x509);\n    } else if (entryType == Ct.LogEntryType.PRECERT_ENTRY_VALUE) {\n        Ct.PreCert.Builder preCertBuilder = Ct.PreCert.newBuilder();\n        byte[] arr = readFixedLength(in, NUM);\n        preCertBuilder.setIssuerKeyHash(ByteString.copyFrom(arr));\n        arr = readFixedLength(in, NUM);\n        int length = (int) readNumber(in, NUM);\n        preCertBuilder.setTbsCertificate(ByteString.copyFrom(readFixedLength(in, length)));\n        preCertBuilder.build();\n        signedEntryBuilder.setPrecert(preCertBuilder);\n    } else {\n        throw new SerializationException(String.format(STR, entryType));\n    }\n    signedEntryBuilder.build();\n    timestampedEntry.setSignedEntry(signedEntryBuilder);\n    return timestampedEntry.build();\n}","new_comment_raw":"@return Built {@link TimestampedEntry}.","old_comment_raw":"@return Built {@link Ct.TimestampedEntry}.","label":1,"pre_label":0,"AST_level":10,"line_counts":25,"new_code_token_num":212},{"new_code_raw":"private static String convertBufferToString(byte[] buf) throws UnsupportedEncodingException { return new String(buf, 0, buf.length - 2, \"UTF-16LE\"); }","old_code_raw":"  private static String convertBufferToString(byte[] buf) throws UnsupportedEncodingException {\n    return(new String(buf, 0, buf.length - 2, \"UTF-16LE\"));\n  }\n","new_comment_raw":"@return String","old_comment_raw":"@return String","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public AggIterOutcome outputCurrentBatch() { \/\/ Handle the case of an EMIT with an empty batch if ( handleEmit && ( batchHolders == null || batchHolders[0].size() == 0 ) ) { lastBatchOutputCount = 0; \/\/ empty allocateOutgoing(0); for (VectorWrapper<?> v : outgoing) { v.getValueVector().getMutator().setValueCount(0); } outgoing.getContainer().setRecordCount(0); \/\/ When returning the last outgoing batch (following an incoming EMIT), then replace OK with EMIT this.outcome = IterOutcome.EMIT; handleEmit = false; \/\/ finish handling EMIT if ( outBatchIndex != null ) { outBatchIndex[0] = 0; \/\/ reset, for the next EMIT } return AggIterOutcome.AGG_EMIT; } \/\/ when incoming was an empty batch, just finish up if ( schema == null ) { logger.trace(\"Incoming was empty; output is an empty batch.\"); this.outcome = IterOutcome.NONE; \/\/ no records were read allFlushed = true; return AggIterOutcome.AGG_NONE; } \/\/ Initialization (covers the case of early output) ArrayList<BatchHolder> currPartition = batchHolders[earlyPartition]; int currOutBatchIndex = outBatchIndex[earlyPartition]; int partitionToReturn = earlyPartition; if ( ! earlyOutput ) { \/\/ Update the next partition to return (if needed) \/\/ skip fully returned (or spilled) partitions while (nextPartitionToReturn < numPartitions) { \/\/ \/\/ If this partition was spilled - spill the rest of it and skip it \/\/ if ( isSpilled(nextPartitionToReturn) ) { spillAPartition(nextPartitionToReturn); \/\/ spill the rest SpilledPartition sp = new SpilledPartition(); sp.spillFile = spillFiles[nextPartitionToReturn]; sp.spilledBatches = spilledBatchesCount[nextPartitionToReturn]; sp.cycleNum = cycleNum; \/\/ remember the current cycle sp.origPartn = nextPartitionToReturn; \/\/ for debugging \/ filename sp.prevOrigPartn = originalPartition; \/\/ for debugging \/ filename spilledPartitionsList.add(sp); reinitPartition(nextPartitionToReturn); \/\/ free the memory try { spillSet.close(writers[nextPartitionToReturn]); } catch (IOException ioe) { throw UserException.resourceError(ioe) .message(\"IO Error while closing output stream\") .build(logger); } writers[nextPartitionToReturn] = null; } else { currPartition = batchHolders[nextPartitionToReturn]; currOutBatchIndex = outBatchIndex[nextPartitionToReturn]; \/\/ If curr batch (partition X index) is not empty - proceed to return it if (currOutBatchIndex < currPartition.size() && 0 != currPartition.get(currOutBatchIndex).getNumPendingOutput()) { break; } } nextPartitionToReturn++; \/\/ else check next partition } \/\/ if passed the last partition - either done or need to restart and read spilled partitions if (nextPartitionToReturn >= numPartitions) { \/\/ The following \"if\" is probably never used; due to a similar check at the end of this method if ( spilledPartitionsList.isEmpty() ) { \/\/ and no spilled partitions allFlushed = true; this.outcome = IterOutcome.NONE; if ( is2ndPhase && spillSet.getWriteBytes() > 0 ) { stats.setLongStat(Metric.SPILL_MB, \/\/ update stats - total MB spilled (int) Math.round(spillSet.getWriteBytes() \/ 1024.0D \/ 1024.0)); } return AggIterOutcome.AGG_NONE; \/\/ then return NONE } \/\/ Else - there are still spilled partitions to process - pick one and handle just like a new incoming buildComplete = false; \/\/ go back and call doWork() again handlingSpills = true; \/\/ beginning to work on the spill files \/\/ pick a spilled partition; set a new incoming ... SpilledPartition sp = spilledPartitionsList.remove(0); \/\/ Create a new \"incoming\" out of the spilled partition spill file newIncoming = new SpilledRecordbatch(sp.spillFile, sp.spilledBatches, context, schema, oContext, spillSet); originalPartition = sp.origPartn; \/\/ used for the filename logger.trace(\"Reading back spilled original partition {} as an incoming\",originalPartition); \/\/ Initialize .... new incoming, new set of partitions try { initializeSetup(newIncoming); } catch (Exception e) { throw new RuntimeException(e); } \/\/ update the cycle num if needed \/\/ The current cycle num should always be one larger than in the spilled partition if ( cycleNum == sp.cycleNum ) { cycleNum = 1 + sp.cycleNum; stats.setLongStat(Metric.SPILL_CYCLE, cycleNum); \/\/ update stats \/\/ report first spill or memory stressful situations if ( cycleNum == 1 ) { logger.info(\"Started reading spilled records \"); } if ( cycleNum == 2 ) { logger.info(\"SECONDARY SPILLING \"); } if ( cycleNum == 3 ) { logger.warn(\"TERTIARY SPILLING \"); } if ( cycleNum == 4 ) { logger.warn(\"QUATERNARY SPILLING \"); } if ( cycleNum == 5 ) { logger.warn(\"QUINARY SPILLING \"); } } if ( EXTRA_DEBUG_SPILL ) { logger.debug(\"Start reading spilled partition {} (prev {}) from cycle {} (with {} batches). More {} spilled partitions left.\", sp.origPartn, sp.prevOrigPartn, sp.cycleNum, sp.spilledBatches, spilledPartitionsList.size()); } return AggIterOutcome.AGG_RESTART; } partitionToReturn = nextPartitionToReturn ; } \/\/ get the number of records in the batch holder that are pending output int numPendingOutput = currPartition.get(currOutBatchIndex).getNumPendingOutput(); \/\/ The following accounting is for logging, metrics, etc. rowsInPartition += numPendingOutput ; if ( ! handlingSpills ) { rowsNotSpilled += numPendingOutput; } else { rowsSpilledReturned += numPendingOutput; } if ( earlyOutput ) { rowsReturnedEarly += numPendingOutput; } allocateOutgoing(numPendingOutput); currPartition.get(currOutBatchIndex).outputValues(outStartIdxHolder, outNumRecordsHolder); int numOutputRecords = outNumRecordsHolder.value; if (EXTRA_DEBUG_1) { logger.debug(\"After output values: outStartIdx = {}, outNumRecords = {}\", outStartIdxHolder.value, outNumRecordsHolder.value); } this.htables[partitionToReturn].outputKeys(currOutBatchIndex, this.outContainer, outStartIdxHolder.value, outNumRecordsHolder.value, numPendingOutput); \/\/ set the value count for outgoing batch value vectors for (VectorWrapper<?> v : outgoing) { v.getValueVector().getMutator().setValueCount(numOutputRecords); } this.outcome = IterOutcome.OK; if ( EXTRA_DEBUG_SPILL && is2ndPhase ) { logger.debug(\"So far returned {} + SpilledReturned {} total {} (spilled {})\",rowsNotSpilled,rowsSpilledReturned, rowsNotSpilled+rowsSpilledReturned, rowsSpilled); } lastBatchOutputCount = numOutputRecords; outBatchIndex[partitionToReturn]++; \/\/ if just flushed the last batch in the partition if (outBatchIndex[partitionToReturn] == currPartition.size()) { if ( EXTRA_DEBUG_SPILL ) { logger.debug(\"HashAggregate: {} Flushed partition {} with {} batches total {} rows\", earlyOutput ? \"(Early)\" : \"\", partitionToReturn, outBatchIndex[partitionToReturn], rowsInPartition); } rowsInPartition = 0; \/\/ reset to count for the next partition \/\/ deallocate memory used by this partition, and re-initialize reinitPartition(partitionToReturn); if ( earlyOutput ) { if ( EXTRA_DEBUG_SPILL ) { logger.debug(\"HASH AGG: Finished (early) re-init partition {}, mem allocated: {}\", earlyPartition, allocator.getAllocatedMemory()); } outBatchIndex[earlyPartition] = 0; \/\/ reset, for next time earlyOutput = false ; \/\/ done with early output } else if ( handleEmit ) { \/\/ When returning the last outgoing batch (following an incoming EMIT), then replace OK with EMIT this.outcome = IterOutcome.EMIT; handleEmit = false; \/\/ finished handling EMIT outBatchIndex[partitionToReturn] = 0; \/\/ reset, for the next EMIT return AggIterOutcome.AGG_EMIT; } else if ( (partitionToReturn + 1 == numPartitions) && spilledPartitionsList.isEmpty() ) { \/\/ last partition ? allFlushed = true; \/\/ next next() call will return NONE logger.trace(\"HashAggregate: All batches flushed.\"); \/\/ cleanup my internal state since there is nothing more to return this.cleanup(); } } return AggIterOutcome.AGG_OK; }","old_code_raw":"  public AggIterOutcome outputCurrentBatch() {\n\n    \/\/ when incoming was an empty batch, just finish up\n    if ( schema == null ) {\n      logger.trace(\"Incoming was empty; output is an empty batch.\");\n      this.outcome = IterOutcome.NONE; \/\/ no records were read\n      allFlushed = true;\n      return AggIterOutcome.AGG_NONE;\n    }\n\n    \/\/ Initialization (covers the case of early output)\n    ArrayList<BatchHolder> currPartition = batchHolders[earlyPartition];\n    int currOutBatchIndex = outBatchIndex[earlyPartition];\n    int partitionToReturn = earlyPartition;\n\n    if ( ! earlyOutput ) {\n      \/\/ Update the next partition to return (if needed)\n      \/\/ skip fully returned (or spilled) partitions\n      while (nextPartitionToReturn < numPartitions) {\n        \/\/\n        \/\/ If this partition was spilled - spill the rest of it and skip it\n        \/\/\n        if ( isSpilled(nextPartitionToReturn) ) {\n          spillAPartition(nextPartitionToReturn); \/\/ spill the rest\n          SpilledPartition sp = new SpilledPartition();\n          sp.spillFile = spillFiles[nextPartitionToReturn];\n          sp.spilledBatches = spilledBatchesCount[nextPartitionToReturn];\n          sp.cycleNum = cycleNum; \/\/ remember the current cycle\n          sp.origPartn = nextPartitionToReturn; \/\/ for debugging \/ filename\n          sp.prevOrigPartn = originalPartition; \/\/ for debugging \/ filename\n          spilledPartitionsList.add(sp);\n\n          reinitPartition(nextPartitionToReturn); \/\/ free the memory\n          try {\n            spillSet.close(writers[nextPartitionToReturn]);\n          } catch (IOException ioe) {\n            throw UserException.resourceError(ioe)\n                .message(\"IO Error while closing output stream\")\n                .build(logger);\n          }\n          writers[nextPartitionToReturn] = null;\n        }\n        else {\n          currPartition = batchHolders[nextPartitionToReturn];\n          currOutBatchIndex = outBatchIndex[nextPartitionToReturn];\n          \/\/ If curr batch (partition X index) is not empty - proceed to return it\n          if (currOutBatchIndex < currPartition.size() && 0 != currPartition.get(currOutBatchIndex).getNumPendingOutput()) {\n            break;\n          }\n        }\n        nextPartitionToReturn++; \/\/ else check next partition\n      }\n\n      \/\/ if passed the last partition - either done or need to restart and read spilled partitions\n      if (nextPartitionToReturn >= numPartitions) {\n        \/\/ The following \"if\" is probably never used; due to a similar check at the end of this method\n        if ( spilledPartitionsList.isEmpty() ) { \/\/ and no spilled partitions\n          allFlushed = true;\n          this.outcome = IterOutcome.NONE;\n          if ( is2ndPhase && spillSet.getWriteBytes() > 0 ) {\n            stats.setLongStat(Metric.SPILL_MB, \/\/ update stats - total MB spilled\n                (int) Math.round(spillSet.getWriteBytes() \/ 1024.0D \/ 1024.0));\n          }\n          return AggIterOutcome.AGG_NONE;  \/\/ then return NONE\n        }\n        \/\/ Else - there are still spilled partitions to process - pick one and handle just like a new incoming\n        buildComplete = false; \/\/ go back and call doWork() again\n        handlingSpills = true; \/\/ beginning to work on the spill files\n        \/\/ pick a spilled partition; set a new incoming ...\n        SpilledPartition sp = spilledPartitionsList.remove(0);\n        \/\/ Create a new \"incoming\" out of the spilled partition spill file\n        newIncoming = new SpilledRecordbatch(sp.spillFile, sp.spilledBatches, context, schema, oContext, spillSet);\n        originalPartition = sp.origPartn; \/\/ used for the filename\n        logger.trace(\"Reading back spilled original partition {} as an incoming\",originalPartition);\n        \/\/ Initialize .... new incoming, new set of partitions\n        try { initializeSetup(newIncoming); } catch (Exception e) { throw new RuntimeException(e); }\n        \/\/ update the cycle num if needed\n        \/\/ The current cycle num should always be one larger than in the spilled partition\n        if ( cycleNum == sp.cycleNum ) {\n          cycleNum = 1 + sp.cycleNum;\n          stats.setLongStat(Metric.SPILL_CYCLE, cycleNum); \/\/ update stats\n          \/\/ report first spill or memory stressful situations\n          if ( cycleNum == 1 ) { logger.info(\"Started reading spilled records \"); }\n          if ( cycleNum == 2 ) { logger.info(\"SECONDARY SPILLING \"); }\n          if ( cycleNum == 3 ) { logger.warn(\"TERTIARY SPILLING \"); }\n          if ( cycleNum == 4 ) { logger.warn(\"QUATERNARY SPILLING \"); }\n          if ( cycleNum == 5 ) { logger.warn(\"QUINARY SPILLING \"); }\n        }\n        if ( EXTRA_DEBUG_SPILL ) {\n          logger.debug(\"Start reading spilled partition {} (prev {}) from cycle {} (with {} batches). More {} spilled partitions left.\",\n              sp.origPartn, sp.prevOrigPartn, sp.cycleNum, sp.spilledBatches, spilledPartitionsList.size());\n        }\n        return AggIterOutcome.AGG_RESTART;\n      }\n\n      partitionToReturn = nextPartitionToReturn ;\n\n    }\n\n    \/\/ get the number of records in the batch holder that are pending output\n    int numPendingOutput = currPartition.get(currOutBatchIndex).getNumPendingOutput();\n\n    \/\/ The following accounting is for logging, metrics, etc.\n    rowsInPartition += numPendingOutput ;\n    if ( ! handlingSpills ) { rowsNotSpilled += numPendingOutput; }\n    else { rowsSpilledReturned += numPendingOutput; }\n    if ( earlyOutput ) { rowsReturnedEarly += numPendingOutput; }\n\n    allocateOutgoing(numPendingOutput);\n\n    currPartition.get(currOutBatchIndex).outputValues(outStartIdxHolder, outNumRecordsHolder);\n    int numOutputRecords = outNumRecordsHolder.value;\n\n    if (EXTRA_DEBUG_1) {\n      logger.debug(\"After output values: outStartIdx = {}, outNumRecords = {}\", outStartIdxHolder.value, outNumRecordsHolder.value);\n    }\n\n    this.htables[partitionToReturn].outputKeys(currOutBatchIndex, this.outContainer, outStartIdxHolder.value, outNumRecordsHolder.value, numPendingOutput);\n\n    \/\/ set the value count for outgoing batch value vectors\n    for (VectorWrapper<?> v : outgoing) {\n      v.getValueVector().getMutator().setValueCount(numOutputRecords);\n    }\n\n    this.outcome = IterOutcome.OK;\n\n    if ( EXTRA_DEBUG_SPILL && is2ndPhase ) {\n      logger.debug(\"So far returned {} + SpilledReturned {}  total {} (spilled {})\",rowsNotSpilled,rowsSpilledReturned,\n        rowsNotSpilled+rowsSpilledReturned,\n        rowsSpilled);\n    }\n\n    lastBatchOutputCount = numOutputRecords;\n    outBatchIndex[partitionToReturn]++;\n    \/\/ if just flushed the last batch in the partition\n    if (outBatchIndex[partitionToReturn] == currPartition.size()) {\n\n      if ( EXTRA_DEBUG_SPILL ) {\n        logger.debug(\"HashAggregate: {} Flushed partition {} with {} batches total {} rows\",\n            earlyOutput ? \"(Early)\" : \"\",\n            partitionToReturn, outBatchIndex[partitionToReturn], rowsInPartition);\n      }\n      rowsInPartition = 0; \/\/ reset to count for the next partition\n\n      \/\/ deallocate memory used by this partition, and re-initialize\n      reinitPartition(partitionToReturn);\n\n      if ( earlyOutput ) {\n\n        if ( EXTRA_DEBUG_SPILL ) {\n          logger.debug(\"HASH AGG: Finished (early) re-init partition {}, mem allocated: {}\", earlyPartition, allocator.getAllocatedMemory());\n        }\n        outBatchIndex[earlyPartition] = 0; \/\/ reset, for next time\n        earlyOutput = false ; \/\/ done with early output\n      }\n      else if ( (partitionToReturn + 1 == numPartitions) && spilledPartitionsList.isEmpty() ) { \/\/ last partition ?\n\n        allFlushed = true; \/\/ next next() call will return NONE\n\n        logger.trace(\"HashAggregate: All batches flushed.\");\n\n        \/\/ cleanup my internal state since there is nothing more to return\n        this.cleanup();\n      }\n    }\n\n    return AggIterOutcome.AGG_OK;\n  }\n","new_comment_raw":"@return iteration outcome (e.g., OK, NONE ...)","old_comment_raw":"@return iteration outcome (e.g., OK, NONE ...)","label":0,"pre_label":1,"AST_level":17,"line_counts":193,"new_code_token_num":1505},{"new_code_raw":"public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\"); } \/\/ create path and map variables String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"multipart\/form-data\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder builder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { builder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { builder.addBinaryBody(\"file\", file); } HttpEntity httpEntity = builder.build(); postBody = httpEntity; } else { \/\/ normal form params formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata)); } try { String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType); if(response != null){ return (ApiResponse) ApiInvoker.deserialize(response, \"\", ApiResponse.class); } else { return null; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public void  uploadFile (Long petId, String additionalMetadata, File file) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n\n    \n\n    String[] contentTypes = {\n      \"multipart\/form-data\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n      if (additionalMetadata != null) {\n        builder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      \n      if (file != null) {\n        builder.addBinaryBody(\"file\", file);\n      }\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata));\n      \n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return ;\n      }\n      else {\n        return ;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@return ApiResponse","old_comment_raw":"@return void","label":1,"pre_label":0,"AST_level":10,"line_counts":63,"new_code_token_num":369},{"new_code_raw":"public Map<String, TopicMetadata> topicMetaData(final String... topicNames) { if (!running.get()) throw new IllegalStateException(STR); final ZkUtils z = getZkUtils(); final Set<String> set = (topicNames == null || topicNames.length == NUM) ? topicNames() : new LinkedHashSet<String>(Arrays.asList(topicNames)); final Set<TopicMetadata> meta = JavaConversions.setAsJavaSet(AdminUtils.fetchTopicMetadataFromZk(JavaConverters.asScalaSetConverter(set).asScala(), z)); final Map<String, TopicMetadata> map = new HashMap<String, TopicMetadata>(meta.size()); for (TopicMetadata tm : meta) { map.put(tm.topic(), tm); } return map; }","old_code_raw":"public Set<TopicMetadata> topicMetaData(final String... topicNames) {\n    if (!running.get())\n        throw new IllegalStateException(STR);\n    if (topicNames == null || topicNames.length == NUM)\n        return Collections.emptySet();\n    final ZkUtils z = getZkUtils();\n    final Set<String> set = new LinkedHashSet<String>(Arrays.asList(topicNames));\n    return JavaConversions.setAsJavaSet(AdminUtils.fetchTopicMetadataFromZk(JavaConverters.asScalaSetConverter(set).asScala(), z));\n}","new_comment_raw":"@return a map of TopicMetadatas keyed by topic name","old_comment_raw":"@return a set of TopicMetadatas","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":128},{"new_code_raw":"public final int querySingleInt(String sqlCmd, int defVal, Connection conn) { return querySingleInt(sqlCmd, null, defVal, conn); }","old_code_raw":"public final int querySingleInt(String sqlCmd, int defVal, Connection conn) {\n    Object value = querySingleValue(sqlCmd, conn);\n    return ObjectUtils.getInteger(value, defVal);\n}","new_comment_raw":"@return the result as a int value","old_comment_raw":"@return the result as a int value, if no result the int value 0","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":28},{"new_code_raw":"private AutoInstallsLayout createWorkspaceLoaderFromAppRestriction(AppWidgetHost widgetHost) { Context ctx = getContext(); UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE); Bundle bundle = um.getApplicationRestrictions(ctx.getPackageName()); if (bundle == null) { return null; } String packageName = bundle.getString(RESTRICTION_PACKAGE_NAME); if (packageName != null) { try { Resources targetResources = ctx.getPackageManager() .getResourcesForApplication(packageName); return AutoInstallsLayout.get(ctx, packageName, targetResources, widgetHost, mOpenHelper); } catch (NameNotFoundException e) { Log.e(TAG, \"Target package for restricted profile not found\", e); return null; } } return null; }","old_code_raw":"    private AutoInstallsLayout createWorkspaceLoaderFromAppRestriction(AppWidgetHost widgetHost) {\n        \/\/ UserManager.getApplicationRestrictions() requires minSdkVersion >= 18\n        if (!Utilities.ATLEAST_JB_MR2) {\n            return null;\n        }\n\n        Context ctx = getContext();\n        UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);\n        Bundle bundle = um.getApplicationRestrictions(ctx.getPackageName());\n        if (bundle == null) {\n            return null;\n        }\n\n        String packageName = bundle.getString(RESTRICTION_PACKAGE_NAME);\n        if (packageName != null) {\n            try {\n                Resources targetResources = ctx.getPackageManager()\n                        .getResourcesForApplication(packageName);\n                return AutoInstallsLayout.get(ctx, packageName, targetResources,\n                        widgetHost, mOpenHelper);\n            } catch (NameNotFoundException e) {\n                Log.e(TAG, \"Target package for restricted profile not found\", e);\n                return null;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@return the loader if the restrictions are set and the resource exists; null otherwise.","old_comment_raw":"@return the loader if the restrictions are set and the resource exists; null otherwise.","label":0,"pre_label":1,"AST_level":10,"line_counts":23,"new_code_token_num":124},{"new_code_raw":"protected Control initControl(boolean ignoreProxyError) { if (!Control.initSingletonWithoutView(getControlOverrides()) && ! ignoreProxyError) { return null; } return Control.getSingleton(); }","old_code_raw":"    protected Control initControl() {\n        Control.initSingletonWithoutView(getControlOverrides());\n        return Control.getSingleton();\n    }\n","new_comment_raw":"@return the initialised  Control singleton, unless theres a problem setting up the proxy and ignoreProxyError is false","old_comment_raw":"@return the initialised Control singleton","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":35},{"new_code_raw":"public boolean searchToggleButton(String search, int matches) { long now = System.currentTimeMillis(); final long endTime = now + TIMEOUT; while (!searchForToggleButton(search, matches) && now < endTime) { now = System.currentTimeMillis(); countMatches = 0; } countMatches = 0; if(now < endTime) return true; else return false; }","old_code_raw":"\tpublic boolean searchToggleButton(String search, int matches) {\n        long now = System.currentTimeMillis();\n        final long endTime = now + TIMEOUT;\n        while (!searchForToggleButton(search, matches) && now < endTime)\n        {\n        \tnow = System.currentTimeMillis();\n        }\n        return searchForToggleButton(search, matches);\n\t}\n","new_comment_raw":"@return true if a toggle button with the given text is found a given number of times and false if it is not found","old_comment_raw":"@return true if a toggle button with the given text is found a given number of times and false if it is not found","label":0,"pre_label":1,"AST_level":7,"line_counts":15,"new_code_token_num":66},{"new_code_raw":"public ASTNode getNode() { return node; }","old_code_raw":"public DartNode getNode() {\n    return node;\n}","new_comment_raw":"@return the {@link ASNode}.","old_comment_raw":"@return the {@link DartNode}.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public boolean findCellForSpan(int[] cellXY, int spanX, int spanY) { if (cellXY == null) { cellXY = new int[2]; } return mOccupied.findVacantCell(cellXY, spanX, spanY); }","old_code_raw":"    public boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {\n        boolean foundCell = false;\n        final int endX = mCountX - (spanX - 1);\n        final int endY = mCountY - (spanY - 1);\n\n        for (int y = 0; y < endY && !foundCell; y++) {\n            inner:\n            for (int x = 0; x < endX; x++) {\n                for (int i = 0; i < spanX; i++) {\n                    for (int j = 0; j < spanY; j++) {\n                        if (mOccupied[x + i][y + j]) {\n                            \/\/ small optimization: we can skip to after the column we just found\n                            \/\/ an occupied cell\n                            x += i;\n                            continue inner;\n                        }\n                    }\n                }\n                if (cellXY != null) {\n                    cellXY[0] = x;\n                    cellXY[1] = y;\n                }\n                foundCell = true;\n                break;\n            }\n        }\n\n        return foundCell;\n    }\n","new_comment_raw":"@return True if a vacant cell of the specified dimension was found, false otherwise.","old_comment_raw":"@return True if a vacant cell of the specified dimension was found, false otherwise.","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":42},{"new_code_raw":"public Builder hasArgs() { numberOfArgs = Option.UNLIMITED_VALUES; return this; }","old_code_raw":"public boolean hasArgs() {\n    return numberOfArgs > NUM || numberOfArgs == UNLIMITED_VALUES;\n}","new_comment_raw":"@return this builder, to allow method chaining","old_comment_raw":"@return boolean flag indicating if multiple values are allowed","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public GraphQLOutputType getType() { return type; }","old_code_raw":"    public GraphQLType getType() {\n        return type;\n    }\n","new_comment_raw":"@return the graphql type in question","old_comment_raw":"@return the graphql type in question","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public Collection<Tree> getRelatedNodes(Tree t, Tree root) { if (root.value() == null) { root.setValue(\"ROOT\"); \/\/ todo: cdm: it doesn't seem like this line should be here } Set<Tree> nodeList = new LinkedHashSet<Tree>(); for (TregexPattern p : targetPatterns) { \/\/ cdm: I deleted: && nodeList.isEmpty() TregexMatcher m = p.matcher(root); while (m.findAt(t)) { nodeList.add(m.getNode(\"target\")); \/\/System.out.println(\"found \" + this + \"(\" + t + \", \" + m.getNode(\"target\") + \") using pattern \" + p); } } return nodeList; }","old_code_raw":"  public Collection<TreeGraphNode> getRelatedNodes(TreeGraphNode t, TreeGraphNode root, HeadFinder headFinder) {\n    Set<TreeGraphNode> nodeList = new ArraySet<TreeGraphNode>();\n    for (TregexPattern p : targetPatterns) {    \/\/ cdm: I deleted: && nodeList.isEmpty()\n      \/\/ Initialize the TregexMatcher with the HeadFinder so that we\n      \/\/ can use the same HeadFinder through the entire process of\n      \/\/ building the dependencies\n      TregexMatcher m = p.matcher(root, headFinder);\n      while (m.findAt(t)) {\n        TreeGraphNode target = (TreeGraphNode) m.getNode(\"target\");\n        if (target == null) {\n          throw new AssertionError(\"Expression has no target: \" + p);\n        }\n        nodeList.add(target);\n        if (DEBUG) {\n          System.err.println(\"found \" + this + \"(\" + t + \"-\" + t.headWordNode() + \", \" + m.getNode(\"target\") + \"-\" + ((TreeGraphNode) m.getNode(\"target\")).headWordNode() + \") using pattern \" + p);\n          for (String nodeName : m.getNodeNames()) {\n            if (nodeName.equals(\"target\"))\n              continue;\n            System.err.println(\"  node \" + nodeName + \": \" + m.getNode(nodeName));\n          }\n        }\n      }\n    }\n    return nodeList;\n  }\n","new_comment_raw":"@return Governor nodes to which t bears this GR","old_comment_raw":"@return A Collection of dependent nodes to which t bears this GR","label":1,"pre_label":0,"AST_level":10,"line_counts":15,"new_code_token_num":151},{"new_code_raw":"public String executeAs(Function<Response, Response> handler) { Type type = new TypeToken<String>(){}.getType(); return execute(handler).as(type); }","old_code_raw":"        public String executeAs(Function<Response, Response> handler) {\n            Type type = new TypeToken<String>(){}.getType();\n            return getJSON().deserialize(execute(handler).asString(), type);\n        }\n","new_comment_raw":"@return String","old_comment_raw":"@return String","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public double getExtraDouble(String key) throws JSONException { return mExtraData.getDouble(key); }","old_code_raw":"public double getExtraDouble(String key) {\n    return mExtraData.optDouble(key);\n}","new_comment_raw":"@return The stored value.","old_comment_raw":"@return The stored value or null if it doesn't exist in specified form.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public Builder builder(RelNode rel, Clause... clauses) { final Clause maxClause = maxClause(); boolean needNew = false; \/\/ If old and new clause are equal and belong to below set, \/\/ then new SELECT wrap is not required Set<Clause> nonWrapSet = ImmutableSet.of(Clause.SELECT); for (Clause clause : clauses) { if (maxClause.ordinal() > clause.ordinal() || (maxClause == clause && !nonWrapSet.contains(clause))) { needNew = true; } } if (rel instanceof Aggregate && !dialect.supportsNestedAggregations() && hasNestedAggregations((Aggregate) rel)) { needNew = true; } SqlSelect select; Expressions.FluentList<Clause> clauseList = Expressions.list(); if (needNew) { select = subSelect(); } else { select = asSelect(); clauseList.addAll(this.clauses); } clauseList.appendAll(clauses); final Context newContext; final SqlNodeList selectList = select.getSelectList(); if (selectList != null) { newContext = new Context(dialect, selectList.size()) { public SqlNode field(int ordinal) { final SqlNode selectItem = selectList.get(ordinal); switch (selectItem.getKind()) { case AS: return ((SqlCall) selectItem).operand(0); } return selectItem; } @Override public SqlNode orderField(int ordinal) { \/\/ If the field expression is an unqualified column identifier \/\/ and matches a different alias, use an ordinal. \/\/ For example, given \/\/ SELECT deptno AS empno, empno AS x FROM emp ORDER BY emp.empno \/\/ we generate \/\/ SELECT deptno AS empno, empno AS x FROM emp ORDER BY 2 \/\/ \"ORDER BY empno\" would give incorrect result; \/\/ \"ORDER BY x\" is acceptable but is not preferred. final SqlNode node = field(ordinal); if (node instanceof SqlIdentifier && ((SqlIdentifier) node).isSimple()) { final String name = ((SqlIdentifier) node).getSimple(); for (Ord<SqlNode> selectItem : Ord.zip(selectList)) { if (selectItem.i != ordinal) { final String alias = SqlValidatorUtil.getAlias(selectItem.e, -1); if (name.equalsIgnoreCase(alias)) { return SqlLiteral.createExactNumeric( Integer.toString(ordinal + 1), SqlParserPos.ZERO); } } } } return node; } }; } else { boolean qualified = !dialect.hasImplicitTableAlias() || aliases.size() > 1; \/\/ basically, we did a subSelect() since needNew is set and neededAlias is not null \/\/ now, we need to make sure that we need to update the alias context. \/\/ if our aliases map has a single element: <neededAlias, rowType>, \/\/ then we don't need to rewrite the alias but otherwise, it should be updated. if (needNew && neededAlias != null && (aliases.size() != 1 || !aliases.containsKey(neededAlias))) { final Map<String, RelDataType> newAliases = ImmutableMap.of(neededAlias, rel.getInput(0).getRowType()); newContext = aliasContext(newAliases, qualified); } else { newContext = aliasContext(aliases, qualified); } } return new Builder(rel, clauseList, select, newContext, needNew ? null : aliases); }","old_code_raw":"    public Builder builder(RelNode rel, Clause... clauses) {\n      final Clause maxClause = maxClause();\n      boolean needNew = false;\n      \/\/ If old and new clause are equal and belong to below set,\n      \/\/ then new SELECT wrap is not required\n      Set<Clause> nonWrapSet = ImmutableSet.of(Clause.SELECT);\n      for (Clause clause : clauses) {\n        if (maxClause.ordinal() > clause.ordinal()\n            || (maxClause == clause && !nonWrapSet.contains(clause))) {\n          needNew = true;\n        }\n      }\n      if (rel instanceof Aggregate\n          && !dialect.supportsNestedAggregations()\n          && hasNestedAggregations((Aggregate) rel)) {\n        needNew = true;\n      }\n\n      SqlSelect select;\n      Expressions.FluentList<Clause> clauseList = Expressions.list();\n      if (needNew) {\n        select = subSelect();\n      } else {\n        select = asSelect();\n        clauseList.addAll(this.clauses);\n      }\n      clauseList.appendAll(clauses);\n      Context newContext;\n      final SqlNodeList selectList = select.getSelectList();\n      if (selectList != null) {\n        newContext = new Context(dialect, selectList.size()) {\n          public SqlNode field(int ordinal) {\n            final SqlNode selectItem = selectList.get(ordinal);\n            switch (selectItem.getKind()) {\n            case AS:\n              return ((SqlCall) selectItem).operand(0);\n            }\n            return selectItem;\n          }\n        };\n      } else {\n        boolean qualified =\n            !dialect.hasImplicitTableAlias() || aliases.size() > 1;\n        \/\/ basically, we did a subSelect() since needNew is set and neededAlias is not null\n        \/\/ now, we need to make sure that we need to update the alias context.\n        \/\/ if our aliases map has a single element:  <neededAlias, rowType>,\n        \/\/ then we don't need to rewrite the alias but otherwise, it should be updated.\n        if (needNew\n                && neededAlias != null\n                && (aliases.size() != 1 || !aliases.containsKey(neededAlias))) {\n          final Map<String, RelDataType> newAliases =\n              ImmutableMap.of(neededAlias, rel.getInput(0).getRowType());\n          newContext = aliasContext(newAliases, qualified);\n        } else {\n          newContext = aliasContext(aliases, qualified);\n        }\n      }\n      return new Builder(rel, clauseList, select, newContext,\n          needNew ? null : aliases);\n    }\n","new_comment_raw":"@return A builder","old_comment_raw":"@return A builder","label":0,"pre_label":1,"AST_level":21,"line_counts":88,"new_code_token_num":626},{"new_code_raw":"public static IPath toPath(URI uri) { Assert.isNotNull(uri); if (EFS.SCHEME_FILE.equals(uri.getScheme())) return new Path(uri.getSchemeSpecificPart()); return null; }","old_code_raw":"public static IPath toPath(URI uri) {\n    if (uri == null)\n        return null;\n    if (EFS.SCHEME_FILE.equals(uri.getScheme()))\n        return new Path(uri.getSchemeSpecificPart());\n    return new Path(uri.getPath());\n}","new_comment_raw":"@return The path representing the provided URI, <code>null<\/code>","old_comment_raw":"@return The path representing the provided URI","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":41},{"new_code_raw":"public Score toScore() { SQLiteHabitList habitList = SQLiteHabitList.getInstance(); Habit h = habitList.getById(habit.getId()); return new Score(timestamp, score); }","old_code_raw":"    public Score toScore()\n    {\n        SQLiteHabitList habitList = SQLiteHabitList.getInstance();\n        Habit h = habitList.getById(habit.getId());\n        return new Score(h, timestamp, score);\n    }\n","new_comment_raw":"@return a  Score with this record's data","old_comment_raw":"@return a Score with this record's data","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":34},{"new_code_raw":"public int getItemPrice(int itemID) { if (itemID == ItemID.COINS_995) { return 1; } if (itemID == ItemID.PLATINUM_TOKEN) { return 1000; } UntradeableItemMapping p = UntradeableItemMapping.map(ItemVariationMapping.map(itemID)); if (p != null) { return getItemPrice(p.getPriceID()) * p.getQuantity(); } int price = 0; for (int mappedID : ItemMapping.map(itemID)) { ItemPrice ip = itemPrices.get(mappedID); if (ip != null) { price += ip.getPrice(); } } return price; }","old_code_raw":"\tpublic int getItemPrice(int itemID)\n\t{\n\t\tif (itemID == ItemID.COINS_995)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\tif (itemID == ItemID.PLATINUM_TOKEN)\n\t\t{\n\t\t\treturn 1000;\n\t\t}\n\n\t\tint price = 0;\n\t\tfor (int mappedID : ItemMapping.map(itemID))\n\t\t{\n\t\t\tItemPrice ip = itemPrices.get(mappedID);\n\t\t\tif (ip != null)\n\t\t\t{\n\t\t\t\tprice += ip.getPrice();\n\t\t\t}\n\t\t}\n\n\t\treturn price;\n\t}\n","new_comment_raw":"@return item price","old_comment_raw":"@return item price","label":0,"pre_label":1,"AST_level":9,"line_counts":30,"new_code_token_num":108},{"new_code_raw":"public static ClusterFixtureBuilder bareBuilder(BaseDirTestWatcher dirTestWatcher) { return new ClusterFixtureBuilder(dirTestWatcher); }","old_code_raw":"  public static ClusterFixtureBuilder bareBuilder() {\n    return new ClusterFixtureBuilder();\n  }\n","new_comment_raw":"@return a fixture builder with no default properties set","old_comment_raw":"@return a fixture builder with no default properties set","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"private boolean isReplaceableHotseatItem(Favorite favorite) { return favorite.container == Favorites.CONTAINER_HOTSEAT && favorite.intent != null && (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT || favorite.itemType == Favorites.ITEM_TYPE_DEEP_SHORTCUT); }","old_code_raw":"    private boolean isReplaceableHotseatItem(Favorite favorite) {\n        return favorite.container == Favorites.CONTAINER_HOTSEAT\n                && favorite.intent != null\n                && (favorite.itemType == Favorites.ITEM_TYPE_APPLICATION\n                || favorite.itemType == Favorites.ITEM_TYPE_SHORTCUT);\n    }\n","new_comment_raw":"@return true if its an hotseat item, that can be replaced during restore. TODO: Extend check for folders in hotseat.","old_comment_raw":"@return true if its an hotseat item, that can be replaced during restore. TODO: Extend check for folders in hotseat.","label":0,"pre_label":1,"AST_level":8,"line_counts":8,"new_code_token_num":41},{"new_code_raw":"public boolean searchButton(String text) { return searcher.searchWithTimeoutFor(Button.class, text, 0, true, false); }","old_code_raw":"\tpublic boolean searchButton(String text) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, 0, true, false);\n\t\treturn found;\n\t}\n","new_comment_raw":"@return  true if a  Button with the given text is found and  false if it is not found","old_comment_raw":"@return true if a Button with the given text is found and false if it is not found","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public String[] getAllWindowIds() { return getAttributeFromAllWindows(\"id\"); }","old_code_raw":"  public String[] getAllWindowIds() {\n    throw new UnsupportedOperationException(\"getAllWindowIds\");\n  }\n","new_comment_raw":"@return the IDs of all windows that the browser knows about.","old_comment_raw":"@return the IDs of all windows that the browser knows about.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public final boolean isPosOnAdView(final int pos) { return isOnAdView(pos); }","old_code_raw":"public boolean isPosOnAdView(final int pos) {\n    final int zero_for_admob_selection = (pos + NUM) % adfrequency;\n    return zero_for_admob_selection == NUM;\n}","new_comment_raw":"@return bool","old_comment_raw":"@return yes or no","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public static long durationNanos(int years, int months, int days, int hours, int minutes, long seconds) { return durationNanos(years, months, days, hours, minutes, seconds, 0); }","old_code_raw":"    public static double durationNanos(int years, int months, int days, int hours, int minutes, double seconds) {\n        return durationNanos(years, months, days, hours, minutes, seconds, 0);\n    }\n","new_comment_raw":"@return Approximate representation of the given interval as a number of nanoseconds","old_comment_raw":"@return a BigDecimal value which contains the number of nanoseconds, never null","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":43},{"new_code_raw":"static boolean isNewStyleColumn(Common.ColumnValue column) { return column.hasField(HAS_ARRAY_VALUE_DESCRIPTOR) || column.hasField(SCALAR_VALUE_DESCRIPTOR); }","old_code_raw":"    static boolean isNewStyleColumn(Common.ColumnValue column) {\n      final Descriptor desc = column.getDescriptorForType();\n      return ProtobufService.hasField(column, desc, Common.ColumnValue.HAS_ARRAY_VALUE_FIELD_NUMBER)\n          || ProtobufService.hasField(column, desc, Common.ColumnValue.SCALAR_VALUE_FIELD_NUMBER);\n    }\n","new_comment_raw":"@return True if the message is the new style, false otherwise.","old_comment_raw":"@return True if the message is the new style, false otherwise.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":24},{"new_code_raw":"public static FxEnvironment getFilteredEnvironment() { return new FxFilteredEnvironment(getEnvironment()); }","old_code_raw":"public static FxEnvironment getFilteredEnvironment() {\n    return new FilteredEnvironment(getEnvironment());\n}","new_comment_raw":"@return a {@link com.flexive.shared.structure.FxFilteredEnvironment} for the calling user.","old_comment_raw":"@return a {@link FilteredEnvironment} for the calling user.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public DateTimeFormatterBuilder appendDayOfYear(int minDigits) { return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3); }","old_code_raw":"    public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {\n        return appendDecimal(iChronoUTC.dayOfYear(), minDigits, 3);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"@Override public Object clone() { try { DBTable clone = (DBTable) super.clone(); Class<?> colClass = columns.get(NUM).getClass(); Class<?> colBase = colClass.getSuperclass(); clone.columns = new ArrayList<DBColumn>(); Field[] fields = getClass().getFields(); for (int i = NUM; i < columns.size(); i++) { DBTableColumn srcCol = (DBTableColumn) columns.get(i); DBTableColumn newCol = new DBTableColumn(clone, srcCol); for (int j = NUM; j < fields.length; j++) { Class<?> type = fields[j].getType(); if (type == colClass || type == colBase) { try { if (fields[j].get(clone) == srcCol) fields[j].set(clone, newCol); } catch (Exception e) { String fieldName = fields[j].getName(); log.error(STR + fieldName + STR + e.getMessage()); CloneNotSupportedException cnse = new CloneNotSupportedException(STR + fieldName); cnse.initCause(e); throw cnse; } } } } clone.alias = STR + String.valueOf(tableCount.incrementAndGet()); log.info(STR + name + STR + alias + STR + clone.alias); return clone; } catch (CloneNotSupportedException e) { log.error(STR + getName()); throw new RuntimeException(e); } }","old_code_raw":"@Override\npublic Object clone() {\n    try {\n        DBTable clone = (DBTable) super.clone();\n        Class<?> colClass = columns.get(NUM).getClass();\n        Class<?> colBase = colClass.getSuperclass();\n        clone.columns = new ArrayList<DBColumn>();\n        Field[] fields = getClass().getDeclaredFields();\n        for (int i = NUM; i < columns.size(); i++) {\n            DBTableColumn srcCol = (DBTableColumn) columns.get(i);\n            DBTableColumn newCol = new DBTableColumn(clone, srcCol);\n            for (int j = NUM; j < fields.length; j++) {\n                Class<?> type = fields[j].getType();\n                if (type == colClass || type == colBase) {\n                    try {\n                        if (fields[j].get(clone) == srcCol)\n                            fields[j].set(clone, newCol);\n                    } catch (Exception e) {\n                        log.error(STR + fields[j].getName() + STR + e.getMessage());\n                    }\n                }\n            }\n        }\n        clone.alias = STR + String.valueOf(tableCount.incrementAndGet());\n        log.info(STR + name + STR + alias + STR + clone.alias);\n        return clone;\n    } catch (CloneNotSupportedException e) {\n        return null;\n    }\n}","new_comment_raw":"@return a table clone with new table alias","old_comment_raw":"@return this cloned Object","label":1,"pre_label":0,"AST_level":17,"line_counts":35,"new_code_token_num":272},{"new_code_raw":"public static <T extends CharSequence> T notEmpty(final T chars) { return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE); }","old_code_raw":"public static <T extends Collection<?>> T notEmpty(final T collection) {\n    return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE);\n}","new_comment_raw":"@return the validated character sequence (never {@code null} method for chaining)","old_comment_raw":"@return the validated collection (never {@code null} method for chaining)","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":22},{"new_code_raw":"private IDKey getIdentityKey(Object value) { return new IDKey(value); }","old_code_raw":"private String getIdentityKey(Object value) {\n    return STR + System.identityHashCode(value);\n}","new_comment_raw":"@return a unique IDKey for the identity","old_comment_raw":"@return a String containing the unique identity hashCode","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"public Number getElementPositionLeft(String locator) { return (Number) seleneseMethods.get(\"getElementPositionLeft\").apply(driver, locator); }","old_code_raw":"  public Number getElementPositionLeft(String locator) {\n    Point location = ((RenderedWebElement) elementFinder.findElement(driver, locator)).getLocation();\n    return (int) location.getX();\n  }\n","new_comment_raw":"@return of pixels from the edge of the frame.","old_comment_raw":"@return of pixels from the edge of the frame.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"@SuppressWarnings(STR) public ObjectName getQueueObjectName(String virtualHostName, String queue) { AllObjects allObject = new AllObjects(_mbsc); allObject.querystring = STR + virtualHostName + STR + queue + STR; Set<ObjectName> objectNames = allObject.returnObjects(); _test.assertNotNull(STR, objectNames); _test.assertEquals(STR + allObject.querystring + STR, NUM, objectNames.size()); ObjectName objectName = objectNames.iterator().next(); _test.getLogger().info(STR + objectName); return objectName; }","old_code_raw":"public ObjectName getQueueObjectName(String virtualHostName, String queue) {\n    AllObjects allObject = new AllObjects(_mbsc);\n    allObject.querystring = STR + virtualHostName + STR + queue + STR;\n    Set<ObjectName> objectNames = allObject.returnObjects();\n    _test.assertNotNull(STR, objectNames);\n    _test.assertEquals(STR + allObject.querystring + STR, NUM, objectNames.size());\n    return objectNames.iterator().next();\n}","new_comment_raw":"@return the ObjectName for the given queue on the VirtualHost","old_comment_raw":"@return the ObjectName for the given exchange on the test VirtualHost.","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":95},{"new_code_raw":"public boolean[] getSlew() { boolean[] data = new boolean[NUM]; String answer = this.getData(STR, STR, STR); data[NUM] = (!answer.equals(STR)); answer = this.getData(STR, STR, STR); data[NUM] = (!answer.equals(STR)); answer = this.getData(STR, STR, STR); data[NUM] = (!answer.equals(STR)); return data; }","old_code_raw":"public boolean getSlew() {\n    return false;\n}","new_comment_raw":"@return true if Fast Slew is on, false if not. In order (x,y,z).","old_comment_raw":"@return true if Fast Slew is on, false if not","label":1,"pre_label":0,"AST_level":7,"line_counts":10,"new_code_token_num":95},{"new_code_raw":"protected int getInSubqueryThreshold() { return config.getInSubqueryThreshold(); }","old_code_raw":"  protected int getInSubqueryThreshold() {\n    return IN_SUBQUERY_THRESHOLD;\n  }\n","new_comment_raw":"@return threshold, default  #DEFAULT_IN_SUBQUERY_THRESHOLD","old_comment_raw":"@return threshold, default #IN_SUBQUERY_THRESHOLD","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"protected Object convertSmallInt(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, SHORT_FALSE, (r) -> { if (data instanceof Short) { r.deliver(data); } else if (data instanceof Number) { Number value = (Number) data; r.deliver(new Short(value.shortValue())); } else if (data instanceof Boolean) { r.deliver(NumberConversions.getShort((Boolean)data)); } else if (data instanceof String) { r.deliver(Short.parseShort((String)data)); } }); }","old_code_raw":"    protected Object convertSmallInt(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return SHORT_FALSE;\n        }\n        if (data instanceof Short) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Short(value.shortValue());\n        }\n        if (data instanceof Boolean) {\n            return NumberConversions.getShort((Boolean) data);\n        }\n        if (data instanceof String) {\n            return Short.parseShort((String) data);\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":15,"line_counts":18,"new_code_token_num":121},{"new_code_raw":"public static int[] getBodyToViewPosition(JTextArea view, String header, int start, int end) { validateView(view); validateHeader(header); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } int excessChars = 0; int pos = 0; while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1) { pos += 2; ++excessChars; } int len = view.getDocument().getLength(); int bodyLen = len - header.length() + excessChars; if (bodyLen < 0 || start > bodyLen || end > bodyLen) { return INVALID_POSITION; } int finalStartPos = start + header.length() - excessChars; int finalEndPos = end + header.length() - excessChars; return new int[] { finalStartPos, finalEndPos }; }","old_code_raw":"    public static int[] getBodyToViewPosition(JTextArea view, String header, int start, int end) {\n        validateView(view);\n        validateHeader(header);\n        validateStartEnd(start, end, view.getDocument().getLength());\n\n        int excessChars = 0;\n\n        int pos = 0;\n        while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1) {\n            pos += 2;\n            ++excessChars;\n        }\n\n        int len = view.getDocument().getLength();\n        int bodyLen = len - header.length() + excessChars;\n        if (bodyLen < 0 || start > bodyLen || end > bodyLen) {\n            return INVALID_POSITION;\n        }\n\n        int finalStartPos = start + header.length() - excessChars;\n        int finalEndPos = end + header.length() - excessChars;\n        return new int[] { finalStartPos, finalEndPos };\n    }\n","new_comment_raw":"@return the positions offset for the  view, or  #INVALID_POSITION if the  start and  end positions are greater than the length of the body or the  view.","old_comment_raw":"@return the positions offset for the view, or #INVALID_POSITION if the start and end positions are greater than body's length.","label":1,"pre_label":0,"AST_level":7,"line_counts":28,"new_code_token_num":168},{"new_code_raw":"public String getValue(String locator) { return elementFinder.findElement(driver, locator) .getValue(); }","old_code_raw":"  public String getValue(String locator) {\n    return findElement(locator).getValue();\n  }\n","new_comment_raw":"@return the element value, or \"on\/off\" for checkbox\/radio elements","old_comment_raw":"@return the element value, or \"on\/off\" for checkbox\/radio elements","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":21},{"new_code_raw":"public static Builder newSchema(GraphQLSchema existingSchema) { return new Builder() .query(existingSchema.getQueryType()) .mutation(existingSchema.getMutationType()) .subscription(existingSchema.getSubscriptionType()) .fieldVisibility(existingSchema.getFieldVisibility()) .clearAdditionalTypes() .clearDirectives() .additionalDirectives(existingSchema.directives) .additionalTypes(existingSchema.additionalTypes); }","old_code_raw":"    public static Builder newSchema(GraphQLSchema existingSchema) {\n        return new Builder()\n                .query(existingSchema.getQueryType())\n                .mutation(existingSchema.getMutationType())\n                .subscription(existingSchema.getSubscriptionType())\n                .fieldVisibility(existingSchema.getFieldVisibility())\n                .additionalDirectives(existingSchema.directives)\n                .additionalTypes(existingSchema.additionalTypes);\n    }\n","new_comment_raw":"@return a new schema builder","old_comment_raw":"@return a new schema builder","label":0,"pre_label":1,"AST_level":6,"line_counts":12,"new_code_token_num":60},{"new_code_raw":"public String getTypeDeclaration(Schema p) { String openAPIType = getSchemaType(p); if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return getSchemaType(p) + \"<\" + getTypeDeclaration(inner) + \">\"; } if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); return getSchemaType(p) + \"<std::string, \" + getTypeDeclaration(inner) + \">\"; } else if (ModelUtils.isByteArraySchema(p)) { return \"std::string\"; } if (ModelUtils.isStringSchema(p) || ModelUtils.isDateSchema(p) || ModelUtils.isDateTimeSchema(p) || ModelUtils.isFileSchema(p) || languageSpecificPrimitives.contains(openAPIType)) { return toModelName(openAPIType); } return openAPIType; }","old_code_raw":"    public String getTypeDeclaration(Schema p) {\n        String openAPIType = getSchemaType(p);\n\n        if (ModelUtils.isArraySchema(p)) {\n            ArraySchema ap = (ArraySchema) p;\n            Schema inner = ap.getItems();\n            return getSchemaType(p) + \"<\" + getTypeDeclaration(inner) + \">\";\n        }\n        if (ModelUtils.isMapSchema(p)) {\n            Schema inner = (Schema) p.getAdditionalProperties();\n            return getSchemaType(p) + \"<std::string, \" + getTypeDeclaration(inner) + \">\";\n        }\n        if (ModelUtils.isStringSchema(p)\n                || ModelUtils.isDateSchema(p)\n                || ModelUtils.isDateTimeSchema(p) || ModelUtils.isFileSchema(p)\n                || languageSpecificPrimitives.contains(openAPIType)) {\n            return toModelName(openAPIType);\n        }\n\n        return openAPIType;\n    }\n","new_comment_raw":"@return a string value used as the `dataType` field for model templates, `returnType` for api templates","old_comment_raw":"@return a string value used as the `dataType` field for model templates, `returnType` for api templates","label":0,"pre_label":1,"AST_level":10,"line_counts":25,"new_code_token_num":165},{"new_code_raw":"public String getAuthorizationUrl(String state, Map<String, String> additionalParams, PKCE pkce) { return createAuthorizationUrlBuilder() .state(state) .additionalParams(additionalParams) .pkce(pkce) .build(); }","old_code_raw":"    public String getAuthorizationUrl(Map<String, String> additionalParams) {\n        return getAuthorizationUrl(null, additionalParams);\n    }\n","new_comment_raw":"@return url","old_comment_raw":"@return the URL where you should redirect your users","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":38},{"new_code_raw":"public static String tripleToString(RelationTriple extraction, String docid, CoreMap sentence) { switch (FORMAT) { case REVERB: return extraction.toReverbString(docid, sentence); case OLLIE: return extraction.confidenceGloss() + \": (\" + extraction.subjectGloss() + \"; \" + extraction.relationGloss() + \"; \" + extraction.objectGloss() + \")\"; case DEFAULT: return extraction.toString(); case QA_SRL: return extraction.toQaSrlString(sentence); default: throw new IllegalStateException(\"Format is not implemented: \" + FORMAT); } }","old_code_raw":"  public static String tripleToString(RelationTriple extraction, String docid, CoreMap sentence) {\n    switch (FORMAT) {\n      case REVERB:\n        return extraction.toReverbString(docid, sentence);\n      case OLLIE:\n        return extraction.confidenceGloss() + \": (\" + extraction.subjectGloss() + \"; \" + extraction.relationGloss() + \"; \" + extraction.objectGloss() + \")\";\n      case DEFAULT:\n        return extraction.toString();\n      default:\n        throw new IllegalStateException(\"Format is not implemented: \" + FORMAT);\n    }\n\n  }\n","new_comment_raw":"@return A String representation of the triple.","old_comment_raw":"@return A String representation of the triple.","label":0,"pre_label":1,"AST_level":13,"line_counts":16,"new_code_token_num":111},{"new_code_raw":"protected Collection<I> orphanedItems(Collection<I> orphaned, TaskListener listener) throws IOException, InterruptedException { return getOrphanedItemStrategy().orphanedItems(this, orphaned, listener); }","old_code_raw":"protected Collection<I> orphanedItems(Collection<I> orphaned, TaskListener listener) throws IOException, InterruptedException {\n    return orphaned;\n}","new_comment_raw":"@return any subset of {@code orphaned}, representing those children which ought to be removed from the folder now; items not listed will be left alone for the time being","old_comment_raw":"@return any subset of {@code orphaned}, representing those children which ought to be removed from the folder now (by default, all of them); items not listed will be left alone for the time being","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":31},{"new_code_raw":"public Service<Vault> createLockAllService(Collection<Vault> vaults, boolean forced) { Iterator<Vault> iter = ImmutableList.copyOf(vaults).iterator(); ScheduledService<Vault> service = new ScheduledService<>() { @Override protected Task<Vault> createTask() { assert Platform.isFxApplicationThread(); if (iter.hasNext()) { return new LockVaultTask(iter.next(), forced); } else { cancel(); return new IllegalStateTask(\"This task should never be executed.\"); } } }; service.setExecutor(executorService); return service; }","old_code_raw":"\tpublic Service<Void> createLockAllService(Collection<Vault> vaults, boolean forced) {\n\t\tIterator<Vault> iter = vaults.iterator();\n\t\tScheduledService<Void> service = new ScheduledService<>() {\n\n\t\t\t@Override\n\t\t\tprotected Task<Void> createTask() {\n\t\t\t\tassert Platform.isFxApplicationThread();\n\t\t\t\tif (iter.hasNext()) {\n\t\t\t\t\treturn createLockTask(iter.next(), forced);\n\t\t\t\t} else {\n\t\t\t\t\t\/\/ This should be unreachable code, since iter is only accessed on the FX App Thread.\n\t\t\t\t\t\/\/ But if quitting the application takes longer for any reason, this service should shut down properly\n\t\t\t\t\treset();\n\t\t\t\t\treturn createNoopTask();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tservice.setExecutor(executorService);\n\t\treturn service;\n\t}\n","new_comment_raw":"@return Service that tries to lock all given vaults and cancels itself automatically when done","old_comment_raw":"@return Service that tries to lock all given vaults","label":1,"pre_label":0,"AST_level":11,"line_counts":19,"new_code_token_num":103},{"new_code_raw":"public String getContent() { \/\/return node.getTextContent(); \/\/ requires Android 2.2 StringBuilder buffer = new StringBuilder(); NodeList childList = node.getChildNodes(); for (int i = 0; i < childList.getLength(); i++) { Node child = childList.item(i); if (child.getNodeType() == Node.TEXT_NODE) { \/\/ skip non-text nodes buffer.append(child.getNodeValue()); } } return buffer.toString(); }","old_code_raw":"  public String getContent() {\n    return node.getTextContent();\n  }\n","new_comment_raw":"@return the content.","old_comment_raw":"@return the content.","label":0,"pre_label":1,"AST_level":9,"line_counts":14,"new_code_token_num":94},{"new_code_raw":"public synchronized IConfigurationElement[] getContainerConfigurations(String containerid, String[] containerPaths) { if (contributions == null) processProxyContributionExtensionPoint(); return (IConfigurationElement[]) contributions.containerPathContributions.getContributors(containerid, containerPaths); }","old_code_raw":"public synchronized IConfigurationElement[] getContainerConfigurations(String containerid) {\n    if (containerToContributions == null)\n        processProxyContributionExtensionPoint();\n    return (IConfigurationElement[]) containerToContributions.get(containerid);\n}","new_comment_raw":"@return Array of configuration elements.","old_comment_raw":"@return Array of configuration elements or <code>null<\/code> if this container has no contributions.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":41},{"new_code_raw":"public String toDefaultValue(Schema schema) { if (schema.getDefault() != null) { return schema.getDefault().toString(); } return getPropertyDefaultValue(schema); }","old_code_raw":"    public String toDefaultValue(Schema schema) {\n        if (schema.getDefault() != null) {\n            return schema.getDefault().toString();\n        }\n\n        if (ModelUtils.isBooleanSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isDateTimeSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isNumberSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isIntegerSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isStringSchema(schema)) {\n            return \"null\";\n        } else if (ModelUtils.isObjectSchema(schema)) {\n            return \"null\";\n        } else {\n            return \"null\";\n        }\n    }\n","new_comment_raw":"@return string presentation of the default value of the property","old_comment_raw":"@return string presentation of the default value of the property","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"public static String versionName() { return \"1.0.2\"; }","old_code_raw":"    public static String versionName() {\n        return \"1.0.1\";\n    }\n","new_comment_raw":"@return  String.","old_comment_raw":"@return String.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"protected Tree determineNonTrivialHead(Tree t, Tree parent) { String motherCat = tlp.basicCategory(t.label().value()); if (DEBUG) { System.err.println(\"At \" + motherCat + \", my parent is \" + parent); } \/\/ do VPs with auxiliary as special case if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) { Tree[] kids = t.children(); \/\/ try to find if there is an auxiliary verb if (DEBUG) { System.err.println(\"Semantic head finder: at VP\"); System.err.println(\"Class is \" + t.getClass().getName()); t.pennPrint(System.err); \/\/System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries)); } \/\/ looks for auxiliaries if (hasVerbalAuxiliary(kids, verbalAuxiliaries) || hasPassiveProgressiveAuxiliary(kids, passiveAuxiliaries)) { \/\/ String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"}; \/\/ Including NP etc seems okay for copular sentences but is \/\/ problematic for other auxiliaries, like 'he has an answer' \/\/ But maybe doing ADJP is fine! String[] how = { \"left\", \"VP\", \"ADJP\" }; Tree pti = traverseLocate(kids, how, false); if (DEBUG) { System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti); } if (pti != null) { return pti; } else { \/\/ System.err.println(\"------\"); \/\/ System.err.println(\"SemanticHeadFinder failed to reassign head for\"); \/\/ t.pennPrint(System.err); \/\/ System.err.println(\"------\"); } } \/\/ looks for copular verbs if (hasVerbalAuxiliary(kids, copulars) && ! isExistential(t, parent) && ! isWHQ(t, parent)) { String[] how; if (motherCat.equals(\"SQ\")) { how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"}; } else { how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"}; } Tree pti = traverseLocate(kids, how, false); \/\/ don't allow a temporal to become head if (pti != null && pti.label() != null && pti.label().value().contains(\"-TMP\")) { pti = null; } \/\/ In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative) if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) { boolean foundAnotherNp = false; for (Tree kid : kids) { if (kid == pti) { break; } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) { foundAnotherNp = true; break; } } if ( ! foundAnotherNp) { pti = null; } } if (DEBUG) { System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti); } if (pti != null) { return pti; } else { if (DEBUG) { System.err.println(\"------\"); System.err.println(\"SemanticHeadFinder failed to reassign head for\"); t.pennPrint(System.err); System.err.println(\"------\"); } } } } Tree hd = super.determineNonTrivialHead(t, parent); \/\/ Heuristically repair punctuation heads Tree[] hdChildren = hd.children(); if (hdChildren != null && hdChildren.length > 0 && hdChildren[0].isLeaf()) { if (tlp.isPunctuationWord(hdChildren[0].label().value())) { Tree[] tChildren = t.children(); if (DEBUG) { System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label()); } for (int i = tChildren.length - 1; i >= 0; i--) { if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) { hd = tChildren[i]; if (DEBUG) { System.err.printf(\"New head: %s %s\", hd.label(), hd.children()[0].label()); } break; } } } } if (DEBUG) { System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd); } return hd; }","old_code_raw":"  protected Tree determineNonTrivialHead(Tree t, Tree parent) {\n    String motherCat = tlp.basicCategory(t.label().value());\n\n    if (DEBUG) {\n      System.err.println(\"At \" + motherCat + \", my parent is \" + parent);\n    }\n\n    \/\/ Some conj expressions seem to make more sense with the \"not\" or\n    \/\/ other key words as the head.  For example, \"and not\" means\n    \/\/ something completely different than \"and\".  Furthermore,\n    \/\/ downstream code was written assuming \"not\" would be the head...\n    if (motherCat.equals(\"CONJP\")) {\n      for (TregexPattern pattern : headOfConjpTregex) {\n        TregexMatcher matcher = pattern.matcher(t);\n        if (matcher.matchesAt(t)) {\n          return matcher.getNode(\"head\");\n        }\n      }\n      \/\/ if none of the above patterns match, use the standard method\n    }\n\n    if (motherCat.equals(\"SBARQ\") || motherCat.equals(\"SINV\")) {\n      if (!makeCopulaHead) {\n        for (TregexPattern pattern : headOfCopulaTregex) {\n          TregexMatcher matcher = pattern.matcher(t);\n          if (matcher.matchesAt(t)) {\n            return matcher.getNode(\"head\");\n          }\n        }\n      }\n      \/\/ if none of the above patterns match, use the standard method\n    }\n\n    \/\/ do VPs with auxiliary as special case\n    if ((motherCat.equals(\"VP\") || motherCat.equals(\"SQ\") || motherCat.equals(\"SINV\"))) {\n      Tree[] kids = t.children();\n      \/\/ try to find if there is an auxiliary verb\n\n      if (DEBUG) {\n        System.err.println(\"Semantic head finder: at VP\");\n        System.err.println(\"Class is \" + t.getClass().getName());\n        t.pennPrint(System.err);\n        \/\/System.err.println(\"hasVerbalAuxiliary = \" + hasVerbalAuxiliary(kids, verbalAuxiliaries));\n      }\n\n      \/\/ looks for auxiliaries\n      Tree[] tmpFilteredChildren = null;\n      if (hasVerbalAuxiliary(kids, verbalAuxiliaries, true) || hasPassiveProgressiveAuxiliary(kids)) {\n        \/\/ String[] how = new String[] {\"left\", \"VP\", \"ADJP\", \"NP\"};\n        \/\/ Including NP etc seems okay for copular sentences but is\n        \/\/ problematic for other auxiliaries, like 'he has an answer'\n        String[] how ;\n        if (hasVerbalAuxiliary(kids, copulars, true)) {\n          \/\/ Only allow ADJP in copular constructions\n          \/\/ In constructions like \"It gets cold\", \"get\" should be the head\n          how = new String[]{ \"left\", \"VP\", \"ADJP\" };\n        } else {\n          how = new String[]{ \"left\", \"VP\" };\n        }\n\n        if (tmpFilteredChildren == null) {\n          tmpFilteredChildren = ArrayUtils.filter(kids, REMOVE_TMP_AND_ADV);\n        }\n        Tree pti = traverseLocate(tmpFilteredChildren, how, false);\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 1) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        \/\/ } else {\n          \/\/ System.err.println(\"------\");\n          \/\/ System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n          \/\/ t.pennPrint(System.err);\n          \/\/ System.err.println(\"------\");\n        }\n      }\n\n      \/\/ looks for copular verbs\n      if (hasVerbalAuxiliary(kids, copulars, false) && ! isExistential(t, parent) && ! isWHQ(t, parent)) {\n        String[] how;\n        if (motherCat.equals(\"SQ\")) {\n          how = new String[]{\"right\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        } else {\n          how = new String[]{\"left\", \"VP\", \"ADJP\", \"NP\", \"WHADJP\", \"WHNP\"};\n        }\n        \/\/ Avoid undesirable heads by filtering them from the list of potential children\n        if (tmpFilteredChildren == null) {\n          tmpFilteredChildren = ArrayUtils.filter(kids, REMOVE_TMP_AND_ADV);\n        }\n        Tree pti = traverseLocate(tmpFilteredChildren, how, false);\n        \/\/ In SQ, only allow an NP to become head if there is another one to the left (then it's probably predicative)\n        if (motherCat.equals(\"SQ\") && pti != null && pti.label() != null && pti.label().value().startsWith(\"NP\")) {\n            boolean foundAnotherNp = false;\n            for (Tree kid : kids) {\n              if (kid == pti) {\n                break;\n              } else if (kid.label() != null && kid.label().value().startsWith(\"NP\")) {\n                foundAnotherNp = true;\n                break;\n              }\n            }\n          if ( ! foundAnotherNp) {\n            pti = null;\n          }\n        }\n\n        if (DEBUG) {\n          System.err.println(\"Determined head (case 2) for \" + t.value() + \" is: \" + pti);\n        }\n        if (pti != null) {\n          return pti;\n        } else {\n          if (DEBUG) {\n            System.err.println(\"------\");\n            System.err.println(\"SemanticHeadFinder failed to reassign head for\");\n            t.pennPrint(System.err);\n            System.err.println(\"------\");\n          }\n        }\n      }\n    }\n\n    Tree hd = super.determineNonTrivialHead(t, parent);\n\n    \/* ----\n    \/\/ This should now be handled at the AbstractCollinsHeadFinder level, so see if we can comment this out\n    \/\/ Heuristically repair punctuation heads\n    Tree[] hdChildren = hd.children();\n    if (hdChildren != null && hdChildren.length > 0 &&\n        hdChildren[0].isLeaf()) {\n      if (tlp.isPunctuationWord(hdChildren[0].label().value())) {\n         Tree[] tChildren = t.children();\n         if (DEBUG) {\n           System.err.printf(\"head is punct: %s\\n\", hdChildren[0].label());\n         }\n         for (int i = tChildren.length - 1; i >= 0; i--) {\n           if (!tlp.isPunctuationWord(tChildren[i].children()[0].label().value())) {\n             hd = tChildren[i];\n             if (DEBUG) {\n               System.err.printf(\"New head of %s is %s%n\", hd.label(), hd.children()[0].label());\n             }\n             break;\n           }\n         }\n      }\n    }\n    *\/\n\n    if (DEBUG) {\n      System.err.println(\"Determined head (case 3) for \" + t.value() + \" is: \" + hd);\n    }\n    return hd;\n  }\n","new_comment_raw":"@return The parse tree that is the head","old_comment_raw":"@return The parse tree that is the head","label":0,"pre_label":1,"AST_level":17,"line_counts":114,"new_code_token_num":1034},{"new_code_raw":"public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } if (promoteNameToValue) { return name(value); } writeDeferredName(); beforeValue(false); string(value); pathIndices[stackSize - 1]++; return this; }","old_code_raw":"  public JsonWriter value(String value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue(false);\n    string(value);\n    pathIndices[stackSize - 1]++;\n    return this;\n  }\n","new_comment_raw":"@return this writer.","old_comment_raw":"@return this writer.","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":61},{"new_code_raw":"public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) { validateView(view); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } return getViewToHeaderPositionImpl(view, start, end); }","old_code_raw":"    public static int[] getViewToHeaderPosition(JTextArea view, int start, int end) {\n        validateView(view);\n        validateStartEnd(start, end, view.getDocument().getLength());\n        return getViewToHeaderPositionImpl(view, start, end);\n    }\n","new_comment_raw":"@return the positions offset for the header, or  #INVALID_POSITION if the  start or  end is greater than the length of the  view","old_comment_raw":"@return the positions offset for the header","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":63},{"new_code_raw":"@SuppressWarnings(STR) public V getInstance() { if (instance == null && element.getAttribute(STR) != null) { try { instance = (V) element.createExecutableExtension(STR); } catch (Exception e) { IStatus status = new Status(IStatus.ERROR, Activator.PLUGIN_ID, NLS.bind(TcfPluginMessages.Extension_error_invalidExtensionPoint, element.getDeclaringExtension().getUniqueIdentifier()), e); Activator.getDefault().getLog().log(status); } } return instance; }","old_code_raw":"@SuppressWarnings(STR)\npublic V getInstance() {\n    if (fInstance == null) {\n        IConfigurationElement element = getConfigurationElement();\n        assert element != null;\n        if (element != null && element.getAttribute(STR) != null) {\n            try {\n                fInstance = (V) element.createExecutableExtension(STR);\n            } catch (Exception e) {\n                IStatus status = new Status(IStatus.ERROR, Activator.PLUGIN_ID, NLS.bind(TcfPluginMessages.Extension_error_invalidExtensionPoint, element.getDeclaringExtension().getUniqueIdentifier()), e);\n                Activator.getDefault().getLog().log(status);\n            }\n        }\n    }\n    return fInstance;\n}","new_comment_raw":"@return The extension class instance. Might be <code>null<\/code> if the instantiation fails.","old_comment_raw":"@return The extension class instance. Might be <code>null<\/code> if the instanciation fails.","label":1,"pre_label":0,"AST_level":12,"line_counts":12,"new_code_token_num":92},{"new_code_raw":"public static String toString(byte[] bytes, int base) { char[] chars; int j = 0; switch (base) { case 2: chars = new char[bytes.length * 8]; for (byte b : bytes) { chars[j++] = digits[(b & 0x80) >> 7]; chars[j++] = digits[(b & 0x40) >> 6]; chars[j++] = digits[(b & 0x20) >> 5]; chars[j++] = digits[(b & 0x10) >> 4]; chars[j++] = digits[(b & 0x08) >> 3]; chars[j++] = digits[(b & 0x04) >> 2]; chars[j++] = digits[(b & 0x02) >> 1]; chars[j++] = digits[b & 0x01]; } break; case 16: chars = new char[bytes.length * 2]; for (byte b : bytes) { chars[j++] = digits[(b & 0xF0) >> 4]; chars[j++] = digits[b & 0x0F]; } break; default: throw new IllegalArgumentException(\"bad base \" + base); } return new String(chars, 0, j); }","old_code_raw":"  public static String toString(byte[] bytes) {\n    char[] chars = new char[bytes.length * 2];\n    for (int i = 0, j = 0; i < bytes.length; i++) {\n      byte b = bytes[i];\n      chars[j++] = digits[(b & 0xF0) >> 4];\n      chars[j++] = digits[b & 0x0F];\n    }\n    return new String(chars);\n  }\n","new_comment_raw":"@return String","old_comment_raw":"@return String","label":0,"pre_label":1,"AST_level":13,"line_counts":30,"new_code_token_num":257},{"new_code_raw":"protected Rectangle getLabelBounds(DrawContext dc, OrderedPlacemark opm) { if (this.getLabelText() == null) return null; Vec4 labelPoint = this.computeLabelPoint(dc, opm); Font font = this.getActiveAttributes().getLabelFont(); if (font == null) font = PointPlacemarkAttributes.DEFAULT_LABEL_FONT; TextRenderer textRenderer = OGLTextRenderer.getOrCreateTextRenderer(dc.getTextRendererCache(), font); Rectangle2D bounds = textRenderer.getBounds(this.getLabelText()); double width = bounds.getWidth(); double height = bounds.getHeight(); Double labelScale = this.getActiveAttributes().getLabelScale(); if (labelScale != null) { width *= labelScale; height *= labelScale; } int y = (int) (labelPoint.getY() + bounds.getY() \/ NUM); return new Rectangle((int) labelPoint.x, y, (int) Math.ceil(width), (int) Math.ceil(height)); }","old_code_raw":"protected Rectangle2D getLabelBounds(DrawContext dc, OrderedPlacemark opm) {\n    if (this.labelText == null)\n        return null;\n    double x = (float) (opm.screenPoint.x + this.dx);\n    double y = (float) (opm.screenPoint.y + this.dy);\n    Double imageScale = this.getActiveAttributes().getScale();\n    Offset os = this.getActiveAttributes().getLabelOffset();\n    if (os == null)\n        os = DEFAULT_LABEL_OFFSET_IF_UNSPECIFIED;\n    double w = this.activeTexture != null ? this.activeTexture.getWidth(dc) : NUM;\n    double h = this.activeTexture != null ? this.activeTexture.getHeight(dc) : NUM;\n    Point.Double offset = os.computeOffset(w, h, imageScale, imageScale);\n    x += offset.x;\n    y += offset.y;\n    Font font = this.getActiveAttributes().getLabelFont();\n    if (font == null)\n        font = PointPlacemarkAttributes.DEFAULT_LABEL_FONT;\n    Rectangle2D bounds;\n    if (this.labelBounds != null && font == this.boundsFont) {\n        bounds = new Rectangle.Double(x, y, this.labelBounds.getWidth(), this.labelBounds.getHeight());\n    } else {\n        TextRenderer textRenderer = OGLTextRenderer.getOrCreateTextRenderer(dc.getTextRendererCache(), font);\n        bounds = textRenderer.getBounds(this.labelText);\n        this.boundsFont = font;\n        this.labelBounds = bounds;\n    }\n    Double labelScale = this.getActiveAttributes().getLabelScale();\n    if (labelScale != null) {\n        double tw = labelScale * bounds.getWidth();\n        double th = labelScale * bounds.getHeight();\n        bounds = new Rectangle2D.Double(x, y, tw, th);\n    } else {\n        bounds = new Rectangle2D.Double(x, y, bounds.getWidth(), bounds.getHeight());\n    }\n    return bounds;\n}","new_comment_raw":"@return the label bounds, in lower-left origin screen coordinates, or null if there is no label.","old_comment_raw":"@return the label bounds, in lower-left origin screen coordinates.","label":1,"pre_label":0,"AST_level":8,"line_counts":19,"new_code_token_num":166},{"new_code_raw":"public ResponseEntity<BigDecimal> fakeOuterNumberSerializeWithHttpInfo(BigDecimal body) throws RestClientException { Object postBody = body; String path = apiClient.expandPath(\"\/fake\/outer\/number\", Collections.<String, Object>emptyMap()); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { \"*\/*\" }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public ResponseEntity<BigDecimal> fakeOuterNumberSerializeWithHttpInfo(BigDecimal body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = apiClient.expandPath(\"\/fake\/outer\/number\", Collections.<String, Object>emptyMap());\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*\/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<BigDecimal> returnType = new ParameterizedTypeReference<BigDecimal>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@return ResponseEntity&lt;BigDecimal&gt;","old_comment_raw":"@return ResponseEntity&lt;BigDecimal&gt;","label":0,"pre_label":1,"AST_level":8,"line_counts":23,"new_code_token_num":179},{"new_code_raw":"public int getSeconds() { return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX); }","old_code_raw":"    public int getSeconds() {\n        return getPeriodType().getSeconds(this);\n    }\n","new_comment_raw":"@return the number of seconds in the period, zero if unsupported","old_comment_raw":"@return the number of seconds in the period, zero if unsupported","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public android.telecom.Connection.VideoProvider getVideoProvider() { return mVideoProvider; }","old_code_raw":"public android.telecomm.Connection.VideoProvider getVideoProvider() {\n    return mVideoProvider;\n}","new_comment_raw":"@return The {@link android.telecom.Connection.VideoProvider}.","old_comment_raw":"@return The {@link android.telecomm.Connection.VideoProvider}.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"@Override public boolean equals(Object other) { if (this == other) { return true; } if (other instanceof PwPair) { PwPair otherPwPair = (PwPair) other; return getRank() == otherPwPair.getRank() && mUrlDevice.equals(otherPwPair.mUrlDevice) && mPwsResult.equals(otherPwPair.mPwsResult); } return false; }","old_code_raw":"public boolean equals(Object other) {\n    if (other instanceof PwPair) {\n        PwPair otherPwPair = (PwPair) other;\n        return getRank() == otherPwPair.getRank();\n    }\n    return false;\n}","new_comment_raw":"@return true if the PwPairs are equal.","old_comment_raw":"@return true if the ranks are equal.","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":64},{"new_code_raw":"@NonNull protected List<Action> retrieveActions(@NonNull SCMSourceEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }","old_code_raw":"@NonNull\nprotected Map<Class<? extends Action>, Action> retrieveActions(@NonNull TaskListener listener) throws IOException, InterruptedException {\n    return Collections.emptyMap();\n}","new_comment_raw":"@return the list of {@link Action} instances to persist.","old_comment_raw":"@return the map of {@link Action} instances to persist, keyed by the class of action. Keys with {@code null} values indicate actions that should be removed if present.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"public static W3CWidget getWidget(String metadata, String shindig) throws Exception { JSONObject gadget = null; JSONObject response = new JSONObject(metadata); JSONArray gadgets = response.getJSONArray(STR); if (gadgets.length() == NUM) return null; gadget = gadgets.getJSONObject(NUM); return new GadgetAdapter(gadget, shindig); }","old_code_raw":"public static Widget getWidget(String metadata, String shindig) throws Exception {\n    JSONObject gadget = null;\n    Widget widget = null;\n    JSONObject response = new JSONObject(metadata);\n    JSONArray gadgets = response.getJSONArray(STR);\n    if (gadgets.length() > NUM) {\n        gadget = gadgets.getJSONObject(NUM);\n        if (gadget.has(STR))\n            throw new Exception(STR);\n        widget = new Widget();\n        String title = STR;\n        int height = NUM;\n        int width = NUM;\n        String author = STR;\n        String description = STR;\n        String icon = DEFAULT_ICON;\n        if (!gadget.has(STR))\n            throw new Exception(STR);\n        if (gadget.getString(STR) == null || gadget.getString(STR).equals(STR))\n            throw new Exception(STR);\n        try {\n            @SuppressWarnings(STR)\n            URL url = new URL(gadget.getString(STR));\n        } catch (Exception e) {\n            throw new Exception(STR);\n        }\n        widget.setGuid(gadget.getString(STR));\n        StartFile sf = new StartFile();\n        sf.setWidget(widget);\n        sf.setUrl(shindig + STR + gadget.getString(STR) + STR);\n        if (gadget.has(STR))\n            if (gadget.getInt(STR) != NUM)\n                height = gadget.getInt(STR);\n        if (gadget.has(STR))\n            if (gadget.getInt(STR) != NUM)\n                width = gadget.getInt(STR);\n        if (gadget.has(STR)) {\n            if (gadget.getString(STR) != null) {\n                if (!(gadget.getString(STR).trim()).equals(STR)) {\n                    author = gadget.getString(STR);\n                }\n            }\n        }\n        if (gadget.has(STR)) {\n            if (gadget.getString(STR) != null) {\n                if (!(gadget.getString(STR).trim()).equals(STR)) {\n                    title = gadget.getString(STR);\n                }\n            }\n        }\n        if (gadget.has(STR)) {\n            if (gadget.getString(STR) != null) {\n                if (!(gadget.getString(STR).trim()).equals(STR)) {\n                    title = gadget.getString(STR);\n                }\n            }\n        }\n        if (gadget.has(STR)) {\n            if (gadget.getString(STR) != null) {\n                if (!(gadget.getString(STR).trim()).equals(STR)) {\n                    title = gadget.getString(STR);\n                }\n            }\n        }\n        if (gadget.has(STR)) {\n            if (gadget.getString(STR) != null) {\n                if (!(gadget.getString(STR).trim()).equals(STR)) {\n                    icon = gadget.getString(STR);\n                }\n            }\n        }\n        widget.setMaximize(false);\n        widget.setHeight(height);\n        widget.setWidth(width);\n        Name name = new Name();\n        name.setWidget(widget);\n        name.setName(title);\n        Description desc = new Description();\n        desc.setWidget(widget);\n        desc.setContent(description);\n        WidgetIcon wicon = new WidgetIcon();\n        wicon.setSrc(icon);\n        wicon.setWidget(widget);\n        widget.setWidgetAuthor(author);\n        widget.save();\n        sf.save();\n        name.save();\n        wicon.save();\n        desc.save();\n    }\n    return widget;\n}","new_comment_raw":"@return a W3CWidget instance","old_comment_raw":"@return a Widget instance","label":1,"pre_label":0,"AST_level":6,"line_counts":9,"new_code_token_num":62},{"new_code_raw":"private Producer<EncodedImage> newDiskCacheSequence(Producer<EncodedImage> inputProducer) { Producer<EncodedImage> cacheWriteProducer; if (mPartialImageCachingEnabled) { Producer<EncodedImage> partialDiskCacheProducer = mProducerFactory.newPartialDiskCacheProducer(inputProducer); cacheWriteProducer = mProducerFactory.newDiskCacheWriteProducer(partialDiskCacheProducer); } else { cacheWriteProducer = mProducerFactory.newDiskCacheWriteProducer(inputProducer); } return mProducerFactory.newDiskCacheReadProducer(cacheWriteProducer); }","old_code_raw":"  private Producer<EncodedImage> newDiskCacheSequence(Producer<EncodedImage> inputProducer) {\n    Producer<EncodedImage> cacheWriteProducer;\n    if (mPartialImageCachingEnabled) {\n      Producer<EncodedImage> partialDiskCacheProducer =\n          mProducerFactory.newPartialDiskCacheProducer(inputProducer);\n      cacheWriteProducer = mProducerFactory.newDiskCacheWriteProducer(partialDiskCacheProducer);\n    } else {\n      cacheWriteProducer = mProducerFactory.newDiskCacheWriteProducer(inputProducer);\n    }\n    Producer<EncodedImage> mediaVariationsProducer =\n        mProducerFactory.newMediaVariationsProducer(cacheWriteProducer);\n    return mProducerFactory.newDiskCacheReadProducer(mediaVariationsProducer);\n  }\n","new_comment_raw":"@return encoded cache multiplex to webp transcode sequence","old_comment_raw":"@return encoded cache multiplex to webp transcode sequence","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":54},{"new_code_raw":"public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if ( \"findColumn\".equals( method.getName() ) ) { return findColumn( (String) args[0] ); } if ( isFirstArgColumnLabel( method ) ) { Method columnIndexMethod = NAME_TO_INDEX_METHOD_MAPPING.get( new ResultSetMethodKey( method.getName(), method.getParameterTypes() ) ); if ( columnIndexMethod != null ) { try { final Integer columnIndex = findColumn( (String) args[0] ); return invokeMethod( columnIndexMethod, buildColumnIndexMethodArgs( args, columnIndex ) ); } catch ( SQLException ex ) { final String msg = \"Exception getting column index for column: [\" + args[0] + \"].\\nReverting to using: [\" + args[0] + \"] as first argument for method: [\" + method + \"]\"; SQL_EXCEPTION_HELPER.logExceptions( ex, msg ); } } } return invokeMethod( method, args ); }","old_code_raw":"\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\tif ( \"findColumn\".equals( method.getName() ) ) {\n\t\t\treturn findColumn( (String) args[0] );\n\t\t}\n\n\t\tif ( isFirstArgColumnLabel( method, args ) ) {\n\t\t\ttry {\n\t\t\t\tfinal Integer columnIndex = findColumn( (String) args[0] );\n\t\t\t\treturn invokeMethod(\n\t\t\t\t\t\tlocateCorrespondingColumnIndexMethod( method ),\n\t\t\t\t\t\tbuildColumnIndexMethodArgs( args, columnIndex )\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch ( SQLException ex ) {\n\t\t\t\tfinal String msg = \"Exception getting column index for column: [\" + args[0] +\n\t\t\t\t\t\t\"].\\nReverting to using: [\" + args[0] +\n\t\t\t\t\t\t\"] as first argument for method: [\" + method + \"]\";\n\t\t\t\tSQL_EXCEPTION_HELPER.logExceptions( ex, msg );\n\t\t\t}\n\t\t\tcatch ( NoSuchMethodException ex ) {\n\t\t\t\tLOG.unableToSwitchToMethodUsingColumnIndex( method );\n\t\t\t}\n\t\t}\n\t\treturn invokeMethod( method, args );\n\t}\n","new_comment_raw":"@return The generated proxy.","old_comment_raw":"@return The generated proxy.","label":0,"pre_label":1,"AST_level":19,"line_counts":25,"new_code_token_num":187},{"new_code_raw":"public <T> HttpResponse<T> doGet(HttpRequest httpRequest, final Class<T> responseType) { Function<String, T> convertResponse = new Function<String, T>() { @Override public T apply(String input) { return gson.fromJson(input, responseType); } }; return doGetWithSerializeFunction(httpRequest, convertResponse); }","old_code_raw":"public <T> HttpResponse<T> doGet(HttpRequest httpRequest, Class<T> responseType) {\n    InputStream is = null;\n    try {\n        HttpURLConnection conn = (HttpURLConnection) new URL(httpRequest.getUrl()).openConnection();\n        conn.setRequestMethod(STR);\n        int connectTimeout = httpRequest.getConnectTimeout();\n        if (connectTimeout < NUM) {\n            connectTimeout = m_configUtil.getConnectTimeout();\n        }\n        int readTimeout = httpRequest.getReadTimeout();\n        if (readTimeout < NUM) {\n            readTimeout = m_configUtil.getReadTimeout();\n        }\n        conn.setConnectTimeout(connectTimeout);\n        conn.setReadTimeout(readTimeout);\n        conn.connect();\n        int statusCode = conn.getResponseCode();\n        if (statusCode == NUM) {\n            is = conn.getInputStream();\n            String content = Files.IO.INSTANCE.readFrom(is, Charsets.UTF_8.name());\n            return new HttpResponse<>(statusCode, gson.fromJson(content, responseType));\n        }\n        if (statusCode == NUM) {\n            return new HttpResponse<>(statusCode, null);\n        }\n        throw new RuntimeException(String.format(STR, httpRequest.getUrl(), statusCode));\n    } catch (Throwable ex) {\n        throw new RuntimeException(STR, ex);\n    } finally {\n        if (is != null) {\n            try {\n                is.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n}","new_comment_raw":"@return the response","old_comment_raw":"@return the http response","label":1,"pre_label":0,"AST_level":9,"line_counts":10,"new_code_token_num":59},{"new_code_raw":"public static ConversionDefn analyze(ColumnMetadata inputSchema, ColumnMetadata outputSchema) { if (inputSchema.type().equals(outputSchema.type())) { return new ConversionDefn(ConversionType.NONE); } switch (inputSchema.type()) { case VARCHAR: return new ConversionDefn(convertFromVarchar(outputSchema)); case BIT: switch (outputSchema.type()) { case TINYINT: case SMALLINT: case INT: return ConversionDefn.IMPLICIT; case VARCHAR: return new ConversionDefn(ConvertBooleanToString.class); default: break; } break; case TINYINT: switch (outputSchema.type()) { case SMALLINT: case INT: case BIGINT: case FLOAT4: case FLOAT8: case VARDECIMAL: return ConversionDefn.IMPLICIT; case VARCHAR: return new ConversionDefn(ConvertIntToString.class); default: break; } break; case SMALLINT: switch (outputSchema.type()) { case TINYINT: return ConversionDefn.IMPLICIT_UNSAFE; case INT: case BIGINT: case FLOAT4: case FLOAT8: case VARDECIMAL: return ConversionDefn.IMPLICIT; case VARCHAR: return new ConversionDefn(ConvertIntToString.class); default: break; } break; case INT: switch (outputSchema.type()) { case TINYINT: case SMALLINT: return ConversionDefn.IMPLICIT_UNSAFE; case BIGINT: case FLOAT4: case FLOAT8: case VARDECIMAL: case TIME: return ConversionDefn.IMPLICIT; case VARCHAR: return new ConversionDefn(ConvertIntToString.class); default: break; } break; case BIGINT: switch (outputSchema.type()) { case TINYINT: case SMALLINT: case INT: return ConversionDefn.IMPLICIT_UNSAFE; case FLOAT4: case FLOAT8: case VARDECIMAL: case DATE: case TIMESTAMP: return ConversionDefn.IMPLICIT; case VARCHAR: return new ConversionDefn(ConvertLongToString.class); default: break; } break; case FLOAT4: switch (outputSchema.type()) { case TINYINT: case SMALLINT: case INT: case BIGINT: return ConversionDefn.IMPLICIT_UNSAFE; case FLOAT8: case VARDECIMAL: return ConversionDefn.IMPLICIT; case VARCHAR: return new ConversionDefn(ConvertDoubleToString.class); default: break; } break; case FLOAT8: switch (outputSchema.type()) { case TINYINT: case SMALLINT: case INT: case BIGINT: case FLOAT4: return ConversionDefn.IMPLICIT_UNSAFE; case VARDECIMAL: return ConversionDefn.IMPLICIT; case VARCHAR: return new ConversionDefn(ConvertDoubleToString.class); default: break; } break; case DATE: switch (outputSchema.type()) { case BIGINT: return ConversionDefn.IMPLICIT; case VARCHAR: return new ConversionDefn(ConvertDateToString.class); default: break; } break; case TIME: switch (outputSchema.type()) { case INT: return ConversionDefn.IMPLICIT; case VARCHAR: return new ConversionDefn(ConvertTimeToString.class); default: break; } break; case TIMESTAMP: switch (outputSchema.type()) { case BIGINT: return ConversionDefn.IMPLICIT; case VARCHAR: return new ConversionDefn(ConvertTimeStampToString.class); default: break; } break; case INTERVAL: case INTERVALYEAR: case INTERVALDAY: switch (outputSchema.type()) { case VARCHAR: return new ConversionDefn(ConvertIntervalToString.class); default: break; } break; default: break; } return ConversionDefn.EXPLICIT; }","old_code_raw":"  public static ConversionDefn analyze(ColumnMetadata inputSchema, ColumnMetadata outputSchema) {\n    if (inputSchema.type().equals(outputSchema.type())) {\n      return new ConversionDefn(ConversionType.NONE);\n    }\n\n    switch (inputSchema.type()) {\n    case VARCHAR:\n      return new ConversionDefn(convertFromVarchar(outputSchema));\n    case TINYINT:\n      switch (outputSchema.type()) {\n      case SMALLINT:\n      case INT:\n      case BIGINT:\n      case FLOAT4:\n      case FLOAT8:\n      case VARDECIMAL:\n        return new ConversionDefn(ConversionType.IMPLICIT);\n      default:\n        break;\n      }\n      break;\n    case SMALLINT:\n      switch (outputSchema.type()) {\n      case TINYINT:\n        return new ConversionDefn(ConversionType.IMPLICIT_UNSAFE);\n      case INT:\n      case BIGINT:\n      case FLOAT4:\n      case FLOAT8:\n      case VARDECIMAL:\n        return new ConversionDefn(ConversionType.IMPLICIT);\n      default:\n        break;\n      }\n      break;\n    case INT:\n      switch (outputSchema.type()) {\n      case TINYINT:\n      case SMALLINT:\n        return new ConversionDefn(ConversionType.IMPLICIT_UNSAFE);\n      case BIGINT:\n      case FLOAT4:\n      case FLOAT8:\n      case VARDECIMAL:\n        return new ConversionDefn(ConversionType.IMPLICIT);\n      default:\n        break;\n      }\n      break;\n    case BIGINT:\n      switch (outputSchema.type()) {\n      case TINYINT:\n      case SMALLINT:\n      case INT:\n        return new ConversionDefn(ConversionType.IMPLICIT_UNSAFE);\n      case FLOAT4:\n      case FLOAT8:\n      case VARDECIMAL:\n        return new ConversionDefn(ConversionType.IMPLICIT);\n      default:\n        break;\n      }\n      break;\n    case FLOAT4:\n      switch (outputSchema.type()) {\n      case TINYINT:\n      case SMALLINT:\n      case INT:\n      case BIGINT:\n        return new ConversionDefn(ConversionType.IMPLICIT_UNSAFE);\n      case FLOAT8:\n      case VARDECIMAL:\n        return new ConversionDefn(ConversionType.IMPLICIT);\n      default:\n        break;\n      }\n      break;\n    case FLOAT8:\n      switch (outputSchema.type()) {\n      case TINYINT:\n      case SMALLINT:\n      case INT:\n      case BIGINT:\n      case FLOAT4:\n        return new ConversionDefn(ConversionType.IMPLICIT_UNSAFE);\n      case VARDECIMAL:\n        return new ConversionDefn(ConversionType.IMPLICIT);\n      default:\n        break;\n      }\n      break;\n    default:\n      break;\n    }\n    return new ConversionDefn(ConversionType.EXPLICIT);\n  }\n","new_comment_raw":"@return a description of the conversion needed (if any), along with the standard conversion class, if available","old_comment_raw":"@return a description of the conversion needed (if any), along with the standard conversion class, if available","label":0,"pre_label":1,"AST_level":10,"line_counts":164,"new_code_token_num":587},{"new_code_raw":"@Override public AbstractObjectParser executeSQL() throws Exception { if (isTable == false) { sqlReponse = new JSONObject(sqlRequest); } else { try { sqlReponse = onSQLExecute(); } catch (Exception e) { Log.e(TAG, STR); if (e instanceof NotExistException) { sqlReponse = null; } else { throw e; } } if (drop) { sqlReponse = null; } } return this; }","old_code_raw":"@Override\npublic AbstractObjectParser executeSQL() throws Exception {\n    return executeSQL(NUM, NUM, NUM);\n}","new_comment_raw":"@return this","old_comment_raw":"@return {@link #executeSQL(int, int, int)}","label":1,"pre_label":0,"AST_level":11,"line_counts":21,"new_code_token_num":80},{"new_code_raw":"private Annotation getDocument(Properties props, HttpExchange httpExchange) throws IOException, ClassNotFoundException { String inputFormat = props.getProperty(\"inputFormat\", \"text\"); String date = props.getProperty(\"date\"); switch (inputFormat) { case \"text\": \/\/ The default encoding by the HTTP standard is ISO-8859-1, but most \/\/ real users of CoreNLP would likely assume UTF-8 by default. String defaultEncoding = this.strict ? \"ISO-8859-1\" : \"UTF-8\"; \/\/ Get the encoding Headers h = httpExchange.getRequestHeaders(); String encoding; if (h.containsKey(\"Content-type\")) { String[] charsetPair = Arrays.asList(h.getFirst(\"Content-type\").split(\";\")).stream() .map(x -> x.split(\"=\")) .filter(x -> x.length > 0 && \"charset\".equals(x[0])) .findFirst().orElse(new String[]{\"charset\", defaultEncoding}); if (charsetPair.length == 2) { encoding = charsetPair[1]; } else { encoding = defaultEncoding; } } else { encoding = defaultEncoding; } String text = IOUtils.slurpReader(IOUtils.encodedInputStreamReader(httpExchange.getRequestBody(), encoding)); text = URLDecoder.decode(text, encoding).trim(); \/\/ TODO(chaganty): URLdecode string. \/\/ Read the annotation Annotation annotation = new Annotation(text); \/\/ Set the date (if provided) if (date != null) { annotation.set(CoreAnnotations.DocDateAnnotation.class, date); } return annotation; case \"serialized\": String inputSerializerName = props.getProperty(\"inputSerializer\", ProtobufAnnotationSerializer.class.getName()); AnnotationSerializer serializer = MetaClass.create(inputSerializerName).createInstance(); Pair<Annotation, InputStream> pair = serializer.read(httpExchange.getRequestBody()); return pair.first; default: throw new IOException(\"Could not parse input format: \" + inputFormat); } }","old_code_raw":"  private Annotation getDocument(Properties props, HttpExchange httpExchange) throws IOException, ClassNotFoundException {\n    String inputFormat = props.getProperty(\"inputFormat\", \"text\");\n    switch (inputFormat) {\n      case \"text\":\n        \/\/ The default encoding by the HTTP standard is ISO-8859-1, but most\n        \/\/ real users of CoreNLP would likely assume UTF-8 by default.\n        String defaultEncoding = this.strict ? \"ISO-8859-1\" : \"UTF-8\";\n        \/\/ Get the encoding\n        Headers h = httpExchange.getRequestHeaders();\n        String encoding;\n        if (h.containsKey(\"Content-type\")) {\n          String[] charsetPair = Arrays.asList(h.getFirst(\"Content-type\").split(\";\")).stream()\n              .map(x -> x.split(\"=\"))\n              .filter(x -> x.length > 0 && \"charset\".equals(x[0]))\n              .findFirst().orElse(new String[]{\"charset\", defaultEncoding});\n          if (charsetPair.length == 2) {\n            encoding = charsetPair[1];\n          } else {\n            encoding = defaultEncoding;\n          }\n        } else {\n          encoding = defaultEncoding;\n        }\n\n        String text = IOUtils.slurpReader(IOUtils.encodedInputStreamReader(httpExchange.getRequestBody(), encoding));\n        text = URLDecoder.decode(text, encoding).trim();\n        \/\/ TODO(chaganty): URLdecode string.\n        \/\/ Read the annotation\n        return new Annotation(text);\n      case \"serialized\":\n        String inputSerializerName = props.getProperty(\"inputSerializer\", ProtobufAnnotationSerializer.class.getName());\n        AnnotationSerializer serializer = MetaClass.create(inputSerializerName).createInstance();\n        Pair<Annotation, InputStream> pair = serializer.read(httpExchange.getRequestBody());\n        return pair.first;\n      default:\n        throw new IOException(\"Could not parse input format: \" + inputFormat);\n    }\n  }\n","new_comment_raw":"@return An Annotation representing the read document.","old_comment_raw":"@return An Annotation representing the read document.","label":0,"pre_label":1,"AST_level":17,"line_counts":45,"new_code_token_num":381},{"new_code_raw":"protected Object convertBigInt(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; } if (data instanceof Long) return data; if (data instanceof Number) { Number value = (Number) data; return new Long(value.longValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? LONG_TRUE : LONG_FALSE; } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertBigInt(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof Long) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Long(value.longValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? LONG_TRUE : LONG_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":19,"new_code_token_num":118},{"new_code_raw":"public ArrayList<ErrorMsg> getWarnings() { return _parser.getWarnings(); }","old_code_raw":"public Vector getWarnings() {\n    return _parser.getWarnings();\n}","new_comment_raw":"@return A List containing all compile error messages","old_comment_raw":"@return A Vector containing all compile error messages","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":14},{"new_code_raw":"public static DateTimeZone getInstance(String id) throws IllegalArgumentException { if (id == null) { return getDefault(); } if (id.equals(\"UTC\")) { return DateTimeZone.UTC; } DateTimeZone zone = cProvider.getZone(id); if (zone != null) { return zone; } if (id.startsWith(\"+\") || id.startsWith(\"-\")) { int offset = -(int) offsetFormatter().parseMillis(id); if (offset == 0L) { return DateTimeZone.UTC; } else { id = offsetFormatter().print(0, UTC, offset); return fixedOffsetZone(id, offset); } } throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id); }","old_code_raw":"    public static DateTimeZone getInstance(String id) throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = -(int) offsetFormatter().parseMillis(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = offsetFormatter().print(0, UTC, offset);\n                return new FixedDateTimeZone(id, null, offset, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n    }\n","new_comment_raw":"@return the DateTimeZone object for the ID","old_comment_raw":"@return the DateTimeZone object for the ID","label":0,"pre_label":1,"AST_level":11,"line_counts":23,"new_code_token_num":147},{"new_code_raw":"public static List<Accept> parse(final HttpServletRequest r) throws IllegalArgumentException { return parse(r.getHeader(STR)); }","old_code_raw":"public static ImmutableList<Accept> parse(final HttpServletRequest r) throws IllegalArgumentException {\n    return parse(Strings.nullToEmpty(r.getHeader(STR)));\n}","new_comment_raw":"@return An immutable list of {@link Accept} entities sorted by RFC priority.","old_comment_raw":"@return A group of {@link Accept} entities.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":24},{"new_code_raw":"public int transformToActualPosition(int position) { if(getAdapter() == null || getAdapter().getItemCount() < 0) { return 0; } return position % getActualItemCountFromAdapter(); }","old_code_raw":"    public int transformToActualPosition(int position) {\n        return position % getActualItemCountFromAdapter();\n    }\n","new_comment_raw":"@return actual position","old_comment_raw":"@return actual position","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":37},{"new_code_raw":"private void drawInstanceMap(Graphics2D graphics) { Region region = client.getRegion(); Tile[][] tiles = getTiles(); Dimension mapOverlaySize = new Dimension(tiles.length * TILE_SIZE, tiles[0].length * TILE_SIZE); graphics.setColor(Color.black); graphics.fillRect(0, 0, mapOverlaySize.width, mapOverlaySize.height);\/\/draw background graphics.setColor(Color.white); graphics.drawRect(0, 0, mapOverlaySize.width - 1, mapOverlaySize.height - 1);\/\/draw outline \/\/Draw the base colors first for (int x = 0; x < tiles.length; x++) { for (int y = tiles[x].length - 1; y >= 0; y--)\/\/flip y value { drawTileColor(graphics, region, tiles[x][(tiles[x].length - 1) - y], x, y); } } \/\/Draw walls on top for (int x = 0; x < tiles.length; x++) { for (int y = tiles[x].length - 1; y >= 0; y--)\/\/Flip y value { drawTileWalls(graphics, tiles[x][(tiles[x].length - 1) - y], x, y); } } }","old_code_raw":"\tprivate Dimension drawInstanceMap(Graphics2D graphics)\n\t{\n\t\tTile[][][] regionTiles = client.getRegion().getTiles();\n\n\t\tint plane = client.getPlane();\n\t\tTile[][] tiles = regionTiles[plane];\n\n\t\tDimension mapOverlaySize = new Dimension(tiles.length * tileSize, tiles[0].length * tileSize);\n\n\t\tgraphics.setColor(Color.BLACK);\n\t\tgraphics.fillRect(0, 0, mapOverlaySize.width, mapOverlaySize.height);\n\n\t\tfor (int x = 0; x < tiles.length; x++)\n\t\t{\n\t\t\tfor (int y = 0; y < tiles[x].length; y++)\n\t\t\t{\n\t\t\t\tTile curTile = tiles[x][(tiles[x].length - 1) - y]; \/\/ flip the y value\n\t\t\t\tif (curTile != null && curTile.getSceneTilePaint() != null)\n\t\t\t\t{\n\t\t\t\t\tgraphics.setColor(new Color(curTile.getSceneTilePaint().getRBG()));\n\t\t\t\t\tgraphics.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn mapOverlaySize;\n\t}\n","new_comment_raw":"@return The dimensions of the map","old_comment_raw":"@return The dimensions of the map","label":0,"pre_label":1,"AST_level":15,"line_counts":32,"new_code_token_num":252},{"new_code_raw":"public double valueSum() { \/\/ We want the exp(log-sum-exp), for stability \/\/ This rearranges to exp(a)*(sum-exp) double max = 0.0; for (int[] assignment : this) { double v = getAssignmentLogValue(assignment); if (v > max) { max = v; } } double sumExp = 0.0; for (int[] assignment : this) { sumExp += Math.exp(getAssignmentLogValue(assignment) - max); } return sumExp * Math.exp(max); }","old_code_raw":"    public double valueSum() {\n\n        \/\/ We want the exp(log-sum-exp), for stability\n        \/\/ This rearranges to exp(a)*(sum-exp)\n\n        double max = 0.0;\n        for (int[] assignment : this) {\n            double v = getAssignmentLogValue(assignment);\n            if (v > max) {\n                max = v;\n            }\n        }\n\n        double sumExp = 0.0;\n        for (int[] assignment : this) {\n            sumExp += FastMath.exp(getAssignmentLogValue(assignment) - max);\n        }\n\n        return sumExp * FastMath.exp(max);\n    }\n","new_comment_raw":"@return the sum of all values for all assignments to the TableFactor","old_comment_raw":"@return the sum of all values for all assignments to the TableFactor","label":0,"pre_label":1,"AST_level":10,"line_counts":21,"new_code_token_num":109},{"new_code_raw":"public static <T, N extends TreeNode<T>> String toString(final N inputNode, final Function<N, String> toString) { final StringBuilder builder = new StringBuilder(); depthFirst(inputNode, new TreeVisitor<N>() { final Set<Integer> depths = Sets.newHashSet(); @SuppressWarnings(STR) @Override public void onNode(final int depth, final N node) { if (!isRoot(node) && !isLeaf(node) && !isLastChild(node)) { this.depths.add(depth); } else { this.depths.remove(depth); } builder.append(indent(depth)); final String nodeString = toString.apply(node); builder.append(STR).append(nodeString).append(Strings2.NEW_LINE); } private String indent(final int depth) { final StringBuilder b = new StringBuilder(); for (int i = NUM; i < depth; i++) { if (this.depths.contains(Integer.valueOf(i))) { b.append(STR); } else { b.append(STR); } } return b.toString(); } }); return builder.toString(); }","old_code_raw":"public static <T, N extends TreeNode<T>> String toString(final N node) {\n    final Function<N, String> function = new Function<N, String>() {\n\n        @Override\n        public String apply(final N arg0) {\n            return arg0.toString();\n        }\n    };\n    return toString(node, function);\n}","new_comment_raw":"@return a string representation of the tree","old_comment_raw":"@return the node as a string","label":1,"pre_label":0,"AST_level":13,"line_counts":33,"new_code_token_num":224},{"new_code_raw":"public ArrayList filterContent(String key) { return this.of.filter(key); }","old_code_raw":"public ArrayList filterContent(String prefix) {\n    if (STR.equals(prefix)) {\n        this.filteredItemsBuffer = new ArrayList(getItemIds());\n        return this.filteredItemsBuffer;\n    } else if (items != null) {\n        this.filteredItemsBuffer = new ArrayList();\n        for (Iterator iter = items.getItemIds().iterator(); iter.hasNext(); ) {\n            Object id = iter.next();\n            Item item = getItem(id);\n            String test = STR;\n            if (getItemCaptionMode() == ITEM_CAPTION_MODE_PROPERTY)\n                test = item.getItemProperty(getItemCaptionPropertyId()).getValue().toString().trim();\n            else\n                test = String.valueOf(id);\n            if (test.toLowerCase().startsWith(prefix)) {\n                this.filteredItemsBuffer.add(id);\n            }\n        }\n    }\n    return this.filteredItemsBuffer;\n}","new_comment_raw":"@return All item ids filtered by given key.","old_comment_raw":"@return All item ids filtered by given prefix.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"protected ReadableInstant create(long instant, Chronology chrono) { \/\/ ignore chrono if (instant == getMillis()) { return this; } return new Instant(instant); }","old_code_raw":"    protected ReadableInstant create(long millis, Chronology chrono) {\n        \/\/ ignore chrono\n        if (millis == getMillis()) {\n            return this;\n        }\n        return new Instant(millis);\n    }\n","new_comment_raw":"@return a new instance of this class","old_comment_raw":"@return a new instance of this class","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"public static DateTimeFormatter dateHourMinuteSecondFraction() { return Constants.dhmsf; }","old_code_raw":"    public static DateTimeFormatter dateHourMinuteSecondFraction() {\n        if (dhmsf == null) {\n            dhmsf = new DateTimeFormatterBuilder()\n                .append(date())\n                .append(literalTElement())\n                .append(hourMinuteSecondFraction())\n                .toFormatter();\n        }\n        return dhmsf;\n    }\n","new_comment_raw":"@return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS","old_comment_raw":"@return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public CompositeData[] browse() throws OpenDataException{ return broker.browse(this); }","old_code_raw":"    public CompositeData[] browse() throws OpenDataException{\n        return null;\n    }\n","new_comment_raw":"@return messages","old_comment_raw":"@return messages","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public static Treepath getNextSibling(Treepath treepath) { if (treepath.getHeight() < NUM) { throw new IllegalArgumentException(STR); } final Tree treeToMove = treepath.getBottom(); final Tree parent = treepath.getTreeAtHeight(NUM); for (int i = NUM; i < parent.getChildCount() - NUM; i++) { final Tree child = parent.getChildAt(i); if (child == treeToMove) { return Treepath.create(treepath.getParent(), parent.getChildAt(i + NUM)); } } throw new IllegalArgumentException(STR); }","old_code_raw":"public static Treepath getNextSibling(Treepath treepath) {\n    throw new UnsupportedOperationException(STR);\n}","new_comment_raw":"@return non-null object.","old_comment_raw":"@return non-null if sibling was found, null otherwise.","label":1,"pre_label":0,"AST_level":11,"line_counts":14,"new_code_token_num":105},{"new_code_raw":"public int toStatusCode(Throwable thrown) { if (thrown == null) { return SUCCESS; } else if (thrown instanceof InvalidCookieDomainException) { return INVALID_COOKIE_DOMAIN; } else if (thrown instanceof UnableToSetCookieException) { return UNABLE_TO_SET_COOKIE; } else if (thrown instanceof NoSuchWindowException) { return NO_SUCH_WINDOW; } else if (thrown instanceof InvalidSelectorException) { return INVALID_SELECTOR_ERROR; } else if (thrown instanceof NoSuchElementException) { return NO_SUCH_ELEMENT; } else if (thrown instanceof NoSuchFrameException) { return NO_SUCH_FRAME; } else if (thrown instanceof StaleElementReferenceException) { return STALE_ELEMENT_REFERENCE; } else if (thrown instanceof ElementNotVisibleException) { return ELEMENT_NOT_VISIBLE; } else if (thrown instanceof InvalidElementStateException) { return INVALID_ELEMENT_STATE; } else if (thrown instanceof XPathLookupException) { return XPATH_LOOKUP_ERROR; } else if (thrown instanceof TimeoutException) { return ASYNC_SCRIPT_TIMEOUT; } else if (thrown instanceof InvalidCoordinatesException) { return INVALID_ELEMENT_COORDINATES; } else if (thrown instanceof ImeNotAvailableException) { return IME_NOT_AVAILABLE; } else if (thrown instanceof ImeActivationFailedException) { return IME_ENGINE_ACTIVATION_FAILED; } else if (thrown instanceof NoAlertPresentException) { return NO_ALERT_PRESENT; } else { return UNHANDLED_ERROR; } }","old_code_raw":"  public int toStatusCode(Throwable thrown) {\n    if (thrown == null) {\n      return SUCCESS; \n    } else if (thrown instanceof InvalidCookieDomainException) {\n      return INVALID_COOKIE_DOMAIN;\n    } else if (thrown instanceof UnableToSetCookieException) {\n      return UNABLE_TO_SET_COOKIE;\n    } else if (thrown instanceof NoSuchWindowException) {\n      return NO_SUCH_WINDOW;\n    } else if (thrown instanceof InvalidSelectorException) {\n      return INVALID_SELECTOR_ERROR;\n    } else if (thrown instanceof NoSuchElementException) {\n      return NO_SUCH_ELEMENT;\n    } else if (thrown instanceof NoSuchFrameException) {\n      return NO_SUCH_FRAME;\n    } else if (thrown instanceof StaleElementReferenceException) {\n      return STALE_ELEMENT_REFERENCE;\n    } else if (thrown instanceof ElementNotVisibleException) {\n      return ELEMENT_NOT_VISIBLE;\n    } else if (thrown instanceof InvalidElementStateException) {\n      return INVALID_ELEMENT_STATE;\n    } else if (thrown instanceof XPathLookupException) {\n      return XPATH_LOOKUP_ERROR;\n    } else if (thrown instanceof TimeoutException) {\n      return ASYNC_SCRIPT_TIMEOUT;\n    } else if (thrown instanceof InvalidCoordinatesException) {\n      return INVALID_ELEMENT_COORDINATES;\n    } else if (thrown instanceof ImeNotAvailableException) {\n      return IME_NOT_AVAILABLE;\n    } else if (thrown instanceof ImeActivationFailedException) {\n      return IME_ENGINE_ACTIVATION_FAILED;\n    } else {\n      return UNHANDLED_ERROR;\n    }\n  }\n","new_comment_raw":"@return The corresponding status code for the given thrown error.","old_comment_raw":"@return The corresponding status code for the given thrown error.","label":0,"pre_label":1,"AST_level":21,"line_counts":38,"new_code_token_num":205},{"new_code_raw":"protected Object convertTimestampToEpochMillis(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return Timestamp.toEpochMillis(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimestampToEpochMillis(Column column, Field fieldDefn, Object data) {\n        if ( data == null ) return null;\n        try {\n            return Timestamp.toEpochMillis(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":82},{"new_code_raw":"protected RecordCommitter buildRecordCommitter(OffsetStorageWriter offsetWriter, SourceTask task, Duration commitTimeout) { return new RecordCommitter() { @Override public synchronized void markProcessed(SourceRecord record) throws InterruptedException { task.commitRecord(record); recordsSinceLastCommit += 1; offsetWriter.offset(record.sourcePartition(), record.sourceOffset()); } @Override public synchronized void markBatchFinished() { maybeFlush(offsetWriter, offsetCommitPolicy, commitTimeout, task); } }; }","old_code_raw":"    protected RecordCommitter buildRecordCommitter(OffsetStorageWriter offsetWriter, SourceTask task, Duration commitTimeout) {\n        Object lock = this;\n        return new RecordCommitter() {\n            @Override\n            public void markProcessed(SourceRecord record) throws InterruptedException {\n                synchronized (lock) {\n                    task.commitRecord(record);\n                    recordsSinceLastCommit += 1;\n                    offsetWriter.offset(record.sourcePartition(), record.sourceOffset());\n                }\n            }\n\n            @Override\n            public void markBatchFinished() {\n                synchronized (lock) {\n                    maybeFlush(offsetWriter, offsetCommitPolicy, commitTimeout, task);\n                }\n            }\n        };\n    }\n","new_comment_raw":"@return the new recordCommitter to be used for a given batch","old_comment_raw":"@return the new recordCommitter to be used for a given batch","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":82},{"new_code_raw":"protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return MicroTime.toMicroOfDay(data, adjuster); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimeToMicrosPastMidnight(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L; \/\/ return epoch\n        }\n        try {\n            return MicroTime.toMicroOfDay(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":84},{"new_code_raw":"public Map<String, TopicConfig> getTopicConfigs() { return Collections.unmodifiableMap(topicConfigs); }","old_code_raw":"public Map<String, TopicConfig> getTopicConfigs() {\n    return Collections.unmodifiableMap(mapTopicConfigs);\n}","new_comment_raw":"@return the topicConfigs","old_comment_raw":"@return the mapTopicConfigs","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public GrammaticalStructureFactory grammaticalStructureFactory(Predicate<String> puncFilter) { if (generateOriginalDependencies) { return new EnglishGrammaticalStructureFactory(puncFilter); } else { return new UniversalEnglishGrammaticalStructureFactory(puncFilter); } }","old_code_raw":"  public GrammaticalStructureFactory grammaticalStructureFactory(Predicate<String> puncFilter) {\n    return new EnglishGrammaticalStructureFactory(puncFilter);\n  }\n","new_comment_raw":"@return A GrammaticalStructure suitable for this language\/treebank.","old_comment_raw":"@return A GrammaticalStructure suitable for this language\/treebank.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":33},{"new_code_raw":"private static ArrayList<Uri> getTreeUris(Context context) { ArrayList<Uri> uris = new ArrayList<Uri>(); Uri uri1 = getSharedPreferenceUri(context, R.string.preference_internal_uri_extsdcard_photos); if (uri1 != null) uris.add(uri1); return uris; }","old_code_raw":"  private static Uri[] getTreeUris(Context context) {\n\tList<Uri> uris = new ArrayList<Uri>();\n\n\tUri uri1 = getSharedPreferenceUri(context, R.string.preference_internal_uri_extsdcard_photos);\n\tif (uri1 != null) {\n\t  uris.add(uri1);\n\t}\n\n\t\/*\n\tUri uri2 = getSharedPreferenceUri(R.string.key_internal_uri_extsdcard_input);\n\tif (uri2 != null) {\n\t  uris.add(uri2);\n\t}\n\t*\/\n\treturn uris.toArray(new Uri[uris.size()]);\n  }\n","new_comment_raw":"@return The tree URIs.","old_comment_raw":"@return The tree URIs.","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":46},{"new_code_raw":"public Pet getPetById(Long petId) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\"); } \/\/ create path and map variables String localVarPath = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, String> localVarCookieParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"api_key\" }; GenericType<Pet> localVarReturnType = new GenericType<Pet>() {}; return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Pet getPetById(Long petId) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/pet\/{petId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key\" };\n\n    GenericType<Pet> localVarReturnType = new GenericType<Pet>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return a  Pet","old_comment_raw":"@return a Pet","label":0,"pre_label":1,"AST_level":9,"line_counts":38,"new_code_token_num":265},{"new_code_raw":"public Object get(long timeout, String key) throws TimeoutException { SynchronizationObject<CachedData[]> sync = setupGet(key); waitForNotNull(timeout, sync); CachedData[] rvContainer = sync.get(); assert rvContainer.length == NUM; Object rv = null; if (rvContainer[NUM] != null) { rv = transcoder.decode(rvContainer[NUM]); } return rv; }","old_code_raw":"public Map<String, Object> get(String... keys) {\n    final Map<String, Object> rv = new ConcurrentHashMap<String, Object>();\n    final AtomicInteger requests = new AtomicInteger();\n    final SynchronizationObject<AtomicInteger> sync = new SynchronizationObject<AtomicInteger>(requests);\n    GetOperation.Callback cb = new GetOperation.Callback() {\n\n        public void getComplete() {\n            requests.decrementAndGet();\n            sync.set(requests);\n        }\n\n        public void gotData(String k, int flags, byte[] data) {\n            rv.put(k, transcoder.decode(new CachedData(flags, data)));\n        }\n    };\n    Map<Integer, Collection<String>> chunks = new HashMap<Integer, Collection<String>>();\n    for (String key : keys) {\n        int which = getServerForKey(key);\n        Collection<String> ks = chunks.get(which);\n        if (ks == null) {\n            ks = new ArrayList<String>();\n            chunks.put(which, ks);\n        }\n        ks.add(key);\n    }\n    for (Map.Entry<Integer, Collection<String>> me : chunks.entrySet()) {\n        requests.incrementAndGet();\n        addOp(me.getKey(), new GetOperation(me.getValue(), cb));\n    }\n    try {\n        sync.waitUntilTrue(new SynchronizationObject.Predicate<AtomicInteger>() {\n\n            public boolean evaluate(AtomicInteger val) {\n                return val.get() == NUM;\n            }\n        }, Long.MAX_VALUE, TimeUnit.SECONDS);\n    } catch (InterruptedException e) {\n        throw new RuntimeException(STR, e);\n    } catch (TimeoutException e) {\n        throw new RuntimeException(STR, e);\n    }\n    return rv;\n}","new_comment_raw":"@return the result from the cache (null if there is none)","old_comment_raw":"@return a map of the values (for each value that exists)","label":1,"pre_label":0,"AST_level":10,"line_counts":11,"new_code_token_num":73},{"new_code_raw":"public Object h2TCPServer() throws SQLException { String port = \"1\" + env.getProperty(\"server.port\"); log.debug(\"H2 database is available on port {}\", port); return H2ConfigurationHelper.createServer(port); }","old_code_raw":"    public Object h2TCPServer() throws SQLException {\n        log.debug(\"Starting H2 database\");\n        return H2ConfigurationHelper.createServer();\n    }\n","new_comment_raw":"@return the H2 database TCP server","old_comment_raw":"@return the H2 database TCP server","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":48},{"new_code_raw":"public Insets getBorderInsets(Component c) { return getBorderInsets(c, null); }","old_code_raw":"public Insets getBorderInsets(Component c, Insets insets) {\n    if (this.insets != null) {\n        if (insets == null) {\n            insets = new Insets(this.insets.top, this.insets.left, this.insets.bottom, this.insets.right);\n        } else {\n            insets.top = this.insets.top;\n            insets.bottom = this.insets.bottom;\n            insets.left = this.insets.left;\n            insets.right = this.insets.right;\n        }\n    } else if (insets == null) {\n        insets = new Insets(NUM, NUM, NUM, NUM);\n    } else {\n        insets.top = insets.bottom = insets.left = insets.right = NUM;\n    }\n    if (c instanceof JComponent) {\n        Region region = Region.getRegion((JComponent) c);\n        Insets margin = null;\n        if ((region == Region.ARROW_BUTTON || region == Region.BUTTON || region == Region.CHECK_BOX || region == Region.CHECK_BOX_MENU_ITEM || region == Region.MENU || region == Region.MENU_ITEM || region == Region.RADIO_BUTTON || region == Region.RADIO_BUTTON_MENU_ITEM || region == Region.TOGGLE_BUTTON) && (c instanceof AbstractButton)) {\n            margin = ((AbstractButton) c).getMargin();\n        } else if ((region == Region.EDITOR_PANE || region == Region.FORMATTED_TEXT_FIELD || region == Region.PASSWORD_FIELD || region == Region.TEXT_AREA || region == Region.TEXT_FIELD || region == Region.TEXT_PANE) && (c instanceof JTextComponent)) {\n            margin = ((JTextComponent) c).getMargin();\n        } else if (region == Region.TOOL_BAR && (c instanceof JToolBar)) {\n            margin = ((JToolBar) c).getMargin();\n        } else if (region == Region.MENU_BAR && (c instanceof JMenuBar)) {\n            margin = ((JMenuBar) c).getMargin();\n        }\n        if (margin != null) {\n            insets.top += margin.top;\n            insets.bottom += margin.bottom;\n            insets.left += margin.left;\n            insets.right += margin.right;\n        }\n    }\n    return insets;\n}","new_comment_raw":"@return the new <code>Insets<\/code> object initialized to 0","old_comment_raw":"@return the <code>insets<\/code> object","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public Role[] getRoles() { Item[] items = super.getItems(); Role[] roles = new Role[items.length]; for (int i = NUM; i < roles.length; i++) { roles[i] = (Role) items[i]; } return roles; }","old_code_raw":"public Iterator getRoles() {\n    return super.getItems();\n}","new_comment_raw":"@return an array of roles.","old_comment_raw":"@return an <code>Iterator<\/code>","label":1,"pre_label":0,"AST_level":10,"line_counts":8,"new_code_token_num":60},{"new_code_raw":"public JSONObject getExtraJSONObject(String key) throws JSONException { return mExtraData.getJSONObject(key); }","old_code_raw":"public JSONObject getExtraJSONObject(String key) {\n    return mExtraData.optJSONObject(key);\n}","new_comment_raw":"@return The stored value.","old_comment_raw":"@return The stored value or null if it doesn't exist in specified form.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public BooleanExpression startsWith(Expression<String> str) { return BooleanOperation.create(Ops.STARTS_WITH, mixin, str); }","old_code_raw":"    public BooleanExpression startsWith(Expression<String> str) {\n        return BooleanOperation.create(Ops.STARTS_WITH, this, str);\n    }\n","new_comment_raw":"@return this.startsWith(str)","old_comment_raw":"@return this.startsWith(str)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public static ExecutorService getMessageDispatcher(final AtmosphereConfig config, final String name) { final boolean shared = config.framework().isShareExecutorServices(); useForkJoinPool = config.getInitParameter(ApplicationConfig.USE_FORJOINPOOL, true); if (!shared || config.properties().get(BROADCASTER_THREAD_POOL) == null) { int numberOfMessageProcessingThread = DEFAULT_MESSAGE_THREAD; String s = config.getInitParameter(ApplicationConfig.BROADCASTER_MESSAGE_PROCESSING_THREADPOOL_MAXSIZE); if (s != null) { numberOfMessageProcessingThread = Integer.parseInt(s); } if (shared && numberOfMessageProcessingThread == 1) { logger.warn(\"Not enough numberOfMessageProcessingThread for a shareable thread pool {}, \" + \"Setting it to a newCachedThreadPool\", numberOfMessageProcessingThread); numberOfMessageProcessingThread = -1; } AbstractExecutorService messageService; logger.trace(\"Max number of DispatchOp {}\", numberOfMessageProcessingThread == -1 ? \"Unlimited\" : numberOfMessageProcessingThread); if (numberOfMessageProcessingThread == -1) { messageService = !useForkJoinPool ? (ThreadPoolExecutor) Executors.newCachedThreadPool(new AtmosphereThreadFactory(shared, name + \"-DispatchOp-\")) : new org.atmosphere.util.ForkJoinPool(); } else { messageService = (ThreadPoolExecutor) Executors.newFixedThreadPool(numberOfMessageProcessingThread, new AtmosphereThreadFactory(shared, name + \"-DispatchOp-\")); } keepAliveThreads(messageService, config); if (shared) { config.properties().put(BROADCASTER_THREAD_POOL, messageService); } return messageService; } else { return (ExecutorService) config.properties().get(BROADCASTER_THREAD_POOL); } }","old_code_raw":"    public static ExecutorService getMessageDispatcher(final AtmosphereConfig config, final String name) {\n        final boolean shared = config.framework().isShareExecutorServices();\n\n        if (!shared || config.properties().get(BROADCASTER_THREAD_POOL) == null) {\n            int numberOfMessageProcessingThread = DEFAULT_MESSAGE_THREAD;\n            String s = config.getInitParameter(ApplicationConfig.BROADCASTER_MESSAGE_PROCESSING_THREADPOOL_MAXSIZE);\n            if (s != null) {\n                numberOfMessageProcessingThread = Integer.parseInt(s);\n            }\n\n            if (shared && numberOfMessageProcessingThread == 1) {\n                logger.warn(\"Not enough numberOfMessageProcessingThread for a shareable thread pool {}, \" +\n                        \"Setting it to a newCachedThreadPool\", numberOfMessageProcessingThread);\n                numberOfMessageProcessingThread = -1;\n            }\n\n            ThreadPoolExecutor messageService;\n            logger.trace(\"Max number of DispatchOp {}\", numberOfMessageProcessingThread == -1 ? \"Unlimited\" : numberOfMessageProcessingThread);\n            if (numberOfMessageProcessingThread == -1) {\n                messageService = (ThreadPoolExecutor) Executors.newCachedThreadPool(new ThreadFactory() {\n\n                    private final AtomicInteger count = new AtomicInteger();\n\n                    @Override\n                    public Thread newThread(final Runnable runnable) {\n                        Thread t = new Thread(runnable, (shared ? \"Atmosphere-Shared\" : name) + \"-DispatchOp-\" + count.getAndIncrement());\n                        t.setDaemon(true);\n                        return t;\n                    }\n                });\n            } else {\n                messageService = (ThreadPoolExecutor) Executors.newFixedThreadPool(numberOfMessageProcessingThread, new ThreadFactory() {\n\n                    private final AtomicInteger count = new AtomicInteger();\n\n                    @Override\n                    public Thread newThread(final Runnable runnable) {\n                        Thread t = new Thread(runnable, (shared ? \"Atmosphere-Shared\" : name) + \"-DispatchOp-\" + count.getAndIncrement());\n                        t.setDaemon(true);\n                        return t;\n                    }\n                });\n            }\n\n            keepAliveThreads(messageService, config);\n\n            if (shared) {\n                config.properties().put(BROADCASTER_THREAD_POOL, messageService);\n            }\n            return messageService;\n        } else {\n            return (ExecutorService) config.properties().get(BROADCASTER_THREAD_POOL);\n        }\n    }\n","new_comment_raw":"@return  ExecutorService","old_comment_raw":"@return ExecutorService","label":0,"pre_label":1,"AST_level":14,"line_counts":37,"new_code_token_num":261},{"new_code_raw":"public Set<Warning> getWarnings() { return Collections.unmodifiableSet(project.getWarnings(packageName)); }","old_code_raw":"public Collection<Warning> getWarnings() {\n    return project.getWarnings(packageName);\n}","new_comment_raw":"@return the warnings for this package details view","old_comment_raw":"@return all warnings of this package","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public PeriodFormatterBuilder appendSeparator(String text, String finalText) { return appendSeparator(text, finalText, null, true, true); }","old_code_raw":"    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {\n        return appendSeparator(text, finalText, true, true);\n    }\n","new_comment_raw":"@return this PeriodFormatterBuilder","old_comment_raw":"@return this PeriodFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"private File[] getProjectFiles(File directory) { return directory.listFiles(new FileFilter() { public boolean accept(File file) { return (file.isFile() && file.getName().endsWith(STR)); } }); }","old_code_raw":"private File[] getProjectFiles(File directory) {\n    File[] files = directory.listFiles(new FileFilter() {\n\n        public boolean accept(File file) {\n            return (file.isFile() && file.getName().endsWith(STR));\n        }\n    });\n    switch(explorerTableSortColumn) {\n        case NUM:\n        case NUM:\n        case NUM:\n        default:\n    }\n    selectedFile = -NUM;\n    if (getProject() != null)\n        for (int n = NUM; n < files.length; n++) if (getProject().getFile().equals(files[n]))\n            selectedFile = n;\n    return files;\n}","new_comment_raw":"@return project files in that directory.","old_comment_raw":"@return project files in that directory, sorted alphabetically.","label":1,"pre_label":0,"AST_level":11,"line_counts":8,"new_code_token_num":50},{"new_code_raw":"public ByteBuf getContent() { return this.facade.getContent(); }","old_code_raw":"public Buffer getContent() {\n    return this.facade.getContent();\n}","new_comment_raw":"@return a ByteBuf holding the bytes contained in this message.","old_comment_raw":"@return a Buffer holding the bytes contained in this message.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":14},{"new_code_raw":"public Options includeDirectives(boolean flag) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, flag, this.useAstDefinitions, this.comparatorRegistry); }","old_code_raw":"        public Options includeDirectives(boolean flag) {\n            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, flag, this.comparatorRegistry);\n        }\n","new_comment_raw":"@return new instance of options","old_comment_raw":"@return new instance of options","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public static String getLibraryPathPropertyName() { Platform current = Platform.getCurrent(); if (current.is(WINDOWS)) { return \"PATH\"; } else if (current.is(MAC)) { return \"DYLD_LIBRARY_PATH\"; } else { return \"LD_LIBRARY_PATH\"; } }","old_code_raw":"  public static String getLibraryPathPropertyName() {\n    switch (Platform.getCurrent()) {\n      case MAC:\n        return \"DYLD_LIBRARY_PATH\";\n\n      case WINDOWS:\n      case VISTA:\n      case XP:\n        return \"PATH\";\n\n      default:\n        return \"LD_LIBRARY_PATH\";\n    }\n  }\n","new_comment_raw":"@return The platform specific env property name which contains the library path.","old_comment_raw":"@return The platform specific env property name which contains the library path.","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":54},{"new_code_raw":"public ScheduledReporter build() { ScheduledReporter reporter; switch(influxdbVersion) { case V08: Influxdb influxdb = buildInfluxdb(); reporter = (executor == null) ? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics) : new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor); break; default: Sender s = buildSender(); reporter = executor == null ? new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer) : new MeasurementReporter(s, registry, filter, rateUnit, durationUnit, clock, tags, transformer, executor); } return reporter; }","old_code_raw":"public ScheduledReporter build(Influxdb influxdb) {\n    return executor == null ? new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics) : new ReporterV08(registry, influxdb, clock, prefix, rateUnit, durationUnit, filter, skipIdleMetrics, executor);\n}","new_comment_raw":"@return a {@link ScheduledReporter}","old_comment_raw":"@return a {@link InfluxdbReporter}","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":132},{"new_code_raw":"public static String jenkinsJobName(String namespace, String buildConfigName) { return namespace + STR + buildConfigName; }","old_code_raw":"public static String jenkinsJobName(String namespace, String buildConfigName, String defaultNamespace) {\n    if (namespace == null || namespace.length() == NUM || namespace.equals(defaultNamespace)) {\n        return buildConfigName;\n    }\n    return namespace + STR + buildConfigName;\n}","new_comment_raw":"@return the jenkins job name for the given namespace and name","old_comment_raw":"@return the jenkins job name for the given namespace and build config name and default namesapce","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":20},{"new_code_raw":"public boolean waitForActivity(String name, int timeout){ if(isActivityMatching(activityUtils.getCurrentActivity(false, false), name)){ return true; } boolean foundActivity = false; ActivityMonitor activityMonitor = getActivityMonitor(); long currentTime = SystemClock.uptimeMillis(); final long endTime = currentTime + timeout; while(currentTime < endTime){ Activity currentActivity = activityMonitor.waitForActivityWithTimeout(endTime - currentTime); if(isActivityMatching(currentActivity, name)){ foundActivity = true; break; } currentTime = SystemClock.uptimeMillis(); } removeMonitor(activityMonitor); return foundActivity; }","old_code_raw":"\tpublic boolean waitForActivity(String name, int timeout){\n\t\tActivity currentActivity = activityUtils.getCurrentActivity(false, false);\n\t\tfinal long endTime = SystemClock.uptimeMillis() + timeout;\n\n\t\twhile(SystemClock.uptimeMillis() < endTime){\n\t\t\tif(currentActivity != null && currentActivity.getClass().getSimpleName().equals(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tsleeper.sleep(MINISLEEP);\n\t\t\tcurrentActivity = activityUtils.getCurrentActivity(false, false);\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@return  true if  Activity appears before the timeout and  false if it does not","old_comment_raw":"@return true if Activity appears before the timeout and false if it does not","label":0,"pre_label":1,"AST_level":9,"line_counts":23,"new_code_token_num":103},{"new_code_raw":"public DateTime roundHalfCeilingCopy() { DateTime instant = iInstant; return (DateTime)instant.withMillis(iField.roundHalfCeiling(instant.getMillis())); }","old_code_raw":"    public DateTime roundHalfCeilingCopy() {\n        DateTime instant = iInstant;\n        return (DateTime)instant.toCopy(iField.roundHalfCeiling(instant.getMillis()));\n    }\n","new_comment_raw":"@return a copy of the DateTime with the field value changed","old_comment_raw":"@return a copy of the DateTime with the field value changed","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"public static final Test suite() { return null; }","old_code_raw":"public static Test suite(String name) {\n    return new TestSuite(JtdsDataSourceUnitTest.Test_JtdsDataSource_getConnection.class, name);\n}","new_comment_raw":"@return The test suite (always <code>null<\/code>).","old_comment_raw":"@return The test suite.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public boolean getVacantCell(int[] vacant, int spanX, int spanY) { final boolean portrait = mPortrait; final int xCount = portrait ? mShortAxisCells : mLongAxisCells; final int yCount = portrait ? mLongAxisCells : mShortAxisCells; final boolean[][] occupied = mOccupied; findOccupiedCells(xCount, yCount, occupied, null); return findVacantCell(vacant, spanX, spanY, xCount, yCount, occupied); }","old_code_raw":"    public boolean getVacantCell(int[] vacant, int spanX, int spanY) {\n\n        return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);\n    }\n","new_comment_raw":"@return True if a vacant cell was found","old_comment_raw":"@return True if a vacant cell was found","label":0,"pre_label":1,"AST_level":6,"line_counts":11,"new_code_token_num":76},{"new_code_raw":"public Pet getPetById(Long petId) throws ApiException { Object localVarPostBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\"); } \/\/ create path and map variables String localVarPath = \"\/pet\/{petId}\" .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString())); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/xml\", \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { \"api_key\" }; GenericType<Pet> localVarReturnType = new GenericType<Pet>() {}; return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Pet getPetById(Long petId) throws ApiException {\n    Object localVarPostBody = null;\n    \n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      throw new ApiException(400, \"Missing the required parameter 'petId' when calling getPetById\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/pet\/{petId}\"\n      .replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiClient.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/xml\", \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] { \"api_key\" };\n\n    GenericType<Pet> localVarReturnType = new GenericType<Pet>() {};\n    return apiClient.invokeAPI(localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return Pet","old_comment_raw":"@return Pet","label":0,"pre_label":1,"AST_level":9,"line_counts":37,"new_code_token_num":245},{"new_code_raw":"public RelTraitSet plus(RelTrait trait) { if (contains(trait)) { return this; } int i = findIndex(trait.getTraitDef()); if (i >= 0) { return replace(i, trait); } \/\/ Optimize time & space to represent a trait set key. \/\/ \/\/ Don't build a trait set until we're sure there isn't an equivalent one. \/\/ Then we can justify the cost of computing RelTraitSet.string in the \/\/ constructor. final RelTrait canonizedTrait = canonize(trait); List<RelTrait> newTraits; switch (traits.length) { case 0: newTraits = ImmutableList.of(canonizedTrait); break; case 1: newTraits = FlatLists.of(traits[0], canonizedTrait); break; case 2: newTraits = FlatLists.of(traits[0], traits[1], canonizedTrait); break; default: newTraits = ImmutableList.<RelTrait>builder().add(traits) .add(canonizedTrait).build(); } return cache.getOrAdd(newTraits); }","old_code_raw":"  public RelTraitSet plus(RelTrait trait) {\n    if (contains(trait)) {\n      return this;\n    }\n    int i = findIndex(trait.getTraitDef());\n    if (i >= 0) {\n      return replace(i, trait);\n    }\n    final RelTrait canonizedTrait = canonize(trait);\n    RelTrait[] newTraits = Arrays.copyOf(traits, traits.length + 1);\n    newTraits[newTraits.length - 1] = canonizedTrait;\n    return cache.getOrAdd(new RelTraitSet(cache, newTraits));\n  }\n","new_comment_raw":"@return Trait set with given trait","old_comment_raw":"@return Trait set with given trait","label":0,"pre_label":1,"AST_level":10,"line_counts":32,"new_code_token_num":195},{"new_code_raw":"private GridHubConfiguration getHubConfiguration() throws Exception { String hubApi = \"http:\/\/\" + registrationRequest.getConfiguration().getHubHost() + \":\" + registrationRequest.getConfiguration().getHubPort() + \"\/grid\/api\/hub\"; URL api = new URL(hubApi); HttpClient client = httpClientFactory.createClient(api); String url = api.toExternalForm(); HttpRequest request = new HttpRequest(GET, url); HttpResponse response = client.execute(request); try (Reader reader = new StringReader(response.getContentString()); JsonInput jsonInput = new Json().newInput(reader)) { return StandaloneConfiguration.loadFromJson(jsonInput, GridHubConfiguration.class); } }","old_code_raw":"  private GridHubConfiguration getHubConfiguration() throws Exception {\n    String hubApi =\n      \"http:\/\/\" + registrationRequest.getConfiguration().getHubHost() + \":\"\n      + registrationRequest.getConfiguration().getHubPort() + \"\/grid\/api\/hub\";\n\n    URL api = new URL(hubApi);\n    HttpClient client = httpClientFactory.createClient(api);\n    String url = api.toExternalForm();\n    HttpRequest request = new HttpRequest(GET, url);\n\n    HttpResponse response = client.execute(request);\n    return GridHubConfiguration.loadFromJSON(extractObject(response));\n  }\n","new_comment_raw":"@return json object of the current hub configuration","old_comment_raw":"@return json object of the current hub configuration","label":0,"pre_label":1,"AST_level":10,"line_counts":17,"new_code_token_num":124},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<File> listFiles(@Optional @Default(STR) final int maxResults, @Optional final String query, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<File>() { @Override public List<File> doGetPage() throws IOException { FileList response = client.files().list().setMaxResults(maxResults).setPageToken(this.getPageToken()).setQ(query).execute(); this.setPageToken(response.getNextPageToken()); return File.valueOf(response.getItems(), File.class); } }; }","old_code_raw":"@Processor\n@OAuthProtected\n@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)\n@Inject\npublic List<File> listFiles(MuleMessage message, @Optional @Default(STR) int maxResults, @Optional String query, @Optional @Default(STR) String pageToken) throws IOException {\n    FileList response = this.client.files().list().setMaxResults(maxResults).setPageToken(pageToken).setQ(query).execute();\n    PaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n    return File.valueOf(response.getItems(), File.class);\n}","new_comment_raw":"@return a paginated iterator with instances of {@link org.mule.module.google.drive.model.File}","old_comment_raw":"@return a list with instances of {@link org.mule.module.google.drive.model.File}","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":114},{"new_code_raw":"static boolean hasNoNulls(Statistics stat) { return stat.getNumNulls() <= NUM; }","old_code_raw":"static boolean hasNoNulls(Statistics stat) {\n    return !stat.isNumNullsSet() || stat.getNumNulls() == NUM;\n}","new_comment_raw":"@return <tt>true<\/tt> if the parquet file does not have nulls and <tt>false<\/tt> otherwise","old_comment_raw":"@return True if the parquet file has nulls False if the parquet file hasn't nulls.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"public String toDefaultValue(Schema p) { if (ModelUtils.isBooleanSchema(p)) { if (p.getDefault() != null) { return p.getDefault().toString(); } } else if (ModelUtils.isDateSchema(p)) { if (p.getDefault() != null) { return \"\\\"\" + p.getDefault().toString() + \"\\\"\"; } } else if (ModelUtils.isDateTimeSchema(p)) { if (p.getDefault() != null) { return \"\\\"\" + p.getDefault().toString() + \"\\\"\"; } } else if (ModelUtils.isNumberSchema(p)) { if (p.getDefault() != null) { if (ModelUtils.isFloatSchema(p)) { \/\/ float return p.getDefault().toString() + \"F\"; } else if (ModelUtils.isDoubleSchema(p)) { \/\/ double return p.getDefault().toString() + \"D\"; } else { \/\/ decimal return p.getDefault().toString() + \"M\"; } } } else if (ModelUtils.isIntegerSchema(p)) { if (p.getDefault() != null) { return p.getDefault().toString(); } } else if (ModelUtils.isStringSchema(p)) { if (p.getDefault() != null) { String _default = (String) p.getDefault(); if (p.getEnum() == null) { return \"\\\"\" + _default + \"\\\"\"; } else { \/\/ convert to enum var name later in postProcessModels return _default; } } } return null; }","old_code_raw":"    public String toDefaultValue(Schema p) {\n        if (ModelUtils.isBooleanSchema(p)) {\n            if (p.getDefault() != null) {\n                return p.getDefault().toString();\n            }\n        } else if (ModelUtils.isDateSchema(p)) {\n            if (p.getDefault() != null) {\n                return \"\\\"\" + p.getDefault().toString() + \"\\\"\";\n            }\n        } else if (ModelUtils.isDateTimeSchema(p)) {\n            if (p.getDefault() != null) {\n                return \"\\\"\" + p.getDefault().toString() + \"\\\"\";\n            }\n        } else if (ModelUtils.isNumberSchema(p)) {\n            if (p.getDefault() != null) {\n                if (ModelUtils.isFloatSchema(p)) { \/\/ float\n                    return p.getDefault().toString() + \"F\";\n                } else if (ModelUtils.isDoubleSchema(p)) { \/\/ double\n                    return p.getDefault().toString() + \"D\";\n                } else {\n                    return p.getDefault().toString();\n                }\n            }\n        } else if (ModelUtils.isIntegerSchema(p)) {\n            if (p.getDefault() != null) {\n                return p.getDefault().toString();\n            }\n        } else if (ModelUtils.isStringSchema(p)) {\n            if (p.getDefault() != null) {\n                String _default = (String) p.getDefault();\n                if (p.getEnum() == null) {\n                    return \"\\\"\" + _default + \"\\\"\";\n                } else {\n                    \/\/ convert to enum var name later in postProcessModels\n                    return _default;\n                }\n            }\n        }\n\n        return null;\n    }\n","new_comment_raw":"@return string presentation of the default value of the property","old_comment_raw":"@return string presentation of the default value of the property","label":0,"pre_label":1,"AST_level":17,"line_counts":42,"new_code_token_num":320},{"new_code_raw":"@Transactional(readOnly = true) @Override public int getCount(final List<BatchInstanceStatus> batchInstStatusList, final List<BatchPriority> batchPriorities, final boolean isCurrUsrNotReq, final String currentUser, final Set<String> userRoles, EphesoftUser ephesoftUser) { return batchInstanceDao.getCount(batchInstStatusList, batchPriorities, isCurrUsrNotReq, userRoles, currentUser, ephesoftUser); }","old_code_raw":"@Transactional(readOnly = true)\n@Override\npublic int getCount(final List<BatchInstanceStatus> batchInstStatusList, final List<BatchPriority> batchPriorities, final boolean isCurrUsrNotReq, final String currentUser, final Set<String> currentRole) {\n    return batchInstanceDao.getCount(batchInstStatusList, batchPriorities, isCurrUsrNotReq, currentRole, currentUser);\n}","new_comment_raw":"@return int, the count satisfying the above requirements","old_comment_raw":"@return the count satisfying the above requirements","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":57},{"new_code_raw":"private long computePartitionSize(final int start) { logger.trace(\"compute partition size starting from {} on {} batches\", start, batches.size()); \/\/ current partition always starts from first batch final VectorAccessible first = getCurrent(); long length = 0; \/\/ count all rows that are in the same partition of start \/\/ keep increasing length until we find first row of next partition or we reach the very \/\/ last batch for (WindowDataBatch batch : batches) { final int recordCount = batch.getRecordCount(); \/\/ check first container from start row, and subsequent containers from first row for (int row = (batch == first) ? start : 0; row < recordCount; row++, length++) { if (!isSamePartition(start, first, row, batch)) { return length; } } } return length; }","old_code_raw":"  private int computePartitionSize(final int start) {\n    logger.trace(\"compute partition size starting from {} on {} batches\", start, batches.size());\n\n    \/\/ current partition always starts from first batch\n    final VectorAccessible first = getCurrent();\n\n    int length = 0;\n\n    \/\/ count all rows that are in the same partition of start\n    \/\/ keep increasing length until we find first row of next partition or we reach the very\n    \/\/ last batch\n    for (WindowDataBatch batch : batches) {\n      final int recordCount = batch.getRecordCount();\n\n      \/\/ check first container from start row, and subsequent containers from first row\n      for (int row = (batch == first) ? start : 0; row < recordCount; row++, length++) {\n        if (!isSamePartition(start, first, row, batch)) {\n          return length;\n        }\n      }\n    }\n\n    return length;\n  }\n","new_comment_raw":"@return number of rows that are part of the partition starting at row start of first batch","old_comment_raw":"@return number of rows that are part of the partition starting at row start of first batch","label":0,"pre_label":1,"AST_level":11,"line_counts":25,"new_code_token_num":170},{"new_code_raw":"public int getSkillExperience(Skill skill) { int[] experiences = getSkillExperiences(); if (skill == Skill.OVERALL) { logger.debug(\"getSkillExperience called for {}!\", skill); return (int) getOverallExperience(); } int idx = skill.ordinal(); \/\/ I'm not certain exactly how needed this is, but if the Skill enum is updated in the future \/\/ to hold something else that's not reported it'll save us from an ArrayIndexOutOfBoundsException. if (idx >= experiences.length) { return -1; } return experiences[idx]; }","old_code_raw":"\tpublic int getSkillExperience(Skill skill)\n\t{\n\t\tint[] experiences = getSkillExperiences();\n\n\t\tif (skill == Skill.OVERALL)\n\t\t{\n\t\t\tint totalExperience = 0;\n\n\t\t\tfor (int experience : experiences)\n\t\t\t{\n\t\t\t\ttotalExperience += experience;\n\t\t\t}\n\n\t\t\treturn totalExperience;\n\t\t}\n\n\t\tint idx = skill.ordinal();\n\n\t\t\/\/ I'm not certain exactly how needed this is, but if the Skill enum is updated in the future\n\t\t\/\/ to hold something else that's not reported it'll save us from an ArrayIndexOutOfBoundsException.\n\t\tif (idx >= experiences.length)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn experiences[idx];\n\t}\n","new_comment_raw":"@return the local player's current experience in the specified  Skill, or -1 if the  Skill isn't valid","old_comment_raw":"@return the local player's current experience in the specified Skill, or -1 if the Skill isn't valid","label":0,"pre_label":1,"AST_level":7,"line_counts":22,"new_code_token_num":115},{"new_code_raw":"private int measureWidth(int widthMeasureSpec) { int widthSize = MeasureSpec.getSize(widthMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int measuredWidth = widthSize; if (mThumbWidth == 0 && mIsThumbUseDrawable) { mThumbWidth = mThumbDrawable.getIntrinsicWidth(); } int moveRange; int textWidth = ceil(mTextWidth); \/\/ how much the background should extend to fit text. int textExtraSpace; int contentSize; if (mThumbRangeRatio == 0) { mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO; } if (widthMode == MeasureSpec.EXACTLY) { contentSize = widthSize - getPaddingLeft() - getPaddingRight(); if (mThumbWidth != 0) { moveRange = ceil(mThumbWidth * mThumbRangeRatio); textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth + ceil(Math.max(mThumbMargin.left, mThumbMargin.right))); mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(textExtraSpace, 0)); if (mBackWidth < 0) { mThumbWidth = 0; } if (moveRange + Math.max(mThumbMargin.left, 0) + Math.max(mThumbMargin.right, 0) + Math.max(textExtraSpace, 0) > contentSize) { mThumbWidth = 0; } } if (mThumbWidth == 0) { contentSize = widthSize - getPaddingLeft() - getPaddingRight(); moveRange = ceil(contentSize - Math.max(mThumbMargin.left, 0) - Math.max(mThumbMargin.right, 0)); if (moveRange < 0) { mThumbWidth = 0; mBackWidth = 0; return measuredWidth; } mThumbWidth = ceil(moveRange \/ mThumbRangeRatio); mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right); if (mBackWidth < 0) { mThumbWidth = 0; mBackWidth = 0; return measuredWidth; } textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth + ceil(Math.max(mThumbMargin.left, mThumbMargin.right))); if (textExtraSpace > 0) { \/\/ since backWidth is determined by view width, so we can only reduce thumbSize. mThumbWidth = mThumbWidth - textExtraSpace; } if (mThumbWidth < 0) { mThumbWidth = 0; mBackWidth = 0; return measuredWidth; } } } else { \/* If parent view want SwitchButton to determine it's size itself, we calculate the minimal size of it's content. Further more, we ignore the limitation of widthSize since we want to display SwitchButton in its actual size rather than compress the shape. *\/ if (mThumbWidth == 0) { \/* If thumbWidth is not set, use the default one. *\/ mThumbWidth = ceil(getResources().getDisplayMetrics().density * DEFAULT_THUMB_SIZE_DP); } if (mThumbRangeRatio == 0) { mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO; } moveRange = ceil(mThumbWidth * mThumbRangeRatio); textExtraSpace = ceil(textWidth + mTextExtra - (moveRange - mThumbWidth + Math.max(mThumbMargin.left, mThumbMargin.right) + mTextThumbInset)); mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(0, textExtraSpace)); if (mBackWidth < 0) { mThumbWidth = 0; mBackWidth = 0; return measuredWidth; } contentSize = ceil(moveRange + Math.max(0, mThumbMargin.left) + Math.max(0, mThumbMargin.right) + Math.max(0, textExtraSpace)); measuredWidth = Math.max(contentSize, contentSize + getPaddingLeft() + getPaddingRight()); } return measuredWidth; }","old_code_raw":"    private int measureWidth(int widthMeasureSpec) {\n        int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int measuredWidth = widthSize;\n\n        if (mThumbWidth == 0 && mIsThumbUseDrawable) {\n            mThumbWidth = mThumbDrawable.getIntrinsicWidth();\n        }\n\n        int moveRange;\n        int textWidth = ceil(mTextWidth);\n        \/\/ how much the background should extend to fit text.\n        int textExtraSpace;\n        int contentSize;\n\n        if (mThumbRangeRatio == 0) {\n            mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO;\n        }\n\n        if (widthMode == MeasureSpec.EXACTLY) {\n            contentSize = widthSize - getPaddingLeft() - getPaddingRight();\n\n            if (mThumbWidth != 0) {\n                moveRange = ceil(mThumbWidth * mThumbRangeRatio);\n                textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth - ceil(Math.max(mThumbMargin.left, mThumbMargin.right)));\n                mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(textExtraSpace, 0));\n                if (mBackWidth < 0) {\n                    mThumbWidth = 0;\n                }\n                if (moveRange + Math.max(mThumbMargin.left, 0) + Math.max(mThumbMargin.right, 0) + Math.max(textExtraSpace, 0) > contentSize) {\n                    mThumbWidth = 0;\n                }\n            }\n\n            if (mThumbWidth == 0) {\n                contentSize = widthSize - getPaddingLeft() - getPaddingRight();\n                moveRange = ceil(contentSize - Math.max(mThumbMargin.left, 0) - Math.max(mThumbMargin.right, 0));\n                if (moveRange < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n                mThumbWidth = ceil(moveRange \/ mThumbRangeRatio);\n                mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right);\n                if (mBackWidth < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n                textExtraSpace = textWidth + mTextExtra - (moveRange - mThumbWidth - ceil(Math.max(mThumbMargin.left, mThumbMargin.right)));\n                if (textExtraSpace > 0) {\n                    \/\/ since backWidth is determined by view width, so we can only reduce thumbSize.\n                    mThumbWidth = mThumbWidth - textExtraSpace;\n                }\n                if (mThumbWidth < 0) {\n                    mThumbWidth = 0;\n                    mBackWidth = 0;\n                    return measuredWidth;\n                }\n            }\n        } else {\n            \/*\n            If parent view want SwitchButton to determine it's size itself, we calculate the minimal\n            size of it's content. Further more, we ignore the limitation of widthSize since we want\n            to display SwitchButton in its actual size rather than compress the shape.\n             *\/\n            if (mThumbWidth == 0) {\n                \/*\n                If thumbWidth is not set, use the default one.\n                 *\/\n                mThumbWidth = ceil(getResources().getDisplayMetrics().density * DEFAULT_THUMB_SIZE_DP);\n            }\n            if (mThumbRangeRatio == 0) {\n                mThumbRangeRatio = DEFAULT_THUMB_RANGE_RATIO;\n            }\n\n            moveRange = ceil(mThumbWidth * mThumbRangeRatio);\n            textExtraSpace = ceil(textWidth + mTextExtra - (moveRange - mThumbWidth + Math.max(mThumbMargin.left, mThumbMargin.right) + mTextThumbInset));\n            mBackWidth = ceil(moveRange + mThumbMargin.left + mThumbMargin.right + Math.max(0, textExtraSpace));\n            contentSize = ceil(moveRange + Math.max(0, mThumbMargin.left) + Math.max(0, mThumbMargin.right) + Math.max(0, textExtraSpace));\n\n            measuredWidth = Math.max(contentSize, contentSize + getPaddingLeft() + getPaddingRight());\n        }\n        return measuredWidth;\n    }\n","new_comment_raw":"@return measuredWidth","old_comment_raw":"@return measuredWidth","label":0,"pre_label":1,"AST_level":13,"line_counts":91,"new_code_token_num":590},{"new_code_raw":"public Date getCreateDate() { return this.createDate; }","old_code_raw":"public java.util.Date getCreateDate() {\n    return this.createDate;\n}","new_comment_raw":"@return {@link Date} ","old_comment_raw":"@return java.util.Date","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public DateOnly roundFloorCopy() { DateOnly instant = iInstant; return (DateOnly)instant.withMillis(iField.roundFloor(instant.getMillis())); }","old_code_raw":"    public DateOnly roundFloorCopy() {\n        DateOnly instant = iInstant;\n        return (DateOnly)instant.toCopy(iField.roundFloor(instant.getMillis()));\n    }\n","new_comment_raw":"@return a copy of the DateOnly with the field value changed","old_comment_raw":"@return a copy of the DateOnly with the field value changed","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"public String getLocalName(int nodeHandle) { \/\/ if(JJK_NEWCODE) \/\/ { int id=makeNodeIdentity(nodeHandle); if(NULL==id) return null; Node newnode=(Node)m_nodes.elementAt(id); String newname=newnode.getLocalName(); if (null == newname) { \/\/ XSLT treats PIs, and possibly other things, as having QNames. String qname = newnode.getNodeName(); if('#'==qname.charAt(0)) { \/\/ Match old default for this function \/\/ This conversion may or may not be necessary newname=\"\"; } else { int index = qname.indexOf(':'); newname = (index < 0) ? qname : qname.substring(index + 1); } } return newname; \/\/ } \/\/ else \/\/ { \/\/ String name; \/\/ short type = getNodeType(nodeHandle); \/\/ switch (type) \/\/ { \/\/ case DTM.ATTRIBUTE_NODE : \/\/ case DTM.ELEMENT_NODE : \/\/ case DTM.ENTITY_REFERENCE_NODE : \/\/ case DTM.NAMESPACE_NODE : \/\/ case DTM.PROCESSING_INSTRUCTION_NODE : \/\/ { \/\/ Node node = getNode(nodeHandle); \/\/ \/\/ \/\/ assume not null. \/\/ name = node.getLocalName(); \/\/ \/\/ if (null == name) \/\/ { \/\/ String qname = node.getNodeName(); \/\/ int index = qname.indexOf(':'); \/\/ \/\/ name = (index < 0) ? qname : qname.substring(index + 1); \/\/ } \/\/ } \/\/ break; \/\/ default : \/\/ name = \"\"; \/\/ } \/\/ return name; \/\/ } }","old_code_raw":"    public String getLocalName(int nodeHandle)\n    {\n        if(JJK_NEWCODE)\n        {\n            int id=makeNodeIdentity(nodeHandle);\n            if(NULL==id) return null;\n            Node newnode=(Node)m_nodes.elementAt(id);\n            String newname=newnode.getLocalName();\n            if (null == newname)\n            {\n                \/\/ XSLT treats PIs, and possibly other things, as having QNames.\n                String qname = newnode.getNodeName();\n                if('#'==qname.charAt(0))\n                {\n                    \/\/  Match old default for this function\n                    \/\/ This conversion may or may not be necessary\n                    newname=\"\";\n                }\n                else\n                {\n                    int index = qname.indexOf(':');\n                    newname = (index < 0) ? qname : qname.substring(index + 1);\n                }\n            }\n            return newname;\n        }\n        else\n        {\n            String name;\n            short type = getNodeType(nodeHandle);\n            switch (type)\n            {\n                case DTM.ATTRIBUTE_NODE :\n                case DTM.ELEMENT_NODE :\n                case DTM.ENTITY_REFERENCE_NODE :\n                case DTM.NAMESPACE_NODE :\n                case DTM.PROCESSING_INSTRUCTION_NODE :\n                {\n                    Node node = getNode(nodeHandle);\n\n                    \/\/ assume not null.\n                    name = node.getLocalName();\n\n                    if (null == name)\n                    {\n                        String qname = node.getNodeName();\n                        int index = qname.indexOf(':');\n\n                        name = (index < 0) ? qname : qname.substring(index + 1);\n                    }\n                }\n                break;\n                default :\n                    name = \"\";\n            }\n            return name;\n        }\n    }\n","new_comment_raw":"@return String Local name of this node.","old_comment_raw":"@return String Local name of this node.","label":0,"pre_label":1,"AST_level":12,"line_counts":59,"new_code_token_num":321},{"new_code_raw":"public boolean get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public boolean get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public ConcurrentHashMap<String, String> getSubToSuperMap() { return subToSuperMap; }","old_code_raw":"public HashMap<String, String> getSubToSuperMap() {\n    return subToSuperMap;\n}","new_comment_raw":"@return ConcurrentHashMap of {@link ProductType} ids mapped to their parent id","old_comment_raw":"@return HashMap of {@link ProductType} ids mapped to their parent id","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"@ManagedAttribute(description = STR) public boolean getRunning() { return running.get(); }","old_code_raw":"public AtomicBoolean getRunning() {\n    return running;\n}","new_comment_raw":"@return true if running, false if stopped","old_comment_raw":"@return the running","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public MColor getColor() { if (m_vo.AD_Color_ID == NUM) return null; MColor mc = new MColor(m_vo.ctx, m_vo.AD_Color_ID, null); return mc; }","old_code_raw":"public CompiereColor getColor() {\n    if (m_vo.AD_Color_ID == NUM)\n        return null;\n    MColor mc = new MColor(m_vo.ctx, m_vo.AD_Color_ID, null);\n    return mc.getAdempiereColor();\n}","new_comment_raw":"@return MColor or null","old_comment_raw":"@return AdempiereColor or null","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":33},{"new_code_raw":"public synchronized VisualItem getItem(String itemClass, Entity entity, boolean create) { ItemEntry entry = (ItemEntry) m_entryMap.get(itemClass); if (entry != null) { VisualItem item = (VisualItem) entry.itemMap.get(entity); if (!create) { return item; } else if (item == null) { item = m_ifactory.getItem(itemClass); item.init(this, itemClass, entity); addItem(entry, entity, item); } if (item instanceof NodeItem) ((NodeItem) item).removeAllNeighbors(); item.setDirty(NUM); item.setVisible(true); return item; } else { throw new IllegalArgumentException(STR + STR); } }","old_code_raw":"public synchronized GraphItem getItem(String itemClass, Entity entity, boolean create) {\n    ItemEntry entry = (ItemEntry) m_entryMap.get(itemClass);\n    if (entry != null) {\n        GraphItem item = (GraphItem) entry.itemMap.get(entity);\n        if (!create) {\n            return item;\n        } else if (item == null) {\n            item = m_ifactory.getItem(itemClass);\n            item.init(this, itemClass, entity);\n            addItem(entry, entity, item);\n        }\n        if (item instanceof NodeItem)\n            ((NodeItem) item).removeAllNeighbors();\n        item.setDirty(NUM);\n        item.setVisible(true);\n        return item;\n    } else {\n        throw new IllegalArgumentException(STR + STR);\n    }\n}","new_comment_raw":"@return the requested VisualItem, or null if the VisualItem wasn't found and the create parameter is false.","old_comment_raw":"@return the requested GraphItem, or null if the GraphItem wasn't found and the create parameter is false.","label":1,"pre_label":0,"AST_level":11,"line_counts":20,"new_code_token_num":134},{"new_code_raw":"public static String normalizeDateString(String s, String ctxdate) { \/\/ TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5 \u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\") \/\/ TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15) \/\/ TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")? Pattern p; Matcher m; String ctxyear = \"XXXX\", ctxmonth = \"XX\", ctxday = \"XX\"; \/\/ set up context date if (ctxdate != null) { p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\"); m = p.matcher(ctxdate); if (m.find() && m.groupCount() == 3) { ctxyear = m.group(1); ctxmonth = m.group(2); ctxday = m.group(3); } } p = Pattern.compile(\"^\" + BIRTH_DECADE_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear, true).substring(0, 3) + \"X\"); res.append(\"-XX-XX\"); return res.toString(); } p = Pattern.compile(\"^\" + RELATIVE_TIME_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(ctxmonth); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); res.append(normalizeYear(m.group(1), ctxyear)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(3), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 2) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 1) { StringBuilder res = new StringBuilder(); res.append(ctxyear); res.append(\"-\"); res.append(ctxmonth); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxday)); return res.toString(); } p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\"); m = p.matcher(s); if (m.find() && m.groupCount() == 3) { StringBuilder res = new StringBuilder(); if (m.group(3) == null) res.append(ctxyear); else res.append(normalizeYear(m.group(3), ctxyear)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(1), ctxmonth)); res.append(\"-\"); res.append(normalizeMonthOrDay(m.group(2), ctxday)); return res.toString(); } return s; }","old_code_raw":"  public static String normalizeDateString(String s, Date ctxdate) {\n    \/\/ TODO [pengqi]: need to handle basic localization (\"\u00e5\u009c\u00a8\u00e4\u00b8\u0083\u00e6\u009c\u0088\u00e4\u00ba\u008c\u00e6\u0097\u00a5\u00e5\u0088\u00b0[\u00e5\u0085\u00ab\u00e6\u0097\u00a5]\u00e9\u0097\u00b4\")\n    \/\/ TODO [pengqi]: need to handle literal numeral dates (usually used in events, e.g. \"\u00e4\u00b8\u0089\u00e4\u00b8\u0080\u00e4\u00ba\u0094\" for 03-15)\n    \/\/ TODO [pengqi]: might need to add a pattern for centuries (\"\u00e4\u00b8\u008a\u00e4\u00b8\u0096\u00e7\u00ba\u00aa90\u00e5\u00b9\u00b4\u00e4\u00bb\u00a3\")?\n    String ctxyear = new SimpleDateFormat(\"yyyy\").format(ctxdate);\n    String ctxmonth = new SimpleDateFormat(\"MM\").format(ctxdate);\n    String ctxday = new SimpleDateFormat(\"dd\").format(ctxdate);\n\n    Pattern p = Pattern.compile(\"^\" + BASIC_YYYYMMDD_PATTERN + \"$\");\n    Matcher m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(normalizeYear(m.group(1), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(3), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_MMDD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 2) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + BASIC_DD_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 1) {\n      StringBuilder res = new StringBuilder();\n\n      res.append(ctxyear);\n      res.append(\"-\");\n      res.append(ctxmonth);\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxday));\n\n      return res.toString();\n    }\n\n    p = Pattern.compile(\"^\" + ENGLISH_MMDDYYYY_PATTERN + \"$\");\n    m = p.matcher(s);\n\n    if (m.find() && m.groupCount() == 3) {\n      StringBuilder res = new StringBuilder();\n\n      if (m.group(3) == null)\n        res.append(ctxyear);\n      else\n        res.append(normalizeYear(m.group(3), ctxyear));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(1), ctxmonth));\n      res.append(\"-\");\n      res.append(normalizeMonthOrDay(m.group(2), ctxday));\n\n      return res.toString();\n    }\n\n    return s;\n  }\n","new_comment_raw":"@return Normalized Timex expression of the input date string","old_comment_raw":"@return Normalized Timex expression of the input date string","label":0,"pre_label":1,"AST_level":10,"line_counts":114,"new_code_token_num":813},{"new_code_raw":"private int measureHeight(int measureSpec) { float result = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) { \/\/We were told how big to be result = specSize; } else { \/\/Calculate the text bounds Rect bounds = new Rect(); bounds.bottom = (int) (mPaintText.descent()-mPaintText.ascent()); result = bounds.bottom - bounds.top + mFooterLineHeight; if (mFooterIndicatorStyle != IndicatorStyle.None) { result += mFooterIndicatorHeight + mFooterIndicatorPadding; } } return (int)result; }","old_code_raw":"    private int measureHeight(int measureSpec) {\n        int result = 0;\n        int specMode = MeasureSpec.getMode(measureSpec);\n        int specSize = MeasureSpec.getSize(measureSpec);\n\n        if (specMode == MeasureSpec.EXACTLY) {\n            \/\/We were told how big to be\n            result = specSize;\n        } else {\n            \/\/Calculate the text bounds\n            Rect bounds = new Rect();\n            bounds.bottom = (int) (mPaintText.descent()-mPaintText.ascent());\n            result = bounds.bottom - bounds.top + (int)mFooterLineHeight;\n            if (mFooterIndicatorStyle != IndicatorStyle.None) {\n                result += (int)mFooterIndicatorHeight;\n            }\n        }\n        return result;\n    }\n","new_comment_raw":"@return The height of the view, honoring constraints from measureSpec","old_comment_raw":"@return The height of the view, honoring constraints from measureSpec","label":0,"pre_label":1,"AST_level":10,"line_counts":20,"new_code_token_num":112},{"new_code_raw":"private boolean onTouchForwarded(MotionEvent srcEvent) { final View src = mSrcIcon; final DeepShortcutsContainer dst = mLauncher.getOpenShortcutsContainer(); if (dst == null) { return false; } if (!dst.isLaidOut()) { return true; } \/\/ Convert event to destination-local coordinates. final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent); Utilities.translateEventCoordinates(src, dst, dstEvent); \/\/ Convert touch down event to destination-local coordinates. if (!mHasMappedTouchDownToContainerCoord) { mDragLayer.mapCoordInSelfToDescendent(dst, mTouchDown); mHasMappedTouchDownToContainerCoord = true; } \/\/ Forward converted event to destination view, then recycle it. final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId, mTouchDown); dstEvent.recycle(); \/\/ Always cancel forwarding when the touch stream ends. final int action = srcEvent.getActionMasked(); final boolean keepForwarding = action != MotionEvent.ACTION_UP && action != MotionEvent.ACTION_CANCEL; return handled && keepForwarding; }","old_code_raw":"    private boolean onTouchForwarded(MotionEvent srcEvent) {\n        final View src = mSrcIcon;\n\n        final DeepShortcutsContainer dst = mLauncher.getOpenShortcutsContainer();\n        if (dst == null) {\n            return false;\n        }\n\n        \/\/ Convert event to destination-local coordinates.\n        final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);\n        Utilities.translateEventCoordinates(src, dst, dstEvent);\n\n        \/\/ Forward converted event to destination view, then recycle it.\n        \/\/ TODO: don't create objects in onForwardedEvent.\n        final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId, mTouchDown);\n        dstEvent.recycle();\n\n        \/\/ Always cancel forwarding when the touch stream ends.\n        final int action = srcEvent.getActionMasked();\n        final boolean keepForwarding = action != MotionEvent.ACTION_UP\n                && action != MotionEvent.ACTION_CANCEL;\n\n        return handled && keepForwarding;\n    }\n","new_comment_raw":"@return true to continue forwarding motion events, false to cancel","old_comment_raw":"@return true to continue forwarding motion events, false to cancel","label":0,"pre_label":1,"AST_level":7,"line_counts":33,"new_code_token_num":170},{"new_code_raw":"public boolean waitForText(String text, int minimumNumberOfMatches, long timeout, boolean scroll) { return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout, scroll); }","old_code_raw":"public boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout, boolean scroll) {\n    return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout, scroll);\n}","new_comment_raw":"@return {@code true} if text is shown and {@code false} if it is not shown before the timeout","old_comment_raw":"@return {@code true} if text is found and {@code false} if it is not found before the timeout","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":31},{"new_code_raw":"public Period withField(DurationFieldType field, int value) { if (field == null) { throw new IllegalArgumentException(\"Field must not be null\"); } int[] newValues = getValues(); \/\/ cloned super.setFieldInto(newValues, field, value); return new Period(newValues, getPeriodType()); }","old_code_raw":"    public Period withField(DurationFieldType field, int value) {\n        if (field == null) {\n            return this;\n        }\n        int[] newValues = getValues();  \/\/ cloned\n        super.setFieldInto(newValues, field, value);\n        return new Period(newValues, getPeriodType());\n    }\n","new_comment_raw":"@return the new period instance","old_comment_raw":"@return the new period instance","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":64},{"new_code_raw":"public Actions moveByOffset(int xOffset, int yOffset) { if (isBuildingActions()) { action.addAction(new MoveToOffsetAction(jsonMouse, null, xOffset, yOffset)); } return tick( defaultMouse.createPointerMove(Duration.ofMillis(200), Origin.pointer(), xOffset, yOffset)); }","old_code_raw":"  public Actions moveByOffset(int xOffset, int yOffset) {\n    if (isBuildingActions()) {\n      action.addAction(new MoveToOffsetAction(jsonMouse, null, xOffset, yOffset));\n    }\n\n    return tick(\n        defaultMouse.createPointerMove(Duration.ofMillis(200), null, xOffset, yOffset));\n  }\n","new_comment_raw":"@return A self reference.","old_comment_raw":"@return A self reference.","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":59},{"new_code_raw":"public static int[] getHeaderToViewPosition(JTextArea view, String header, int start, int end) { validateView(view); validateHeader(header); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, header.length())) { return INVALID_POSITION; } int excessChars = 0; int pos = 0; while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1 && pos < start) { pos += 2; ++excessChars; } int len = view.getDocument().getLength(); int finalStartPos = start - excessChars; if (finalStartPos > len) { return INVALID_POSITION; } if (pos != -1) { while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1 && pos < end) { pos += 2; ++excessChars; } } int finalEndPos = end - excessChars; if (finalEndPos > len) { return INVALID_POSITION; } return new int[] { finalStartPos, finalEndPos }; }","old_code_raw":"    public static int[] getHeaderToViewPosition(JTextArea view, String header, int start, int end) {\n        validateView(view);\n        validateHeader(header);\n        validateStartEnd(start, end, header.length());\n\n        int excessChars = 0;\n\n        int pos = 0;\n        while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1 && pos < start) {\n            pos += 2;\n            ++excessChars;\n        }\n\n        int len = view.getDocument().getLength();\n        int finalStartPos = start - excessChars;\n        if (finalStartPos > len) {\n            return INVALID_POSITION;\n        }\n\n        if (pos != -1) {\n            while ((pos = header.indexOf(HttpHeader.CRLF, pos)) != -1 && pos < end) {\n                pos += 2;\n                ++excessChars;\n            }\n        }\n\n        int finalEndPos = end - excessChars;\n        if (finalEndPos > len) {\n            return INVALID_POSITION;\n        }\n\n        return new int[] { finalStartPos, finalEndPos };\n    }\n","new_comment_raw":"@return the positions offset for the  view, or  #INVALID_POSITION if the  start,  end or offset positions are greater than  view's length.","old_comment_raw":"@return the positions offset for the view, or #INVALID_POSITION if the offset positions are greater than view's length.","label":1,"pre_label":0,"AST_level":10,"line_counts":38,"new_code_token_num":190},{"new_code_raw":"public MainWindowBase getSleakWindow() { DeviceData data = new DeviceData(); data.tracking = true; Display display = new Display(data); Sleak sleak = new Sleak(); sleak.open(); Shell shell = new Shell(display); window = new MainWindowBase(shell); return window; }","old_code_raw":"public MainWindow getSleakWindow() {\n    DeviceData data = new DeviceData();\n    data.tracking = true;\n    Display display = new Display(data);\n    Sleak sleak = new Sleak();\n    sleak.open();\n    Shell shell = new Shell(display);\n    window = new MainWindow(shell);\n    return window;\n}","new_comment_raw":"@return The {@link MainWindowBase} monitored by Sleak.java","old_comment_raw":"@return The {@link MainWindow} monitored by Sleak.java","label":1,"pre_label":0,"AST_level":6,"line_counts":10,"new_code_token_num":56},{"new_code_raw":"public String getSelectionHost() { ISelection selection = getSelection(); if (selection instanceof IStructuredSelection && !selection.isEmpty()) { Object element = ((IStructuredSelection) selection).getFirstElement(); IPropertiesAccessService service = ServiceManager.getInstance().getService(element, IPropertiesAccessService.class); if (service != null) { Map<String, String> props = service.getTargetAddress(element); if (props != null && props.containsKey(IPropertiesAccessServiceConstants.PROP_ADDRESS)) { return props.get(IPropertiesAccessServiceConstants.PROP_ADDRESS); } } } return null; }","old_code_raw":"public String getSelectionHost() {\n    ISelection selection = getSelection();\n    final AtomicReference<String> result = new AtomicReference<String>();\n    if (selection instanceof IStructuredSelection && !selection.isEmpty()) {\n        Object element = ((IStructuredSelection) selection).getFirstElement();\n        if (element instanceof IPeerModel) {\n            final IPeerModel peerModel = (IPeerModel) element;\n            if (Protocol.isDispatchThread()) {\n                result.set(peerModel.getPeer().getAttributes().get(IPeer.ATTR_IP_HOST));\n            } else {\n                Protocol.invokeAndWait(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        result.set(peerModel.getPeer().getAttributes().get(IPeer.ATTR_IP_HOST));\n                    }\n                });\n            }\n        }\n    }\n    return result.get();\n}","new_comment_raw":"@return The host name or IP, or <code>null<\/code>.","old_comment_raw":"@return The host name or IP.","label":1,"pre_label":0,"AST_level":11,"line_counts":14,"new_code_token_num":100},{"new_code_raw":"public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) { return hasPatternAt(byteArray, pattern, 0); }","old_code_raw":"  public static boolean startsWithPattern(final byte[] byteArray, final byte[] pattern) {\n    Preconditions.checkNotNull(byteArray);\n    Preconditions.checkNotNull(pattern);\n    if (pattern.length > byteArray.length) {\n      return false;\n    }\n\n    for (int i = 0; i < pattern.length; ++i) {\n      if (byteArray[i] != pattern[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n","new_comment_raw":"@return true if byteArray starts with pattern","old_comment_raw":"@return true if byteArray starts with pattern","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":29},{"new_code_raw":"public int getDrawQueue() { return drawQueueType; }","old_code_raw":"public DrawQueue getDrawQueue() {\n    return drawQueue;\n}","new_comment_raw":"@return the current draw queue type for this Layer","old_comment_raw":"@return the current DrawQueue object for this Scene","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 6: { return getEllipsis(); } case 8: break; case 4: { return getNext(false); } case 9: break; case 7: { if ( ! removeProMarker) { return getNext(false); } } case 10: break; case 2: { return getNewline(); } case 11: break; case 5: { return getNext(true); } case 12: break; case 3: { } case 13: break; case 1: { System.err.printf(\"Untokenizable: %s%n\", yytext()); return getNext(true); } case 14: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { System.err.printf(\"Untokenizable: %s%n\", yytext());\n\t      return getNext(true);\n          }\n        case 9: break;\n        case 2: \n          { if (tokenizeNLs) {\n                return getNext(NEWLINE_TOKEN, yytext());\n              }\n          }\n        case 10: break;\n        case 3: \n          { \n          }\n        case 11: break;\n        case 4: \n          { return getNext(false);\n          }\n        case 12: break;\n        case 5: \n          { return getNext(true);\n          }\n        case 13: break;\n        case 6: \n          { return getEllipsis();\n          }\n        case 14: break;\n        case 7: \n          { if (! removeProMarker) return getNext(false);\n          }\n        case 15: break;\n        case 8: \n          { if (removeProMarker) {\n                if ( ! removeSegMarker) {\n                  return getNext(\"-\", yytext());\n                }\n              } else {\n                return getNext(false);\n              }\n          }\n        case 16: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":115,"new_code_token_num":431},{"new_code_raw":"public int hashCode() { \/\/ must be to fulfil ReadableInstant contract return ((int) (getMillis() ^ (getMillis() >>> 32))) + (getChronology().hashCode()); }","old_code_raw":"    public int hashCode() {\n        \/\/ must be to fulfil ReadableInstant contract\n        return\n            ((int) (getMillis() ^ (getMillis() >>> 32))) +\n            (getChronology() == null ? 0 : getChronology().hashCode());\n    }\n","new_comment_raw":"@return a suitable hash code","old_comment_raw":"@return a suitable hash code","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":43},{"new_code_raw":"public ArrayList<TextView> clickInList(int line, int index) { line--; if(line < 0) line = 0; boolean foundList = waiter.waitForView(ListView.class, index); if (!foundList) Assert.assertTrue(\"No ListView with index \" + index + \" is available!\", false); ArrayList<View> views = new ArrayList<View>(); final ListView listView = viewFetcher.getView(ListView.class, null, index); if(listView == null) Assert.assertTrue(\"ListView is null!\", false); View view = listView.getChildAt(line); if(view != null){ views = viewFetcher.getViews(view, true); views = RobotiumUtils.removeInvisibleViews(views); clickOnScreen(getClickableView(views)); } return RobotiumUtils.filterViews(TextView.class, views); }","old_code_raw":"\tpublic ArrayList<TextView> clickInList(int line, int index) {\t\n\t\tif(line < 1)\n\t\t\tline = 1;\n\n\t\tboolean foundList = waiter.waitForView(ListView.class, index);\n\n\t\tif (!foundList) {\n\t\t\tAssert.assertTrue(\"No ListView with index \" + index + \" is available!\", false);\n\t\t}\n\n\t\tArrayList<TextView> textViews = null;\n\t\tfinal ListView listView = viewFetcher.getView(ListView.class, null, index);\n\t\tif(listView == null)\n\t\t\tAssert.assertTrue(\"ListView is null!\", false);\n\n\t\ttextViews = viewFetcher.getCurrentViews(TextView.class, listView);\n\t\ttextViews = RobotiumUtils.removeInvisibleViews(textViews);\n\n\t\tArrayList<TextView> textViewGroup = new ArrayList<TextView>();\n\t\tint myLine = 0;\n\t\tif(textViews !=null ){\n\t\t\tfor (int i = 0; i < textViews.size(); i++) {\n\t\t\t\tView view = viewFetcher.getListItemParent(textViews.get(i));\n\t\t\t\ttry {\n\t\t\t\t\tif (view.equals(viewFetcher.getListItemParent(textViews.get(i + 1)))) {\n\t\t\t\t\t\ttextViewGroup.add(textViews.get(i));\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextViewGroup.add(textViews.get(i));\n\t\t\t\t\t\tmyLine++;\n\t\t\t\t\t\tif (myLine == line)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttextViewGroup.clear();\n\t\t\t\t\t}\n\t\t\t\t} catch (IndexOutOfBoundsException e) {textViewGroup.add(textViews.get(i));}\n\t\t\t}\n\t\t}\n\t\tif (textViewGroup.size() != 0){\n\t\t\tclickOnScreen(textViewGroup.get(textViewGroup.size()-1));\n\t\t}\n\t\treturn textViewGroup;\n\t}\n","new_comment_raw":"@return an  ArrayList of the  TextViews located in the list line","old_comment_raw":"@return an ArrayList of the TextViews located in the list line","label":0,"pre_label":1,"AST_level":8,"line_counts":23,"new_code_token_num":153},{"new_code_raw":"private Bitmap getWidgetPreview(AppWidgetProviderInfo info) { final PackageManager packageManager = mPackageManager; String packageName = info.provider.getPackageName(); Drawable drawable = null; if (info.previewImage != 0) { drawable = packageManager.getDrawable(packageName, info.previewImage, null); if (drawable == null) { Log.w(TAG, \"Can't load icon drawable 0x\" + Integer.toHexString(info.icon) + \" for provider: \" + info.provider); } } \/\/ If we don't have a preview image, create a default one if (drawable == null) { Resources resources = mLauncher.getResources(); \/\/ Create a new bitmap to hold the widget preview int width = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minWidth)) * sScaleFactor); int height = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, info.minHeight)) * sScaleFactor); final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); final Drawable background = resources.getDrawable(R.drawable.default_widget_preview); renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f); \/\/ Draw the icon flush left try { Drawable icon = null; if (info.icon > 0) { icon = packageManager.getDrawable(packageName, info.icon, null); } if (icon == null) { icon = resources.getDrawable(R.drawable.ic_launcher_application); } final int iconSize = mMinWidgetPreviewDim \/ 2; final int offset = iconSize \/ 4; renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f); } catch (Resources.NotFoundException e) { \/\/ if we can't find the icon, then just don't draw it } return bitmap; } else { \/\/ Scale down the preview if necessary final float imageWidth = drawable.getIntrinsicWidth(); final float imageHeight = drawable.getIntrinsicHeight(); final float aspect = (float) imageWidth \/ imageHeight; final int scaledWidth = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageWidth)) * sScaleFactor); final int scaledHeight = (int) (Math.max(mMinWidgetPreviewDim, Math.min(mMaxWidgetPreviewDim, imageHeight)) * sScaleFactor); int width; int height; if (aspect >= 1.0f) { width = scaledWidth; height = (int) (((float) scaledWidth \/ imageWidth) * imageHeight); } else { height = scaledHeight; width = (int) (((float) scaledHeight \/ imageHeight) * imageWidth); } final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888); renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f); return bitmap; } }","old_code_raw":"    private FastBitmapDrawable getWidgetPreview(AppWidgetProviderInfo info) {\n        final PackageManager packageManager = mPackageManager;\n        String packageName = info.provider.getPackageName();\n        Drawable drawable = null;\n        FastBitmapDrawable newDrawable = null;\n        if (info.previewImage != 0) {\n            drawable = packageManager.getDrawable(packageName, info.previewImage, null);\n            if (drawable == null) {\n                Log.w(TAG, \"Can't load icon drawable 0x\" + Integer.toHexString(info.icon)\n                        + \" for provider: \" + info.provider);\n            }\n        }\n\n        \/\/ If we don't have a preview image, create a default one\n        final int minDim = mWorkspaceWidgetLayout.estimateCellWidth(1);\n        final int maxDim = mWorkspaceWidgetLayout.estimateCellWidth(3);\n        if (drawable == null) {\n            Resources resources = mLauncher.getResources();\n\n            \/\/ Create a new bitmap to hold the widget preview\n            int width = (int) (Math.max(minDim, Math.min(maxDim, info.minWidth)) * sScaleFactor);\n            int height = (int) (Math.max(minDim, Math.min(maxDim, info.minHeight)) * sScaleFactor);\n            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n            final Drawable background = resources.getDrawable(R.drawable.default_widget_preview);\n            renderDrawableToBitmap(background, bitmap, 0, 0, width, height, 1.0f, 1.0f);\n\n            \/\/ Draw the icon flush left\n            try {\n                Drawable icon = null;\n                if (info.icon > 0) {\n                    icon = packageManager.getDrawable(packageName, info.icon, null);\n                }\n                if (icon == null) {\n                    icon = resources.getDrawable(R.drawable.ic_launcher_application);\n                }\n\n                final int iconSize = minDim \/ 2;\n                final int offset = iconSize \/ 4;\n                renderDrawableToBitmap(icon, null, offset, offset, iconSize, iconSize, 1.0f, 1.0f);\n            } catch (Resources.NotFoundException e) {\n                \/\/ if we can't find the icon, then just don't draw it\n            }\n\n            newDrawable = new FastBitmapDrawable(bitmap);\n        } else {\n            \/\/ Scale down the preview if necessary\n            final float imageWidth = drawable.getIntrinsicWidth();\n            final float imageHeight = drawable.getIntrinsicHeight();\n            final float aspect = (float) imageWidth \/ imageHeight;\n            final int scaledWidth =\n                (int) (Math.max(minDim, Math.min(maxDim, imageWidth)) * sScaleFactor);\n            final int scaledHeight =\n                (int) (Math.max(minDim, Math.min(maxDim, imageHeight)) * sScaleFactor);\n            int width;\n            int height;\n            if (aspect >= 1.0f) {\n                width = scaledWidth;\n                height = (int) (((float) scaledWidth \/ imageWidth) * imageHeight);\n            } else {\n                height = scaledHeight;\n                width = (int) (((float) scaledHeight \/ imageHeight) * imageWidth);\n            }\n\n            final Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);\n            renderDrawableToBitmap(drawable, bitmap, 0, 0, width, height, 1.0f, 1.0f);\n\n            newDrawable = new FastBitmapDrawable(bitmap);\n        }\n        newDrawable.setBounds(0, 0, newDrawable.getIntrinsicWidth(),\n                newDrawable.getIntrinsicHeight());\n        return newDrawable;\n    }\n","new_comment_raw":"@return the Bitmap that will be wrapped in a FastBitmapDrawable and used and sized in the ImageView to represent the widget","old_comment_raw":"@return the drawable that will be used and sized in the ImageView to represent the widget","label":1,"pre_label":0,"AST_level":13,"line_counts":69,"new_code_token_num":515},{"new_code_raw":"@Deprecated public Command getCommand() { Command rtnVal; if (command == null) { rtnVal = null; } else if (command instanceof Command) { rtnVal = (Command) command; } else { rtnVal = new Command() { @Override public void execute() { if (command != null) { command.execute(); } } }; } return rtnVal; }","old_code_raw":"public Command getCommand() {\n    return command;\n}","new_comment_raw":"@return the command","old_comment_raw":"@return this item's command, or <code>null<\/code> if none exists","label":1,"pre_label":0,"AST_level":13,"line_counts":20,"new_code_token_num":73},{"new_code_raw":"public JSONArray names() { JSONArray ja = new JSONArray(); Iterator keys = this.keys(); while (keys.hasNext()) { ja.append(keys.next()); } return ja.size() == 0 ? null : ja; }","old_code_raw":"  public JSONArray names() {\n    JSONArray ja = new JSONArray();\n    Iterator  keys = this.keys();\n    while (keys.hasNext()) {\n      ja.append(keys.next());\n    }\n    return ja.length() == 0 ? null : ja;\n  }\n","new_comment_raw":"@return A JSONArray containing the key strings, or null if the JSONObject is empty.","old_comment_raw":"@return A JSONArray containing the key strings, or null if the JSONObject is empty.","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":50},{"new_code_raw":"public static boolean reinstateAutoIncrement(String colName, String tableId, StringBuffer colDef) throws SQLException { getAutoIncStmt.setString(NUM, dblook.stripQuotes(colName)); getAutoIncStmt.setString(NUM, tableId); ResultSet autoIncCols = getAutoIncStmt.executeQuery(); if (autoIncCols.next()) { long start = autoIncCols.getLong(NUM); if (!autoIncCols.wasNull()) { colDef.append(STR); colDef.append(autoIncCols.getObject(NUM) == null ? STR : STR); colDef.append(STR); colDef.append(autoIncCols.getLong(NUM)); colDef.append(STR); colDef.append(autoIncCols.getLong(NUM)); colDef.append(STR); return true; } } return false; }","old_code_raw":"public static void reinstateAutoIncrement(String colName, String tableId, StringBuffer colDef) throws SQLException {\n    getAutoIncStmt.setString(NUM, dblook.stripQuotes(colName));\n    getAutoIncStmt.setString(NUM, tableId);\n    ResultSet autoIncCols = getAutoIncStmt.executeQuery();\n    if (autoIncCols.next()) {\n        long start = autoIncCols.getLong(NUM);\n        if (!autoIncCols.wasNull()) {\n            colDef.append(STR);\n            colDef.append(autoIncCols.getObject(NUM) == null ? STR : STR);\n            colDef.append(STR);\n            colDef.append(autoIncCols.getLong(NUM));\n            colDef.append(STR);\n            colDef.append(autoIncCols.getLong(NUM));\n            colDef.append(STR);\n        }\n    }\n    return;\n}","new_comment_raw":"@return True if autoincrement DDL has been generated. **","old_comment_raw":"@return The DDL for all autoincrement columns has been written to the received string buffer. **","label":1,"pre_label":0,"AST_level":12,"line_counts":19,"new_code_token_num":137},{"new_code_raw":"public YearMonthDay setCopy(int value) { int[] newValues = iYearMonthDay.getValues(); newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, value); return new YearMonthDay(iYearMonthDay, newValues); }","old_code_raw":"        public YearMonthDay setCopy(int value) {\n            int[] newValues = iInstant.getValues();\n            getField().set(iInstant, iFieldIndex, newValues, value);\n            return new YearMonthDay(iInstant, newValues);\n        }\n","new_comment_raw":"@return a copy of the YearMonthDay with the field value changed","old_comment_raw":"@return a copy of the YearMonthDay with the field value changed","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":42},{"new_code_raw":"static public IStructuredTextExpert getStatefulExpert(String type) { return getStatefulExpert(type, StructuredTextEnvironment.DEFAULT); }","old_code_raw":"static public ISTextExpert getStatefulExpert(String type) {\n    return getStatefulExpert(type, STextEnvironment.DEFAULT);\n}","new_comment_raw":"@return the IStructuredTextExpert instance.","old_comment_raw":"@return the ISTextExpert instance.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public ResponseEntity<Void> addPetWithHttpInfo(Pet body) throws RestClientException { Object postBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling addPet\"); } String path = apiClient.expandPath(\"\/pet\", Collections.<String, Object>emptyMap()); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\", \"application\/xml\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"petstore_auth\" }; ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {}; return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public ResponseEntity<Void> addPetWithHttpInfo(Pet body) throws RestClientException {\n        Object postBody = body;\n        \n        \/\/ verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling addPet\");\n        }\n        \n        String path = apiClient.expandPath(\"\/pet\", Collections.<String, Object>emptyMap());\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\", \"application\/xml\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@return ResponseEntity&lt;Void&gt;","old_comment_raw":"@return ResponseEntity&lt;Void&gt;","label":0,"pre_label":1,"AST_level":8,"line_counts":28,"new_code_token_num":223},{"new_code_raw":"@ApiModelProperty(required = true, value = STR) public String getIn() { return in; }","old_code_raw":"@ApiModelProperty(required = true, value = STR)\npublic InEnum getIn() {\n    return in;\n}","new_comment_raw":"@return String in","old_comment_raw":"@return InEnum in","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public List<List<CoreLabel>> toStatement(List<CoreLabel> question) { TokenSequenceMatcher matcher; if ((matcher = triggerWhatIsThere.matcher(question)).matches()) { \/\/ must come before triggerWhatIs return postProcess(question, processWhatIsThere(matcher)); } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) { \/\/ must come before triggerWhatIs return postProcess(question, processWhNNIs(matcher)); } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) { \/\/ must come before triggerWhatHave return postProcess(question, processWhNNHaveIs(matcher)); } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) { \/\/ must come before triggerWhatHave return postProcess(question, processWhNNHaveNN(matcher)); } else if ((matcher = triggerHow.matcher(question)).matches()) { \/\/ must come before triggerWhatIs return postProcess(question, processHow(matcher)); } else if ((matcher = triggerHowMuchDo.matcher(question)).matches()) { return postProcess(question, processHowMuchDo(matcher)); } else if ((matcher = triggerWhatIs.matcher(question)).matches()) { return postProcess(question, processWhatIs(matcher)); } else if ((matcher = triggerWhatHave.matcher(question)).matches()) { return postProcess(question, processWhatHave(matcher)); } else if ((matcher = triggerWhereDo.matcher(question)).matches()) { return postProcess(question, processWhereDo(matcher, question)); } else if ((matcher = triggerWhereIs.matcher(question)).matches()) { return postProcess(question, processWhereIs(matcher)); } else if ((matcher = triggerWhoIs.matcher(question)).matches()) { return postProcess(question, processWhoIs(matcher)); } else if ((matcher = triggerWhoDid.matcher(question)).matches()) { return postProcess(question, processWhoDid(matcher)); } else if ((matcher = triggerWhatDo.matcher(question)).matches()) { return postProcess(question, processWhatDo(matcher)); } else if ((matcher = triggerWhenDo.matcher(question)).matches()) { return postProcess(question, processWhenDo(matcher)); } else { return Collections.emptyList(); } }","old_code_raw":"  public List<List<CoreLabel>> toStatement(List<CoreLabel> question) {\n    TokenSequenceMatcher matcher;\n    if ((matcher = triggerWhatIsThere.matcher(question)).matches()) {  \/\/ must come before triggerWhatIs\n      return postProcess(question, processWhatIsThere(matcher));\n    } else if ((matcher = triggerWhNNIs.matcher(question)).matches()) {  \/\/ must come before triggerWhatIs\n      return postProcess(question, processWhNNIs(matcher));\n    } else if ((matcher = triggerWhNNHave.matcher(question)).matches()) {  \/\/ must come before triggerWhatHave\n      return postProcess(question, processWhNNHaveIs(matcher));\n    } else if ((matcher = triggerWhNNHaveNN.matcher(question)).matches()) {  \/\/ must come before triggerWhatHave\n      return postProcess(question, processWhNNHaveNN(matcher));\n    } else if ((matcher = triggerWhatIs.matcher(question)).matches()) {\n      return postProcess(question, processWhatIs(matcher));\n    } else if ((matcher = triggerWhatHave.matcher(question)).matches()) {\n      return postProcess(question, processWhatHave(matcher));\n    } else if ((matcher = triggerWhereDo.matcher(question)).matches()) {\n      return postProcess(question, processWhereDo(matcher, question));\n    } else if ((matcher = triggerWhereIs.matcher(question)).matches()) {\n      return postProcess(question, processWhereIs(matcher));\n    } else if ((matcher = triggerWhoIs.matcher(question)).matches()) {\n      return postProcess(question, processWhoIs(matcher));\n    } else if ((matcher = triggerWhoDid.matcher(question)).matches()) {\n      return postProcess(question, processWhoDid(matcher));\n    } else if ((matcher = triggerWhatDo.matcher(question)).matches()) {\n      return postProcess(question, processWhatDo(matcher));\n    } else if ((matcher = triggerWhenDo.matcher(question)).matches()) {\n      return postProcess(question, processWhenDo(matcher));\n    } else if ((matcher = triggerHow.matcher(question)).matches()) {\n      return postProcess(question, processHow(matcher));\n    } else {\n      return Collections.emptyList();\n    }\n  }\n","new_comment_raw":"@return A list of statement translations of the question. This is usually a singleton list.","old_comment_raw":"@return A list of statement translations of the question. This is usually a singleton list.","label":0,"pre_label":1,"AST_level":21,"line_counts":35,"new_code_token_num":447},{"new_code_raw":"static Object wrapArgumentForScriptExecution(Object argument) { JSONObject wrappedArgument = new JSONObject(); try { if (argument instanceof String) { wrappedArgument.put(\"type\", \"STRING\"); wrappedArgument.put(\"value\", argument); } else if (argument instanceof Boolean) { wrappedArgument.put(\"type\", \"BOOLEAN\"); wrappedArgument.put(\"value\", argument); } else if (argument instanceof Number) { wrappedArgument.put(\"type\", \"NUMBER\"); wrappedArgument.put(\"value\", argument); } else if (argument instanceof ChromeWebElement) { wrappedArgument.put(\"type\", \"ELEMENT\"); wrappedArgument.put(\"value\", ((ChromeWebElement)argument).getElementId()); } else if (argument instanceof Collection<?>) { JSONArray array = new JSONArray(); for (Object o : (Collection<?>)argument) { array.put(wrapArgumentForScriptExecution(o)); } return array; } else { throw new IllegalArgumentException(\"Could not wrap up \" + \"javascript parameter \" + argument + \"(class: \" + argument.getClass() + \")\"); } } catch (JSONException e) { throw new WebDriverException(e); } return wrappedArgument; }","old_code_raw":"    static JSONObject wrapArgumentForScriptExecution(Object argument) {\n      JSONObject wrappedArgument = new JSONObject();\n      try {\n        if (argument instanceof String) {\n          wrappedArgument.put(\"type\", \"STRING\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof Boolean) {\n          wrappedArgument.put(\"type\", \"BOOLEAN\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof Number) {\n          wrappedArgument.put(\"type\", \"NUMBER\");\n          wrappedArgument.put(\"value\", argument);\n        } else if (argument instanceof ChromeWebElement) {\n          wrappedArgument.put(\"type\", \"ELEMENT\");\n          wrappedArgument.put(\"value\", ((ChromeWebElement)argument).getElementId());\n        } else {\n          throw new IllegalArgumentException(\"Could not wrap up \" +\n                \"javascript parameter \" + argument +\n                \"(class: \" + argument.getClass() + \")\");\n        }\n      } catch (JSONException e) {\n        throw new WebDriverException(e);\n      }\n      return wrappedArgument;\n    }\n","new_comment_raw":"@return wrapped up value TODO(danielwh): See if JSONObject and JSONArray have a useful common superclass","old_comment_raw":"@return wrapped up value","label":1,"pre_label":0,"AST_level":17,"line_counts":32,"new_code_token_num":246},{"new_code_raw":"private IterOutcome produceOutputBatch() { boolean isLeftProcessed = false; \/\/ Try to fully pack the outgoing container while (!isOutgoingBatchFull()) { final int previousOutputCount = outputIndex; \/\/ invoke the runtime generated method to emit records in the output batch for each leftJoinIndex crossJoinAndOutputRecords(); \/\/ We have produced some records in outgoing container, hence there must be a match found for left record if (outputIndex > previousOutputCount) { \/\/ Need this extra flag since there can be left join case where for current leftJoinIndex it receives a right \/\/ batch with data, then an empty batch and again another empty batch with EMIT outcome. If we just use \/\/ outputIndex then we will loose the information that few rows for leftJoinIndex is already produced using \/\/ first right batch matchedRecordFound = true; } \/\/ One right batch might span across multiple output batch. So rightIndex will be moving sum of all the \/\/ output records for this record batch until it's fully consumed. \/\/ \/\/ Also it can be so that one output batch can contain records from 2 different right batch hence the \/\/ rightJoinIndex should move by number of records in output batch for current right batch only. rightJoinIndex += outputIndex - previousOutputCount; final boolean isRightProcessed = rightJoinIndex == -1 || rightJoinIndex >= right.getRecordCount(); \/\/ Check if above join to produce output was based on empty right batch or \/\/ it resulted in right side batch to be fully consumed. In this scenario only if rightUpstream \/\/ is EMIT then increase the leftJoinIndex. \/\/ Otherwise it means for the given right batch there is still some record left to be processed. if (isRightProcessed) { if (rightUpstream == EMIT) { if (!matchedRecordFound && JoinRelType.LEFT == popConfig.getJoinType()) { \/\/ copy left side in case of LEFT join emitLeft(leftJoinIndex, outputIndex, 1); ++outputIndex; } ++leftJoinIndex; \/\/ Reset matchedRecord for next left index record matchedRecordFound = false; } \/\/ Release vectors of right batch. This will happen for both rightUpstream = EMIT\/OK VectorAccessibleUtilities.clear(right); rightJoinIndex = -1; } \/\/ Check if previous left record was last one, then set leftJoinIndex to -1 isLeftProcessed = leftJoinIndex >= left.getRecordCount(); if (isLeftProcessed) { leftJoinIndex = -1; VectorAccessibleUtilities.clear(left); } \/\/ Check if output batch still has some space if (!isOutgoingBatchFull()) { \/\/ Check if left side still has records or not if (isLeftProcessed) { \/\/ The current left batch was with EMIT\/OK_NEW_SCHEMA outcome, then return output to downstream layer before \/\/ getting next batch if (leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) { break; } else { logger.debug(\"Output batch still has some space left, getting new batches from left and right\"); \/\/ Get both left batch and the right batch and make sure indexes are properly set leftUpstream = processLeftBatch(); \/\/ output batch is not empty and we have new left batch with OK_NEW_SCHEMA or terminal outcome if (processLeftBatchInFuture) { logger.debug(\"Received left batch with outcome {} such that we have to return the current outgoing \" + \"batch and process the new batch in subsequent next call\", leftUpstream); \/\/ We should return the current output batch with OK outcome and don't reset the leftUpstream finalizeOutputContainer(); return OK; } \/\/ If left batch received a terminal outcome then don't call right batch if (isTerminalOutcome(leftUpstream)) { finalizeOutputContainer(); return leftUpstream; } \/\/ If we have received the left batch with EMIT outcome and is empty then we should return previous output \/\/ batch with EMIT outcome if ((leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) && left.getRecordCount() == 0) { isLeftProcessed = true; break; } \/\/ Update the batch memory manager to use new left incoming batch updateMemoryManager(LEFT_INDEX); } } \/\/ If we are here it means one of the below: \/\/ 1) Either previous left batch was not fully processed and it came with OK outcome. There is still some space \/\/ left in outgoing batch so let's get next right batch. \/\/ 2) OR previous left & right batch was fully processed and it came with OK outcome. There is space in outgoing \/\/ batch. Now we have got new left batch with OK outcome. Let's get next right batch \/\/ 3) OR previous left & right batch was fully processed and left came with OK outcome. Outgoing batch is \/\/ empty since all right batches were empty for all left rows. Now we got another non-empty left batch with \/\/ OK_NEW_SCHEMA. rightUpstream = processRightBatch(); if (rightUpstream == OK_NEW_SCHEMA) { leftUpstream = (leftUpstream != EMIT) ? OK : leftUpstream; rightUpstream = OK; finalizeOutputContainer(); return OK_NEW_SCHEMA; } if (isTerminalOutcome(rightUpstream)) { finalizeOutputContainer(); return rightUpstream; } \/\/ Update the batch memory manager to use new right incoming batch updateMemoryManager(RIGHT_INDEX); \/\/ If OK_NEW_SCHEMA is seen only on non empty left batch but not on right batch, then we should setup schema in \/\/ output container based on new left schema and old right schema. If schema change failed then return STOP \/\/ downstream if (leftUpstream == OK_NEW_SCHEMA && isLeftProcessed) { if (!handleSchemaChange()) { return STOP; } \/\/ Since schema has change so we have new empty vectors in output container hence allocateMemory for them allocateVectors(); } } } \/\/ output batch is full to its max capacity finalizeOutputContainer(); \/\/ Check if output batch was full and left was fully consumed or not. Since if left is not consumed entirely \/\/ but output batch is full, then if the left batch came with EMIT outcome we should send this output batch along \/\/ with OK outcome not with EMIT. Whereas if output is full and left is also fully consumed then we should send \/\/ EMIT outcome. if (leftUpstream == EMIT && isLeftProcessed) { logger.debug(\"Sending current output batch with EMIT outcome since left is received with EMIT and is fully \" + \"consumed in output batch\"); return EMIT; } if (leftUpstream == OK_NEW_SCHEMA) { \/\/ return output batch with OK_NEW_SCHEMA and reset the state to OK logger.debug(\"Sending current output batch with OK_NEW_SCHEMA and resetting the left outcome to OK for next set\" + \" of batches\"); leftUpstream = OK; return OK_NEW_SCHEMA; } return OK; }","old_code_raw":"  private IterOutcome produceOutputBatch() {\n\n    boolean isLeftProcessed = false;\n\n    \/\/ Try to fully pack the outgoing container\n    while (!isOutgoingBatchFull()) {\n      final int previousOutputCount = outputIndex;\n      \/\/ invoke the runtime generated method to emit records in the output batch for each leftJoinIndex\n      crossJoinAndOutputRecords();\n\n      \/\/ We have produced some records in outgoing container, hence there must be a match found for left record\n      if (outputIndex > previousOutputCount) {\n        \/\/ Need this extra flag since there can be left join case where for current leftJoinIndex it receives a right\n        \/\/ batch with data, then an empty batch and again another empty batch with EMIT outcome. If we just use\n        \/\/ outputIndex then we will loose the information that few rows for leftJoinIndex is already produced using\n        \/\/ first right batch\n        matchedRecordFound = true;\n      }\n\n      \/\/ One right batch might span across multiple output batch. So rightIndex will be moving sum of all the\n      \/\/ output records for this record batch until it's fully consumed.\n      \/\/\n      \/\/ Also it can be so that one output batch can contain records from 2 different right batch hence the\n      \/\/ rightJoinIndex should move by number of records in output batch for current right batch only.\n      rightJoinIndex += outputIndex - previousOutputCount;\n      final boolean isRightProcessed = rightJoinIndex == -1 || rightJoinIndex >= right.getRecordCount();\n\n      \/\/ Check if above join to produce output was based on empty right batch or\n      \/\/ it resulted in right side batch to be fully consumed. In this scenario only if rightUpstream\n      \/\/ is EMIT then increase the leftJoinIndex.\n      \/\/ Otherwise it means for the given right batch there is still some record left to be processed.\n      if (isRightProcessed) {\n        if (rightUpstream == EMIT) {\n          if (!matchedRecordFound && JoinRelType.LEFT == popConfig.getJoinType()) {\n            \/\/ copy left side in case of LEFT join\n            emitLeft(leftJoinIndex, outputIndex, 1);\n            ++outputIndex;\n          }\n          ++leftJoinIndex;\n          \/\/ Reset matchedRecord for next left index record\n          matchedRecordFound = false;\n        }\n\n        \/\/ Release vectors of right batch. This will happen for both rightUpstream = EMIT\/OK\n        VectorAccessibleUtilities.clear(right);\n        rightJoinIndex = -1;\n      }\n\n      \/\/ Check if previous left record was last one, then set leftJoinIndex to -1\n      isLeftProcessed = leftJoinIndex >= left.getRecordCount();\n      if (isLeftProcessed) {\n        leftJoinIndex = -1;\n        VectorAccessibleUtilities.clear(left);\n      }\n\n      \/\/ Check if output batch still has some space\n      if (!isOutgoingBatchFull()) {\n        \/\/ Check if left side still has records or not\n        if (isLeftProcessed) {\n          \/\/ The current left batch was with EMIT\/OK_NEW_SCHEMA outcome, then return output to downstream layer before\n          \/\/ getting next batch\n          if (leftUpstream == EMIT || leftUpstream == OK_NEW_SCHEMA) {\n            break;\n          } else {\n            logger.debug(\"Output batch still has some space left, getting new batches from left and right\");\n            \/\/ Get both left batch and the right batch and make sure indexes are properly set\n            leftUpstream = processLeftBatch();\n\n            if (processLeftBatchInFuture) {\n              logger.debug(\"Received left batch with outcome {} such that we have to return the current outgoing \" +\n                \"batch and process the new batch in subsequent next call\", leftUpstream);\n              \/\/ We should return the current output batch with OK outcome and don't reset the leftUpstream\n              finalizeOutputContainer();\n              return OK;\n            }\n\n            \/\/ If left batch received a terminal outcome then don't call right batch\n            if (isTerminalOutcome(leftUpstream)) {\n              finalizeOutputContainer();\n              return leftUpstream;\n            }\n\n            \/\/ If we have received the left batch with EMIT outcome and is empty then we should return previous output\n            \/\/ batch with EMIT outcome\n            if (leftUpstream == EMIT && left.getRecordCount() == 0) {\n              isLeftProcessed = true;\n              break;\n            }\n\n            \/\/ Update the batch memory manager to use new left incoming batch\n            updateMemoryManager(LEFT_INDEX);\n          }\n        }\n\n        \/\/ If we are here it means one of the below:\n        \/\/ 1) Either previous left batch was not fully processed and it came with OK outcome. There is still some space\n        \/\/ left in outgoing batch so let's get next right batch.\n        \/\/ 2) OR previous left & right batch was fully processed and it came with OK outcome. There is space in outgoing\n        \/\/ batch. Now we have got new left batch with OK outcome. Let's get next right batch\n        \/\/\n        \/\/ It will not hit OK_NEW_SCHEMA since left side have not seen that outcome\n        rightUpstream = processRightBatch();\n        Preconditions.checkState(rightUpstream != OK_NEW_SCHEMA, \"Unexpected schema change in right branch\");\n\n        if (isTerminalOutcome(rightUpstream)) {\n          finalizeOutputContainer();\n          return rightUpstream;\n        }\n\n        \/\/ Update the batch memory manager to use new right incoming batch\n        updateMemoryManager(RIGHT_INDEX);\n      }\n    } \/\/ output batch is full to its max capacity\n\n    finalizeOutputContainer();\n\n    \/\/ Check if output batch was full and left was fully consumed or not. Since if left is not consumed entirely\n    \/\/ but output batch is full, then if the left batch came with EMIT outcome we should send this output batch along\n    \/\/ with OK outcome not with EMIT. Whereas if output is full and left is also fully consumed then we should send\n    \/\/ EMIT outcome.\n    if (leftUpstream == EMIT && isLeftProcessed) {\n      logger.debug(\"Sending current output batch with EMIT outcome since left is received with EMIT and is fully \" +\n        \"consumed in output batch\");\n      return EMIT;\n    }\n\n    if (leftUpstream == OK_NEW_SCHEMA) {\n      \/\/ return output batch with OK_NEW_SCHEMA and reset the state to OK\n      logger.debug(\"Sending current output batch with OK_NEW_SCHEMA and resetting the left outcome to OK for next set\" +\n        \" of batches\");\n      leftUpstream = OK;\n      return OK_NEW_SCHEMA;\n    }\n    return OK;\n  }\n","new_comment_raw":"@return - IterOutcome to be send along with output batch to downstream operator","old_comment_raw":"@return - IterOutcome to be send along with output batch to downstream operator","label":0,"pre_label":1,"AST_level":16,"line_counts":154,"new_code_token_num":1239},{"new_code_raw":"public void uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException { Object postBody = null; \/\/ verify the required parameter 'petId' is set if (petId == null) { VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling uploadFile\", new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\")); } \/\/ create path and map variables String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{format\\\\}\",\"json\").replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> headerParams = new HashMap<String, String>(); \/\/ form params Map<String, String> formParams = new HashMap<String, String>(); String[] contentTypes = { \"multipart\/form-data\" }; String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\"; if (contentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); if (additionalMetadata != null) { localVarBuilder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8); } if (file != null) { localVarBuilder.addBinaryBody(\"file\", file); } HttpEntity httpEntity = localVarBuilder.build(); postBody = httpEntity; } else { \/\/ normal form params formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata)); } String[] authNames = new String[] { \"petstore_auth\" }; try { String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames); if (localVarResponse != null) { return ; } else { return ; } } catch (ApiException ex) { throw ex; } catch (InterruptedException ex) { throw ex; } catch (ExecutionException ex) { if (ex.getCause() instanceof VolleyError) { VolleyError volleyError = (VolleyError)ex.getCause(); if (volleyError.networkResponse != null) { throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage()); } } throw ex; } catch (TimeoutException ex) { throw ex; } }","old_code_raw":"  public ApiResponse uploadFile (Long petId, String additionalMetadata, File file) throws TimeoutException, ExecutionException, InterruptedException, ApiException {\n    Object postBody = null;\n    \/\/ verify the required parameter 'petId' is set\n    if (petId == null) {\n      VolleyError error = new VolleyError(\"Missing the required parameter 'petId' when calling uploadFile\",\n        new ApiException(400, \"Missing the required parameter 'petId' when calling uploadFile\"));\n    }\n\n    \/\/ create path and map variables\n    String path = \"\/pet\/{petId}\/uploadImage\".replaceAll(\"\\\\{\" + \"petId\" + \"\\\\}\", apiInvoker.escapeString(petId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n    String[] contentTypes = {\n      \"multipart\/form-data\"\n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();\n      if (additionalMetadata != null) {\n        localVarBuilder.addTextBody(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata), ApiInvoker.TEXT_PLAIN_UTF8);\n      }\n      if (file != null) {\n        localVarBuilder.addBinaryBody(\"file\", file);\n      }\n      HttpEntity httpEntity = localVarBuilder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      formParams.put(\"additionalMetadata\", ApiInvoker.parameterToString(additionalMetadata));\n    }\n\n    String[] authNames = new String[] { \"petstore_auth\" };\n\n    try {\n      String localVarResponse = apiInvoker.invokeAPI (basePath, path, \"POST\", queryParams, postBody, headerParams, formParams, contentType, authNames);\n      if (localVarResponse != null) {\n         return (ApiResponse) ApiInvoker.deserialize(localVarResponse, \"\", ApiResponse.class);\n      } else {\n         return null;\n      }\n    } catch (ApiException ex) {\n       throw ex;\n    } catch (InterruptedException ex) {\n       throw ex;\n    } catch (ExecutionException ex) {\n      if (ex.getCause() instanceof VolleyError) {\n        VolleyError volleyError = (VolleyError)ex.getCause();\n        if (volleyError.networkResponse != null) {\n          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());\n        }\n      }\n      throw ex;\n    } catch (TimeoutException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@return void","old_comment_raw":"@return ApiResponse","label":1,"pre_label":0,"AST_level":11,"line_counts":64,"new_code_token_num":468},{"new_code_raw":"public BufferedImage getImage() { if (!isReady()) { return null; } long t1 = 0; long t2 = 0; if (asynchronous) { return updater.getImage(); } else { \/\/ get image t1 = System.currentTimeMillis(); BufferedImage image = new WebcamReadImageTask(driver, device).getImage(); t2 = System.currentTimeMillis(); if (image == null) { return null; } \/\/ calculate FPS \/\/ +1 to avoid division by zero fps = (4 * fps + 1000 \/ (t2 - t1 + 1)) \/ 5; \/\/ notify webcam listeners about new image available updater.notifyWebcamImageObtained(this, image); return image; } }","old_code_raw":"\tpublic BufferedImage getImage() {\n\n\t\tif (!isReady()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (asynchronous) {\n\t\t\treturn updater.getImage();\n\t\t} else {\n\n\t\t\t\/\/ get image\n\n\t\t\tlong time = System.currentTimeMillis();\n\t\t\tBufferedImage image = new WebcamReadImageTask(driver, device).getImage();\n\n\t\t\t\/\/ calculate FPS\n\n\t\t\tfps = (4 * fps + 1000 \/ (double) (System.currentTimeMillis() - time)) \/ 5;\n\n\t\t\t\/\/ notify webcam listeners about new image available\n\n\t\t\tupdater.notifyWebcamImageObtained(this, image);\n\n\t\t\treturn image;\n\t\t}\n\t}\n","new_comment_raw":"@return Captured image or null if webcam is closed or disposed by JVM","old_comment_raw":"@return Captured image or null if webcam is closed or disposed by JVM","label":0,"pre_label":1,"AST_level":12,"line_counts":36,"new_code_token_num":133},{"new_code_raw":"protected static Serializable deserializeTimestamp(ByteArrayInputStream inputStream) throws IOException { long epochSecond = inputStream.readLong(4); int nanoSeconds = 0; \/\/ no fractional seconds return ZonedDateTime.ofInstant(Instant.ofEpochSecond(epochSecond, nanoSeconds), ZoneId.systemDefault()); }","old_code_raw":"    protected static Serializable deserializeTimestamp(ByteArrayInputStream inputStream) throws IOException {\n        long epochSecond = inputStream.readLong(4);\n        int nanoSeconds = 0; \/\/ no fractional seconds\n        LocalDateTime localDateTime = LocalDateTime.ofEpochSecond(epochSecond, nanoSeconds, ZoneOffset.UTC);\n        return ZonedDateTime.of(localDateTime, ZoneId.systemDefault());\n    }\n","new_comment_raw":"@return the  OffsetDateTime object","old_comment_raw":"@return the OffsetDateTime object","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":47},{"new_code_raw":"long getFieldValue(ReadablePeriod period) { PeriodType type; if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { type = null; \/\/ Don't need to check if supported. } else { type = period.getPeriodType(); } int value; switch (iFieldType) { default: return Long.MAX_VALUE; case 1: if (type != null && type.years().isSupported() == false) { return Long.MAX_VALUE; } value = period.getYears(); break; case 2: if (type != null && type.months().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMonths(); break; case 3: if (type != null && type.weeks().isSupported() == false) { return Long.MAX_VALUE; } value = period.getWeeks(); break; case 4: if (type != null && type.days().isSupported() == false) { return Long.MAX_VALUE; } value = period.getDays(); break; case 5: if (type != null && type.hours().isSupported() == false) { return Long.MAX_VALUE; } value = period.getHours(); break; case 6: if (type != null && type.minutes().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMinutes(); break; case 7: if (type != null && type.seconds().isSupported() == false) { return Long.MAX_VALUE; } value = period.getSeconds(); break; case 8: if (type != null && type.millis().isSupported() == false) { return Long.MAX_VALUE; } value = period.getMillis(); break; case 9: \/\/ drop through case 10: if (type != null && type.seconds().isSupported() == false && type.millis().isSupported() == false) { return Long.MAX_VALUE; } value = period.getSeconds() * DateTimeConstants.MILLIS_PER_SECOND + period.getMillis(); break; } if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) { return Long.MAX_VALUE; } return value; }","old_code_raw":"        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; \/\/ Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n\n            int value;\n\n            switch (iFieldType) {\n            default:\n                return -1;\n            case 1:\n                if (type != null && type.years().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getYears();\n                break;\n            case 2:\n                if (type != null && type.months().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getMonths();\n                break;\n            case 3:\n                if (type != null && type.weeks().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getWeeks();\n                break;\n            case 4:\n                if (type != null && type.days().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getDays();\n                break;\n            case 5:\n                if (type != null && type.hours().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getHours();\n                break;\n            case 6:\n                if (type != null && type.minutes().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getMinutes();\n                break;\n            case 7:\n                if (type != null && type.seconds().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getSeconds();\n                break;\n            case 8:\n                if (type != null && type.millis().isSupported() == false) {\n                    return -1;\n                }\n                value = period.getMillis();\n                break;\n            }\n\n            if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) {\n                return -1;\n            }\n\n            return value & 0xffffffffL;\n        }\n","new_comment_raw":"@return Long.MAX_VALUE if nothing to print, otherwise value","old_comment_raw":"@return negative value if nothing to print, otherwise lower 32 bits is signed int value.","label":1,"pre_label":0,"AST_level":10,"line_counts":77,"new_code_token_num":395},{"new_code_raw":"public final Image[] getPendingImages() { return pendingImages != null ? Arrays.copyOf(pendingImages, pendingImages.length) : new Image[NUM]; }","old_code_raw":"public final Image[] getPendingImages() {\n    return pendingImages != null ? Arrays.copyOf(pendingImages, pendingImages.length) : null;\n}","new_comment_raw":"@return A image list.","old_comment_raw":"@return A image list or <code>null<\/code>.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":30},{"new_code_raw":"private int externalToInternalRow(int extRow) { if (extRow < -mActiveTranscriptRows || extRow > mScreenRows) { String errorMessage = \"externalToInternalRow \"+ extRow + \" \" + mScreenRows + \" \" + mActiveTranscriptRows; Log.e(TAG, errorMessage); throw new IllegalArgumentException(errorMessage); } if (extRow >= 0) { return (mScreenFirstRow + extRow) % mTotalRows; } else { if (-extRow > mScreenFirstRow) { return mTotalRows + mScreenFirstRow + extRow; } else { return mScreenFirstRow + extRow; } } }","old_code_raw":"    private int externalToInternalRow(int extRow) {\n        if (extRow < -mActiveTranscriptRows || extRow > mScreenRows) {\n            String errorMessage = \"externalToInternalRow \"+ extRow +\n                \" \" + mScreenRows + \" \" + mActiveTranscriptRows;\n            Log.e(TAG, errorMessage);\n            throw new IllegalArgumentException(errorMessage);\n        }\n\n        if (extRow >= 0) {\n            return extRow;\n        } else {\n            if (mNextTranscriptRow >= -extRow) {\n                return mScreenRows + mNextTranscriptRow + extRow;\n            } else {\n                return mScreenRows + mActiveTranscriptRows + mNextTranscriptRow + extRow;\n            }\n        }\n    }\n","new_comment_raw":"@return The row corresponding to the input argument in the private coordinate system.","old_comment_raw":"@return The row corresponding to the input argument in the private coordinate system.","label":0,"pre_label":1,"AST_level":12,"line_counts":19,"new_code_token_num":96},{"new_code_raw":"public static Type<?> valueOf(String name) { return ModTheMod.getGame().getTypeManager().getType(name); }","old_code_raw":"public static Type valueOf(String name) {\n    return null;\n}","new_comment_raw":"@return The {@link Type} corresponding with the given name.","old_comment_raw":"@return The {@link Type}.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":24},{"new_code_raw":"public List<Pet> findPetsByTags(List<String> tags) throws ApiException { ApiResponse<List<Pet>> resp = findPetsByTagsWithHttpInfo(tags); return resp.getData(); }","old_code_raw":"  public List<Pet> findPetsByTags(List<String> tags) throws ApiException {\n    Call call = findPetsByTagsCall(tags, null, null);\n    Type returnType = new TypeToken<List<Pet>>(){}.getType();\n    return apiClient.execute(call, returnType);\n  }\n","new_comment_raw":"@return List","old_comment_raw":"@return List","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"synchronized public Value put(Transaction tx, Key key, Value value) throws IOException { Value oldValue = null; if (lastGetNodeCache != null) { if(lastGetEntryCache.getKey().equals(key)) { oldValue = lastGetEntryCache.setValue(value); lastGetEntryCache.setValue(value); lastGetNodeCache.storeUpdate(tx); return oldValue; } \/\/ This searches from the last location of a call to get for the element to replace \/\/ all the way to the end of the ListIndex. Iterator<Map.Entry<Key, Value>> iterator = lastGetNodeCache.iterator(tx); while (iterator.hasNext()) { Map.Entry<Key, Value> entry = iterator.next(); if (entry.getKey().equals(key)) { oldValue = entry.setValue(value); ((ListIterator) iterator).getCurrent().storeUpdate(tx); return oldValue; } } } \/\/ Not found because the cache wasn't set or its not at the end of the list so we \/\/ start from the beginning and go to the cached location or the end, then we do \/\/ an add if its not found. Iterator<Map.Entry<Key, Value>> iterator = iterator(tx); while (iterator.hasNext() && ((ListIterator) iterator).getCurrent() != lastGetNodeCache) { Map.Entry<Key, Value> entry = iterator.next(); if (entry.getKey().equals(key)) { oldValue = entry.setValue(value); ((ListIterator) iterator).getCurrent().storeUpdate(tx); return oldValue; } } \/\/ Not found so add it last. return add(tx, key, value); }","old_code_raw":"    synchronized public Value put(Transaction tx, Key key, Value value) throws IOException {\n        return add(tx, key, value);\n    }\n","new_comment_raw":"@return the old value contained in the list if one exists or null.","old_comment_raw":"@return null","label":1,"pre_label":0,"AST_level":12,"line_counts":43,"new_code_token_num":313},{"new_code_raw":"public String getTypeDeclaration(Schema p) { if (ModelUtils.isArraySchema(p)) { ArraySchema ap = (ArraySchema) p; Schema inner = ap.getItems(); return \"[\" + getTypeDeclaration(inner) + \"]\"; } else if (ModelUtils.isMapSchema(p)) { Schema inner = (Schema) p.getAdditionalProperties(); return \"%{optional(String.t) => \" + getTypeDeclaration(inner) + \"}\"; } else if (ModelUtils.isPasswordSchema(p)) { return \"String.t\"; } else if (ModelUtils.isEmailSchema(p)) { return \"String.t\"; } else if (ModelUtils.isByteArraySchema(p)) { return \"binary()\"; } else if (ModelUtils.isUUIDSchema(p)) { return \"String.t\"; } else if (ModelUtils.isDateSchema(p)) { return \"Date.t\"; } else if (ModelUtils.isDateTimeSchema(p)) { return \"DateTime.t\"; } else if (ModelUtils.isObjectSchema(p)) { \/\/ How to map it? return super.getTypeDeclaration(p); } else if (ModelUtils.isIntegerSchema(p)) { return \"integer()\"; } else if (ModelUtils.isNumberSchema(p)) { return \"float()\"; } else if (ModelUtils.isBinarySchema(p)) { return \"binary()\"; } else if (ModelUtils.isBooleanSchema(p)) { return \"boolean()\"; } else if (!StringUtils.isEmpty(p.get$ref())) { \/\/ model \/\/ How to map it? return super.getTypeDeclaration(p); } else if (ModelUtils.isFileSchema(p)) { return \"String.t\"; } else if (ModelUtils.isStringSchema(p)) { return \"String.t\"; } return super.getTypeDeclaration(p); }","old_code_raw":"    public String getTypeDeclaration(Property p) {\n        \/\/ SubClasses of AbstractProperty\n        \/\/\n        \/\/ ArrayProperty\n        \/\/ MapProperty\n        \/\/ PasswordProperty\n        \/\/ StringProperty\n        \/\/     EmailProperty\n        \/\/     ByteArrayProperty\n        \/\/ DateProperty\n        \/\/ UUIDProperty\n        \/\/ DateTimeProperty\n        \/\/ ObjectProperty\n        \/\/ AbstractNumericProperty\n        \/\/     BaseIntegerProperty\n        \/\/         IntegerProperty\n        \/\/         LongProperty\n        \/\/     DecimalProperty\n        \/\/         DoubleProperty\n        \/\/         FloatProperty\n        \/\/ BinaryProperty\n        \/\/ BooleanProperty\n        \/\/ RefProperty\n        \/\/ FileProperty\n        if (p instanceof ArrayProperty) {\n            ArrayProperty ap = (ArrayProperty) p;\n            Property inner = ap.getItems();\n            return \"[\" + getTypeDeclaration(inner) + \"]\";\n        } else if (p instanceof MapProperty) {\n            MapProperty mp = (MapProperty) p;\n            Property inner = mp.getAdditionalProperties();\n            return \"%{optional(String.t) => \" + getTypeDeclaration(inner) + \"}\";\n        } else if (p instanceof PasswordProperty) {\n            return \"String.t\";\n        } else if (p instanceof EmailProperty) {\n            return \"String.t\";\n        } else if (p instanceof ByteArrayProperty) {\n            return \"binary()\";\n        } else if (p instanceof StringProperty) {\n            return \"String.t\";\n        } else if (p instanceof DateProperty) {\n            return \"Date.t\";\n        } else if (p instanceof UUIDProperty) {\n            return \"String.t\";\n        } else if (p instanceof DateTimeProperty) {\n            return \"DateTime.t\";\n        } else if (p instanceof ObjectProperty) {\n            \/\/ How to map it?\n            return super.getTypeDeclaration(p);\n        } else if (p instanceof IntegerProperty) {\n            return \"integer()\";\n        } else if (p instanceof LongProperty) {\n            return \"integer()\";\n        } else if (p instanceof BaseIntegerProperty) {\n            return \"integer()\";\n        } else if (p instanceof DoubleProperty) {\n            return \"float()\";\n        } else if (p instanceof FloatProperty) {\n            return \"float()\";\n        } else if (p instanceof DecimalProperty) {\n            return \"float()\";\n        } else if (p instanceof AbstractNumericProperty) {\n            return \"number()\";\n        } else if (p instanceof BinaryProperty) {\n            return \"binary()\";\n        } else if (p instanceof BooleanProperty) {\n            return \"boolean()\";\n        } else if (p instanceof RefProperty) {\n            \/\/ How to map it?\n            return super.getTypeDeclaration(p);\n        } else if (p instanceof FileProperty) {\n            return \"String.t\";\n        }\n        return super.getTypeDeclaration(p);\n    }\n","new_comment_raw":"@return a string value used as the `dataType` field for model templates, `returnType` for api templates","old_comment_raw":"@return a string value used as the `dataType` field for model templates, `returnType` for api templates","label":0,"pre_label":1,"AST_level":21,"line_counts":42,"new_code_token_num":363},{"new_code_raw":"public GraphQLInputType buildDirectiveInputType(Value value) { if (value instanceof NullValue) { return Scalars.GraphQLString; } if (value instanceof FloatValue) { return Scalars.GraphQLFloat; } if (value instanceof StringValue) { return Scalars.GraphQLString; } if (value instanceof IntValue) { return Scalars.GraphQLInt; } if (value instanceof BooleanValue) { return Scalars.GraphQLBoolean; } return assertShouldNeverHappen(\"Directive values of type '%s' are not supported yet\", value.getClass().getName()); }","old_code_raw":"    public GraphQLInputType buildDirectiveInputType(Value value) {\n        if (value instanceof NullValue) {\n            return Scalars.GraphQLString;\n        }\n        if (value instanceof FloatValue) {\n            return Scalars.GraphQLFloat;\n        }\n        if (value instanceof StringValue) {\n            return Scalars.GraphQLString;\n        }\n        if (value instanceof IntValue) {\n            return Scalars.GraphQLInt;\n        }\n        if (value instanceof BooleanValue) {\n            return Scalars.GraphQLBoolean;\n        }\n        return Assert.assertShouldNeverHappen(\"Directive values of type '%s' are not supported yet\", value.getClass().getName());\n    }\n","new_comment_raw":"@return a graphql input type","old_comment_raw":"@return a graphql input type","label":0,"pre_label":1,"AST_level":6,"line_counts":19,"new_code_token_num":96},{"new_code_raw":"public static EntityMode parse(String entityMode) { if ( entityMode == null ) { return POJO; } if ( MAP.externalName.equalsIgnoreCase( entityMode ) ) { return MAP; } return valueOf( entityMode.toUpperCase( Locale.ENGLISH ) ); }","old_code_raw":"\tpublic static EntityMode parse(String entityMode) {\n\t\tif ( entityMode == null ) {\n\t\t\treturn POJO;\n\t\t}\n\t\tentityMode = entityMode.toUpperCase();\n\t\tif ( DYNAMIC_MAP_NAME.equals( entityMode ) ) {\n\t\t\treturn MAP;\n\t\t}\n\t\treturn valueOf( entityMode );\n\t}\n","new_comment_raw":"@return The appropriate entity mode;  null for incoming  entityMode param is treated by returning  #POJO.","old_comment_raw":"@return The appropriate entity mode; null for incoming entityMode param is treated by returning #POJO.","label":0,"pre_label":1,"AST_level":6,"line_counts":10,"new_code_token_num":45},{"new_code_raw":"public static <T extends CharSequence> T notEmpty(final T chars, final String message, final Object... values) { if (chars == null) { throw new NullPointerException(String.format(message, values)); } if (chars.length() == NUM) { throw new IllegalArgumentException(String.format(message, values)); } return chars; }","old_code_raw":"public static <T extends Collection<?>> T notEmpty(final T collection, final String message, final Object... values) {\n    if (collection == null) {\n        throw new NullPointerException(String.format(message, values));\n    }\n    if (collection.isEmpty()) {\n        throw new IllegalArgumentException(String.format(message, values));\n    }\n    return collection;\n}","new_comment_raw":"@return the validated character sequence (never {@code null} method for chaining)","old_comment_raw":"@return the validated collection (never {@code null} method for chaining)","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":68},{"new_code_raw":"public static String getFullUrl(HttpServletRequest request) { if (request.getQueryString() == null) { return request.getRequestURI(); } return request.getRequestURI() + \"?\" + request.getQueryString(); }","old_code_raw":"    public static String getFullUrl(HttpServletRequest request) {\n        final StringBuilder url = new StringBuilder(100).append(request.getRequestURI());\n        if (request.getQueryString() != null) {\n            url.append('?').append(request.getQueryString());\n        }\n        return url.toString();\n    }\n","new_comment_raw":"@return the full URL, including the query string","old_comment_raw":"@return the full URL, including the query string","label":0,"pre_label":1,"AST_level":6,"line_counts":9,"new_code_token_num":41},{"new_code_raw":"private CollectionPersister getPersister(SharedSessionContractImplementor session) { return getPersister( session.getFactory() ); }","old_code_raw":"\tprivate CollectionPersister getPersister(SharedSessionContractImplementor session) {\n\t\treturn session.getFactory().getMetamodel().collectionPersister( role );\n\t}\n","new_comment_raw":"@return The underlying collection persister","old_comment_raw":"@return The underlying collection persister","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public ResponseEntity<Void> updatePetWithHttpInfo(Pet body) throws RestClientException { Object postBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling updatePet\"); } String path = apiClient.expandPath(\"\/pet\", Collections.<String, Object>emptyMap()); final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>(); final HttpHeaders headerParams = new HttpHeaders(); final MultiValueMap<String, String> cookieParams = new LinkedMultiValueMap<String, String>(); final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>(); final String[] accepts = { }; final List<MediaType> accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { \"application\/json\", \"application\/xml\" }; final MediaType contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"petstore_auth\" }; ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {}; return apiClient.invokeAPI(path, HttpMethod.PUT, queryParams, postBody, headerParams, cookieParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"    public ResponseEntity<Void> updatePetWithHttpInfo(Pet body) throws RestClientException {\n        Object postBody = body;\n        \n        \/\/ verify the required parameter 'body' is set\n        if (body == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'body' when calling updatePet\");\n        }\n        \n        String path = apiClient.expandPath(\"\/pet\", Collections.<String, Object>emptyMap());\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { \n            \"application\/json\", \"application\/xml\"\n        };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] { \"petstore_auth\" };\n\n        ParameterizedTypeReference<Void> returnType = new ParameterizedTypeReference<Void>() {};\n        return apiClient.invokeAPI(path, HttpMethod.PUT, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@return ResponseEntity&lt;Void&gt;","old_comment_raw":"@return ResponseEntity&lt;Void&gt;","label":0,"pre_label":1,"AST_level":8,"line_counts":28,"new_code_token_num":223},{"new_code_raw":"@JsonIgnore @SuppressWarnings(STR) @Nullable public <T extends Credentials> Credentials getLoginDetails(Class<T> loginDetailsClass) { return Maps.uniqueIndex(this.credentials, new Function<Credentials, Class<Credentials>>() { @Override public Class<Credentials> apply(@Nullable Credentials credentials) { if (credentials != null) { return (Class<Credentials>) credentials.getClass(); } return null; } }).get(loginDetailsClass); }","old_code_raw":"@JsonIgnore\n@SuppressWarnings(STR)\n@Nullable\npublic <T extends LoginDetails> LoginDetails getLoginDetails(Class<T> loginDetailsClass) {\n    return Maps.uniqueIndex(this.loginDetails, new Function<LoginDetails, Class<LoginDetails>>() {\n\n        @Override\n        public Class<LoginDetails> apply(@Nullable LoginDetails loginDetails) {\n            if (loginDetails != null) {\n                return (Class<LoginDetails>) loginDetails.getClass();\n            }\n            return null;\n        }\n    }).get(loginDetailsClass);\n}","new_comment_raw":"@return Credentials instance corresponding to the given Credentials class. Null if no such id found.","old_comment_raw":"@return LoginDetails instance corresponding to the given LoginDetails class. Null if no such id found.","label":1,"pre_label":0,"AST_level":13,"line_counts":15,"new_code_token_num":80},{"new_code_raw":"public static String encodeValue(Value value) { if (value instanceof BNode) { return ((BNode) value).getID(); } return NTriplesUtil.toNTriplesString(value); }","old_code_raw":"public static String encodeValue(Value value) {\n    return NTriplesUtil.toNTriplesString(value);\n}","new_comment_raw":"@return The protocol-serialized representation of the supplied value, or {@link #NULL_PARAM_VALUE} if the supplied value was <tt>null<\/tt>.","old_comment_raw":"@return The N-Triples representation of the supplied value, or {@link #NULL_PARAM_VALUE} if the supplied value was <tt>null<\/tt>.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"protected Writer openTestLog() throws Exception { File testClassDir = new File( getTestlogRoot(), ReflectUtil.getUnqualifiedClassName(getClass())); testClassDir.mkdirs(); File testLogFile = new File( testClassDir, testCaseName); return new OutputStreamWriter( openTestLogOutputStream(testLogFile), StandardCharsets.UTF_8); }","old_code_raw":"  protected Writer openTestLog() throws Exception {\n    File testClassDir =\n        new File(\n            getTestlogRoot(),\n            ReflectUtil.getUnqualifiedClassName(getClass()));\n    testClassDir.mkdirs();\n    File testLogFile =\n        new File(\n            testClassDir,\n            testCaseName);\n    return new OutputStreamWriter(openTestLogOutputStream(testLogFile));\n  }\n","new_comment_raw":"@return Writer for log file, which caller should use as a destination for test output to be diffed","old_comment_raw":"@return Writer for log file, which caller should use as a destination for test output to be diffed","label":0,"pre_label":1,"AST_level":7,"line_counts":14,"new_code_token_num":55},{"new_code_raw":"public static int[] getViewToHeaderBodyPosition(JTextArea view, String header, int start, int end) { validateView(view); validateHeader(header); validateStartEnd(start, end); if (!isValidStartEndForLength(start, end, view.getDocument().getLength())) { return INVALID_POSITION; } int excessChars = 0; int pos = 0; while ((pos = header.indexOf(\"\\r\\n\", pos)) != -1) { pos += 2; ++excessChars; } if (start + excessChars < header.length()) { int[] position = getViewToHeaderPositionImpl(view, start, end); if (position[1] > header.length()) { position[1] = header.length(); } return position; } int finalStartPos = start + excessChars - header.length(); int finalEndPos = end + excessChars - header.length(); return new int[] { finalStartPos, finalEndPos, 0 }; }","old_code_raw":"    public static int[] getViewToHeaderBodyPosition(JTextArea view, String header, int start, int end) {\n        validateView(view);\n        validateHeader(header);\n        validateStartEnd(start, end, view.getDocument().getLength());\n\n        int excessChars = 0;\n        int pos = 0;\n        while ((pos = header.indexOf(\"\\r\\n\", pos)) != -1) {\n            pos += 2;\n            ++excessChars;\n        }\n\n        if (start + excessChars < header.length()) {\n            int[] position = getViewToHeaderPositionImpl(view, start, end);\n            if (position[1] > header.length()) {\n                position[1] = header.length();\n            }\n            return position;\n        }\n\n        int finalStartPos = start + excessChars - header.length();\n        int finalEndPos = end + excessChars - header.length();\n        return new int[] { finalStartPos, finalEndPos, 0 };\n    }\n","new_comment_raw":"@return the positions offset for the header or, 3 positions, for after the body (the third position is just to indicate that it's the body, the value is meaningless), or  #INVALID_POSITION if the  start or  end is greater than the length of the  view","old_comment_raw":"@return the positions offset for the header or, 3 positions, for after the body (the third position is just to indicate that it's the body, the value is meaningless)","label":1,"pre_label":0,"AST_level":11,"line_counts":29,"new_code_token_num":185},{"new_code_raw":"public static float convertDpToPixel(float dp, Context context) { float scale = context.getResources().getDisplayMetrics().density; return dp * scale + 0.5f; }","old_code_raw":"    public static float convertDpToPixel(float dp, Context context){\n        Resources resources = context.getResources();\n        DisplayMetrics metrics = resources.getDisplayMetrics();\n        float px = dp * ((float)metrics.densityDpi \/ DisplayMetrics.DENSITY_DEFAULT);\n        return px;\n    }\n","new_comment_raw":"@return A float value to represent px equivalent to dp depending on device density","old_comment_raw":"@return A float value to represent px equivalent to dp depending on device density","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public static int getOrientation(InputStream is) { try { int length = moveToAPP1EXIF(is); if (length == 0) { return ExifInterface.ORIENTATION_UNDEFINED; } return TiffUtil.readOrientationFromTIFF(is, length); } catch (IOException ioe) { return ExifInterface.ORIENTATION_UNDEFINED; } }","old_code_raw":"  public static int getOrientation(InputStream is) {\n    try {\n      int length = moveToAPP1EXIF(is);\n      if (length == 0) {\n        return 0; \/\/ unknown orientation\n      }\n      return TiffUtil.readOrientationFromTIFF(is, length);\n    } catch (IOException ioe) {\n      return 0;\n    }\n  }\n","new_comment_raw":"@return orientation: 1\/8\/3\/6. Returns  android.media.ExifInterface#ORIENTATION_UNDEFINED if there is no valid orientation information.","old_comment_raw":"@return orientation: 1\/8\/3\/6. Returns 0 if there is no valid orientation information.","label":1,"pre_label":0,"AST_level":7,"line_counts":12,"new_code_token_num":51},{"new_code_raw":"public List<Pet> findPetsByStatus (List<String> status) throws ApiException { Object localVarPostBody = null; \/\/ create path and map variables String localVarPath = \"\/pet\/findByStatus\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); \/\/ header params Map<String, String> localVarHeaderParams = new HashMap<String, String>(); \/\/ form params Map<String, String> localVarFormParams = new HashMap<String, String>(); localVarQueryParams.addAll(ApiInvoker.parameterToPairs(\"multi\", \"status\", status)); String[] localVarContentTypes = { }; String localVarContentType = localVarContentTypes.length > 0 ? localVarContentTypes[0] : \"application\/json\"; if (localVarContentType.startsWith(\"multipart\/form-data\")) { \/\/ file uploading MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create(); localVarPostBody = localVarBuilder.build(); } else { \/\/ normal form params } try { String localVarResponse = apiInvoker.invokeAPI(basePath, localVarPath, \"GET\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarContentType); if(localVarResponse != null){ return (List<Pet>) ApiInvoker.deserialize(localVarResponse, \"array\", Pet.class); } else { return null; } } catch (ApiException ex) { throw ex; } }","old_code_raw":"  public List<Pet>  findPetsByStatus (List<String> status) throws ApiException {\n    Object postBody = null;\n    \n\n    \/\/ create path and map variables\n    String path = \"\/pet\/findByStatus\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    \/\/ header params\n    Map<String, String> headerParams = new HashMap<String, String>();\n    \/\/ form params\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n    queryParams.addAll(ApiInvoker.parameterToPairs(\"multi\", \"status\", status));\n    \n\n    \n\n    String[] contentTypes = {\n      \n    };\n    String contentType = contentTypes.length > 0 ? contentTypes[0] : \"application\/json\";\n\n    if (contentType.startsWith(\"multipart\/form-data\")) {\n      \/\/ file uploading\n      MultipartEntityBuilder builder = MultipartEntityBuilder.create();\n      \n\n      HttpEntity httpEntity = builder.build();\n      postBody = httpEntity;\n    } else {\n      \/\/ normal form params\n      \n    }\n\n    try {\n      String response = apiInvoker.invokeAPI(basePath, path, \"GET\", queryParams, postBody, headerParams, formParams, contentType);\n      if(response != null){\n        return (List<Pet>) ApiInvoker.deserialize(response, \"array\", Pet.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@return List","old_comment_raw":"@return List","label":0,"pre_label":1,"AST_level":10,"line_counts":49,"new_code_token_num":248},{"new_code_raw":"public static GitlabRepositoryName create(final String url) { LOGGER.log(Level.FINE, STR, url); for (Pattern p : URL_PATTERNS) { Matcher m = p.matcher(url.trim()); if (m.matches()) { LOGGER.log(Level.FINE, STR, m); GitlabRepositoryName ret = new GitlabRepositoryName(m.group(NUM), m.group(NUM), m.group(NUM)); LOGGER.log(Level.FINE, STR, ret); return ret; } } LOGGER.log(Level.WARNING, STR, url); return null; }","old_code_raw":"public static GitHubRepositoryName create(final String url) {\n    LOGGER.log(Level.FINE, STR, url);\n    for (Pattern p : URL_PATTERNS) {\n        Matcher m = p.matcher(url.trim());\n        if (m.matches()) {\n            LOGGER.log(Level.FINE, STR, m);\n            GitHubRepositoryName ret = new GitHubRepositoryName(m.group(NUM), m.group(NUM), m.group(NUM));\n            LOGGER.log(Level.FINE, STR, ret);\n            return ret;\n        }\n    }\n    LOGGER.log(Level.WARNING, STR, url);\n    return null;\n}","new_comment_raw":"@return parsed {@link GitlabRepositoryName} or null if it cannot be parsed from the specified URL","old_comment_raw":"@return parsed {@link GitHubRepositoryName} or null if it cannot be parsed from the specified URL","label":1,"pre_label":0,"AST_level":11,"line_counts":14,"new_code_token_num":114},{"new_code_raw":"public List<SqlValidatorNamespace> getChildren() { return Lists.transform(children, ScopeChild.NAMESPACE_FN); }","old_code_raw":"  public List<SqlValidatorNamespace> getChildren() {\n    return Pair.right(children);\n  }\n","new_comment_raw":"@return list of child namespaces","old_comment_raw":"@return list of child namespaces","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public Vector<QueueItem> getQueue() { return queue; }","old_code_raw":"    public Vector getQueue() {\n        return queue;\n    }\n","new_comment_raw":"@return Returns the queue.","old_comment_raw":"@return Returns the queue.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"protected Object convertValue(Column column, Field fieldDefn, Object data, Object fallback, ValueConversionCallback callback) { if (data == null) { if (column.isOptional()) { return null; } final Object schemaDefault = fieldDefn.schema().defaultValue(); return schemaDefault != null ? schemaDefault : fallback; } final ResultReceiver r = ResultReceiver.create(); callback.convert(r); return r.hasReceived() ? r.get() : handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertValue(Column column, Field fieldDefn, Object data, Object fallback, ValueConversionCallback callback) {\n        if (data == null) {\n            if (column.isOptional()) {\n                return null;\n            }\n            final Object schemaDefault = fieldDefn.schema().defaultValue();\n            if (schemaDefault != null) {\n                return schemaDefault;\n            }\n            return (fallback instanceof Supplier<?>) ? ((Supplier<?>)fallback).get() : fallback;\n        }\n\n        final ResultReceiver r = ResultReceiver.create();\n        callback.convert(r);\n        return r.hasReceived() ? r.get() : handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return The converted value. Will be  null if the inbound value was  null and the column is optional. Will be the column's default value (converted to the corresponding KC type, if the inbound value was  null, the column is non-optional and has a default value. Will be  fallback if the inbound value was  null, the column is non-optional and has no default value. Otherwise, it will be the value produced by  callback and lastly the result returned by  #handleUnknownData(Column, Field, Object).","old_comment_raw":"@return The converted value. Will be null if the inbound value was null and the column is optional. Will be the column's default value (converted to the corresponding KC type, if the inbound value was null, the column is non-optional and has a default value. Will be fallback if the inbound value was null, the column is non-optional and has no default value. Otherwise, it will be the value produced by callback and lastly the result returned by #handleUnknownData(Column, Field, Object).","label":0,"pre_label":1,"AST_level":8,"line_counts":14,"new_code_token_num":94},{"new_code_raw":"public ArrayList<TextView> clickLongInList(int line, int index){ if(config.commandLogging){ Log.d(config.commandLoggingTag, \"clickLongInList(\"+line+\", \"+index+\")\"); } return clicker.clickInList(line, index, 0, true, 0); }","old_code_raw":"\tpublic ArrayList<TextView> clickLongInList(int line, int index){\n\t\tif(config.commandLogging){\n\t\t\tLog.d(config.commandLoggingTag, \"clickLongInList(\"+line+\", \"+index+\")\");\n\t\t}\n\t\t\n\t\treturn clicker.clickInList(line, index, true, 0);\n\t}\n","new_comment_raw":"@return an  ArrayList of the  TextView objects located in the list line","old_comment_raw":"@return an ArrayList of the TextView objects located in the list line","label":0,"pre_label":1,"AST_level":11,"line_counts":8,"new_code_token_num":59},{"new_code_raw":"private boolean scrollScrollView(final ScrollView view, int direction){ if(view == null){ Log.e(TAG, \"ScrollView was null\"); return false; } int height = view.getHeight(); height--; int scrollTo = -1; if (direction == DOWN) { scrollTo = height; } else if (direction == UP) { scrollTo = -height; } int originalY = view.getScrollY(); final int scrollAmount = scrollTo; inst.runOnMainSync(new Runnable(){ public void run(){ view.scrollBy(0, scrollAmount); } }); if (originalY == view.getScrollY()) { return false; } else{ return true; } }","old_code_raw":"\tprivate boolean scrollScrollView(int direction, ArrayList<ScrollView> scrollViews){\n\t\tfinal ScrollView scroll = viewFetcher.getView(ScrollView.class, scrollViews);\n\t\tint scrollAmount = 0;\n\t\t\n\t\tif(scroll != null){\n\t\t\tint height = scroll.getHeight();\n\t\t\theight--;\n\t\t\tint scrollTo = 0;\n\n\t\t\tif (direction == DOWN) {\n\t\t\t\tscrollTo = (height);\n\t\t\t}\n\n\t\t\telse if (direction == UP) {\n\t\t\t\tscrollTo = (-height);\n\t\t\t}\n\t\t\tscrollAmount = scroll.getScrollY();\n\t\t\tscrollScrollViewTo(scroll,0, scrollTo);\n\t\t\tif (scrollAmount == scroll.getScrollY()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@return  true if scrolling occurred, false if it did not","old_comment_raw":"@return true if more scrolling can be done","label":1,"pre_label":0,"AST_level":9,"line_counts":38,"new_code_token_num":130},{"new_code_raw":"static StringList parseImports(StringDict properties) { StringList outgoing = new StringList(); String importStr = properties.get(IMPORTS_PROPERTY); if (importStr != null) { String[] importList = PApplet.trim(PApplet.split(importStr, ',')); for (String importName : importList) { if (!importName.isEmpty()) { outgoing.append(importName); } } } return (outgoing.size() > 0) ? outgoing : null; }","old_code_raw":"  static List<String> parseImports(String importStr) {\n    List<String> outgoing = new ArrayList<String>();\n\n    if (importStr != null) {\n      String[] importList = PApplet.trim(PApplet.split(importStr, ','));\n      for (String importName : importList) {\n        outgoing.add(importName);\n      }\n    }\n    return (outgoing.size() > 0) ? outgoing : null;\n  }\n","new_comment_raw":"@return null if no entries found","old_comment_raw":"@return the list of imports that this contribution (library) contains.","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":88},{"new_code_raw":"public GraphQLInputType buildDirectiveInputType(Value value) { if (value instanceof NullValue) { return Scalars.GraphQLString; } if (value instanceof FloatValue) { return Scalars.GraphQLFloat; } if (value instanceof StringValue) { return Scalars.GraphQLString; } if (value instanceof IntValue) { return Scalars.GraphQLInt; } if (value instanceof BooleanValue) { return Scalars.GraphQLBoolean; } if (value instanceof ArrayValue) { ArrayValue arrayValue = (ArrayValue) value; return list(buildDirectiveInputType(getArrayValueWrappedType(arrayValue))); } return assertShouldNeverHappen(\"Directive values of type '%s' are not supported yet\", value.getClass().getSimpleName()); }","old_code_raw":"    public GraphQLInputType buildDirectiveInputType(Value value) {\n        if (value instanceof NullValue) {\n            return Scalars.GraphQLString;\n        }\n        if (value instanceof FloatValue) {\n            return Scalars.GraphQLFloat;\n        }\n        if (value instanceof StringValue) {\n            return Scalars.GraphQLString;\n        }\n        if (value instanceof IntValue) {\n            return Scalars.GraphQLInt;\n        }\n        if (value instanceof BooleanValue) {\n            return Scalars.GraphQLBoolean;\n        }\n        if (value instanceof ArrayValue) {\n            ArrayValue arrayValue = (ArrayValue) value;\n            return new GraphQLList(buildDirectiveInputType(getArrayValueWrappedType(arrayValue)));\n        }\n        return assertShouldNeverHappen(\"Directive values of type '%s' are not supported yet\", value.getClass().getSimpleName());\n    }\n","new_comment_raw":"@return a graphql input type","old_comment_raw":"@return a graphql input type","label":0,"pre_label":1,"AST_level":9,"line_counts":23,"new_code_token_num":123},{"new_code_raw":"public int getPort() { return serverPort; }","old_code_raw":"public int getPort() {\n    return port;\n}","new_comment_raw":"@return the server port","old_comment_raw":"@return the port","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public boolean isHighWaterMark() { return (getDispatchedQueueSize() - prefetchExtension.get()) >= (info.getPrefetchSize() * .9); }","old_code_raw":"    public boolean isHighWaterMark() {\n        return getDispatchedQueueSize() >= (info.getPrefetchSize() * .9);\n    }\n","new_comment_raw":"@return true when 10% or less room is left for dispatching messages","old_comment_raw":"@return true when 10% or less room is left for dispatching messages","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public Options includeScalarTypes(boolean flag) { return new Options(this.includeIntrospectionTypes, flag, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, this.useAstDefinitions, this.descriptionsAsHashComments, this.comparatorRegistry); }","old_code_raw":"        public Options includeScalarTypes(boolean flag) {\n            return new Options(this.includeIntrospectionTypes, flag, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, this.useAstDefinitions, this.comparatorRegistry);\n        }\n","new_comment_raw":"@return options","old_comment_raw":"@return options","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":37},{"new_code_raw":"public static EntityManagerFactory createEntityManagerFactory(String persistenceUnitName, Map properties) { EntityManagerFactory factory = null; Map props = properties; if (props == null) { props = Collections.EMPTY_MAP; } PersistenceProviderResolver resolver = PersistenceProviderResolverHolder.getPersistenceProviderResolver(); List<PersistenceProvider> providers = resolver.getPersistenceProviders(); Object providerName = props.get(PERSISTENCE_PROVIDER_PROPERTY); if ((providerName != null) && (providerName instanceof String)) { boolean isLoaded = false; for (PersistenceProvider provider : providers) { if (provider.getClass().getName().compareTo(providerName.toString()) == NUM) { isLoaded = true; break; } } if (!isLoaded) { factory = createFactory(providerName.toString(), persistenceUnitName, props); if (factory != null) { return factory; } } } if (providers.size() == NUM) { return providers.get(NUM).createEntityManagerFactory(persistenceUnitName, props); } else { for (PersistenceProvider provider : providers) { try { factory = provider.createEntityManagerFactory(persistenceUnitName, props); } catch (Exception e) { } if (factory != null) { return factory; } } } throw new PersistenceException(STR + persistenceUnitName); }","old_code_raw":"public static EntityManagerFactory createEntityManagerFactory(String persistenceUnitName, Map properties) {\n    EntityManagerFactory factory = null;\n    if (properties == null) {\n        properties = Collections.EMPTY_MAP;\n    }\n    Object providerName = properties.get(PERSISTENCE_PROVIDER_PROPERTY);\n    if (providerName instanceof String) {\n        factory = createFactory(providerName.toString(), persistenceUnitName, properties);\n    }\n    if (factory == null) {\n        PersistenceProviderResolver resolver = PersistenceProviderResolverHolder.getPersistenceProviderResolver();\n        List<PersistenceProvider> providers = resolver.getPersistenceProviders();\n        for (PersistenceProvider provider : providers) {\n            try {\n                factory = provider.createEntityManagerFactory(persistenceUnitName, properties);\n            } catch (Exception e) {\n                throw new PersistenceException(STR + providerName, e);\n            }\n            if (factory != null) {\n                break;\n            }\n        }\n    }\n    return factory;\n}","new_comment_raw":"@return The factory for the specified persistence unit or null if none are applicable.","old_comment_raw":"@return The factory that creates EntityManagers configured according to the specified persistence unit.","label":1,"pre_label":0,"AST_level":11,"line_counts":39,"new_code_token_num":215},{"new_code_raw":"public Iterable<String> getNonNullableTransientPropertyPaths(final Object entity) { if ( propertyPathsByTransientEntity == null ) { return Collections.emptyList(); } else { return propertyPathsByTransientEntity.get( entity ); } }","old_code_raw":"\tpublic Iterable<String> getNonNullableTransientPropertyPaths(Object entity) {\n\t\treturn propertyPathsByTransientEntity.get( entity );\n\t}\n","new_comment_raw":"@return The property paths","old_comment_raw":"@return The property paths","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":34},{"new_code_raw":"public double getRotY() { return Math.toDegrees(mOrientation.getRotationY()); }","old_code_raw":"public double getRotY() {\n    return mOrientation.getRotationY();\n}","new_comment_raw":"@return double The yaw Euler angle in degrees.","old_comment_raw":"@return double The yaw Euler angle.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"protected ActionMessages getErrors(HttpServletRequest request) { ActionMessages errors = (ActionMessages) request.getAttribute(Globals.ERROR_KEY); if (errors == null) { errors = new ActionMessages(); } return errors; }","old_code_raw":"protected ActionErrors getErrors(HttpServletRequest request) {\n    ActionErrors errors = (ActionErrors) request.getAttribute(Globals.ERROR_KEY);\n    if (errors == null) {\n        errors = new ActionErrors();\n    }\n    return errors;\n}","new_comment_raw":"@return the Errors that already exist in the request, or a new ActionMessages object if empty.","old_comment_raw":"@return the Errors that already exist in the request, or a new ActionErrors object if empty.","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":37},{"new_code_raw":"@Deprecated public static String getUserAgent() { return instance(); }","old_code_raw":"public static String getUserAgent() {\n    String webUserAgent = null;\n    try {\n        Class<?> sysResCls = Class.forName(STR);\n        Field webUserAgentField = sysResCls.getDeclaredField(STR);\n        Integer resId = (Integer) webUserAgentField.get(null);\n        webUserAgent = NoHttp.getContext().getString(resId);\n    } catch (Exception e) {\n    }\n    if (TextUtils.isEmpty(webUserAgent)) {\n        webUserAgent = STR;\n    }\n    Locale locale = Locale.getDefault();\n    StringBuffer buffer = new StringBuffer();\n    final String version = Build.VERSION.RELEASE;\n    if (version.length() > NUM) {\n        buffer.append(version);\n    } else {\n        buffer.append(STR);\n    }\n    buffer.append(STR);\n    final String language = locale.getLanguage();\n    if (language != null) {\n        buffer.append(language.toLowerCase(locale));\n        final String country = locale.getCountry();\n        if (!TextUtils.isEmpty(country)) {\n            buffer.append(STR);\n            buffer.append(country.toLowerCase(locale));\n        }\n    } else {\n        buffer.append(STR);\n    }\n    if (STR.equals(Build.VERSION.CODENAME)) {\n        final String model = Build.MODEL;\n        if (model.length() > NUM) {\n            buffer.append(STR);\n            buffer.append(model);\n        }\n    }\n    final String id = Build.ID;\n    if (id.length() > NUM) {\n        buffer.append(STR);\n        buffer.append(id);\n    }\n    return String.format(webUserAgent, buffer, STR);\n}","new_comment_raw":"@return String.","old_comment_raw":"@return UA.","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public List<String> getReservedAndKeyWords() { ensureReservedAndKeyWords(); return reservedWordsList; }","old_code_raw":"  public List<String> getReservedAndKeyWords() {\n    Collection<String> c = SqlAbstractParserImpl.getSql92ReservedWords();\n    List<String> l =\n        Arrays.asList(\n            getParserMetadata().getJdbcKeywords().split(\",\"));\n    List<String> al = new ArrayList<String>();\n    al.addAll(c);\n    al.addAll(l);\n    return al;\n  }\n","new_comment_raw":"@return an of SQL reserved and keywords","old_comment_raw":"@return an of SQL reserved and keywords","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":15},{"new_code_raw":"public File getDefaultSketchbookFolder() throws Exception { return new File(System.getProperty(\"user.home\"), \"sketchbook\"); }","old_code_raw":"  public File getDefaultSketchbookFolder() throws Exception {\n    return new File(System.getProperty(\"user.dir\"), \"sketchbook\");\n  }\n","new_comment_raw":"@return if not overridden, a folder named \"sketchbook\" in user.home.","old_comment_raw":"@return if not overridden, a folder named \"sketchbook\" in user.dir.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public final int getLimit() { return remainingCharacters; }","old_code_raw":"public final int getLimit() {\n    return remainingBytes;\n}","new_comment_raw":"@return the remaining characters left to be read from the stream","old_comment_raw":"@return the remaining bytes left to be read from the stream","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public static boolean canEdit(Permissions perms, Permissions user2Perms) { if (isAdmin(perms)) return true; if (isAdmin(user2Perms)) return false; return getManagementLevel(perms) > getManagementLevel(user2Perms); }","old_code_raw":"public static boolean canEdit(User manager, User toEdit) {\n    if (isAdmin(manager))\n        return true;\n    if (isAdmin(toEdit))\n        return false;\n    return getManagementLevel(manager) > getManagementLevel(toEdit);\n}","new_comment_raw":"@return Whether the user with the first given permissions can modify the user with the second","old_comment_raw":"@return Whether the first user can modify the second","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":43},{"new_code_raw":"public DateTimeField minuteOfHour() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.minuteOfHour(), minutes()); }","old_code_raw":"    public DateTimeField minuteOfHour() {\n        return UnsupportedDateTimeField.getInstance(\"minuteOfHour\", minutes());\n    }\n","new_comment_raw":"@return DateTimeField or UnsupportedDateTimeField if unsupported","old_comment_raw":"@return DateTimeField or UnsupportedDateTimeField if unsupported","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"private ZapTextArea getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextArea(); txtPattern.setLineWrap(true); txtPattern.setFont(new java.awt.Font(\"Courier New\", java.awt.Font.PLAIN, 12)); txtPattern.addMouseListener(new java.awt.event.MouseAdapter() { public void mousePressed(java.awt.event.MouseEvent e) { if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { \/\/ right \/\/ mouse \/\/ button view.getPopupMenu().show(e.getComponent(), e.getX(), e.getY()); } } }); } return txtPattern; }","old_code_raw":"    private JTextArea getTxtPattern() {\n        if (txtPattern == null) {\n            txtPattern = new JTextArea();\n            txtPattern.setLineWrap(true);\n            txtPattern.setFont(new java.awt.Font(\"Courier New\",\n                    java.awt.Font.PLAIN, 12));\n            txtPattern.addMouseListener(new java.awt.event.MouseAdapter() {\n                public void mousePressed(java.awt.event.MouseEvent e) {\n                    if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) { \/\/ right\n                                                                             \/\/ mouse\n                                                                             \/\/ button\n                        view.getPopupMenu().show(e.getComponent(), e.getX(),\n                                e.getY());\n                    }\n                }\n\n            });\n\n        }\n        return txtPattern;\n    }\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":14,"line_counts":22,"new_code_token_num":124},{"new_code_raw":"public int getMaxLineLength() { return maxLineLength; }","old_code_raw":"public int getMaxLineLength() {\n    return InputThread.MAX_LINE_LENGTH;\n}","new_comment_raw":"@return The maximum line length (default 512)","old_comment_raw":"@return The maximum line length (currently fixed at 512)","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public long getDifferenceAsLong(ReadableInstant instant) { if (instant == null) { return getField().getDifferenceAsLong(getReadableInstant().getMillis(), DateTimeUtils.currentTimeMillis()); } return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis()); }","old_code_raw":"    public long getDifferenceAsLong(ReadableInstant instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        return getField().getDifferenceAsLong(getReadableInstant().getMillis(), instant.getMillis());\n    }\n","new_comment_raw":"@return the difference in the units of this field","old_comment_raw":"@return the difference in the units of this field","label":0,"pre_label":1,"AST_level":9,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"protected Object convertYearToInt(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; } if (data instanceof java.time.Year) { \/\/ The MySQL binlog always returns a Year object ... return ((java.time.Year) data).getValue(); } if (data instanceof java.sql.Date) { \/\/ MySQL JDBC driver sometimes returns a Java SQL Date object ... return ((java.sql.Date) data).getYear(); } if (data instanceof Number) { \/\/ MySQL JDBC driver sometimes returns a short ... return ((Number) data).intValue(); } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertYearToInt(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof java.time.Year) {\n            \/\/ The MySQL binlog always returns a Year object ...\n            return ((java.time.Year) data).getValue();\n        }\n        if (data instanceof java.sql.Date) {\n            \/\/ MySQL JDBC driver sometimes returns a Java SQL Date object ...\n            return ((java.sql.Date) data).getYear();\n        }\n        if (data instanceof Number) {\n            \/\/ MySQL JDBC driver sometimes returns a short ...\n            return ((Number) data).intValue();\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":9,"line_counts":23,"new_code_token_num":157},{"new_code_raw":"public RecordsForCollection forCollection(CollectionId collectionId) { return recordMakerByCollectionId.computeIfAbsent(collectionId, id -> { String topicName = topicSelector.topicNameFor(collectionId); return new RecordsForCollection(collectionId, source, topicName, schemaNameAdjuster, valueTransformer, recorder, emitTombstonesOnDelete); }); }","old_code_raw":"    public RecordsForCollection forCollection(CollectionId collectionId) {\n        return recordMakerByCollectionId.computeIfAbsent(collectionId, id -> {\n            String topicName = topicSelector.getTopic(collectionId);\n            return new RecordsForCollection(collectionId, source, topicName, schemaNameAdjuster, valueTransformer, recorder, emitTombstonesOnDelete);\n        });\n    }\n","new_comment_raw":"@return the table-specific record maker; may be null if the table is not included in the connector","old_comment_raw":"@return the table-specific record maker; may be null if the table is not included in the connector","label":0,"pre_label":1,"AST_level":9,"line_counts":7,"new_code_token_num":48},{"new_code_raw":"public int distanceTo(WorldPoint other) { return distanceTo(new WorldArea(other, NUM, NUM)); }","old_code_raw":"public int distanceTo(WorldArea other) {\n    if (this.getPlane() != other.getPlane()) {\n        return Integer.MAX_VALUE;\n    }\n    Point distances = getAxisDistances(other);\n    return Math.max(distances.getX(), distances.getY());\n}","new_comment_raw":"@return the distance, or {@link Integer#MAX_VALUE} if the planes differ","old_comment_raw":"@return Returns the distance","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":23},{"new_code_raw":"public List<RelHint> apply(List<RelHint> hints, RelNode rel) { return hints.stream() .filter(relHint -> canApply(relHint, rel)) .collect(Collectors.toList()); }","old_code_raw":"  public List<RelHint> apply(List<RelHint> hints, RelNode rel) {\n    return hints.stream()\n        .filter(relHint -> supportsRel(relHint, rel))\n        .collect(Collectors.toList());\n  }\n","new_comment_raw":"@return A hints list that can be attached to the  rel","old_comment_raw":"@return A hints list that can be attached to the rel","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":38},{"new_code_raw":"public static ReferenceResult findReferencedMembers(MethodInfo methodInfo) { Set<String> members = new HashSet<String>(); ClassMemberVisitor visitor = new ClassMemberVisitor(members); IdFinderVisitor finder = findPoolReferences(methodInfo, methodInfo.compile(), true); visitor.visitMethod(methodInfo); visitPoolReferences(methodInfo.getClassInfo(), visitor, finder.getIds()); return new ReferenceResult(members, finder.getInvokeSites()); }","old_code_raw":"public static Set<String> findReferencedMembers(MethodInfo methodInfo) {\n    Set<String> members = new HashSet<String>();\n    ClassMemberVisitor visitor = new ClassMemberVisitor(members);\n    Set<Integer> ids = findPoolReferences(methodInfo);\n    visitor.visitMethod(methodInfo);\n    visitPoolReferences(methodInfo.getClassInfo(), visitor, ids);\n    return members;\n}","new_comment_raw":"@return a set of class names and class member signatures found in the method, as well as all invoke sites.","old_comment_raw":"@return a set of class names and class member signatures found in the method.","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":74},{"new_code_raw":"@Deprecated public ImmutableGraph executeSparqlQuery(ConstructQuery query, Graph defaultGraph) { return (ImmutableGraph) executeSparqlQuery((Query) query, defaultGraph); }","old_code_raw":"@Deprecated\npublic Graph executeSparqlQuery(ConstructQuery query, TripleCollection defaultGraph) {\n    return (Graph) executeSparqlQuery((Query) query, defaultGraph);\n}","new_comment_raw":"@return the resulting ImmutableGraph","old_comment_raw":"@return the resulting Graph","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"private Optional<List<CoreLabel>> getValidAdverbChunk(SemanticGraph parse, IndexedWord root, Optional<String> noopArc) { return getValidChunk(parse, root, VALID_ADVERB_ARCS, noopArc); }","old_code_raw":"  protected Optional<List<IndexedWord>> getValidAdverbChunk(SemanticGraph parse, IndexedWord root, Optional<String> noopArc) {\n    return getValidChunk(parse, root, VALID_ADVERB_ARCS, noopArc);\n  }\n","new_comment_raw":"@return If this subtree is a valid adverb, we return its yield. Otherwise, we return empty.","old_comment_raw":"@return If this subtree is a valid adverb, we return its yield. Otherwise, we return empty.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":30},{"new_code_raw":"public Client testClientModel(Client body) throws ApiException { Object localVarPostBody = body; \/\/ verify the required parameter 'body' is set if (body == null) { throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\"); } \/\/ create path and map variables String localVarPath = \"\/fake\"; \/\/ query params List<Pair> localVarQueryParams = new ArrayList<Pair>(); List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>(); Map<String, String> localVarHeaderParams = new HashMap<String, String>(); Map<String, Object> localVarFormParams = new HashMap<String, Object>(); final String[] localVarAccepts = { \"application\/json\" }; final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts); final String[] localVarContentTypes = { \"application\/json\" }; final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes); String[] localVarAuthNames = new String[] { }; GenericType<Client> localVarReturnType = new GenericType<Client>() {}; return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType); }","old_code_raw":"  public Client testClientModel(Client body) throws ApiException {\n    Object localVarPostBody = body;\n    \n    \/\/ verify the required parameter 'body' is set\n    if (body == null) {\n      throw new ApiException(400, \"Missing the required parameter 'body' when calling testClientModel\");\n    }\n    \n    \/\/ create path and map variables\n    String localVarPath = \"\/fake\";\n\n    \/\/ query params\n    List<Pair> localVarQueryParams = new ArrayList<Pair>();\n    Map<String, String> localVarHeaderParams = new HashMap<String, String>();\n    Map<String, Object> localVarFormParams = new HashMap<String, Object>();\n\n\n    \n    \n    final String[] localVarAccepts = {\n      \"application\/json\"\n    };\n    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);\n\n    final String[] localVarContentTypes = {\n      \"application\/json\"\n    };\n    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);\n\n    String[] localVarAuthNames = new String[] {  };\n\n    GenericType<Client> localVarReturnType = new GenericType<Client>() {};\n    return apiClient.invokeAPI(localVarPath, \"PATCH\", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAccept, localVarContentType, localVarAuthNames, localVarReturnType);\n      }\n","new_comment_raw":"@return Client","old_comment_raw":"@return Client","label":0,"pre_label":1,"AST_level":8,"line_counts":36,"new_code_token_num":210},{"new_code_raw":"protected Object convertString(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return \"\"; } return data.toString(); }","old_code_raw":"    protected Object convertString(Column column, Field fieldDefn, Object data) {\n        return data == null ? null : data.toString();\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":58},{"new_code_raw":"public ImageButton getImageButton(int index) { return getView(ImageButton.class, index); }","old_code_raw":"\tpublic ImageButton getImageButton(int index) {\n\t\tArrayList<ImageButton> buttonList = getCurrentViews(ImageButton.class);\n\t\tImageButton imageButton = null;\n\t\ttry{\n\t\t\timageButton = buttonList.get(index);\n\t\t}catch (IndexOutOfBoundsException e){\n\t\t\tAssert.assertTrue(\"No image button with index \" + index + \" is found\", false);\n\t\t}\n\t\treturn imageButton;\n\t}\n","new_comment_raw":"@return the  ImageButton with a specified index or  null if index is invalid","old_comment_raw":"@return the ImageButton with a specified index or null if index is invalid","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"protected boolean checkUsingModifiedFlag(Audited aud) { return globalCfg.hasSettingForUsingModifiedFlag() ? globalCfg.isUsingModifiedFlag() : aud.usingModifiedFlag(); }","old_code_raw":"\tprotected boolean checkUsingModifiedFlag(Audited aud) {\n\t\treturn globalCfg.isOverrideUsingModifiedFlag() ?\n\t\t\t\tglobalCfg.isUsingModifiedFlag() : aud.usingModifiedFlag();\n\t}\n","new_comment_raw":"@return False if this property is not audited.","old_comment_raw":"@return False if this property is not audited.","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof GJChronology) { GJChronology chrono = (GJChronology) obj; return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); } return false; }","old_code_raw":"    public boolean equals(Object obj) {\n        return super.equals(obj);\n    }\n","new_comment_raw":"@return true if equal","old_comment_raw":"@return true if equal","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":63},{"new_code_raw":"protected IsolationLevel getTransactionIsolation() { return this.transactionIsolationLevel; }","old_code_raw":"protected TransactionIsolation getTransactionIsolation() {\n    return this.transactionIsolationLevel;\n}","new_comment_raw":"@return the current {@link IsolationLevel} level. If no transaction is active, this may be <code>null<\/code>.","old_comment_raw":"@return the current {@link TransactionIsolation} level. If no transaction is active, this may be <code>null<\/code>.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public int compare(Object lhsObj, Object rhsObj) { InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj); Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null); long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono); \/\/ handle null==null and other cases where objects are the same \/\/ but only do this after checking the input is valid if (lhsObj == rhsObj) { return 0; } conv = ConverterManager.getInstance().getInstantConverter(rhsObj); Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null); long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono); if (iLowerLimit != null) { lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis); rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis); } if (iUpperLimit != null) { lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis); rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis); } if (lhsMillis < rhsMillis) { return -1; } else if (lhsMillis > rhsMillis) { return 1; } else { return 0; } }","old_code_raw":"    public int compare(Object lhsObj, Object rhsObj) {\n        InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj);\n        Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null);\n        long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono);\n        \n        conv = ConverterManager.getInstance().getInstantConverter(rhsObj);\n        Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null);\n        long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono);\n\n        if (iLowerLimit != null) {\n            lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis);\n            rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis);\n        }\n\n        if (iUpperLimit != null) {\n            lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis);\n            rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis);\n        }\n\n        if (lhsMillis < rhsMillis) {\n            return -1;\n        } else if (lhsMillis > rhsMillis) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n","new_comment_raw":"@return zero if order does not matter, negative value if lhsObj &lt; rhsObj, positive value otherwise.","old_comment_raw":"@return zero if order does not matter, negative value if lhsObj &lt; rhsObj, positive value otherwise.","label":0,"pre_label":1,"AST_level":9,"line_counts":34,"new_code_token_num":202},{"new_code_raw":"public Collection<TypedDependency> typedDependencies() { return typedDependencies(Extras.NONE); }","old_code_raw":"  public Collection<TypedDependency> typedDependencies() {\n    return typedDependencies(false);\n  }\n","new_comment_raw":"@return The typed dependencies of this grammatical structure","old_comment_raw":"@return The typed dependencies of this grammatical structure","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public WebDriver frame(final String nameOrIdOrIndex) { try { \/\/ 1.) try to find frame in current window ... currentWindow = findFrame(currentWindow, nameOrIdOrIndex); } catch (NoSuchFrameException ignored) { \/\/ 2.) try to find frame in top window ... final WebWindow topWindow = currentWindow.getTopWindow(); currentWindow = findFrame(topWindow, nameOrIdOrIndex); } return HtmlUnitDriver.this; }","old_code_raw":"    public WebDriver frame(final String name) {\n      WebWindow window = currentWindow.getTopWindow();\n\n      \/\/ Walk over all parts of the frame identifier, each time looking for a frame\n      \/\/ with a name or ID matching this part of the identifier (separated by '.').\n      String[] frames = name.split(\"\\\\.\");\n      for (int i = 0; i < frames.length; ++i) {\n        final String currentFrameId = frames[i];\n        final HtmlPage page = (HtmlPage) window.getEnclosedPage();\n        \n        if (isNumericFrameIdValid(currentFrameId, page)) {\n          window = getWindowByNumericFrameId(currentFrameId, page);\n        } else {\n          \/\/ Numeric frame ID is not valid - could be either because the identifier\n          \/\/ was numeric and not valid OR the number that was given is actually a frame\n          \/\/ name, not an index.\n          \n          boolean nextFrameFound = false;\n          for (final FrameWindow frameWindow : page.getFrames()) {\n            final String frameName = frameWindow.getName();\n            final String frameId = frameWindow.getFrameElement().getId();\n            final String remainingFrameId = joinFrom(frames, i, '.');\n            if (frameName.equals(remainingFrameId) || frameId.equals(remainingFrameId)) {\n              currentWindow = frameWindow;\n              return HtmlUnitDriver.this;\n            }\n            if (frameName.equals(currentFrameId) || frameId.equals(currentFrameId)) {\n              window = frameWindow;\n              nextFrameFound = true;\n            }\n          } \/\/ End for.\n          \n          if (!nextFrameFound) {\n            throw new NoSuchFrameException(\"Cannot find frame: \" + name);\n          }\n        } \/\/ End else\n\n      } \/\/ End for\n      \n      currentWindow = window;\n      return HtmlUnitDriver.this;\n    }\n","new_comment_raw":"@return This instance.","old_comment_raw":"@returns This instance.","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":70},{"new_code_raw":"public Options setComparators(GraphqlTypeComparatorRegistry comparatorRegistry) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, this.useAstDefinitions, comparatorRegistry); }","old_code_raw":"        public Options setComparators(GraphqlTypeComparatorRegistry comparatorRegistry) {\n            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.useAstDefinitions, this.includeDirectives,\n                    comparatorRegistry);\n        }\n","new_comment_raw":"@return options","old_comment_raw":"@return options","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":34},{"new_code_raw":"public static String formatArrayKey(String key) { if (isArrayKey(key)) { key = StringUtil.addSuffix(key.substring(NUM, key.length() - NUM), STR); } int index = key == null ? -NUM : key.indexOf(STR); if (index >= NUM) { return key.substring(index + NUM); } return formatKey(key, false, true, true, true); }","old_code_raw":"public static String formatArrayKey(String key) {\n    if (isArrayKey(key)) {\n        key = StringUtil.addSuffix(key.substring(NUM, key.length() - NUM), STR);\n    }\n    int index = key == null ? -NUM : key.indexOf(STR);\n    if (index >= NUM) {\n        return key.substring(index + NUM);\n    }\n    return formatKey(key, false, false, true, true);\n}","new_comment_raw":"@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = true, formatHyphen = true, firstCase = true","old_comment_raw":"@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = false, formatHyphen = true, firstCase = true","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":83},{"new_code_raw":"public static GraphicalModel readFromStream(InputStream stream) throws IOException { return readFromProto(GraphicalModelProto.GraphicalModel.parseDelimitedFrom(stream)); }","old_code_raw":"  public static GraphicalModel readFromStream(InputStream stream) throws IOException {\n    return readFromProto(GraphicalModelProto.GraphicalModel.parseFrom(stream));\n  }\n","new_comment_raw":"@return a new graphical model","old_comment_raw":"@return a new graphical model","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean parseRepositoryXml() throws MojoExecutionException { File fout = new File(m_repositoryXml); if (!fout.exists()) { Document doc = m_documentBuilder.newDocument(); Date d = new Date(); d.setTime(System.currentTimeMillis()); Element root = doc.createElement(STR); root.setAttribute(STR, m_format.format(d)); root.setAttribute(STR, STR); try { writeToFile(m_repositoryXml, root); } catch (MojoExecutionException e) { e.printStackTrace(); throw new MojoExecutionException(STR); } } m_repositoryDoc = parseFile(m_repositoryXml, m_documentBuilder); return (null != m_repositoryDoc); }","old_code_raw":"private int parseRepositoryXml() throws MojoExecutionException {\n    File fout = new File(m_repositoryXml);\n    if (!fout.exists()) {\n        Document doc = m_documentBuilder.newDocument();\n        Date d = new Date();\n        d.setTime(System.currentTimeMillis());\n        Element root = doc.createElement(STR);\n        root.setAttribute(STR, m_format.format(d));\n        root.setAttribute(STR, STR);\n        try {\n            writeToFile(m_repositoryXml, root);\n        } catch (MojoExecutionException e) {\n            e.printStackTrace();\n            throw new MojoExecutionException(STR);\n        }\n    }\n    m_repositoryDoc = parseFile(m_repositoryXml, m_documentBuilder);\n    if (m_repositoryDoc == null) {\n        return -NUM;\n    }\n    return NUM;\n}","new_comment_raw":"@return true if the repository file was parsed, otherwise false","old_comment_raw":"@return 0 if the bundle is already in the descriptor, else -1","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":122},{"new_code_raw":"public int read(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.read(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer); }","old_code_raw":"        public int read(Object[] row, long ts, int rowNumber) throws InterruptedException {\n            return converter.read(source, row, rowNumber, includedColumns, ts, consumer);\n        }\n","new_comment_raw":"@return the number of records produced; will be 0 or more","old_comment_raw":"@return the number of records produced; will be 0 or more","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":41},{"new_code_raw":"public Client testClassname(Client client) throws ApiException { return testClassnameWithHttpInfo(client).getData(); }","old_code_raw":"  public Client testClassname(Client body) throws ApiException {\n    return testClassnameWithHttpInfo(body).getData();\n      }\n","new_comment_raw":"@return Client","old_comment_raw":"@return Client","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public String toBooleanGetter(String name) { return getterAndSetterCapitalize(name); }","old_code_raw":"    public String toBooleanGetter(String name) {\n        return \"is\" + getterAndSetterCapitalize(name);\n    }\n","new_comment_raw":"@return partial getter name based on naming convention","old_comment_raw":"@return getter name based on naming convention","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public String[] getFilterExtensions() { return filterExtensions != null ? Arrays.copyOf(filterExtensions, filterExtensions.length) : new String[NUM]; }","old_code_raw":"public String[] getFilterExtensions() {\n    return filterExtensions != null ? Arrays.copyOf(filterExtensions, filterExtensions.length) : null;\n}","new_comment_raw":"@return The filter extensions string array.","old_comment_raw":"@return The filter extensions string array or <code>null<\/code>.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":29},{"new_code_raw":"public static ErrorInfo handler(final RuntimeException exception) { if (exception instanceof AbstractPlatformResourceNotFoundException) { final PlatformResourceNotFoundExceptionMapper mapper = new PlatformResourceNotFoundExceptionMapper(); final String errorBody = jsonHelper .toJson(mapper.toResponse((AbstractPlatformResourceNotFoundException) exception).getEntity()); return new ErrorInfo(404, 1001, errorBody); } else if (exception instanceof UnsupportedParameterException) { final UnsupportedParameterExceptionMapper mapper = new UnsupportedParameterExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((UnsupportedParameterException) exception).getEntity()); return new ErrorInfo(400, 2001, errorBody); } else if (exception instanceof PlatformApiDataValidationException) { final PlatformApiDataValidationExceptionMapper mapper = new PlatformApiDataValidationExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformApiDataValidationException) exception).getEntity()); return new ErrorInfo(400, 2002, errorBody); } else if (exception instanceof PlatformDataIntegrityException) { final PlatformDataIntegrityExceptionMapper mapper = new PlatformDataIntegrityExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformDataIntegrityException) exception).getEntity()); return new ErrorInfo(403, 3001, errorBody); } else if (exception instanceof LinkedAccountRequiredException) { final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((LinkedAccountRequiredException) exception).getEntity()); return new ErrorInfo(403, 3002, errorBody); } else if (exception instanceof MultiDisbursementDataRequiredException) { final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((MultiDisbursementDataRequiredException) exception).getEntity()); return new ErrorInfo(403, 3003, errorBody); } else if (exception instanceof TransactionException) { return new ErrorInfo(400, 4001, \"{\\\"Exception\\\": \" + exception.getMessage()+\"}\"); } else if (exception instanceof PlatformInternalServerException) { final PlatformInternalServerExceptionMapper mapper = new PlatformInternalServerExceptionMapper(); final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformInternalServerException) exception).getEntity()); return new ErrorInfo(500, 5001, errorBody); }else if(exception instanceof NonTransientDataAccessException) { return new ErrorInfo(400, 4001, \"{\\\"Exception\\\": \" + exception.getMessage()+\"}\"); } return new ErrorInfo(500, 9999, \"{\\\"Exception\\\": \" + exception.toString() + \"}\"); }","old_code_raw":"    public static ErrorInfo handler(final RuntimeException exception) {\n\n        if (exception instanceof AbstractPlatformResourceNotFoundException) {\n\n            final PlatformResourceNotFoundExceptionMapper mapper = new PlatformResourceNotFoundExceptionMapper();\n            final String errorBody = jsonHelper\n                    .toJson(mapper.toResponse((AbstractPlatformResourceNotFoundException) exception).getEntity());\n\n            return new ErrorInfo(404, 1001, errorBody);\n\n        } else if (exception instanceof UnsupportedParameterException) {\n\n            final UnsupportedParameterExceptionMapper mapper = new UnsupportedParameterExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((UnsupportedParameterException) exception).getEntity());\n\n            return new ErrorInfo(400, 2001, errorBody);\n\n        } else if (exception instanceof PlatformApiDataValidationException) {\n\n            final PlatformApiDataValidationExceptionMapper mapper = new PlatformApiDataValidationExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformApiDataValidationException) exception).getEntity());\n\n            return new ErrorInfo(400, 2002, errorBody);\n\n        } else if (exception instanceof PlatformDataIntegrityException) {\n\n            final PlatformDataIntegrityExceptionMapper mapper = new PlatformDataIntegrityExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformDataIntegrityException) exception).getEntity());\n\n            return new ErrorInfo(403, 3001, errorBody);\n\n        } else if (exception instanceof LinkedAccountRequiredException) {\n\n            final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((LinkedAccountRequiredException) exception).getEntity());\n\n            return new ErrorInfo(403, 3002, errorBody);\n            \n        } else if (exception instanceof MultiDisbursementDataRequiredException) {\n\n            final PlatformDomainRuleExceptionMapper mapper = new PlatformDomainRuleExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((MultiDisbursementDataRequiredException) exception).getEntity());\n\n            return new ErrorInfo(403, 3003, errorBody);\n            \n        } else if (exception instanceof TransactionException) {\n            return new ErrorInfo(400, 4001, \"{\\\"Exception\\\": \" + exception.getMessage()+\"}\");\n\n        } else if (exception instanceof PlatformInternalServerException) {\n\n            final PlatformInternalServerExceptionMapper mapper = new PlatformInternalServerExceptionMapper();\n            final String errorBody = jsonHelper.toJson(mapper.toResponse((PlatformInternalServerException) exception).getEntity());\n\n            return new ErrorInfo(500, 5001, errorBody);\n        }\n\n        return new ErrorInfo(500, 9999, \"{\\\"Exception\\\": \" + exception.toString() + \"}\");\n    }\n","new_comment_raw":"@return ErrorInfo","old_comment_raw":"@return ErrorInfo","label":0,"pre_label":1,"AST_level":17,"line_counts":61,"new_code_token_num":441},{"new_code_raw":"public Integer[] getVersions() { return vers; }","old_code_raw":"public Integer[] getVersions() {\n    return versions.keySet().toArray(new Integer[versions.keySet().size()]);\n}","new_comment_raw":"@return array for all available versions (sorted)","old_comment_raw":"@return iterator for all available versions","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"public String getMatches() { StringBuilder sb = new StringBuilder(); for(int i = 0, sz = list.getModel().getSize(); i < sz; i++) { Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree(); sb.append(t.pennString()); sb.append(\"\\n\\n\"); } return sb.toString(); }","old_code_raw":"  public StringBuffer getMatches() {\n    StringBuffer sb = new StringBuffer();\n    for(int i = 0; i < list.getModel().getSize(); i++) {\n      Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree();\n      sb.append(t.pennString());\n      sb.append(\"\\n\\n\");\n    }\n    return sb;\n  }\n","new_comment_raw":"@return String filled with the Penn treebank forms of all trees in the matches panel","old_comment_raw":"@return StringBuffer filled with the penn treebank forms of all trees in the matches panel","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":83},{"new_code_raw":"public String getUserAccountName() { return ((username != null) ? username : ANONYMOUS_USER); }","old_code_raw":"public String getUserAccountName() {\n    return username;\n}","new_comment_raw":"@return The user account name. The string represented by {@link #ANONYMOUS_USER} is returned if {@link #setUserAccountName(String)} was never called.","old_comment_raw":"@return The user account name. \"&lt;anonymous&gt;\" is returned if {@link #setUserAccountName(String)} was never called.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":20},{"new_code_raw":"public <RX extends RxInvokerProvider> Client buildRx(String name, Class<RX> invokerType) { return build(name).register(invokerType); }","old_code_raw":"public <RX extends RxInvoker> RxClient<RX> buildRx(String name, Class<RX> invokerType) {\n    return Rx.from(build(name), invokerType, executorService);\n}","new_comment_raw":"@return a fully-configured {@link Client}","old_comment_raw":"@return a fully-configured {@link RxClient}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":26},{"new_code_raw":"public boolean isToExclude(HttpMessage msg, NameValuePair param) { \/\/ Verify if check for the paramType should be maintained because \/\/ It's currently optimized using a Map in the container return ((paramType < 0) || (param.getType() == paramType)) && ((urlPattern == null) || urlPattern.matcher(msg.getRequestHeader().getURI().toString().toUpperCase(Locale.ROOT)).matches()) && (paramNamePattern.matcher(param.getName()).matches()); }","old_code_raw":"    public boolean isToExclude(HttpMessage msg, NameValuePair param) {\n        \/\/ Verify if check for the paramType should be maintained because\n        \/\/ It's currently optimized using a Map in the container\n        return ((paramType < 0) || (param.getType() == paramType)) &&\n                ((urlPattern == null) || urlPattern.matcher(msg.getRequestHeader().getURI().toString()).matches()) && \n                (paramNamePattern.matcher(param.getName()).matches());\n    }\n","new_comment_raw":"@return true if the parameter should be excluded","old_comment_raw":"@return true if the parameter should be excluded","label":0,"pre_label":1,"AST_level":10,"line_counts":8,"new_code_token_num":101},{"new_code_raw":"public LoggingConfiguration getLoggingConfiguration() { return loggingConfiguration; }","old_code_raw":"    public LoggingConfiguration getLoggingConfiguration() {\n        return logging;\n    }\n","new_comment_raw":"@return logging-specific configuration parameters","old_comment_raw":"@return logging-specific configuration parameters","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public DataType parse(TokenStream stream, Consumer<Collection<ParsingException>> errorHandler) { if (stream.hasNext()) { \/\/ Look for all patterns that begin with the first token ... Collection<DataTypePattern> matchingPatterns = patterns.get(stream.peek()); if (matchingPatterns != null) { \/\/ At least one registered type begins with the first token, so go through them all in order ... ErrorCollector errors = new ErrorCollector(); Marker mostReadMarker = null; DataType mostReadType = null; Marker marker = stream.mark(); for (DataTypePattern pattern : matchingPatterns) { DataType result = pattern.match(stream, errors::record); if (result != null) { \/\/ We found a match, so record it if it is better than our previous best ... if (!stream.hasNext()) { \/\/ There's no more to read, so we should be done ... return result; } Marker endMarker = stream.mark(); if (mostReadMarker == null || endMarker.compareTo(mostReadMarker) > 0) { mostReadMarker = endMarker; mostReadType = result; } } stream.rewind(marker); \/\/ always, even in the case of success } if (mostReadType != null) { \/\/ We've found at least one, so advance the stream to the end of what was consumed by that data type \/\/ and return the type that consumes the most of the stream ... stream.advance(mostReadMarker); return mostReadType; } \/\/ We still haven't found a data type ... errors.send(errorHandler); } } \/\/ Ultimately did not find a match ... return null; }","old_code_raw":"    public DataType parse(TokenStream stream, Consumer<Collection<ParsingException>> errorHandler) {\n        if (stream.hasNext()) {\n            \/\/ Look for all patterns that begin with the first token ...\n            Collection<DataTypePattern> matchingPatterns = patterns.get(stream.peek());\n            if (matchingPatterns != null) {\n                \/\/ At least one registered type begins with the first token, so go through them all in order ...\n                ErrorCollector errors = new ErrorCollector();\n                Marker mostReadMarker = null;\n                DataType mostReadType = null;\n                for (DataTypePattern pattern : matchingPatterns) {\n                    Marker marker = stream.mark();\n                    DataType result = pattern.match(stream, errors::record);\n                    if (result != null) {\n                        \/\/ We found a match, so record it if it is better than our previous best ...\n                        Marker endMarker = stream.mark();\n                        if (mostReadMarker == null || endMarker.compareTo(mostReadMarker) > 0) {\n                            mostReadMarker = endMarker;\n                            mostReadType = result;\n                        }\n                    }\n                    stream.rewind(marker); \/\/ always, even in the case of success\n                }\n                if (mostReadType != null) {\n                    \/\/ We've found at least one, so advance the stream to the end of what was consumed by that data type\n                    \/\/ and return the type that consumes the most of the stream ...\n                    stream.advance(mostReadMarker);\n                    return mostReadType;\n                }\n                \/\/ We still haven't found a data type ...\n                errors.send(errorHandler);\n            }\n        }\n        \/\/ Ultimately did not find a match ...\n        return null;\n    }\n","new_comment_raw":"@return the data type if one was found, or null if none were found","old_comment_raw":"@return the data type if one was found, or null if none were found","label":0,"pre_label":1,"AST_level":15,"line_counts":40,"new_code_token_num":300},{"new_code_raw":"public static Consumer<List> elasticsearchChecker(final String... strings) { return actual -> { Object[] actualArray = actual == null || actual.isEmpty() ? null : ((List) actual.get(NUM)).toArray(); CalciteAssert.assertArrayEqual(STR, strings, actualArray); }; }","old_code_raw":"public static Function<List, Void> elasticsearchChecker(final String... strings) {\n    return new Function<List, Void>() {\n\n        @Nullable\n        @Override\n        public Void apply(@Nullable List actual) {\n            Object[] actualArray = actual == null || actual.isEmpty() ? null : ((List) actual.get(NUM)).toArray();\n            CalciteAssert.assertArrayEqual(STR, strings, actualArray);\n            return null;\n        }\n    };\n}","new_comment_raw":"@return function to perform the check","old_comment_raw":"@return validation function","label":1,"pre_label":0,"AST_level":10,"line_counts":6,"new_code_token_num":57},{"new_code_raw":"public PersistentClass getClassMapping(String entityName) { return classes.get( entityName ); }","old_code_raw":"\tpublic PersistentClass getClassMapping(String entityName) {\n\t\treturn (PersistentClass) classes.get( entityName );\n\t}\n","new_comment_raw":"@return the entity mapping information","old_comment_raw":"@return the entity mapping information","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"protected Object convertDateToEpochDaysAsDate(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return new java.util.Date(0L); \/\/ return epoch } try { int epochDay = Date.toEpochDay(data); long epochMillis = TimeUnit.DAYS.toMillis(epochDay); return new java.util.Date(epochMillis); } catch (IllegalArgumentException e) { logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(), fieldDefn.schema(), data.getClass(), data); return null; } }","old_code_raw":"    protected Object convertDateToEpochDaysAsDate(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        try {\n            int epochDay = Date.toEpochDay(data);\n            long epochMillis = TimeUnit.DAYS.toMillis(epochDay);\n            return new java.util.Date(epochMillis);\n        } catch (IllegalArgumentException e) {\n            logger.warn(\"Unexpected JDBC DATE value for field {} with schema {}: class={}, value={}\", fieldDefn.name(),\n                        fieldDefn.schema(), data.getClass(), data);\n            return null;\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":9,"line_counts":19,"new_code_token_num":144},{"new_code_raw":"public synchronized IStatus validateDeploymentInfo() { if (deploymentInfo == null) { String message = NLS.bind(Messages.CloudFoundryApplicationModule_SERVER_OUT_OF_SYNC, server.getId()); IStatus status = CloudFoundryPlugin.getErrorStatus(message); setStatus(status); return status; } else { AbstractApplicationDelegate delegate = ApplicationRegistry.getApplicationDelegate(getLocalModule()); IStatus status = delegate != null ? delegate.validateDeploymentInfo(deploymentInfo) : CloudUtil.basicValidateDeploymentInfo(deploymentInfo); if (status == null) { status = Status.OK_STATUS; } if (!status.isOK()) { status = CloudFoundryPlugin.getErrorStatus(NLS.bind(Messages.ERROR_APP_DEPLOYMENT_VALIDATION_ERROR, getDeployedApplicationName(), status.getMessage())); } setStatus(status); return status; } }","old_code_raw":"public synchronized IStatus validateDeploymentInfo() {\n    AbstractApplicationDelegate delegate = ApplicationRegistry.getApplicationDelegate(getLocalModule());\n    if (delegate == null) {\n        return CloudUtil.basicValidateDeploymentInfo(deploymentInfo);\n    }\n    IStatus status = delegate.validateDeploymentInfo(deploymentInfo);\n    setStatus(status);\n    return status;\n}","new_comment_raw":"@return OK status if deployment information is complete and valid. Returns an error status if invalid (i.e. it is missing some information).","old_comment_raw":"@return OK status if deployment information is complete and valid. Error if failed to validate, or is invalid (i.e. it is missing information).","label":1,"pre_label":0,"AST_level":11,"line_counts":19,"new_code_token_num":126},{"new_code_raw":"public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) { return new InstrumentationFieldCompleteParameters( this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, this.fetchedValue, instrumentationState); }","old_code_raw":"    public InstrumentationFieldCompleteParameters withNewState(InstrumentationState instrumentationState) {\n        return new InstrumentationFieldCompleteParameters(\n                this.executionContext, executionStrategyParameters, this.fieldDef, this.typeInfo, instrumentationState);\n    }\n","new_comment_raw":"@return a new parameters object with the new state","old_comment_raw":"@return a new parameters object with the new state","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"protected Destination getDestinationFromURI(WebClient client, HttpServletRequest request) throws JMSException { String uri = request.getPathInfo(); if (uri == null) return null; \/\/ replace URI separator with JMS destination separator if (uri.startsWith(\"\/\")) { uri = uri.substring(1); if (uri.length()==0) return null; } uri = uri.replace('\/', '.'); System.err.println(\"destination uri=\"+uri); return getDestination(client, request, uri); }","old_code_raw":"    protected Destination getDestinationFromURI(WebClient client, HttpServletRequest request) throws JMSException {\n        String uri = request.getPathInfo();\n        if (uri == null) {\n            return null;\n        }\n        \/\/ replace URI separator with JMS destination separator\n        if (uri.startsWith(\"\/\")) {\n            uri = uri.substring(1);\n        }\n        uri = uri.replace('\/', '.');\n        System.err.println(\"destination uri=\"+uri);\n        return getDestination(client, request, uri);\n    }\n","new_comment_raw":"@return the destination to use for the current request using the relative URI from where this servlet was invoked as the destination name","old_comment_raw":"@return the destination to use for the current request using the relative URI from where this servlet was invoked as the destination name","label":0,"pre_label":1,"AST_level":8,"line_counts":17,"new_code_token_num":102},{"new_code_raw":"private <T> T processResponse(final ClientResponse clientResponse, final Type responseType) { final String response = readResponseFromClientResponse(clientResponse); if (clientResponse.getStatus() == NUM) { return null; } else if (clientResponse.getStatus() >= NUM) { throw new HandshakeAPIException(response); } try { return parseJson(response, responseType); } catch (final IOException e) { throw new RuntimeException(e); } }","old_code_raw":"private <T> T processResponse(final ClientResponse clientResponse, final Type responseType) {\n    final String response = readResponseFromClientResponse(clientResponse);\n    if (clientResponse.getStatus() >= NUM) {\n        throw new HandshakeAPIException(response);\n    }\n    try {\n        return parseJson(response, responseType);\n    } catch (final IOException e) {\n        throw new RuntimeException(e);\n    }\n}","new_comment_raw":"@return the response, null if not found, or an Exception if something bad happened","old_comment_raw":"@return the response, or an Exception if something bad happened","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":80},{"new_code_raw":"public static Months parseMonths(String periodStr) { throw ExceptionUtils.unsupportedInGwt(); \/\/ if (periodStr == null) { \/\/ return Months.ZERO; \/\/ } \/\/ Period p = PARSER.parsePeriod(periodStr); \/\/ return Months.months(p.getMonths()); }","old_code_raw":"    public static Months parseMonths(String periodStr) {\n        if (periodStr == null) {\n            return Months.ZERO;\n        }\n        Period p = PARSER.parsePeriod(periodStr);\n        return Months.months(p.getMonths());\n    }\n","new_comment_raw":"@return the period in months","old_comment_raw":"@return the period in months","label":0,"pre_label":1,"AST_level":4,"line_counts":9,"new_code_token_num":55},{"new_code_raw":"public double conditionalLogProbGivenNext(int[] given, int of) { if (given.length != windowSize - 1) { throw new IllegalArgumentException(\"conditionalLogProbGivenNext requires given one less than clique size (\" + windowSize + \") but was \" + Arrays.toString(given)); } int[] label = indicesEnd(given); double[] masses = new double[label.length]; for (int i = 0; i < masses.length; i++) { masses[i] = table[label[i]]; } return table[indexOf(of, given)] - ArrayMath.logSum(masses); }","old_code_raw":"  public double conditionalLogProbGivenNext(int[] given, int of) {\n    if (given.length != windowSize - 1) {\n      throw new IllegalArgumentException(\"conditionalLogProbGivenNext requires given one less than clique size (\" +\n          windowSize + \") but was \" + Arrays.toString(given));\n    }\n    int[] label = indicesEnd(given);\n    double[] masses = new double[label.length];\n    for (int i = 0; i < masses.length; i++) {\n      masses[i] = table[label[i]];\n    }\n    double z = ArrayMath.logSum(masses);\n\n    return table[indexOf(of, given)] - z;\n  }\n","new_comment_raw":"@return the probability of the tag of being at the beginning of the table","old_comment_raw":"@return the probability of the tag of being at the beginning of the table","label":0,"pre_label":1,"AST_level":11,"line_counts":13,"new_code_token_num":121},{"new_code_raw":"public Call123testSpecialTagsOper reqSpec(Consumer<RequestSpecBuilder> consumer) { consumer.accept(reqSpec); return this; }","old_code_raw":"        public TestSpecialTagsOper reqSpec(Consumer<RequestSpecBuilder> consumer) {\n            consumer.accept(reqSpec);\n            return this;\n        }\n","new_comment_raw":"@return operation","old_comment_raw":"@return operation","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"private static YearClass categorizeByYear(Context c) { ArrayList<YearClass> componentYears = new ArrayList<YearClass>(); conditionallyAdd(componentYears, YearClass.fromNumberOfCores()); conditionallyAdd(componentYears, YearClass.fromClockSpeed()); conditionallyAdd(componentYears, YearClass.fromRamTotal(c)); if (componentYears.isEmpty()) return YearClass.CLASS_UNKNOWN; Collections.sort(componentYears); if ((componentYears.size() & NUM) == NUM) { return componentYears.get(componentYears.size() \/ NUM); } else { int baseIndex = componentYears.size() \/ NUM - NUM; int averageRoundedDown = componentYears.get(baseIndex).mIntValue + (componentYears.get(baseIndex + NUM).mIntValue - componentYears.get(baseIndex).mIntValue) \/ NUM; return YearClass.fromIntValue(averageRoundedDown); } }","old_code_raw":"private static int categorizeByYear(Context c) {\n    ArrayList<Integer> componentYears = new ArrayList<Integer>();\n    conditionallyAdd(componentYears, getNumCoresYear());\n    conditionallyAdd(componentYears, getClockSpeedYear());\n    conditionallyAdd(componentYears, getRamYear(c));\n    if (componentYears.isEmpty())\n        return CLASS_UNKNOWN;\n    Collections.sort(componentYears);\n    if ((componentYears.size() & NUM) == NUM) {\n        return componentYears.get(componentYears.size() \/ NUM);\n    } else {\n        int baseIndex = componentYears.size() \/ NUM - NUM;\n        return componentYears.get(baseIndex) + (componentYears.get(baseIndex + NUM) - componentYears.get(baseIndex)) \/ NUM;\n    }\n}","new_comment_raw":"@return The YearClass when this device would have been considered top-of-the-line.","old_comment_raw":"@return The year when this device would have been considered top-of-the-line.","label":1,"pre_label":0,"AST_level":12,"line_counts":16,"new_code_token_num":143},{"new_code_raw":"public DateOnly roundHalfEvenCopy() { DateOnly instant = iInstant; return instant.withMillis(iField.roundHalfEven(instant.getMillis())); }","old_code_raw":"    public DateOnly roundHalfEvenCopy() {\n        DateOnly instant = iInstant;\n        return (DateOnly)instant.withMillis(iField.roundHalfEven(instant.getMillis()));\n    }\n","new_comment_raw":"@return a copy of the DateOnly with the field value changed","old_comment_raw":"@return a copy of the DateOnly with the field value changed","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public PMetadata getCache(PGraphics renderer) { return g.getCache(renderer); }","old_code_raw":"  public Object getCache(Object parent) {\n    return g.getCache(parent);\n  }\n","new_comment_raw":"@return metadata stored for the specified renderer","old_comment_raw":"@return data stored for the specified parent","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public TregexMatcher matcher(Tree t, HeadFinder headFinder) { return matcher(t, t, null, ArrayMap.newArrayMap(), new VariableStrings(), headFinder); }","old_code_raw":"  public TregexMatcher matcher(Tree t, HeadFinder headFinder) {\n    return matcher(t, t, null, ArrayMap.<String, Tree>newArrayMap(), new VariableStrings(), headFinder);\n  }\n","new_comment_raw":"@return a TregexMatcher","old_comment_raw":"@return a TregexMatcher","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public Throwable getCause() { return super.getCause(); }","old_code_raw":"public Throwable getCause() {\n    return cause;\n}","new_comment_raw":"@return The cause of this exception or <code>null<\/code> if no cause was set.","old_comment_raw":"@return The cause of this exception or <code>null<\/code> if no cause was specified.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public static FactorTable getFactorTable(double[][] weights, int[][] data, Index[] labelIndices, int numClasses) { CliquePotentialFunction cliquePotentialFunc = new LinearCliquePotentialFunction(weights); return getFactorTable(data, labelIndices, numClasses, cliquePotentialFunc); }","old_code_raw":"  static FactorTable getFactorTable(double[][] weights, int[][] data, List<Index<CRFLabel>> labelIndices, int numClasses) {\n    CliquePotentialFunction cliquePotentialFunc = new LinearCliquePotentialFunction(weights);\n    return getFactorTable(data, labelIndices, numClasses, cliquePotentialFunc, null);\n  }\n","new_comment_raw":"@return a new CRFCliqueTree for the weights on the data","old_comment_raw":"@return a new CRFCliqueTree for the weights on the data","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":49},{"new_code_raw":"public BlankNodeOrIri convertNonLiteral(Node node) { if (node == null) { throw new IllegalArgumentException(STR); } if (node.isBlank()) { return convertJenaNode2TriaBlankNode(node); } if (node.isURI()) { return convertJenaUri2UriRef(node); } throw new RuntimeException(STR + node + STR); }","old_code_raw":"public NonLiteral convertNonLiteral(Node node) {\n    if (node == null) {\n        throw new IllegalArgumentException(STR);\n    }\n    if (node.isBlank()) {\n        return convertJenaNode2TriaBlankNode(node);\n    }\n    if (node.isURI()) {\n        return convertJenaUri2UriRef(node);\n    }\n    throw new RuntimeException(STR + node + STR);\n}","new_comment_raw":"@return BlankNode if it is a Blank Node otherwise a Iri","old_comment_raw":"@return BNode if it is a Blank Node otherwise a UriRef","label":1,"pre_label":0,"AST_level":7,"line_counts":12,"new_code_token_num":64},{"new_code_raw":"protected ComponentTemplate getMetaData(final Object entry) { return (ComponentTemplate) entry; }","old_code_raw":"protected ComponentMetaData getMetaData(final Object entry) {\n    return (ComponentMetaData) entry;\n}","new_comment_raw":"@return the ComponentTemplate","old_comment_raw":"@return the ComponentMetaData","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"private boolean fetchRegistry() { ClientResponse response = null; Stopwatch tracer = fetchRegistryTimer.start(); try { \/\/ If the delta is disabled or if it is the first time, get all \/\/ applications if (EUREKA_SERVER_CONFIG.shouldDisableDeltaForRemoteRegions() || (getApplications() == null) || (getApplications().getRegisteredApplications().size() == 0)) { logger.info(\"Disable delta property : {}\", EUREKA_SERVER_CONFIG .shouldDisableDeltaForRemoteRegions()); logger.info(\"Application is null : {}\", (getApplications() == null)); logger.info( \"Registered Applications size is zero : {}\", (getApplications().getRegisteredApplications().size() == 0)); response = storeFullRegistry(); } else { Applications delta = null; response = fetchRemoteRegistry(true); if (null != response) { if (response.getStatus() == Status.OK.getStatusCode()) { delta = response.getEntity(Applications.class); this.applicationsDelta.set(delta); } if (delta == null) { logger.warn(\"The server does not allow the delta revision to be applied because it is not safe. Hence got the full registry.\"); this.closeResponse(response); response = fetchRemoteRegistry(true); } else { updateDelta(delta); String reconcileHashCode = getApplications() .getReconcileHashCode(); \/\/ There is a diff in number of instances for some reason if ((!reconcileHashCode.equals(delta.getAppsHashCode()))) { response = reconcileAndLogDifference(response, delta, reconcileHashCode); } } logTotalInstances(); } } logger.debug(\"Remote Registry Fetch Status : {}\", null == response ? null : response.getStatus()); } catch (Throwable e) { logger.error( \"Unable to fetch registry information from the remote registry \" + this.remoteRegionURL.toString(), e); return false; } finally { if (tracer != null) { tracer.stop(); } closeResponse(response); } return null != response; }","old_code_raw":"    private boolean fetchRegistry() {\n        ClientResponse response = null;\n        Stopwatch tracer = fetchRegistryTimer.start();\n\n        try {\n            \/\/ If the delta is disabled or if it is the first time, get all\n            \/\/ applications\n            if (EUREKA_SERVER_CONFIG.shouldDisableDeltaForRemoteRegions()\n                    || (getApplications() == null)\n                    || (getApplications().getRegisteredApplications().size() == 0)) {\n                logger.info(\"Disable delta property : {}\", EUREKA_SERVER_CONFIG\n                        .shouldDisableDeltaForRemoteRegions());\n                logger.info(\"Application is null : {}\",\n                        (getApplications() == null));\n                logger.info(\n                        \"Registered Applications size is zero : {}\",\n                        (getApplications().getRegisteredApplications().size() == 0));\n                response = storeFullRegistry();\n            } else {\n                Applications delta = null;\n                response = fetchRemoteRegistry(true);\n                if (response.getStatus() == Status.OK.getStatusCode()) {\n                    delta = response.getEntity(Applications.class);\n                    this.applicationsDelta.set(delta);\n                }\n                if (delta == null) {\n                    logger.warn(\"The server does not allow the delta revision to be applied because it is not safe. Hence got the full registry.\");\n                    this.closeResponse(response);\n                    response = fetchRemoteRegistry(true);\n                } else {\n                    updateDelta(delta);\n                    String reconcileHashCode = getApplications()\n                            .getReconcileHashCode();\n                    \/\/ There is a diff in number of instances for some reason\n                    if ((!reconcileHashCode.equals(delta.getAppsHashCode()))) {\n                        response = reconcileAndLogDifference(response, delta,\n                                reconcileHashCode);\n\n                    }\n                }\n                logTotalInstances();\n            }\n            logger.debug(\"Remote Registry Fetch Status : {}\", null == response ? null : response.getStatus());\n        } catch (Throwable e) {\n            logger.error(\n                    \"Unable to fetch registry information from the remote registry \"\n                            + this.remoteRegionURL.toString(), e);\n            return false;\n\n        } finally {\n            if (tracer != null) {\n                tracer.stop();\n            }\n            closeResponse(response);\n        }\n        return true;\n    }\n","new_comment_raw":"@return true, if the fetch was successful, false otherwise.","old_comment_raw":"@return true, if the fetch was successful, false otherwise.","label":0,"pre_label":1,"AST_level":15,"line_counts":59,"new_code_token_num":384},{"new_code_raw":"public static final TwitterTokenStream of(TwitterTokenStream... streams) { return new TokenStreamAggregator(streams); }","old_code_raw":"public static final TokenStream of(TokenStream... streams) {\n    return new TokenStreamAggregator(streams);\n}","new_comment_raw":"@return an aggregated TwitterTokenStream","old_comment_raw":"@return an aggregated TokenStream","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) { return appendDecimal(iChronoUTC.dayOfYear(), minDigits, 3); }","old_code_raw":"    public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {\n        return appendNumeric(iChronoUTC.dayOfYear(), minDigits, 3);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public File getGeneratedOutput() throws CurnException { return null; }","old_code_raw":"public InputStream getGeneratedOutput() throws CurnException {\n    return null;\n}","new_comment_raw":"@return null, unconditionally","old_comment_raw":"@return an open input stream, or null if no suitable output was produced","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":12},{"new_code_raw":"protected BroadcasterConfig createBroadcasterConfig(AtmosphereConfig config){ return new BroadcasterConfig(config.framework().broadcasterFilters, config); }","old_code_raw":"    protected BroadcasterConfig createBroadcasterConfig(AtmosphereConfig config){\n        return new BroadcasterConfig(AtmosphereServlet.broadcasterFilters, config);\n    }\n","new_comment_raw":"@return an instance of  BroadcasterConfig","old_comment_raw":"@return an instance of BroadcasterConfig","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, List<Field>> fields) { for (Selection selection : selectionSet.getSelections()) { if (selection instanceof Field) { collectField(parameters, fields, (Field) selection); } else if (selection instanceof InlineFragment) { collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection); } else if (selection instanceof FragmentSpread) { collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection); } } }","old_code_raw":"    public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) {\n        Map<String, MergedFields> subFields = new LinkedHashMap<>();\n        List<String> visitedFragments = new ArrayList<>();\n        this.collectFields(parameters, selectionSet, visitedFragments, subFields);\n        return newMergedSelectionSet().subFields(subFields).build();\n    }\n","new_comment_raw":"@return a map of the sub field selections","old_comment_raw":"@return a map of the sub field selections","label":0,"pre_label":1,"AST_level":12,"line_counts":13,"new_code_token_num":101},{"new_code_raw":"public Builder hasArg() { return hasArg(true); }","old_code_raw":"public boolean hasArg() {\n    return numberOfArgs > NUM || numberOfArgs == UNLIMITED_VALUES;\n}","new_comment_raw":"@return this builder, to allow method chaining","old_comment_raw":"@return boolean flag indicating if an argument is required","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public static Blob generateProxy(InputStream stream, long length) { return new BlobProxy( stream, length ); }","old_code_raw":"\tpublic static Blob generateProxy(InputStream stream, long length) {\n\t\treturn (Blob) Proxy.newProxyInstance( getProxyClassLoader(), PROXY_INTERFACES, new BlobProxy( stream, length ) );\n\t}\n","new_comment_raw":"@return The BlobProxy instance to represent this data.","old_comment_raw":"@return The generated proxy.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"protected void checkFont() { Font awtFont = textFont.getFont(); if (awtFont == null) { \/\/ always need a native font or reference to it throw new RuntimeException(\"Use createFont() instead of loadFont() \" + \"when drawing text using the PDF library.\"); } else if (textMode != SHAPE) { if (textFont.isStream()) { throw new RuntimeException(\"Use textMode(SHAPE) with when loading \" + \".ttf and .otf files with createFont().\"); } else if (mapper.getAliases().get(textFont.getName()) == null) { \/\/System.out.println(\"alias for \" + name + \" = \" + mapper.getAliases().get(name)); System.err.println(\"Use PGraphicsPDF.listFonts() to get a list of \" + \"fonts that can be used with PDF.\"); throw new RuntimeException(\"The font \u00e2\u0080\u009c\" + textFont.getName() + \"\u00e2\u0080\u009d \" + \"cannot be used with PDF Export.\"); } } }","old_code_raw":"  protected boolean checkFont(String name) {\n    \/\/System.out.println(\"alias for \" + name + \" = \" + mapper.getAliases().get(name));\n    return mapper.getAliases().get(name) != null;\n  }\n","new_comment_raw":"@return true if it's ok","old_comment_raw":"@return true if it's ok","label":0,"pre_label":1,"AST_level":14,"line_counts":19,"new_code_token_num":205},{"new_code_raw":"private boolean canCombine(RelNode input, boolean nullGenerating) { return input instanceof MultiJoin && !((MultiJoin) input).isFullOuterJoin() && !((MultiJoin) input).containsOuter() && !nullGenerating; }","old_code_raw":"  private boolean canCombine(RelNode input, boolean nullGenerating) {\n    return input instanceof MultiJoinRel\n        && !((MultiJoinRel) input).isFullOuterJoin()\n        && !((MultiJoinRel) input).containsOuter()\n        && !nullGenerating;\n  }\n","new_comment_raw":"@return true if the input can be combined into a parent MultiJoin","old_comment_raw":"@return true if the input can be combined into a parent MultiJoinRel","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":45},{"new_code_raw":"public boolean shouldAllowAccess() { boolean allowAccess = false; if (this.peerInstancesTransferEmptyOnStartup) { if (System.currentTimeMillis() > this.startupTime + eurekaServerConfig.getWaitTimeInMsWhenSyncEmpty()) { allowAccess = true; } else { allowAccess = false; } } for (RemoteRegionRegistry remoteRegionRegistry: this.remoteRegionRegistryList) { if (!remoteRegionRegistry.isReadyForServingData()) { return false; } } return allowAccess; }","old_code_raw":"    public boolean shouldAllowAccess() {\n        if (this.peerInstancesTransferEmptyOnStartup) {\n            if (System.currentTimeMillis() > this.startupTime\n                    + eurekaServerConfig.getWaitTimeInMsWhenSyncEmpty()) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n","new_comment_raw":"@return false - if the instances count from a replica transfer returned zero and if the wait time has not elapsed, o otherwise returns true","old_comment_raw":"@return false - if the instances count from a replica transfer returned zero and if the wait time has not elapsed, o otherwise returns true","label":0,"pre_label":1,"AST_level":9,"line_counts":18,"new_code_token_num":69},{"new_code_raw":"public boolean dispatchDataChangeEvent(T dataCollectionId, ChangeRecordEmitter changeRecordEmitter) throws InterruptedException { try { boolean handled = false; if (!filter.isIncluded(dataCollectionId)) { LOGGER.trace(\"Filtered data change event for {}\", dataCollectionId); eventListener.onFilteredEvent(\"source = \" + dataCollectionId); } else { DataCollectionSchema dataCollectionSchema = schema.schemaFor(dataCollectionId); \/\/ TODO handle as per inconsistent schema info option if (dataCollectionSchema == null) { final Optional<DataCollectionSchema> replacementSchema = inconsistentSchemaHandler.handle(dataCollectionId, changeRecordEmitter); if (!replacementSchema.isPresent()) { return false; } dataCollectionSchema = replacementSchema.get(); } changeRecordEmitter.emitChangeRecords(dataCollectionSchema, new Receiver() { @Override public void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value, OffsetContext offset) throws InterruptedException { transactionMonitor.dataEvent(dataCollectionId, offset, key, value); eventListener.onEvent(dataCollectionId, offset, key, value); streamingReceiver.changeRecord(schema, operation, key, value, offset); } }); handled = true; } heartbeat.heartbeat( changeRecordEmitter.getOffset().getPartition(), changeRecordEmitter.getOffset().getOffset(), this::enqueueHeartbeat); return handled; } catch (Exception e) { switch (connectorConfig.getEventProcessingFailureHandlingMode()) { case FAIL: LOGGER.error( \"Error while processing event at offset {}\", changeRecordEmitter.getOffset().getOffset()); throw e; case WARN: LOGGER.warn( \"Error while processing event at offset {}\", changeRecordEmitter.getOffset().getOffset()); break; case IGNORE: LOGGER.debug( \"Error while processing event at offset {}\", changeRecordEmitter.getOffset().getOffset()); break; } return false; } }","old_code_raw":"    public boolean dispatchDataChangeEvent(T dataCollectionId, ChangeRecordEmitter changeRecordEmitter) throws InterruptedException {\n        boolean handled = false;\n        if (!filter.isIncluded(dataCollectionId)) {\n            LOGGER.trace(\"Filtered data change event for {}\", dataCollectionId);\n            eventListener.onFilteredEvent(\"source = \" + dataCollectionId);\n        }\n        else {\n            DataCollectionSchema dataCollectionSchema = schema.schemaFor(dataCollectionId);\n\n            \/\/ TODO handle as per inconsistent schema info option\n            if (dataCollectionSchema == null) {\n                final Optional<DataCollectionSchema> replacementSchema = inconsistentSchemaHandler.handle(dataCollectionId, changeRecordEmitter);\n                if (!replacementSchema.isPresent()) {\n                    return false;\n                }\n                dataCollectionSchema = replacementSchema.get();\n            }\n\n            changeRecordEmitter.emitChangeRecords(dataCollectionSchema, new Receiver() {\n\n                @Override\n                public void changeRecord(DataCollectionSchema schema, Operation operation, Object key, Struct value,\n                                         OffsetContext offset)\n                        throws InterruptedException {\n                    transactionMonitor.dataEvent(dataCollectionId, offset, key, value);\n                    eventListener.onEvent(dataCollectionId, offset, key, value);\n                    streamingReceiver.changeRecord(schema, operation, key, value, offset);\n                }\n            });\n            handled = true;\n        }\n\n        heartbeat.heartbeat(\n                changeRecordEmitter.getOffset().getPartition(),\n                changeRecordEmitter.getOffset().getOffset(),\n                this::enqueueHeartbeat);\n\n        return handled;\n    }\n","new_comment_raw":"@return  true if an event was dispatched (i.e. sent to the message broker),  false otherwise.","old_comment_raw":"@return true if an event was dispatched (i.e. sent to the message broker), false otherwise.","label":0,"pre_label":1,"AST_level":12,"line_counts":62,"new_code_token_num":328},{"new_code_raw":"public RdfTerm convertJenaNode2Resource(Node node) { if (node == null) { throw new IllegalArgumentException(STR); } if (node.isBlank()) { return convertJenaNode2TriaBlankNode(node); } if (node.isURI()) { return convertJenaUri2UriRef(node); } if (node.isLiteral()) { return convertJenaLiteral2Literal(node); } throw new RuntimeException(STR + node + STR); }","old_code_raw":"public Resource convertJenaNode2Resource(Node node) {\n    if (node == null) {\n        throw new IllegalArgumentException(STR);\n    }\n    if (node.isBlank()) {\n        return convertJenaNode2TriaBlankNode(node);\n    }\n    if (node.isURI()) {\n        return convertJenaUri2UriRef(node);\n    }\n    if (node.isLiteral()) {\n        return convertJenaLiteral2Literal(node);\n    }\n    throw new RuntimeException(STR + node + STR);\n}","new_comment_raw":"@return BlankNode if it is a Blank Node, Iri if it is a URI and Literal if it is a literal.","old_comment_raw":"@return BNode if it is a Blank Node, UriRef if it is a URI and Literal if it is a literal.","label":1,"pre_label":0,"AST_level":7,"line_counts":15,"new_code_token_num":79},{"new_code_raw":"public HashSet<String> updateDBIcons(UserHandleCompat user, List<LauncherActivityInfoCompat> apps) { mIconDb.updateSystemStateString(mContext); long userSerial = mUserManager.getSerialNumberForUser(user); PackageManager pm = mContext.getPackageManager(); HashMap<String, PackageInfo> pkgInfoMap = new HashMap<String, PackageInfo>(); for (PackageInfo info : pm.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES)) { pkgInfoMap.put(info.packageName, info); } HashMap<ComponentName, LauncherActivityInfoCompat> componentMap = new HashMap<>(); for (LauncherActivityInfoCompat app : apps) { componentMap.put(app.getComponentName(), app); } Cursor c = mIconDb.getReadableDatabase().query(IconDB.TABLE_NAME, new String[] {IconDB.COLUMN_ROWID, IconDB.COLUMN_COMPONENT, IconDB.COLUMN_LAST_UPDATED, IconDB.COLUMN_VERSION, IconDB.COLUMN_SYSTEM_STATE}, IconDB.COLUMN_USER + \" = ? \", new String[] {Long.toString(userSerial)}, null, null, null); final int indexComponent = c.getColumnIndex(IconDB.COLUMN_COMPONENT); final int indexLastUpdate = c.getColumnIndex(IconDB.COLUMN_LAST_UPDATED); final int indexVersion = c.getColumnIndex(IconDB.COLUMN_VERSION); final int rowIndex = c.getColumnIndex(IconDB.COLUMN_ROWID); final int systemStateIndex = c.getColumnIndex(IconDB.COLUMN_SYSTEM_STATE); HashSet<Integer> itemsToRemove = new HashSet<Integer>(); HashSet<String> updatedPackages = new HashSet<String>(); while (c.moveToNext()) { String cn = c.getString(indexComponent); ComponentName component = ComponentName.unflattenFromString(cn); PackageInfo info = pkgInfoMap.get(component.getPackageName()); if (info == null) { itemsToRemove.add(c.getInt(rowIndex)); continue; } if ((info.applicationInfo.flags & ApplicationInfo.FLAG_IS_DATA_ONLY) != 0) { \/\/ Application is not present continue; } long updateTime = c.getLong(indexLastUpdate); int version = c.getInt(indexVersion); LauncherActivityInfoCompat app = componentMap.remove(component); if (version == info.versionCode && updateTime == info.lastUpdateTime && TextUtils.equals(mIconDb.mSystemState, c.getString(systemStateIndex))) { continue; } if (app == null) { itemsToRemove.add(c.getInt(rowIndex)); continue; } ContentValues values = updateCacheAndGetContentValues(app, true); mIconDb.getWritableDatabase().update(IconDB.TABLE_NAME, values, IconDB.COLUMN_COMPONENT + \" = ? AND \" + IconDB.COLUMN_USER + \" = ?\", new String[] {cn, Long.toString(userSerial)}); updatedPackages.add(component.getPackageName()); } c.close(); if (!itemsToRemove.isEmpty()) { mIconDb.getWritableDatabase().delete(IconDB.TABLE_NAME, IconDB.COLUMN_ROWID + \" IN ( \" + TextUtils.join(\", \", itemsToRemove) +\" )\", null); } \/\/ Insert remaining apps. if (!componentMap.isEmpty()) { mWorkerHandler.post(new SerializedIconAdditionTask(userSerial, pkgInfoMap, componentMap.values())); } return updatedPackages; }","old_code_raw":"    private void updateDBIcons(UserHandleCompat user, List<LauncherActivityInfoCompat> apps) {\n        long userSerial = mUserManager.getSerialNumberForUser(user);\n        PackageManager pm = mContext.getPackageManager();\n        HashMap<String, PackageInfo> pkgInfoMap = new HashMap<String, PackageInfo>();\n        for (PackageInfo info : pm.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES)) {\n            pkgInfoMap.put(info.packageName, info);\n        }\n\n        HashMap<ComponentName, LauncherActivityInfoCompat> componentMap = new HashMap<>();\n        for (LauncherActivityInfoCompat app : apps) {\n            componentMap.put(app.getComponentName(), app);\n        }\n\n        Cursor c = mIconDb.getReadableDatabase().query(IconDB.TABLE_NAME,\n                new String[] {IconDB.COLUMN_ROWID, IconDB.COLUMN_COMPONENT,\n                    IconDB.COLUMN_LAST_UPDATED, IconDB.COLUMN_VERSION,\n                    IconDB.COLUMN_SYSTEM_STATE},\n                IconDB.COLUMN_USER + \" = ? \",\n                new String[] {Long.toString(userSerial)},\n                null, null, null);\n\n        final int indexComponent = c.getColumnIndex(IconDB.COLUMN_COMPONENT);\n        final int indexLastUpdate = c.getColumnIndex(IconDB.COLUMN_LAST_UPDATED);\n        final int indexVersion = c.getColumnIndex(IconDB.COLUMN_VERSION);\n        final int rowIndex = c.getColumnIndex(IconDB.COLUMN_ROWID);\n        final int systemStateIndex = c.getColumnIndex(IconDB.COLUMN_SYSTEM_STATE);\n\n        HashSet<Integer> itemsToRemove = new HashSet<Integer>();\n        Stack<LauncherActivityInfoCompat> appsToUpdate = new Stack<>();\n\n        while (c.moveToNext()) {\n            String cn = c.getString(indexComponent);\n            ComponentName component = ComponentName.unflattenFromString(cn);\n            PackageInfo info = pkgInfoMap.get(component.getPackageName());\n            if (info == null) {\n                itemsToRemove.add(c.getInt(rowIndex));\n                continue;\n            }\n            if ((info.applicationInfo.flags & ApplicationInfo.FLAG_IS_DATA_ONLY) != 0) {\n                \/\/ Application is not present\n                continue;\n            }\n\n            long updateTime = c.getLong(indexLastUpdate);\n            int version = c.getInt(indexVersion);\n            LauncherActivityInfoCompat app = componentMap.remove(component);\n            if (version == info.versionCode && updateTime == info.lastUpdateTime &&\n                    TextUtils.equals(mIconDb.mSystemState, c.getString(systemStateIndex))) {\n                continue;\n            }\n            if (app == null) {\n                itemsToRemove.add(c.getInt(rowIndex));\n            } else {\n                appsToUpdate.add(app);\n            }\n        }\n        c.close();\n        if (!itemsToRemove.isEmpty()) {\n            mIconDb.getWritableDatabase().delete(IconDB.TABLE_NAME,\n                    IconDB.COLUMN_ROWID + \" IN ( \" + TextUtils.join(\", \", itemsToRemove) +\" )\",\n                    null);\n        }\n\n        \/\/ Insert remaining apps.\n        if (!componentMap.isEmpty() || !appsToUpdate.isEmpty()) {\n            Stack<LauncherActivityInfoCompat> appsToAdd = new Stack<>();\n            appsToAdd.addAll(componentMap.values());\n            new SerializedIconUpdateTask(userSerial, pkgInfoMap,\n                    appsToAdd, appsToUpdate).scheduleNext();\n        }\n    }\n","new_comment_raw":"@return The set of packages for which icons have updated.","old_comment_raw":"@return The set of packages for which icons have updated.","label":0,"pre_label":1,"AST_level":11,"line_counts":77,"new_code_token_num":520},{"new_code_raw":"public NumberExpression<Integer> ordinal() { if (ordinal == null) { ordinal = Expressions.numberOperation(Integer.class, Ops.ORDINAL, mixin); } return ordinal; }","old_code_raw":"    public NumberExpression<Integer> ordinal() {\n        return Expressions.numberOperation(Integer.class, Ops.ORDINAL, mixin);\n    }\n","new_comment_raw":"@return ordinal number","old_comment_raw":"@return ordinal number","label":0,"pre_label":1,"AST_level":9,"line_counts":7,"new_code_token_num":31},{"new_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.POST }) @ResponseBody public CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) { MetadataManager metaManager = MetadataManager.getInstance(cubeService.getConfig()); DataModelDesc modelDesc = deserializeDataModelDesc(cubeRequest); if (modelDesc == null) { return errorRequest(cubeRequest, STR); } if (StringUtils.isEmpty(modelDesc.getName())) { return errorRequest(cubeRequest, STR); } try { DataModelDesc existingModel = metaManager.getDataModelDesc(modelDesc.getName()); if (existingModel == null) { metaManager.createDataModelDesc(modelDesc); } else { modelDesc.setLastModified(existingModel.getLastModified()); metaManager.updateDataModelDesc(modelDesc); } } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } CubeDesc desc = deserializeCubeDesc(cubeRequest); if (desc == null) { return cubeRequest; } if (StringUtils.isEmpty(desc.getName())) { logger.info(STR); return errorRequest(cubeRequest, STR); } try { desc.setUuid(UUID.randomUUID().toString()); String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); CubeInstance createdCube = cubeService.createCubeAndDesc(desc.getName(), projectName, desc); accessService.init(createdCube, AclPermission.ADMINISTRATION); ProjectInstance project = cubeService.getProjectManager().getProject(projectName); accessService.inherit(createdCube, project); } catch (Exception e) { logger.error(STR, e); throw new InternalErrorException(e.getLocalizedMessage(), e); } cubeRequest.setUuid(desc.getUuid()); cubeRequest.setSuccessful(true); return cubeRequest; }","old_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.POST })\n@ResponseBody\npublic CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) {\n    MetadataManager metaManager = MetadataManager.getInstance(KylinConfig.getInstanceFromEnv());\n    DataModelDesc modelDesc = deserializeDataModelDesc(cubeRequest);\n    if (modelDesc == null || StringUtils.isEmpty(modelDesc.getName())) {\n        return cubeRequest;\n    }\n    try {\n        DataModelDesc existingModel = metaManager.getDataModelDesc(modelDesc.getName());\n        if (existingModel == null) {\n            metaManager.createDataModelDesc(modelDesc);\n        } else {\n            modelDesc.setLastModified(existingModel.getLastModified());\n            metaManager.updateDataModelDesc(modelDesc);\n        }\n    } catch (IOException e) {\n        logger.error(STR + e.getLocalizedMessage(), e);\n        throw new InternalErrorException(STR + e.getLocalizedMessage());\n    }\n    CubeDesc desc = deserializeCubeDesc(cubeRequest);\n    if (desc == null) {\n        return cubeRequest;\n    }\n    String name = CubeService.getCubeNameFromDesc(desc.getName());\n    if (StringUtils.isEmpty(name)) {\n        logger.info(STR);\n        throw new BadRequestException(STR);\n    }\n    try {\n        desc.setUuid(UUID.randomUUID().toString());\n        String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject();\n        cubeService.createCubeAndDesc(name, projectName, desc);\n    } catch (Exception e) {\n        logger.error(STR, e);\n        throw new InternalErrorException(e.getLocalizedMessage(), e);\n    }\n    cubeRequest.setUuid(desc.getUuid());\n    cubeRequest.setSuccessful(true);\n    return cubeRequest;\n}","new_comment_raw":"@return cubeRequest cube change request","old_comment_raw":"@return Table metadata array","label":1,"pre_label":0,"AST_level":8,"line_counts":46,"new_code_token_num":321},{"new_code_raw":"public float get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public float get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public WebDriver augment(WebDriver driver) { \/\/ TODO(simon): We should really add a \"SelfDescribing\" interface for this if (!(driver instanceof RemoteWebDriver)) { return driver; } Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap(); CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver); for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) { AugmenterProvider augmenter = augmentors.get(capablityName.getKey()); if (augmenter == null) { continue; } Object value = capablityName.getValue(); if (value instanceof Boolean && !((Boolean) value).booleanValue()) { continue; } handler.addCapabilityHander(augmenter.getDescribedInterface(), augmenter.getImplementation(value)); } if (handler.isNeedingApplication()) { \/\/ Gather the existing interfaces Set<Class<?>> interfaces = new HashSet<Class<?>>(); interfaces.addAll(handler.getInterfaces()); interfaces.addAll(getInterfacesFrom(driver.getClass())); Enhancer enhancer = new Enhancer(); enhancer.setInterfaces(interfaces.toArray(new Class<?>[interfaces.size()])); enhancer.setCallback(handler); enhancer.setSuperclass(driver.getClass()); RemoteWebDriver remote = (RemoteWebDriver) enhancer.create(); remote.setCommandExecutor(((RemoteWebDriver) driver).getCommandExecutor()); remote.setElementConverter(((RemoteWebDriver) driver).getElementConverter()); return remote; } return driver; }","old_code_raw":"  public WebDriver augment(WebDriver driver) {\n    \/\/ TODO(simon): We should really add a \"SelfDescribing\" interface for this\n    if (!(driver instanceof RemoteWebDriver)) {\n      return driver;\n    }\n\n    Map<String, ?> capabilities = ((RemoteWebDriver) driver).getCapabilities().asMap();\n\n    CompoundHandler handler = new CompoundHandler((RemoteWebDriver) driver);\n\n    for (Map.Entry<String, ?> capablityName : capabilities.entrySet()) {\n      AugmenterProvider augmenter = augmentors.get(capablityName.getKey());\n      if (augmenter == null) {\n        continue;\n      }\n\n      Object value = capablityName.getValue();\n      if (value instanceof Boolean && !((Boolean) value).booleanValue()) {\n        continue;\n      }\n\n      handler.addCapabilityHander(augmenter.getDescribedInterface(),\n          augmenter.getImplementation(value));\n    }\n\n    if (handler.isNeedingApplication()) {\n      \/\/ Gather the existing interfaces\n      Set<Class<?>> interfaces = new HashSet<Class<?>>();\n      interfaces.addAll(handler.getInterfaces());\n      interfaces.addAll(getInterfacesFrom(driver.getClass()));\n\n      return (WebDriver) Proxy.newProxyInstance(getClass().getClassLoader(),\n          interfaces.toArray(new Class<?>[interfaces.size()]), handler);\n    }\n\n    return driver;\n  }\n","new_comment_raw":"@return A class implementing the described interfaces.","old_comment_raw":"@return A class implementing the described interfaces.","label":0,"pre_label":1,"AST_level":11,"line_counts":45,"new_code_token_num":281},{"new_code_raw":"private Color invertFgColor() { if (currentBgColor_.defaultColor()) { if (!inverted_) clazzes_.add(INVERSE_FG_STYLE); return new Color(); } else if (currentBgColor_.isExtended()) { clazzes_.add(Color.clazzForColorIndex(currentBgColor_.code(), false)); return new Color(true, currentBgColor_.code()); } else if (currentBgColor_.code() >= BACKGROUND_MIN && currentBgColor_.code() <= BACKGROUND_MAX) { int newFg = currentBgColor_.code() - (BACKGROUND_MIN - FOREGROUND_MIN); clazzes_.add(FOREGROUND_STYLE + Integer.toString(newFg - FOREGROUND_MIN)); return new Color(false, newFg); } else { int newFg = currentBgColor_.code() - (BACKGROUND_INTENSE_MIN - FOREGROUND_INTENSE_MIN); clazzes_.add(FOREGROUND_STYLE + Integer.toString(newFg + NUM - FOREGROUND_INTENSE_MIN)); return new Color(false, newFg); } }","old_code_raw":"private int invertFgColor() {\n    if (currentBgColor_.defaultColor()) {\n        if (!inverted_)\n            clazzes_.add(INVERSE_FG_STYLE);\n        return Color.DEFAULT_COLOR;\n    } else if (currentBgColor_.code() >= BACKGROUND_MIN && currentBgColor_.code() <= BACKGROUND_MAX) {\n        int newFg = currentBgColor_.code() - (BACKGROUND_MIN - FOREGROUND_MIN);\n        clazzes_.add(FOREGROUND_STYLE + Integer.toString(newFg - FOREGROUND_MIN));\n        return newFg;\n    } else {\n        int newFg = currentBgColor_.code() - (BACKGROUND_INTENSE_MIN - FOREGROUND_INTENSE_MIN);\n        clazzes_.add(FOREGROUND_STYLE + Integer.toString(newFg + NUM - FOREGROUND_INTENSE_MIN));\n        return newFg;\n    }\n}","new_comment_raw":"@return new foreground color based on the background color","old_comment_raw":"@return new foreground color based on the supplied background color","label":1,"pre_label":0,"AST_level":13,"line_counts":18,"new_code_token_num":165},{"new_code_raw":"public Property weekOfWeekyear() { return new Property(this, getChronology().weekOfWeekyear()); }","old_code_raw":"    public ReadWritableInstantFieldProperty weekOfWeekyear() {\n        return new ReadWritableInstantFieldProperty(this, getChronology().weekOfWeekyear());\n    }\n","new_comment_raw":"@return the week of a week based year property","old_comment_raw":"@return the week of a week based year property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public String getMatchedSentences() { StringBuilder sb = new StringBuilder(); for (int i = NUM, sz = list.getModel().getSize(); i < sz; i++) { String t = list.getModel().getElementAt(i).getLabel().getText(); sb.append(t); sb.append(STR); } return sb.toString(); }","old_code_raw":"public StringBuffer getMatchedSentences() {\n    StringBuffer sb = new StringBuffer();\n    for (int i = NUM; i < list.getModel().getSize(); i++) {\n        String t = ((TreeFromFile) list.getModel().getElementAt(i)).getLabel().getText();\n        sb.append(t);\n        sb.append(STR);\n    }\n    return sb;\n}","new_comment_raw":"@return String filled with the plain text form of all sentences in the matches panel","old_comment_raw":"@return StringBuffer filled with the plain text form of all sentences in the matches panel","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":73},{"new_code_raw":"public MergedSelectionSet collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet) { Map<String, MergedFields> subFields = new LinkedHashMap<>(); List<String> visitedFragments = new ArrayList<>(); this.collectFields(parameters, selectionSet, visitedFragments, subFields); return newMergedSelectionSet().subFields(subFields).build(); }","old_code_raw":"    private void collectFields(FieldCollectorParameters parameters, SelectionSet selectionSet, List<String> visitedFragments, Map<String, MergedFields> fields) {\n\n        for (Selection selection : selectionSet.getSelections()) {\n            if (selection instanceof Field) {\n                collectField(parameters, fields, (Field) selection);\n            } else if (selection instanceof InlineFragment) {\n                collectInlineFragment(parameters, visitedFragments, fields, (InlineFragment) selection);\n            } else if (selection instanceof FragmentSpread) {\n                collectFragmentSpread(parameters, visitedFragments, fields, (FragmentSpread) selection);\n            }\n        }\n    }\n","new_comment_raw":"@return a map of the sub field selections","old_comment_raw":"@return a map of the sub field selections","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"static TopicSelector<TableId> defaultSelector(String prefix, String heartbeatPrefix) { return TopicSelector.defaultSelector(prefix, heartbeatPrefix, \".\", (t, pref, delimiter) -> String.join(delimiter, pref, t.catalog(), t.table())); }","old_code_raw":"    static MySqlTopicSelector defaultSelector(String prefix, String heartbeatPrefix) {\n        return defaultSelector(prefix, heartbeatPrefix, \".\");\n    }\n","new_comment_raw":"@return the topic selector; never null","old_comment_raw":"@return the topic selector; never null","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":51},{"new_code_raw":"public boolean waitForText(String text, int minimumNumberOfMatches, long timeout) { return robotiumUtils.waitForText(text, minimumNumberOfMatches, timeout); }","old_code_raw":"\tpublic boolean waitForText(String text, int expectedMinimumNumberOfMatches, long timeout) {\n       return robotiumUtils.waitForText(text, expectedMinimumNumberOfMatches, timeout);\n    }\n","new_comment_raw":"@return  true if text is shown and  false if it is not shown before the timeout","old_comment_raw":"@return true if text is found and false if it is not found before the timeout","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public String loginUser(String username, String password) throws RestClientException { return loginUserWithHttpInfo(username, password).getBody(); }","old_code_raw":"    public String loginUser(String username, String password) throws RestClientException {\n        Object postBody = null;\n        \n        \/\/ verify the required parameter 'username' is set\n        if (username == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'username' when calling loginUser\");\n        }\n        \n        \/\/ verify the required parameter 'password' is set\n        if (password == null) {\n            throw new HttpClientErrorException(HttpStatus.BAD_REQUEST, \"Missing the required parameter 'password' when calling loginUser\");\n        }\n        \n        String path = apiClient.expandPath(\"\/user\/login\", Collections.<String, Object>emptyMap());\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        queryParams.putAll(apiClient.parameterToMultiValueMap(null, \"username\", username));\n        queryParams.putAll(apiClient.parameterToMultiValueMap(null, \"password\", password));\n\n        final String[] accepts = { \n            \"application\/xml\", \"application\/json\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<String> returnType = new ParameterizedTypeReference<String>() {};\n        return apiClient.invokeAPI(path, HttpMethod.GET, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@return String","old_comment_raw":"@return String","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public Collection getDistancesMap(Group run, String year) { IWContext iwc = IWContext.getInstance(); Map disMap = new LinkedHashMap(); Collection distances = null; Collection type = new ArrayList(); type.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE); Iterator yearsIter = getYears(run).iterator(); while (yearsIter.hasNext()) { Group y = (Group) yearsIter.next(); if (y.getName().equals(year)) { try { distances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true); } catch (Exception e) { distances = null; } } } return distances; }","old_code_raw":"public Map getDistancesMap(Group run, String year) {\n    IWContext iwc = IWContext.getInstance();\n    Map disMap = new LinkedHashMap();\n    Collection distances = null;\n    Collection type = new ArrayList();\n    type.add(IWMarathonConstants.GROUP_TYPE_RUN_DISTANCE);\n    Iterator yearsIter = getYears(run).iterator();\n    while (yearsIter.hasNext()) {\n        Group y = (Group) yearsIter.next();\n        if (y.getName().equals(year)) {\n            try {\n                distances = getGroupBiz(iwc).getChildGroupsRecursiveResultFiltered(y, type, true);\n            } catch (Exception e) {\n                distances = null;\n            }\n        } else {\n            distances = null;\n        }\n    }\n    if (distances != null) {\n        Iterator disIter = distances.iterator();\n        while (disIter.hasNext()) {\n            Group dis = (Group) disIter.next();\n            disMap.put(dis.getPrimaryKey().toString(), dis.getName());\n        }\n    }\n    return disMap;\n}","new_comment_raw":"@return Collection of all distances for a specific run on a specific year","old_comment_raw":"@return Map of all distances for a specific run on a specific year","label":1,"pre_label":0,"AST_level":12,"line_counts":19,"new_code_token_num":116},{"new_code_raw":"public static String getShortClassName(Object o) { String name = o.getClass().getName(); int index = name.lastIndexOf('.'); if (index >= 0) { name = name.substring(index + 1); } return name; }","old_code_raw":"  public static String getShortClassName(Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    String name = o.getClass().getName();\n    int index = name.lastIndexOf('.');\n    if (index >= 0) {\n      name = name.substring(index + 1);\n    }\n    return name;\n  }\n","new_comment_raw":"@return The name of the class minus a package name, for example ArrayList","old_comment_raw":"@return The name of the class minus a package name, for example ArrayList","label":0,"pre_label":1,"AST_level":9,"line_counts":9,"new_code_token_num":48},{"new_code_raw":"private boolean isSameText() { ArrayList<TextView> textViewList = soloView.getCurrentTextViews(null); int size = textViewList.size(); int constant = 0; if (size > 2) constant = 2; else constant = size; if (checkTextView != null && !checkTextView.getText().equals( textViewList.get(size - constant).getText())) { checkTextView = textViewList.get(size - constant); return false; } else if (checkTextView == null) { checkTextView = textViewList.get(size - constant); return false; } else return true; }","old_code_raw":"\tprivate boolean isSameText() {\n\t\tArrayList<TextView> textViewList = soloView.getCurrentTextViews(null);\n\t\tint size = textViewList.size();\n\t\tint constant = 0;\n\t\tif (size > 2)\n\t\t\tconstant = 2;\n\t\telse\n\t\t\tconstant = size;\n\t\t\n\t\tif (checkTextView != null\n\t\t\t\t&& !checkTextView.getText().equals(\n\t\t\t\t\t\tsoloView.getCurrentTextViews(null).get(\n\t\t\t\t\t\t\t\tsoloView.getCurrentTextViews(null).size()\n\t\t\t\t\t\t\t\t\t\t- constant).getText())) {\n\t\t\tcheckTextView = textViewList.get(size - constant);\n\t\t\treturn true;\n\t\t} else if (checkTextView == null) {\n\t\t\tcheckTextView = textViewList.get(size - constant);\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n","new_comment_raw":"@return true if it is the same text and false if it is not","old_comment_raw":"@return true if no more scrolling can be done","label":1,"pre_label":0,"AST_level":10,"line_counts":22,"new_code_token_num":103},{"new_code_raw":"public ArrayList<Activity> getAllOpenedActivities() { return activitiyUtils.getAllOpenedActivities(); }","old_code_raw":"\tpublic ArrayList<Activity> getAllOpenedActivities()\n\t{\n\t\treturn ensureArrayListOrNull(activitiyUtils.getAllOpenedActivities());\n\t}\n","new_comment_raw":"@return an  ArrayList of all the opened\/active activities","old_comment_raw":"@return an ArrayList of all the opened\/active activities","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":14},{"new_code_raw":"public org.apache.poi.ss.usermodel.Workbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException, InvalidFormatException { org.apache.poi.ss.usermodel.Workbook hssfWorkbook = null; try { hssfWorkbook = WorkbookFactory.create(is); transformWorkbook(hssfWorkbook, beanParams); } catch (IOException e) { e.printStackTrace(); } return hssfWorkbook; }","old_code_raw":"public HSSFWorkbook transformXLS(InputStream is, Map beanParams) throws ParsePropertyException {\n    HSSFWorkbook hssfWorkbook = null;\n    try {\n        POIFSFileSystem fs = new POIFSFileSystem(is);\n        hssfWorkbook = new HSSFWorkbook(fs);\n        transformWorkbook(hssfWorkbook, beanParams);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return hssfWorkbook;\n}","new_comment_raw":"@return new {@link org.apache.poi.ss.usermodel.Workbook} generated by inserting beans into corresponding excel template","old_comment_raw":"@return new {@link HSSFWorkbook} generated by inserting beans into corresponding excel template","label":1,"pre_label":0,"AST_level":9,"line_counts":10,"new_code_token_num":62},{"new_code_raw":"public static SecureConnectionMode parse(String value, String defaultValue) { SecureConnectionMode mode = parse(value); if (mode == null && defaultValue != null) mode = parse(defaultValue); return mode; }","old_code_raw":"        public static SnapshotMode parse(String value, String defaultValue) {\n            SnapshotMode mode = parse(value);\n            if (mode == null && defaultValue != null) mode = parse(defaultValue);\n            return mode;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","old_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":39},{"new_code_raw":"private static FunctionExprNode createLikeFunctionExprNode(String fieldName, LikeFilter likeFilter) { if (likeFilter == null) { return null; } return new FunctionExprNode(LIKE_FUNCTION, likeFilter.hasEscape() ? ImmutableList.of( new FieldExprNode(fieldName), new ConstantExprNode(likeFilter.getPattern()), new ConstantExprNode(likeFilter.getEscape())) : ImmutableList.of( new FieldExprNode(fieldName), new ConstantExprNode(likeFilter.getPattern())) ); }","old_code_raw":"  private static FunctionExprNode createLikeFunctionExprNode(String fieldName, LikeFilter likeFilter) {\n    if (likeFilter == null) {\n      return null;\n    }\n\n    return new FunctionExprNode(LIKE_FUNCTION,\n        likeFilter.hasEscape() ?\n            ImmutableList.of(\n                new FieldExprNode(fieldName),\n                new ConstantExprNode(likeFilter.getRegex()),\n                new ConstantExprNode(likeFilter.getEscape())) :\n            ImmutableList.of(\n                new FieldExprNode(fieldName),\n                new ConstantExprNode(likeFilter.getRegex()))\n    );\n  }\n","new_comment_raw":"@return  FunctionExprNode for given arguments. Null if the likeFilter is null.","old_comment_raw":"@return FunctionExprNode for given arguments. Null if the likeFilter is null.","label":0,"pre_label":1,"AST_level":8,"line_counts":17,"new_code_token_num":82},{"new_code_raw":"private boolean isAncestorOf(Object object1, Object object2) { if (object2 == null) return false; Object parent = getParent(object2); if (parent == object1) return true; return isAncestorOf(object1, parent); }","old_code_raw":"private boolean isAncestorOf(Object node, Object target) {\n    if (target == null)\n        return false;\n    Object parent = getParent(target);\n    if (parent == node)\n        return true;\n    return isAncestorOf(node, parent);\n}","new_comment_raw":"@return true if the first object is the ancestor of the second object2.","old_comment_raw":"@return true if the node is an ancestor of the target node.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":43},{"new_code_raw":"public Annotation readUndelimited(File in) throws IOException { FileInputStream delimited = new FileInputStream(in); FileInputStream undelimited = new FileInputStream(in); CoreNLPProtos.Document doc; try { doc = CoreNLPProtos.Document.parseFrom(delimited); } catch (Exception e) { doc = CoreNLPProtos.Document.parseDelimitedFrom(undelimited); } finally { delimited.close(); undelimited.close(); } return fromProto(doc); }","old_code_raw":"  public Annotation readUndelimited(InputStream is) throws IOException {\n    return fromProto(CoreNLPProtos.Document.parseDelimitedFrom(is));\n  }\n","new_comment_raw":"@return A parsed Annotation.","old_comment_raw":"@return A parsed Annotation.","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":76},{"new_code_raw":"public SessionFactory getSessionFactory() { return daoTest.getSessionFactory(); }","old_code_raw":"    public SessionFactory getSessionFactory() {\n        return sessionFactory;\n    }\n","new_comment_raw":"@return  SessionFactory with an open session.","old_comment_raw":"@return SessionFactory with an open session.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"private boolean optimize(Visitor optimizer, boolean performInline) { int optimizeCount = 0; final UseCounter useCounter = new UseCounter(); for (Statement statement : statements) { if (statement instanceof DeclarationStatement && performInline) { DeclarationStatement decl = (DeclarationStatement) statement; useCounter.map.put(decl.parameter, new Slot()); } \/\/ We are added only counters up to current statement. \/\/ It is fine to count usages as the latter declarations cannot be used \/\/ in more recent statements. if (!useCounter.map.isEmpty()) { statement.accept(useCounter); } } final Map<ParameterExpression, Expression> subMap = new IdentityHashMap<ParameterExpression, Expression>( useCounter.map.size()); final SubstituteVariableVisitor visitor = new SubstituteVariableVisitor( subMap); final ArrayList<Statement> oldStatements = new ArrayList<Statement>( statements); statements.clear(); for (Statement oldStatement : oldStatements) { if (oldStatement instanceof DeclarationStatement) { DeclarationStatement statement = (DeclarationStatement) oldStatement; final Slot slot = useCounter.map.get(statement.parameter); int count = slot == null ? 100 : slot.count; if (count > 1 && isSafeForReuse(statement) && isSimpleExpression(statement.initializer)) { \/\/ Inline simple final constants count = 1; } if (statement.parameter.name.startsWith(\"_\")) { \/\/ Don't inline variables whose name begins with \"_\". This \/\/ is a hacky way to prevent inlining. E.g. \/\/ final int _count = collection.size(); \/\/ foo(collection); \/\/ return collection.size() - _count; count = 100; } if (statement.initializer instanceof NewExpression && ((NewExpression) statement.initializer).memberDeclarations != null) { \/\/ Don't inline anonymous inner classes. Janino gets \/\/ confused referencing variables from deeply nested \/\/ anonymous classes. count = 100; } Expression normalized = normalizeDeclaration(statement); expressionForReuse.remove(normalized); switch (count) { case 0: \/\/ Only declared, never used. Throw away declaration. break; case 1: \/\/ declared, used once. inline it. subMap.put(statement.parameter, normalized); break; default: Statement beforeOptimize = oldStatement; if (!subMap.isEmpty()) { oldStatement = oldStatement.accept(visitor); \/\/ remap } oldStatement = oldStatement.accept(optimizer); if (beforeOptimize != oldStatement) { ++optimizeCount; } if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) { if (oldStatement instanceof DeclarationStatement) { addExpresisonForReuse((DeclarationStatement) oldStatement); } statements.add(oldStatement); } break; } } else { Statement beforeOptimize = oldStatement; if (!subMap.isEmpty()) { oldStatement = oldStatement.accept(visitor); \/\/ remap } oldStatement = oldStatement.accept(optimizer); if (beforeOptimize != oldStatement) { ++optimizeCount; } if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) { statements.add(oldStatement); } } } return optimizeCount > 0; }","old_code_raw":"  private boolean optimize(Visitor optimizer, boolean performInline) {\n    boolean optimized = false;\n    final UseCounter useCounter = new UseCounter();\n    for (Statement statement : statements) {\n      if (statement instanceof DeclarationStatement && performInline) {\n        DeclarationStatement decl = (DeclarationStatement) statement;\n        useCounter.map.put(decl.parameter, new Slot());\n      }\n      \/\/ We are added only counters up to current statement.\n      \/\/ It is fine to count usages as the latter declarations cannot be used\n      \/\/ in more recent statements.\n      if (!useCounter.map.isEmpty()) {\n        statement.accept(useCounter);\n      }\n    }\n    final Map<ParameterExpression, Expression> subMap =\n        new IdentityHashMap<ParameterExpression, Expression>(\n            useCounter.map.size());\n    final SubstituteVariableVisitor visitor = new SubstituteVariableVisitor(\n        subMap);\n    final ArrayList<Statement> oldStatements = new ArrayList<Statement>(\n        statements);\n    statements.clear();\n\n    for (Statement oldStatement : oldStatements) {\n      if (oldStatement instanceof DeclarationStatement) {\n        DeclarationStatement statement = (DeclarationStatement) oldStatement;\n        final Slot slot = useCounter.map.get(statement.parameter);\n        int count = slot == null ? 100 : slot.count;\n        if (count > 1 && isSafeForReuse(statement)\n            && isSimpleExpression(statement.initializer)) {\n          \/\/ Inline simple final constants\n          count = 1;\n        }\n        if (statement.parameter.name.startsWith(\"_\")) {\n          \/\/ Don't inline variables whose name begins with \"_\". This\n          \/\/ is a hacky way to prevent inlining. E.g.\n          \/\/   final int _count = collection.size();\n          \/\/   foo(collection);\n          \/\/   return collection.size() - _count;\n          count = 100;\n        }\n        if (statement.initializer instanceof NewExpression\n            && ((NewExpression) statement.initializer).memberDeclarations\n                != null) {\n          \/\/ Don't inline anonymous inner classes. Janino gets\n          \/\/ confused referencing variables from deeply nested\n          \/\/ anonymous classes.\n          count = 100;\n        }\n        Expression normalized = normalizeDeclaration(statement);\n        expressionForReuse.remove(normalized);\n        switch (count) {\n        case 0:\n          \/\/ Only declared, never used. Throw away declaration.\n          break;\n        case 1:\n          \/\/ declared, used once. inline it.\n          subMap.put(statement.parameter, normalized);\n          break;\n        default:\n          Statement beforeOptimize = oldStatement;\n          if (!subMap.isEmpty()) {\n            oldStatement = oldStatement.accept(visitor); \/\/ remap\n          }\n          oldStatement = oldStatement.accept(optimizer);\n          optimized |= beforeOptimize != oldStatement;\n          if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) {\n            if (oldStatement instanceof DeclarationStatement) {\n              addExpresisonForReuse((DeclarationStatement) oldStatement);\n            }\n            statements.add(oldStatement);\n          }\n          break;\n        }\n      } else {\n        Statement beforeOptimize = oldStatement;\n        if (!subMap.isEmpty()) {\n          oldStatement = oldStatement.accept(visitor); \/\/ remap\n        }\n        oldStatement = oldStatement.accept(optimizer);\n        optimized |= beforeOptimize != oldStatement;\n        if (oldStatement != OptimizeVisitor.EMPTY_STATEMENT) {\n          statements.add(oldStatement);\n        }\n      }\n    }\n    return optimized;\n  }\n","new_comment_raw":"@return whether any optimizations were made","old_comment_raw":"@return if any optimizations were made or not","label":1,"pre_label":0,"AST_level":16,"line_counts":94,"new_code_token_num":547},{"new_code_raw":"public Session createSession(boolean transacted,int acknowledgeMode) throws JMSException{ checkClosedOrFailed(); ensureConnectionInfoSent(); boolean doSessionAsync=alwaysSessionAsync||sessions.size()>0||transacted ||acknowledgeMode==Session.CLIENT_ACKNOWLEDGE; return new ActiveMQSession(this,getNextSessionId(),(transacted?Session.SESSION_TRANSACTED :(acknowledgeMode==Session.SESSION_TRANSACTED?Session.AUTO_ACKNOWLEDGE:acknowledgeMode)), asyncDispatch,alwaysSessionAsync); }","old_code_raw":"    public Session createSession(boolean transacted, int acknowledgeMode) throws JMSException {\n        checkClosedOrFailed();\n        ensureConnectionInfoSent();\n        return new ActiveMQSession(this, getNextSessionId(), (transacted ? Session.SESSION_TRANSACTED\n                : (acknowledgeMode == Session.SESSION_TRANSACTED ? Session.AUTO_ACKNOWLEDGE : acknowledgeMode)), asyncDispatch);\n    }\n","new_comment_raw":"@return a newly created session","old_comment_raw":"@return a newly created session","label":0,"pre_label":1,"AST_level":9,"line_counts":10,"new_code_token_num":74},{"new_code_raw":"private StreamEvent findIfActualMax(AttributeDetails latestEvent) { int indexCurrentMax = valueStack.indexOf(currentMax); int postBound = valueStack.indexOf(latestEvent) - indexCurrentMax; if (postBound > maxPostBound) { currentMax.notEligibleForRealMax(); return null; } if (maxPreBound == NUM) { StreamEvent outputEvent = eventStack.get(indexCurrentMax); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { STR, NUM, postBound }); currentMax.sentOutputAsRealMax(); return outputEvent; } int preBound = NUM; double dThreshold = currentMax.getValue() - currentMax.getValue() * preBoundChange \/ NUM; while (preBound <= maxPreBound && indexCurrentMax - preBound >= NUM) { if (valueStack.get(indexCurrentMax - preBound).getValue() <= dThreshold) { StreamEvent outputEvent = eventStack.get(indexCurrentMax); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { STR, preBound, postBound }); currentMax.sentOutputAsRealMax(); return outputEvent; } ++preBound; } currentMax.notEligibleForRealMax(); return null; }","old_code_raw":"private StreamEvent findIfActualMax(attributeDetails latestEvent) {\n    int indexCurrentMax = valueStack.indexOf(currentMax);\n    int actual_L = valueStack.indexOf(latestEvent) - indexCurrentMax;\n    if (actual_L > L) {\n        currentMax.notEligibleForRealMax();\n        return null;\n    }\n    int actual_l = NUM;\n    double dThreshold = currentMax.getValue() - currentMax.getValue() * d \/ NUM;\n    while (actual_l <= l && indexCurrentMax - actual_l >= NUM) {\n        if (valueStack.get(indexCurrentMax - actual_l).getValue() <= dThreshold) {\n            StreamEvent outputEvent = eventStack.get(indexCurrentMax);\n            complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { STR, actual_l, actual_L });\n            currentMax.sentOutputAsRealMax();\n            return outputEvent;\n        }\n        ++actual_l;\n    }\n    currentMax.notEligibleForRealMax();\n    return null;\n}","new_comment_raw":"@return if preBoundChange, maxPostBound conditions are met, send stream event output with extrema type, preBound (distance at which a value satisfying preBoundChange condition is found), postBound (distance at which a value satisfying postBoundChange condition is found)","old_comment_raw":"@return if d, L conditions are met, send stream event output with extrema type, actual_l (distance at which a value satisfying d condition is found), actual_L (distance at which a value satisfying D condition is found)","label":1,"pre_label":0,"AST_level":11,"line_counts":27,"new_code_token_num":178},{"new_code_raw":"public ApiResponse<Order> getOrderByIdWithHttpInfo(Long orderId) throws ApiException { okhttp3.Call localVarCall = getOrderByIdValidateBeforeCall(orderId, null, null); Type localVarReturnType = new TypeToken<Order>(){}.getType(); return localVarApiClient.execute(localVarCall, localVarReturnType); }","old_code_raw":"    public ApiResponse<Order> getOrderByIdWithHttpInfo(Long orderId) throws ApiException {\n        okhttp3.Call call = getOrderByIdValidateBeforeCall(orderId, null, null);\n        Type localVarReturnType = new TypeToken<Order>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n","new_comment_raw":"@return ApiResponse&lt;Order&gt;","old_comment_raw":"@return ApiResponse&lt;Order&gt;","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":46},{"new_code_raw":"public static ExternalSessionKey fromJsonResponseBody(String responseBody) { try { JsonObject json = new JsonParser().parse(responseBody).getAsJsonObject(); if (!json.has(\"sessionId\") || json.get(\"sessionId\").isJsonNull()) { return null; } return new ExternalSessionKey(json.get(\"sessionId\").getAsString()); } catch (JsonSyntaxException e) { return null; } }","old_code_raw":"  public static ExternalSessionKey fromJsonResponseBody(String responseBody) {\n    try {\n      JSONObject json = new JSONObject(responseBody);\n      if (!json.has(\"sessionId\") || json.isNull(\"sessionId\")) {\n        return null;\n      }\n      return new ExternalSessionKey(json.getString(\"sessionId\"));\n    } catch (JSONException e) {\n      return null;\n    }\n  }\n","new_comment_raw":"@return the extracted ExternalKey, or null if one was not found.","old_comment_raw":"@return the extracted ExternalKey, or null if one was not found.","label":0,"pre_label":1,"AST_level":8,"line_counts":12,"new_code_token_num":81},{"new_code_raw":"public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof FiltersAggregation)) { return false; } FiltersAggregation rhs = (FiltersAggregation) o; return new EqualsBuilder() .append(getCountList(), rhs.getCountList()) .append(getCounts(), rhs.getCounts()) .isEquals(); }","old_code_raw":"    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof FiltersAggregation)) {\n            return false;\n        }\n\n        FiltersAggregation that = (FiltersAggregation) o;\n\n        if (!countList.equals(that.countList)) {\n            return false;\n        }\n        if (!counts.equals(that.counts)) {\n            return false;\n        }\n\n        return true;\n    }\n","new_comment_raw":"@return A map filter names to associated counts","old_comment_raw":"@return A map filter names to associated counts","label":0,"pre_label":1,"AST_level":6,"line_counts":15,"new_code_token_num":71},{"new_code_raw":"public CloseableHttpClient build(String name) { final InstrumentedHttpClientConnectionManager manager = createConnectionManager(registry, name); return createClient(org.apache.http.impl.client.HttpClientBuilder.create(), manager, name); }","old_code_raw":"public HttpClient build(String name) {\n    final BasicHttpParams params = createHttpParams(name);\n    final InstrumentedClientConnManager manager = createConnectionManager(registry, name);\n    final InstrumentedHttpClient client = new InstrumentedHttpClient(metricRegistry, manager, params, name);\n    setStrategiesForClient(client);\n    return client;\n}","new_comment_raw":"@return an {@link CloseableHttpClient}","old_comment_raw":"@return an {@link HttpClient}","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":37},{"new_code_raw":"public Settings buildSettings(ConnectionProvider connectionProvider) { Properties clone = ( Properties ) properties.clone(); ConfigurationHelper.resolvePlaceHolders( clone ); return buildSettingsInternal( clone, connectionProvider ); }","old_code_raw":"\tpublic Settings buildSettings() {\n\t\tProperties clone = ( Properties ) properties.clone();\n\t\tConfigurationHelper.resolvePlaceHolders( clone );\n\t\treturn buildSettingsInternal( clone );\n\t}\n","new_comment_raw":"@return The build settings","old_comment_raw":"@return The build settings","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":33},{"new_code_raw":"public static String encodeObject( java.io.Serializable serializableObject, int options ) throws java.io.IOException { if( serializableObject == null ){ throw new NullPointerException( \"Cannot serialize a null object.\" ); } \/\/ end if: null \/\/ Streams java.io.ByteArrayOutputStream baos = null; java.io.OutputStream b64os = null; java.util.zip.GZIPOutputStream gzos = null; java.io.ObjectOutputStream oos = null; try { \/\/ ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream(); b64os = new Base64.OutputStream( baos, ENCODE | options ); if( (options & GZIP) != 0 ){ \/\/ Gzip gzos = new java.util.zip.GZIPOutputStream(b64os); oos = new java.io.ObjectOutputStream( gzos ); } else { \/\/ Not gzipped oos = new java.io.ObjectOutputStream( b64os ); } oos.writeObject( serializableObject ); } \/\/ end try catch( java.io.IOException e ) { \/\/ Catch it and then throw it immediately so that \/\/ the finally{} block is called for cleanup. throw e; } \/\/ end catch finally { try{ oos.close(); } catch( Exception e ){} try{ gzos.close(); } catch( Exception e ){} try{ b64os.close(); } catch( Exception e ){} try{ baos.close(); } catch( Exception e ){} } \/\/ end finally \/\/ Return value according to relevant encoding. try { return new String( baos.toByteArray(), PREFERRED_ENCODING ); } \/\/ end try catch (java.io.UnsupportedEncodingException uue){ \/\/ Fall back to some Java default return new String( baos.toByteArray(), StandardCharsets.UTF_8 ); } \/\/ end catch } \/\/ end encode","old_code_raw":"  public static String encodeObject( java.io.Serializable serializableObject, int options )\n      throws java.io.IOException {\n\n    if( serializableObject == null ){\n      throw new NullPointerException( \"Cannot serialize a null object.\" );\n    }   \/\/ end if: null\n\n    \/\/ Streams\n    java.io.ByteArrayOutputStream  baos  = null;\n    java.io.OutputStream           b64os = null;\n    java.util.zip.GZIPOutputStream gzos  = null;\n    java.io.ObjectOutputStream     oos   = null;\n\n\n    try {\n      \/\/ ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream\n      baos  = new java.io.ByteArrayOutputStream();\n      b64os = new Base64.OutputStream( baos, ENCODE | options );\n      if( (options & GZIP) != 0 ){\n        \/\/ Gzip\n        gzos = new java.util.zip.GZIPOutputStream(b64os);\n        oos = new java.io.ObjectOutputStream( gzos );\n      } else {\n        \/\/ Not gzipped\n        oos = new java.io.ObjectOutputStream( b64os );\n      }\n      oos.writeObject( serializableObject );\n    }   \/\/ end try\n    catch( java.io.IOException e ) {\n      \/\/ Catch it and then throw it immediately so that\n      \/\/ the finally{} block is called for cleanup.\n      throw e;\n    }   \/\/ end catch\n    finally {\n      try{ oos.close();   } catch( Exception e ){}\n      try{ gzos.close();  } catch( Exception e ){}\n      try{ b64os.close(); } catch( Exception e ){}\n      try{ baos.close();  } catch( Exception e ){}\n    }   \/\/ end finally\n\n    \/\/ Return value according to relevant encoding.\n    try {\n      return new String( baos.toByteArray(), PREFERRED_ENCODING );\n    }   \/\/ end try\n    catch (java.io.UnsupportedEncodingException uue){\n      \/\/ Fall back to some Java default\n      return new String( baos.toByteArray() );\n    }   \/\/ end catch\n\n  }   \/\/ end encode\n","new_comment_raw":"@return The Base64-encoded object","old_comment_raw":"@return The Base64-encoded object","label":0,"pre_label":1,"AST_level":12,"line_counts":51,"new_code_token_num":337},{"new_code_raw":"public float getX() { if (left == null) { calculateLeft(); } return left.floatValue(); }","old_code_raw":"public float getX() {\n    return center[NUM];\n}","new_comment_raw":"@return The x location of the left side of this shape.","old_comment_raw":"@return The x location of the center of this circle","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":24},{"new_code_raw":"public static <X> BinaryVisitor<X, PrintStream> println() { return new PrintLine<X>(); }","old_code_raw":"public static <X> BinaryPredicate<X, PrintStream> println() {\n    return new PrintLine<X>();\n}","new_comment_raw":"@return a {@link BinaryVisitor} that will call {@code println(x)} on the {@link java.io.PrintStream} {@code y}","old_comment_raw":"@return a {@link BinaryPredicate} that will call {@code println(x)} on the {@link java.io.PrintStream} {@code y}","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public static Builder create() { return new BuilderImpl(); }","old_code_raw":"    public static Builder create() {\n        return new Builder() {\n            private Configuration config;\n            private ChangeConsumer handler;\n            private ClassLoader classLoader;\n            private Clock clock;\n            private CompletionCallback completionCallback;\n            private ConnectorCallback connectorCallback;\n            private OffsetCommitPolicy offsetCommitPolicy = null;\n\n            @Override\n            public Builder using(Configuration config) {\n                this.config = config;\n                return this;\n            }\n\n            @Override\n            public Builder using(ClassLoader classLoader) {\n                this.classLoader = classLoader;\n                return this;\n            }\n\n            @Override\n            public Builder using(Clock clock) {\n                this.clock = clock;\n                return this;\n            }\n\n            @Override\n            public Builder using(CompletionCallback completionCallback) {\n                this.completionCallback = completionCallback;\n                return this;\n            }\n\n            @Override\n            public Builder using(ConnectorCallback connectorCallback) {\n                this.connectorCallback = connectorCallback;\n                return this;\n            }\n\n            @Override\n            public Builder using(OffsetCommitPolicy offsetCommitPolicy) {\n                this.offsetCommitPolicy = offsetCommitPolicy;\n                return this;\n            }\n\n            @Override\n            public Builder notifying(Consumer<SourceRecord> consumer) {\n                this.handler = buildDefaultChangeConsumer(consumer);\n                return this;\n            }\n\n            @Override\n            public Builder notifying(ChangeConsumer handler) {\n                this.handler = handler;\n                return this;\n            }\n\n            @Override\n            public EmbeddedEngine build() {\n                if (classLoader == null) {\n                    classLoader = getClass().getClassLoader();\n                }\n                if (clock == null) {\n                    clock = Clock.system();\n                }\n                Objects.requireNonNull(config, \"A connector configuration must be specified.\");\n                Objects.requireNonNull(handler, \"A connector consumer or changeHandler must be specified.\");\n                return new EmbeddedEngine(config, classLoader, clock,\n                        handler, completionCallback, connectorCallback, offsetCommitPolicy);\n            }\n\n        };\n    }\n","new_comment_raw":"@return the new builder; never null","old_comment_raw":"@return the new builder; never null","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"protected boolean hasAnnotation(AnnotatedTypeMirror type, AnnotationMirror annotation) { return AnnotatedTypes.getEffectiveAnnotations(type).contains(annotation); }","old_code_raw":"protected boolean hasAnnotation(AnnotatedTypeMirror type, AnnotationMirror annotation) {\n    if (!(type instanceof AnnotatedWildcardType))\n        return type.hasAnnotation(annotation);\n    AnnotatedWildcardType wc = (AnnotatedWildcardType) type;\n    AnnotatedTypeMirror bound = wc.getExtendsBound();\n    if (bound != null && bound.hasAnnotation(annotation))\n        return true;\n    return false;\n}","new_comment_raw":"@return true if the (non-type-variable, non-wildcard) type has the annotation or, if a type variable or wildcard, the type has the annotation on its extends bound","old_comment_raw":"@return true if the (non-wildcard) type has the annotation or, if a wildcard, the type has the annotation on its extends bound","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":23},{"new_code_raw":"public static String moveFile(UploadFile uploadFile) { if (uploadFile == null) return null; File file = uploadFile.getFile(); if (!file.exists()) { return null; } String webRoot = PathKit.getWebRootPath(); String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); StringBuilder newFileName = new StringBuilder(webRoot).append(File.separator).append(\"attachment\") .append(File.separator).append(dateFormat.format(new Date())).append(File.separator).append(uuid) .append(FileUtils.getSuffix(file.getName())); File newfile = new File(newFileName.toString()); if (!newfile.getParentFile().exists()) { newfile.getParentFile().mkdirs(); } file.renameTo(newfile); return FileUtils.removePrefix(newfile.getAbsolutePath(), webRoot); }","old_code_raw":"\tpublic static String moveFile(UploadFile uploadFile) {\n\t\tif (uploadFile == null)\n\t\t\treturn null;\n\n\t\tFile file = uploadFile.getFile();\n\t\tString webRoot = PathKit.getWebRootPath();\n\n\t\tString uuid = UUID.randomUUID().toString().replace(\"-\", \"\");\n\n\t\tStringBuilder newFileName = new StringBuilder(webRoot).append(File.separator).append(\"attachment\")\n\t\t\t\t.append(File.separator).append(dateFormat.format(new Date())).append(File.separator).append(uuid)\n\t\t\t\t.append(FileUtils.getSuffix(file.getName()));\n\n\t\tFile newfile = new File(newFileName.toString());\n\n\t\tif (!newfile.getParentFile().exists()) {\n\t\t\tnewfile.getParentFile().mkdirs();\n\t\t}\n\n\t\tfile.renameTo(newfile);\n\n\t\treturn FileUtils.removePrefix(newfile.getAbsolutePath(), webRoot);\n\t}\n","new_comment_raw":"@return new file relative path","old_comment_raw":"@return new file relative path","label":0,"pre_label":1,"AST_level":9,"line_counts":28,"new_code_token_num":169},{"new_code_raw":"public static EventProcessingFailureHandlingMode parse(String value) { if (value == null) { return null; } value = value.trim(); for (EventProcessingFailureHandlingMode option : EventProcessingFailureHandlingMode.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }","old_code_raw":"        public static Version parse(String value, String defaultValue) {\n            Version mode = parse(value);\n            if (mode == null && defaultValue != null) {\n                mode = parse(defaultValue);\n            }\n            return mode;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found","old_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","label":1,"pre_label":0,"AST_level":8,"line_counts":16,"new_code_token_num":57},{"new_code_raw":"private static File[] determineInputs(List<File> inputs, FilenameFilter filter) { Set<File> fileSet = new LinkedHashSet<>(); \/\/ preserve order and uniqueness for (File file : inputs) { \/\/ if directory, look at contents to see what files match extension if (file.isDirectory()) { File[] files = file.listFiles(filter); Collections.addAll(fileSet, files != null ? files : new File[0]); } \/\/ otherwise, just add the file. else { fileSet.add(file); } } if (fileSet.size() > 0) { System.err.println(\"Input files to compile:\"); for (File file : fileSet) { System.err.println(\" \" + file); } } else { System.err.println(\"No input files found.\"); } return fileSet.toArray(new File[0]); }","old_code_raw":"  private static File[] determineInputs(List<File> inputs, FilenameFilter filter) {\n    Set<File> fileSet = new LinkedHashSet<>(); \/\/ preserve order and uniqueness\n\n    for (File file : inputs) {\n      \/\/ if directory, look at contents to see what files match extension\n      if (file.isDirectory()) {\n        for (File f : file.listFiles(filter)) {\n          fileSet.add(f);\n        }\n      }\n      \/\/ otherwise, just add the file.\n      else {\n        fileSet.add(file);\n      }\n    }\n\n    if (fileSet.size() > 0) {\n      System.err.println(\"Input files to compile:\");\n      for (File file : fileSet) {\n        System.err.println(\"  \" + file);\n      }\n    }\n    else {\n      System.err.println(\"No input files found.\");\n    }\n\n    return fileSet.toArray((new File[fileSet.size()]));\n  }\n","new_comment_raw":"@return Unique array of files","old_comment_raw":"@return Unique array of files","label":0,"pre_label":1,"AST_level":11,"line_counts":28,"new_code_token_num":175},{"new_code_raw":"public static ValueType decode(final String value) { if (value == null || value.trim().isEmpty()) throw new IllegalArgumentException(STR); final ValueType v = decodeByInt.get(value.trim().charAt(NUM)); return v == null ? DIRECTED : v; }","old_code_raw":"public static ValueType decode(final String value) {\n    if (value == null || value.trim().isEmpty())\n        throw new IllegalArgumentException(STR);\n    final ValueType v = decodeByInt.get(value.trim().charAt(NUM));\n    return v == null ? X : v;\n}","new_comment_raw":"@return the decoded ValueType or {@link #DIRECTED} if the char does not map to a ValueType","old_comment_raw":"@return the decoded ValueType or {@link #X} if the char does not map to a ValueType","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":56},{"new_code_raw":"public Tree transformTree(Tree t) { if (VERBOSE) { System.err.println(\"Input to CoordinationTransformer: \" + t); } Tree tx = tn.transformTree(t); if (VERBOSE) { System.err.println(\"After DependencyTreeTransformer: \" + tx); } if (tx == null) { return tx; } Tree tt = UCPtransform(tx); if (VERBOSE) { System.err.println(\"After UCPTransformer: \" + tt); } Tree ttt = CCtransform(tt); if (VERBOSE) { System.err.println(\"After CCTransformer: \" + ttt); } Tree tttt = qp.transformTree(ttt); if (VERBOSE) { System.err.println(\"After QPTreeTransformer: \" + tttt); } Tree flatSQ = SQflatten(tttt); if (VERBOSE) { System.err.println(\"After SQ flattening: \" + flatSQ); } Tree fixedDates = dates.transformTree(flatSQ); if (VERBOSE) { System.err.println(\"After DateTreeTransformer: \" + fixedDates); } Tree removedXX = removeXOverX(fixedDates); if (VERBOSE) { System.err.println(\"After removeXoverX: \" + removedXX); } Tree conjp = combineConjp(removedXX); if (VERBOSE) { System.err.println(\"After combineConjp: \" + conjp); } Tree movedRB = moveRB(conjp); if (VERBOSE) { System.err.println(\"After moveRB: \" + movedRB); } Tree changedSbar = changeSbarToPP(movedRB); if (VERBOSE) { System.err.println(\"After changeSbarToPP: \" + movedRB); } Tree nowThat = rearrangeNowThat(changedSbar); if (VERBOSE) { System.err.println(\"After rearrangeNowThat: \" + nowThat); } return nowThat; }","old_code_raw":"  public Tree transformTree(Tree t) {\n    if (VERBOSE) {\n      System.err.println(\"Input to CoordinationTransformer: \" + t);\n    }\n    Tree tx = tn.transformTree(t);\n    if (VERBOSE) {\n      System.err.println(\"After DependencyTreeTransformer:  \" + tx);\n    }\n    if (tx == null) {\n      return tx;\n    }\n    Tree tt = UCPtransform(tx);\n    if (VERBOSE) {\n      System.err.println(\"After UCPTransformer:             \" + tt);\n    }\n    Tree ttt = CCtransform(tt);\n    if (VERBOSE) {\n      System.err.println(\"After CCTransformer:              \" + ttt);\n    }\n    Tree tttt = qp.transformTree(ttt);\n    if (VERBOSE) {\n      System.err.println(\"After QPTreeTransformer:          \" + tttt);\n    }\n    Tree flatSQ = SQflatten(tttt);\n    if (VERBOSE) {\n      System.err.println(\"After SQ flattening:              \" + flatSQ);\n    }\n    Tree fixedDates = dates.transformTree(flatSQ);\n    if (VERBOSE) {\n      System.err.println(\"After DateTreeTransformer:        \" + fixedDates);\n    }\n    Tree removedXX = removeXOverX(fixedDates);\n    if (VERBOSE) {\n      System.err.println(\"After removeXoverX:               \" + removedXX);\n    }\n    Tree conjp = combineConjp(removedXX);\n    if (VERBOSE) {\n      System.err.println(\"After combineConjp:               \" + conjp);\n    }\n    Tree movedRB = moveRB(conjp);\n    if (VERBOSE) {\n      System.err.println(\"After moveRB:                     \" + movedRB);\n    }\n    Tree changedSbar = changeSbarToPP(movedRB);\n    if (VERBOSE) {\n      System.err.println(\"After changeSbarToPP:             \" + movedRB);\n    }\n    return changedSbar;\n  }\n","new_comment_raw":"@return t transformed","old_comment_raw":"@return t transformed","label":0,"pre_label":1,"AST_level":8,"line_counts":54,"new_code_token_num":332},{"new_code_raw":"public Score score(List<Collection<TypedDependency>> system) { int parserCnt = 0; int goldCnt = 0; int correctAttachment = 0; int correctUnlabeledAttachment = 0; int labelCnt = 0; int labelCorrect = 0; ClassicCounter<String> unlabeledErrorCounts = new ClassicCounter<String>(); ClassicCounter<String> labeledErrorCounts = new ClassicCounter<String>(); \/\/System.out.println(\"Gold size: \"+ goldDeps.size() + \" System size: \"+system.size()); for (int i = 0; i < system.size(); i++) { List<Set<TypedDependency>> l = toSets(system.get(i)); if (ignorePunc) { removeHeadsAssignedToPunc(l.get(0)); removeHeadsAssignedToPunc(l.get(1)); } parserCnt += l.get(0).size(); goldCnt += goldDeps.get(i).size(); l.get(0).retainAll(goldDeps.get(i)); \/\/System.out.println(\"UGold: \"+goldDepsUnlabeled.get(i)+\"\\n\"); \/\/System.out.println(\"USys: \"+l.get(1)+\"\\n\"); l.get(1).retainAll(goldDepsUnlabeled.get(i)); correctAttachment += l.get(0).size(); correctUnlabeledAttachment += l.get(1).size(); labelCnt += l.get(1).size(); labelCorrect += l.get(0).size(); \/\/System.out.println(\"\"+i+\" Acc: \"+(l.get(0).size())\/(double)localCnt+\" \"+l.get(0).size()+\"\/\"+localCnt); \/\/ identify errors List<Set<TypedDependency>> errl = toSets(system.get(i)); errl.get(0).removeAll(goldDeps.get(i)); errl.get(1).removeAll(goldDepsUnlabeled.get(i)); Map<String,String> childCorrectWithLabel = new HashMap<String,String>(); Map<String,String> childCorrectWithOutLabel = new HashMap<String,String>(); for (TypedDependency goldDep: goldDeps.get(i)) { \/\/System.out.print(goldDep); String sChild = goldDep.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\"); String prefixLabeled = \"\"; String prefixUnlabeled = \"\"; if (childCorrectWithLabel.containsKey(sChild)) { prefixLabeled = childCorrectWithLabel.get(sChild)+\", \"; prefixUnlabeled = childCorrectWithOutLabel.get(sChild)+\", \"; } childCorrectWithLabel.put(sChild, prefixLabeled + goldDep.reln()+\"(\"+goldDep.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\")+\", \"+sChild+\")\"); childCorrectWithOutLabel.put(sChild, prefixUnlabeled + \"dep(\"+goldDep.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\")+\", \"+sChild+\")\"); } for (TypedDependency labeledError: errl.get(0)) { String sChild = labeledError.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\"); String sGov = labeledError.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\"); labeledErrorCounts.incrementCount(labeledError.reln().toString()+\"(\"+sGov+\", \"+sChild+\") <= \"+childCorrectWithLabel.get(sChild)); } for (TypedDependency unlabeledError: errl.get(1)) { String sChild = unlabeledError.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\"); String sGov = unlabeledError.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\"); unlabeledErrorCounts.incrementCount(\"dep(\"+sGov+\", \"+sChild+\") <= \"+childCorrectWithOutLabel.get(sChild)); } } return new Score(parserCnt, goldCnt, correctAttachment, correctUnlabeledAttachment, labelCnt, labelCorrect, labeledErrorCounts, unlabeledErrorCounts); }","old_code_raw":"  public Score score(List<Collection<TypedDependency>> system) {\n    int parserCnt = 0;\n    int goldCnt = 0;\n    int parserUnlabeledCnt = 0;\n    int goldUnlabeledCnt = 0;\n    int correctAttachment = 0;\n    int correctUnlabeledAttachment = 0;\n    int labelCnt = 0;\n    int labelCorrect = 0;\n\n    ClassicCounter<String> unlabeledErrorCounts = new ClassicCounter<String>();\n    ClassicCounter<String> labeledErrorCounts = new ClassicCounter<String>();\n    \/\/System.out.println(\"Gold size: \"+ goldDeps.size() + \" System size: \"+system.size());\n    for (int i = 0; i < system.size(); i++) {\n      List<Set<TypedDependency>> l = toSets(system.get(i));\n      if (ignorePunc) {\n        removeHeadsAssignedToPunc(l.get(0));\n        removeHeadsAssignedToPunc(l.get(1));\n      }\n\n      parserCnt += l.get(0).size();\n      goldCnt += goldDeps.get(i).size();\n\n      parserUnlabeledCnt += l.get(1).size();\n      goldUnlabeledCnt += goldDepsUnlabeled.get(i).size();\n\n      l.get(0).retainAll(goldDeps.get(i));\n      l.get(1).retainAll(goldDepsUnlabeled.get(i));\n      correctAttachment += l.get(0).size();\n      correctUnlabeledAttachment += l.get(1).size();\n      labelCnt += l.get(1).size();\n      labelCorrect += l.get(0).size();\n      \/\/System.out.println(\"\"+i+\" Acc: \"+(l.get(0).size())\/(double)localCnt+\" \"+l.get(0).size()+\"\/\"+localCnt);\n\n\n      \/\/ identify errors\n      List<Set<TypedDependency>> errl = toSets(system.get(i));\n      errl.get(0).removeAll(goldDeps.get(i));\n      errl.get(1).removeAll(goldDepsUnlabeled.get(i));\n      Map<String,String> childCorrectWithLabel = Generics.newHashMap();\n      Map<String,String> childCorrectWithOutLabel = Generics.newHashMap();\n\n      for (TypedDependency goldDep: goldDeps.get(i)) {\n          \/\/System.out.print(goldDep);\n          String sChild = goldDep.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\");\n          String prefixLabeled = \"\";\n          String prefixUnlabeled = \"\";\n          if (childCorrectWithLabel.containsKey(sChild)) {\n            prefixLabeled = childCorrectWithLabel.get(sChild)+\", \";\n            prefixUnlabeled = childCorrectWithOutLabel.get(sChild)+\", \";\n          }\n          childCorrectWithLabel.put(sChild, prefixLabeled + goldDep.reln()+\"(\"+goldDep.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\")+\", \"+sChild+\")\");\n          childCorrectWithOutLabel.put(sChild, prefixUnlabeled + \"dep(\"+goldDep.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\")+\", \"+sChild+\")\");\n      }\n\n      for (TypedDependency labeledError: errl.get(0)) {\n          String sChild = labeledError.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\");\n          String sGov   = labeledError.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\");\n          labeledErrorCounts.incrementCount(labeledError.reln().toString()+\"(\"+sGov+\", \"+sChild+\") <= \"+childCorrectWithLabel.get(sChild));\n      }\n      for (TypedDependency unlabeledError: errl.get(1)) {\n          String sChild = unlabeledError.dep().label().toString().replaceFirst(\"-[^-]*$\", \"\");\n          String sGov   = unlabeledError.gov().label().toString().replaceFirst(\"-[^-]*$\", \"\");\n          unlabeledErrorCounts.incrementCount(\"dep(\"+sGov+\", \"+sChild+\") <= \"+childCorrectWithOutLabel.get(sChild));\n      }\n    }\n    return new Score(parserCnt, goldCnt, parserUnlabeledCnt, goldUnlabeledCnt, correctAttachment, correctUnlabeledAttachment, labelCnt, labelCorrect, labeledErrorCounts, unlabeledErrorCounts);\n  }\n","new_comment_raw":"@return a triple consisting of (labeled attachment, unlabeled attachment, label accuracy)","old_comment_raw":"@return a triple consisting of (labeled attachment, unlabeled attachment, label accuracy)","label":0,"pre_label":1,"AST_level":16,"line_counts":64,"new_code_token_num":813},{"new_code_raw":"public Client build(String name) { if ((environment == null) && (executorService == null) && (objectMapper == null)) { throw new IllegalStateException(\"Must have either an environment or both \" + \"an executor service and an object mapper\"); } if (environment == null) { return build(executorService, objectMapper, validator, name); } return build(environment.getLifecycleEnvironment() .executorService(\"jersey-client-\" + name + \"-%d\") .minThreads(configuration.getMinThreads()) .maxThreads(configuration.getMaxThreads()) .build(), environment.getObjectMapper(), environment.getValidator(), name); }","old_code_raw":"    public Client build(String name) {\n        if ((environment == null) && (executorService == null) && (objectMapper == null)) {\n            throw new IllegalStateException(\"Must have either an environment or both \" +\n                                                    \"an executor service and an object mapper\");\n        }\n\n        if (environment == null) {\n            return build(executorService, objectMapper, validator, name);\n        }\n\n        return build(environment.getLifecycleEnvironment()\n                                .managedExecutorService(\"jersey-client-%d\",\n                                                        configuration.getMinThreads(),\n                                                        configuration.getMaxThreads(),\n                                                        60,\n                                                        TimeUnit.SECONDS),\n                     environment.getObjectMapper(),\n                     environment.getValidator(),\n                     name);\n    }\n","new_comment_raw":"@return a fully-configured  Client","old_comment_raw":"@return a fully-configured Client","label":0,"pre_label":1,"AST_level":9,"line_counts":20,"new_code_token_num":129},{"new_code_raw":"public static RelDataTypeField lookupField(final RelDataType rowType, String columnName) { final RelDataTypeField[] fields = rowType.getFields(); for (int i = NUM; i < fields.length; i++) { RelDataTypeField field = fields[i]; if (field.getName().equals(columnName)) { return field; } } return null; }","old_code_raw":"public static int lookupField(final RelDataType rowType, String columnName) {\n    final RelDataTypeField[] fields = rowType.getFields();\n    for (int i = NUM; i < fields.length; i++) {\n        RelDataTypeField field = fields[i];\n        if (field.getName().equals(columnName)) {\n            return i;\n        }\n    }\n    return -NUM;\n}","new_comment_raw":"@return Field, or null if not found","old_comment_raw":"@return Ordinal of field, or -1 if not found","label":1,"pre_label":0,"AST_level":9,"line_counts":10,"new_code_token_num":66},{"new_code_raw":"public Order placeOrder(Order order) throws ApiException { return placeOrderWithHttpInfo(order).getData(); }","old_code_raw":"  public Order placeOrder(Order body) throws ApiException {\n    return placeOrderWithHttpInfo(body).getData();\n      }\n","new_comment_raw":"@return Order","old_comment_raw":"@return Order","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public static String resolve(String originalHost) { String currentHost = originalHost; if (isLocalOrIp(currentHost)) { return originalHost; } try { String targetHost = null; do { Attributes attrs = dirContext.getAttributes(currentHost, new String[] { A_RECORD_TYPE, CNAME_RECORD_TYPE }); Attribute attr = attrs.get(A_RECORD_TYPE); if (attr != null) { targetHost = attr.get().toString(); } attr = attrs.get(CNAME_RECORD_TYPE); if (attr != null) { currentHost = attr.get().toString(); } else { targetHost = currentHost; } } while (targetHost == null); return targetHost; } catch (NamingException e) { logger.warn(STR + currentHost + STR + originalHost, e); return originalHost; } }","old_code_raw":"static String resolve(String originalHost) {\n    String currentHost = originalHost;\n    if (isLocalOrIp(currentHost)) {\n        return originalHost;\n    }\n    try {\n        String targetHost = null;\n        do {\n            Attributes attrs = dirContext.getAttributes(currentHost, new String[] { A_RECORD_TYPE, CNAME_RECORD_TYPE });\n            Attribute attr = attrs.get(A_RECORD_TYPE);\n            if (attr != null) {\n                targetHost = attr.get().toString();\n            }\n            attr = attrs.get(CNAME_RECORD_TYPE);\n            if (attr != null) {\n                currentHost = attr.get().toString();\n            } else {\n                targetHost = currentHost;\n            }\n        } while (targetHost == null);\n        return targetHost;\n    } catch (NamingException e) {\n        logger.warn(STR + currentHost + STR + originalHost, e);\n        return originalHost;\n    }\n}","new_comment_raw":"@return resolved host name","old_comment_raw":"@return URI identical to the one provided, with host name swapped with the resolved value","label":1,"pre_label":0,"AST_level":11,"line_counts":26,"new_code_token_num":142},{"new_code_raw":"public String getKDCList(String realm) throws KrbException { if (realm == null) { realm = getDefaultRealm(); } Exception cause = null; String kdcs = getDefault(STR, realm); if (kdcs == null) { kdcs = java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<String>() { @Override public String run() { String osname = System.getProperty(STR); if (osname.startsWith(STR)) { String logonServer = System.getenv(STR); if (logonServer != null && logonServer.startsWith(STR)) { logonServer = logonServer.substring(NUM); } return logonServer; } return null; } }); } if (kdcs == null) { KrbException ke = new KrbException(STR); if (cause != null) { ke.initCause(cause); } throw ke; } return kdcs; }","old_code_raw":"public String getKDCList(String realm) {\n    if (realm == null) {\n        realm = getDefaultRealm();\n    }\n    String kdcs = getDefault(STR, realm);\n    if (kdcs == null) {\n        return null;\n    }\n    return kdcs;\n}","new_comment_raw":"@return the list of KDCs separated by a space, always non null","old_comment_raw":"@return the list of KDCs","label":1,"pre_label":0,"AST_level":17,"line_counts":32,"new_code_token_num":158},{"new_code_raw":"public Index parseAndUpdateIndex(Set<String> mappingFileNames, Index annotationIndex) { ClassLoaderService classLoaderService = meta.getServiceRegistry().getService( ClassLoaderService.class ); Set<InputStream> mappingStreams = new HashSet<InputStream>(); for ( String fileName : mappingFileNames ) { EntityMappings entityMappings; try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM2_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm2Exception ) { \/\/ if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility try { entityMappings = XmlHelper.unmarshallXml( fileName, ORM1_MAPPING_XSD, EntityMappings.class, classLoaderService ).getRoot(); } catch ( JAXBException orm1Exception ) { throw new AnnotationException( \"Unable to parse xml configuration.\", orm1Exception ); } } entityMappings.toString(); } return null; }","old_code_raw":"\tpublic Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {\n\t\tList<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );\n\t\tfor ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {\n\t\t\tlist.add( jaxbRoot.getRoot() );\n\t\t}\n\t\treturn new EntityMappingsMocker(\n\t\t\t\tlist, annotationIndex, meta.getServiceRegistry()\n\t\t).mockNewIndex();\n\t}\n","new_comment_raw":"@return a new updated annotation index, enhancing and modifying the existing ones according to the jpa xml rules","old_comment_raw":"@return a new updated annotation index, enhancing and modifying the existing ones according to the jpa xml rules","label":0,"pre_label":1,"AST_level":12,"line_counts":29,"new_code_token_num":139},{"new_code_raw":"public int size() { return applications.stream().mapToInt(Application::size).sum(); }","old_code_raw":"    public int size() {\n        int result = 0;\n        for (Application application : applications) {\n            result += application.size();\n        }\n\n        return result;\n    }\n","new_comment_raw":"@return a weakly consistent size of the number of instances in all the applications","old_comment_raw":"@return a weakly consistent size of the number of instances in all the applications","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public LockableMGraph getUnsecuredMGraph() { try { checkWrite(); return wrapped; } catch (AccessControlException ex) { checkRead(); return new WriteBlockedMGraph(wrapped); } }","old_code_raw":"public LockableMGraph getUnsecuredMGraph() {\n    checkWrite();\n    return wrapped;\n}","new_comment_raw":"@return the wrapped LockableMGraph or a write-block LockableMGraph depending on the access rights of the caller.","old_comment_raw":"@return the wrapped LockableMGraph.","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":35},{"new_code_raw":"public boolean isMirrored() { if (!fMirroringEnabled) return false; Object property = getProperty(MIRRORED); return property instanceof Boolean && (Boolean) property; }","old_code_raw":"public boolean isMirrored() {\n    Object property = getProperty(MIRRORED);\n    return property instanceof Boolean && (Boolean) property;\n}","new_comment_raw":"@return true if the compare viewer is mirrored. By default the Compare viewer is not mirrored.","old_comment_raw":"@return true if the left and right side of the viewer are mirrored. Default is false.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":33},{"new_code_raw":"public ArrayList<ErrorMsg> getErrors() { return _parser.getErrors(); }","old_code_raw":"public Vector getErrors() {\n    return _parser.getErrors();\n}","new_comment_raw":"@return A List containing all compile error messages","old_comment_raw":"@return A Vector containing all compile error messages","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":14},{"new_code_raw":"protected BroadcastAction filter(AtmosphereResource r, Object message, Object originalMessage) { Object newO = unwrap(message); boolean isManipulated = false; if (!newO.equals(message)) { isManipulated = true; message = newO; } BroadcastAction transformed = new BroadcastAction(message); for (PerRequestBroadcastFilter mf : perRequestFilters) { synchronized (mf) { transformed = mf.filter(r, originalMessage, transformed.message()); if (transformed == null || transformed.action() == BroadcastAction.ACTION.ABORT || transformed.action() == BroadcastAction.ACTION.SKIP) { return transformed; } } } return wrap(transformed, isManipulated); }","old_code_raw":"    protected BroadcastAction filter(AtmosphereResource r, Object message, Object originalMessage) {\n        BroadcastAction transformed = new BroadcastAction(message);\n        for (PerRequestBroadcastFilter mf : perRequestFilters) {\n            synchronized (mf) {\n                transformed = mf.filter(r, originalMessage, transformed.message());\n                if (transformed == null\n                        || transformed.action() == BroadcastAction.ACTION.ABORT\n                        || transformed.action() == BroadcastAction.ACTION.SKIP) {\n                    return transformed;\n                }\n            }\n        }\n        return transformed;\n    }\n","new_comment_raw":"@return BroadcastAction that tell Atmosphere to invoke the next filter or not.","old_comment_raw":"@return BroadcastAction that tell Atmosphere to invoke the next filter or not.","label":0,"pre_label":1,"AST_level":10,"line_counts":23,"new_code_token_num":116},{"new_code_raw":"public String getValue(String locator) { return (String) seleneseMethods.get(\"getValue\").apply(driver, locator); }","old_code_raw":"  public String getValue(String locator) {\n    return elementFinder.findElement(driver, locator)\n        .getValue();\n  }\n","new_comment_raw":"@return the element value, or \"on\/off\" for checkbox\/radio elements","old_comment_raw":"@return the element value, or \"on\/off\" for checkbox\/radio elements","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { \/\/ prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\"); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" + \/\/ prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\"); prevWordAfter.setLength(0); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 77: break; case 2: { return getNext(\"<\", yytext()); } case 78: break; case 3: { return getNext(); } case 79: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 80: break; case 5: { if (tokenizeNLs) { return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens } else if (invertible) { \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\"); prevWordAfter.append(yytext()); } } case 81: break; case 6: { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 82: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 83: break; case 8: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 84: break; case 9: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 85: break; case 10: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 86: break; case 11: { return getNext(\">\", yytext()); } case 87: break; case 12: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 88: break; case 13: { handleHyphenatedNumber(yytext()); if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); } return getNext(removeFromNumber(yytext()), yytext()); } case 89: break; case 14: { return handleEllipsis(yytext()); } case 90: break; case 15: { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much! String tok = yytext(); \/* A THING can contain quote like O'Malley *\/ String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 91: break; case 16: { String txt = yytext(); String norm = normalizeFractions(yytext()); if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm + \"; normalizeFractions=\" + normalizeFractions + \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); } return getNext(norm, txt); } case 92: break; case 17: { if (normalizeCurrency) { return getNext(LexerUtils.normalizeCurrency(yytext()), yytext()); } else { return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext()); } } case 93: break; case 18: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 94: break; case 19: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 95: break; case 20: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 96: break; case 21: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 97: break; case 22: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 98: break; case 23: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 99: break; case 24: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 100: break; case 25: { String tok = yytext(); String norm = LexerUtils.processCp1252misc(tok); if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); } return getNext(norm, tok); } case 101: break; case 26: { if (invertible) { prevWordAfter.append(yytext()); } } case 102: break; case 27: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 103: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 104: break; case 29: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 105: break; case 30: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 106: break; case 31: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 107: break; case 32: { String tok = yytext(); if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); } return getNext(tok, tok); } case 108: break; case 33: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 109: break; case 34: { breakByHyphens(yytext()); if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + LexerUtils.removeSoftHyphens(yytext())); } return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 110: break; case 35: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (americanize) { tok = Americanize.americanize(tok); } if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 111: break; case 36: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 112: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String origTok = yytext(); String norm = LexerUtils.removeSoftHyphens(origTok); if (DEBUG) { logger.info(\"Used {WORD} (3) to recognize \" + origTok + \" as \" + norm); } return getNext(norm, origTok); } case 113: break; case 38: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) return processAbbrev1(); } case 114: break; case 39: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 115: break; case 40: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\" \/\/ can't have digit here because of cases like '90s String tok = yytext(); \/* invert single quote - often but not always right *\/ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 116: break; case 41: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 117: break; case 42: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\" \/\/ can't have digit here because of cases like '90s String tok = yytext(); \/* invert single quote - often but not always right *\/ String norm = handleQuotes(tok, true); if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + true); } return getNext(norm, tok); } case 118: break; case 43: { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 119: break; case 44: { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 120: break; case 45: { if (splitAssimilations) { yypushback(2); } String tok = yytext(); if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok + \"; splitAssimilations=\" + splitAssimilations); } return getNext(tok, tok); } case 121: break; case 46: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); return getNext(); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, yytext()); } case 122: break; case 47: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {THINGA} (2) to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 123: break; case 48: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 124: break; case 49: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 125: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tok = LexerUtils.removeSoftHyphens(origTxt); if (DEBUG) { logger.info(\"Used {SWORD} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 126: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 127: break; case 52: { String txt = yytext(); String normTok = txt; if (escapeForwardSlashAsterisk) { normTok = delimit(normTok, '*'); } if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); } return getNext(normTok, txt); } case 128: break; case 53: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {TBSPEC} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 129: break; case 54: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); String norm = handleQuotes(tok, false); if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm + \"; probablyLeft=\" + false); } return getNext(norm, tok); } case 130: break; case 55: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 131: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; case 57: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 133: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 134: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 135: break; case 60: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 136: break; case 61: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String tok = yytext(); breakByHyphens(tok); tok = yytext(); String norm = LexerUtils.removeSoftHyphens(tok); if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); } return getNext(norm, tok); } case 137: break; case 62: { if (splitAssimilations) { yypushback(3); } String tok = yytext(); if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok + \"; splitAssimilations=\" + splitAssimilations); } return getNext(tok, tok); } case 138: break; case 63: { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {SPAMP} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 139: break; case 64: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext()); } case 140: break; case 65: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { final String origTxt = yytext(); String tok; if (normalizeAmpersandEntity) { tok = LexerUtils.normalizeAmp(origTxt); } else { tok = origTxt; } if (DEBUG) { logger.info(\"Used {THINGA} to recognize \" + origTxt + \" as \" + tok); } return getNext(tok, origTxt); } case 141: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 142: break; case 67: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 143: break; case 68: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 144: break; case 69: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 145: break; case 70: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 146: break; case 71: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 147: break; case 72: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 148: break; case 73: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 149: break; case 74: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); } return getNext(txt, yytext()); } case 150: break; case 75: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 151: break; case 76: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 152: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            \/\/ prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            \/\/         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 80: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 81: break;\n          case 3: \n            { return getNext();\n            }\n          case 82: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens\n                  } else if (invertible) {\n                    \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 84: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 85: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 86: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 87: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 88: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 89: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 90: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 91: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 92: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 93: break;\n          case 15: \n            { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  \/* A THING can contain quote like O'Malley *\/\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 94: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 95: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(LexerUtils.normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(LexerUtils.minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 96: break;\n          case 18: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 19: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 98: break;\n          case 20: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 99: break;\n          case 21: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 100: break;\n          case 22: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 101: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 102: break;\n          case 24: \n            { String tok = yytext();\n                        String norm = LexerUtils.processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 103: break;\n          case 25: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 104: break;\n          case 26: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 105: break;\n          case 27: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 18;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 106: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 107: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 108: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 109: break;\n          case 31: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 110: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 111: break;\n          case 33: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 112: break;\n          case 34: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + LexerUtils.removeSoftHyphens(yytext())); }\n                  return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 113: break;\n          case 35: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 114: break;\n          case 36: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 115: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String origTok = yytext();\n                          String norm = LexerUtils.removeSoftHyphens(origTok);\n                          if (DEBUG) { logger.info(\"Used {WORD} (3) to recognize \" + origTok + \" as \" + norm); }\n                          return getNext(norm, origTok);\n            }\n          case 116: break;\n          case 38: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          return processAbbrev1();\n            }\n          case 117: break;\n          case 39: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 118: break;\n          case 40: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 119: break;\n          case 41: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 120: break;\n          case 42: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 121: break;\n          case 43: \n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 122: break;\n          case 44: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 123: break;\n          case 45: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 124: break;\n          case 46: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { String txt = yytext();\n                  if (DEBUG) { logger.info(\"Used {DIGIT}\/{SEP_SUFFIX} to recognize \" + txt); }\n                  return getNext(txt, txt);\n            }\n          case 125: break;\n          case 47: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 126: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} (2) to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 127: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 128: break;\n          case 50: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 129: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = LexerUtils.removeSoftHyphens(origTxt);\n                          if (DEBUG) { logger.info(\"Used {SWORD} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 130: break;\n          case 52: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 19;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 18;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 131: break;\n          case 53: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 132: break;\n          case 54: \n            { final String origTxt = yytext();\n                  String tok;\n                  if (normalizeAmpersandEntity) {\n                    tok = LexerUtils.normalizeAmp(origTxt);\n                  } else {\n                    tok = origTxt;\n                  }\n                  if (DEBUG) { logger.info(\"Used {TBSPEC} to recognize \" + origTxt + \" as \" + tok); }\n                  return getNext(tok, origTxt);\n            }\n          case 133: break;\n          case 55: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 134: break;\n          case 56: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 2);\n            { String txt = yytext();\n                  return getNext(txt, txt);\n            }\n          case 135: break;\n          case 57: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 136: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 22;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 137: break;\n          case 59: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 138: break;\n          case 60: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 139: break;\n          case 61: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 22;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 23;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 140: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = LexerUtils.removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 141: break;\n          case 63: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 142: break;\n          case 64: \n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {SPAMP} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 143: break;\n          case 65: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(LexerUtils.removeSoftHyphens(yytext()), yytext());\n            }\n          case 144: break;\n          case 66: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { final String origTxt = yytext();\n                          String tok;\n                          if (normalizeAmpersandEntity) {\n                            tok = LexerUtils.normalizeAmp(origTxt);\n                          } else {\n                            tok = origTxt;\n                          }\n                          if (DEBUG) { logger.info(\"Used {THINGA} to recognize \" + origTxt + \" as \" + tok); }\n                          return getNext(tok, origTxt);\n            }\n          case 145: break;\n          case 67: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 9;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 146: break;\n          case 68: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 147: break;\n          case 69: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 14;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 148: break;\n          case 70: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 9;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 10;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 149: break;\n          case 71: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 14;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 15;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 150: break;\n          case 72: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                            String norm = txt;\n                            if (escapeForwardSlashAsterisk) {\n                              norm = delimit(norm, '\/');\n                              norm = delimit(norm, '*');\n                            }\n                            if (DEBUG) { logger.info(\"Used {LIKELYURL} to recognize \" + txt + \" as \" + norm); }\n                            return getNext(norm, txt);\n            }\n          case 151: break;\n          case 73: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 152: break;\n          case 74: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 153: break;\n          case 75: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 154: break;\n          case 76: \n            { String txt = yytext();\n                          String norm = txt;\n                          if (escapeForwardSlashAsterisk) {\n                            norm = delimit(norm, '\/');\n                            norm = delimit(norm, '*');\n                          }\n                          if (DEBUG) { logger.info(\"Used {FULLURL} to recognize \" + txt + \" as \" + norm); }\n                          return getNext(norm, txt);\n            }\n          case 155: break;\n          case 77: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 156: break;\n          case 78: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 25;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 27;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 157: break;\n          case 79: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 25;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 26;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 158: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":21,"line_counts":1120,"new_code_token_num":7930},{"new_code_raw":"long insertOpenCell(double latitude, double longitude, int mcc, int mnc, int lac, int cellID, int avgSigStr, int range, int samples, int isGPSexact, String RAT) { ContentValues cellIDValues = new ContentValues(); cellIDValues.put(STR, latitude); cellIDValues.put(STR, longitude); cellIDValues.put(STR, mcc); cellIDValues.put(STR, mnc); cellIDValues.put(STR, lac); cellIDValues.put(STR, cellID); cellIDValues.put(STR, avgSigStr); cellIDValues.put(STR, range); cellIDValues.put(STR, samples); cellIDValues.put(STR, isGPSexact); cellIDValues.put(STR, RAT); if (openCellExists(cellID)) { Log.v(TAG, mTAG + STR + cellID); return NUM; } else { return mDb.insert(OPENCELLID_TABLE, null, cellIDValues); } }","old_code_raw":"long insertOpenCell(double latitude, double longitude, int mcc, int mnc, int lac, int cellID, int avgSigStr, int range, int samples, int isGPSexact, String RAT) {\n    ContentValues cellIDValues = new ContentValues();\n    cellIDValues.put(STR, latitude);\n    cellIDValues.put(STR, longitude);\n    cellIDValues.put(STR, mcc);\n    cellIDValues.put(STR, mnc);\n    cellIDValues.put(STR, lac);\n    cellIDValues.put(STR, cellID);\n    cellIDValues.put(STR, avgSigStr);\n    cellIDValues.put(STR, range);\n    cellIDValues.put(STR, samples);\n    cellIDValues.put(STR, isGPSexact);\n    cellIDValues.put(STR, RAT);\n    if (openCellExists(cellID)) {\n        Log.v(TAG, STR + cellID);\n        return NUM;\n    } else {\n        return mDb.insert(OPENCELLID_TABLE, null, cellIDValues);\n    }\n}","new_comment_raw":"@return row id or -1 if error","old_comment_raw":"@return row id or -1 if error TODO: Is this where CSV data is populating the opencellid table?","label":1,"pre_label":0,"AST_level":9,"line_counts":20,"new_code_token_num":171},{"new_code_raw":"public Long getCountOfTheWords(String studySetName) { return (Long) EM.createQuery(STR).setParameter(STR, studySetName).getSingleResult(); }","old_code_raw":"public Long getCountOfTheWords() {\n    return (Long) EM.createQuery(STR).getSingleResult();\n}","new_comment_raw":"@return current number of words for study from respective study set","old_comment_raw":"@return current number of words for study","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":28},{"new_code_raw":"public BuildResult getPreviousResult() { ResultAction<? extends BuildResult> action = getPreviousAction(); if (action != null) { return action.getResult(); } throw new NoSuchElementException(STR); }","old_code_raw":"public BuildResult getPreviousResult() {\n    return getPreviousAction().getResult();\n}","new_comment_raw":"@return the previous build result","old_comment_raw":"@return the action of the previous build, or <code>null<\/code> if no such build exists","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":37},{"new_code_raw":"public ContainerResponse filter(final ContainerRequest request, final ContainerResponse response) { if (response.getMappedThrowable() != null) { return response; } AtmosphereResource<HttpServletRequest, HttpServletResponse> r = (AtmosphereResource<HttpServletRequest, HttpServletResponse>) servletReq .getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE); if (Boolean.parseBoolean((String) servletReq.getAttribute(ApplicationConfig.SUPPORT_LOCATION_HEADER))) { useResumeAnnotation = true; } switch (action) { case ASYNCHRONOUS: \/\/ Force the status code to 200 events independently of the value of the entity (null or not) if (response.getStatus() == 204) { response.setStatus(200); } String transport = servletReq.getHeader(X_ATMOSPHERE_TRANSPORT); String broadcasterName = servletReq.getHeader(topic); if (transport == null || broadcasterName == null) { throw new WebApplicationException(new IllegalStateException(\"Must specify transport using header value \" + X_ATMOSPHERE_TRANSPORT + \" and uuid \" + X_ATMOSPHERE_TRACKING_ID)); } String subProtocol = (String) servletReq.getAttribute(FrameworkConfig.WEBSOCKET_SUBPROTOCOL); final boolean waitForResource = waitFor == -1 ? true : false; final Broadcaster bcaster = BroadcasterFactory.getDefault().lookup(broadcasterName, true); if (!transport.startsWith(POLLING_TRANSPORT) && subProtocol == null) { boolean outputJunk = transport.equalsIgnoreCase(STREAMING_TRANSPORT); final boolean resumeOnBroadcast = resumeOnBroadcast(false); for (Class<? extends AtmosphereResourceEventListener> listener : listeners) { try { AtmosphereResourceEventListener el = listener.newInstance(); InjectorProvider.getInjector().inject(el); if (r instanceof AtmosphereEventLifecycle) { r.addEventListener(el); } } catch (Throwable t) { throw new WebApplicationException( new IllegalStateException(\"Invalid AtmosphereResourceEventListener \" + listener)); } } final Object entity = response.getEntity(); r.addEventListener(new AtmosphereResourceEventListenerAdapter() { @Override public void onSuspend(AtmosphereResourceEvent<HttpServletRequest, HttpServletResponse> event) { try { if (entity != null) { if (waitForResource) { bcaster.awaitAndBroadcast(entity, 30, TimeUnit.SECONDS); } else { bcaster.broadcast(entity); } } } finally { event.getResource().removeEventListener(this); } } }); if (resumeOnBroadcast) { servletReq.setAttribute(ApplicationConfig.RESUME_ON_BROADCAST, new Boolean(true)); } r.setBroadcaster(bcaster); executeSuspend(r, timeout, outputJunk, resumeOnBroadcast, null, request, response, false); } else { Object entity = response.getEntity(); if (waitForResource) { bcaster.awaitAndBroadcast(entity, 30, TimeUnit.SECONDS); } else { bcaster.broadcast(entity); } if (subProtocol == null) { try { if (Callable.class.isAssignableFrom(entity.getClass())) { entity = Callable.class.cast(entity).call(); } response.setEntity(entity); response.write(); } catch (Throwable t) { logger.debug(\"Error running Callable\", t); response.setEntity(null); } } else { response.setEntity(null); } } break; case SUSPEND_RESPONSE: SuspendResponse<?> s = SuspendResponse.class.cast(JResponseAsResponse.class.cast(response.getResponse()).getJResponse()); boolean outputJunk = outputJunk(s.outputComments()); boolean resumeOnBroadcast = resumeOnBroadcast(s.resumeOnBroadcast()); for (AtmosphereResourceEventListener el : s.listeners()) { if (r instanceof AtmosphereEventLifecycle) { r.addEventListener(el); } } Broadcaster bc = s.broadcaster(); if (bc == null && s.scope() != Suspend.SCOPE.REQUEST) { bc = (Broadcaster) servletReq.getAttribute(INJECTED_BROADCASTER); } boolean supportTrackable = servletReq.getAttribute(ApplicationConfig.SUPPORT_TRACKABLE) != null; \/\/ Register our TrackableResource boolean isTracked = response.getEntity() != null ? TrackableResource.class.isAssignableFrom(response.getEntity().getClass()) : supportTrackable; TrackableResource<? extends Trackable> trackableResource = null; if (isTracked) { trackableResource = preTrack(request, response); } suspend(resumeOnBroadcast, outputJunk, translateTimeUnit(s.period().value(), s.period().timeUnit()), request, response, bc, r, s.scope()); \/\/ Associate the tracked resource. if (isTracked && trackableResource != null) { postTrack(trackableResource, r); } break; case SUBSCRIBE_TRACKABLE: case SUBSCRIBE: case SUSPEND: case SUSPEND_TRACKABLE: case SUSPEND_RESUME: outputJunk = outputJunk(outputComments); resumeOnBroadcast = resumeOnBroadcast((action == Action.SUSPEND_RESUME)); for (Class<? extends AtmosphereResourceEventListener> listener : listeners) { try { AtmosphereResourceEventListener el = listener.newInstance(); InjectorProvider.getInjector().inject(el); if (r instanceof AtmosphereEventLifecycle) { ((AtmosphereEventLifecycle) r).addEventListener(el); } } catch (Throwable t) { throw new WebApplicationException( new IllegalStateException(\"Invalid AtmosphereResourceEventListener \" + listener, t)); } } Broadcaster broadcaster = (Broadcaster) servletReq.getAttribute(INJECTED_BROADCASTER); \/\/ @Subscribe if (action == Action.SUBSCRIBE) { Class<Broadcaster> c = null; try { c = (Class<Broadcaster>) Class.forName((String) servletReq.getAttribute(ApplicationConfig.BROADCASTER_CLASS)); } catch (Throwable e) { throw new IllegalStateException(e.getMessage()); } broadcaster = BroadcasterFactory.getDefault().lookup(c, topic, true); } \/\/ Tracking is enabled by default supportTrackable = servletReq.getAttribute(ApplicationConfig.SUPPORT_TRACKABLE) != null; \/\/ Register our TrackableResource isTracked = response.getEntity() != null ? TrackableResource.class.isAssignableFrom(response.getEntity().getClass()) : supportTrackable; if (isTracked) { trackableResource = preTrack(request, response); } else { trackableResource = null; } suspend(resumeOnBroadcast, outputJunk, timeout, request, response, broadcaster, r, scope); \/\/ Associate the tracked resource. if (isTracked && trackableResource != null) { postTrack(trackableResource, r); } break; case RESUME: if (response.getEntity() != null) { try { response.write(); } catch (IOException ex) { throw new WebApplicationException(ex); } } boolean sessionSupported = (Boolean) servletReq.getAttribute(FrameworkConfig.SUPPORT_SESSION); if (sessionSupported) { r = (AtmosphereResource) servletReq.getSession().getAttribute(SUSPENDED_RESOURCE); } else { String path = response.getContainerRequest().getPath(); r = resumeCandidates.remove(path.substring(path.lastIndexOf(\"\/\") + 1)); } if (r != null) { resume(r); } else { throw new WebApplicationException( new IllegalStateException(\"Unable to retrieve suspended Response. \" + \"Either session-support is not enabled in atmosphere.xml or the\" + \"path used to resume is invalid.\")); } break; case BROADCAST: case PUBLISH: case RESUME_ON_BROADCAST: AtmosphereResource ar = (AtmosphereResource) servletReq.getAttribute(SUSPENDED_RESOURCE); if (ar != null) { r = ar; } if (action == Action.PUBLISH) { Class<Broadcaster> c = null; try { c = (Class<Broadcaster>) Class.forName((String) servletReq.getAttribute(ApplicationConfig.BROADCASTER_CLASS)); } catch (Throwable e) { throw new IllegalStateException(e.getMessage()); } r.setBroadcaster(BroadcasterFactory.getDefault().lookup(c, topic, true)); } broadcast(response, r, timeout); break; case SCHEDULE: case SCHEDULE_RESUME: Object o = response.getEntity(); Broadcaster b = r.getBroadcaster(); if (response.getEntity() instanceof Broadcastable) { b = ((Broadcastable) response.getEntity()).getBroadcaster(); o = ((Broadcastable) response.getEntity()).getMessage(); response.setEntity(((Broadcastable) response.getEntity()).getResponseMessage()); } if (response.getEntity() != null) { try { response.write(); } catch (IOException ex) { throw new WebApplicationException(ex); } } if (action == Action.SCHEDULE_RESUME) { configureResumeOnBroadcast(b); } b.scheduleFixedBroadcast(o, waitFor, timeout, TimeUnit.SECONDS); break; } return response; }","old_code_raw":"        public ContainerResponse filter(final ContainerRequest request, final ContainerResponse response) {\n            if (response.getMappedThrowable() != null) {\n                return response;\n            }\n\n            AtmosphereResource<HttpServletRequest, HttpServletResponse> r =\n                    (AtmosphereResource<HttpServletRequest, HttpServletResponse>) servletReq\n                            .getAttribute(FrameworkConfig.ATMOSPHERE_RESOURCE);\n\n            if (Boolean.parseBoolean((String) servletReq.getAttribute(ApplicationConfig.SUPPORT_LOCATION_HEADER))) {\n                useResumeAnnotation = true;\n            }\n\n            switch (action) {\n                case ASYNCHRONOUS:\n                    \/\/ Force the status code to 200 events independently of the value of the entity (null or not)\n                    if (response.getStatus() == 204) {\n                        response.setStatus(200);\n                    }\n\n                    String transport = servletReq.getHeader(X_ATMOSPHERE_TRANSPORT);\n                    if (transport == null) {\n                        logger.warn(\"Must specify transport using header value \" + X_ATMOSPHERE_TRANSPORT);\n                        response.setStatus(400);\n                        return response;\n                    }\n                    String subProtocol = (String) servletReq.getAttribute(FrameworkConfig.WEBSOCKET_SUBPROTOCOL);\n\n                    String broadcasterName = servletReq.getHeader(topic);\n                    final boolean waitForResource = waitFor == -1 ? true : false;\n                    final Broadcaster bcaster = BroadcasterFactory.getDefault().lookup(broadcasterName, true);\n\n                    if (!transport.startsWith(POLLING_TRANSPORT) && subProtocol == null) {\n                        boolean outputJunk = transport.equalsIgnoreCase(STREAMING_TRANSPORT);\n                        final boolean resumeOnBroadcast = resumeOnBroadcast(false);\n\n                        for (Class<? extends AtmosphereResourceEventListener> listener : listeners) {\n                            try {\n                                AtmosphereResourceEventListener el = listener.newInstance();\n                                InjectorProvider.getInjector().inject(el);\n                                if (r instanceof AtmosphereEventLifecycle) {\n                                    r.addEventListener(el);\n                                }\n                            } catch (Throwable t) {\n                                throw new WebApplicationException(\n                                        new IllegalStateException(\"Invalid AtmosphereResourceEventListener \" + listener));\n                            }\n                        }\n                        final Object entity = response.getEntity();\n\n                        r.addEventListener(new AtmosphereResourceEventListenerAdapter() {\n                            @Override\n                            public void onSuspend(AtmosphereResourceEvent<HttpServletRequest, HttpServletResponse> event) {\n                                try {\n                                    if (entity != null) {\n                                        if (waitForResource) {\n                                            bcaster.awaitAndBroadcast(entity, 30, TimeUnit.SECONDS);\n                                        } else {\n                                            bcaster.broadcast(entity);\n                                        }\n                                    }\n                                } finally {\n                                    event.getResource().removeEventListener(this);\n                                }\n                            }\n                        });\n\n                        if (resumeOnBroadcast) {\n                            servletReq.setAttribute(ApplicationConfig.RESUME_ON_BROADCAST, new Boolean(true));\n                        }\n\n                        r.setBroadcaster(bcaster);\n                        executeSuspend(r, timeout, outputJunk, resumeOnBroadcast, null, request, response, false);\n                    } else {\n                        Object entity = response.getEntity();\n                        if (waitForResource) {\n                            bcaster.awaitAndBroadcast(entity, 30, TimeUnit.SECONDS);\n                        } else {\n                            bcaster.broadcast(entity);\n                        }\n\n                        if (subProtocol == null) {\n                            try {\n                                if (Callable.class.isAssignableFrom(entity.getClass())) {\n                                    entity = Callable.class.cast(entity).call();\n                                }\n                                response.setEntity(entity);\n                                response.write();\n                            } catch (Throwable t) {\n                                logger.debug(\"Error running Callable\", t);\n                                response.setEntity(null);\n                            }\n                        } else {\n                            response.setEntity(null);\n                        }\n                    }\n                    break;\n                case SUSPEND_RESPONSE:\n                    SuspendResponse<?> s = SuspendResponse.class.cast(JResponseAsResponse.class.cast(response.getResponse()).getJResponse());\n\n                    boolean outputJunk = outputJunk(s.outputComments());\n                    boolean resumeOnBroadcast = resumeOnBroadcast(s.resumeOnBroadcast());\n\n                    for (AtmosphereResourceEventListener el : s.listeners()) {\n                        if (r instanceof AtmosphereEventLifecycle) {\n                            r.addEventListener(el);\n                        }\n                    }\n\n                    Broadcaster bc = s.broadcaster();\n                    if (bc == null && s.scope() != Suspend.SCOPE.REQUEST) {\n                        bc = (Broadcaster) servletReq.getAttribute(INJECTED_BROADCASTER);\n                    }\n\n                    boolean supportTrackable = servletReq.getAttribute(ApplicationConfig.SUPPORT_TRACKABLE) != null;\n                    \/\/ Register our TrackableResource\n                    boolean isTracked = response.getEntity() != null ? TrackableResource.class.isAssignableFrom(response.getEntity().getClass()) : supportTrackable;\n\n                    TrackableResource<? extends Trackable> trackableResource = null;\n                    if (isTracked) {\n                        trackableResource = preTrack(request, response);\n                    }\n\n                    suspend(resumeOnBroadcast, outputJunk,\n                            translateTimeUnit(s.period().value(), s.period().timeUnit()), request, response, bc, r, s.scope());\n\n                    \/\/ Associate the tracked resource.\n                    if (isTracked && trackableResource != null) {\n                        postTrack(trackableResource, r);\n                    }\n\n                    break;\n                case SUBSCRIBE_TRACKABLE:\n                case SUBSCRIBE:\n                case SUSPEND:\n                case SUSPEND_TRACKABLE:\n                case SUSPEND_RESUME:\n                    outputJunk = outputJunk(outputComments);\n                    resumeOnBroadcast = resumeOnBroadcast((action == Action.SUSPEND_RESUME));\n\n                    for (Class<? extends AtmosphereResourceEventListener> listener : listeners) {\n                        try {\n                            AtmosphereResourceEventListener el = listener.newInstance();\n                            InjectorProvider.getInjector().inject(el);\n                            if (r instanceof AtmosphereEventLifecycle) {\n                                ((AtmosphereEventLifecycle) r).addEventListener(el);\n                            }\n                        } catch (Throwable t) {\n                            throw new WebApplicationException(\n                                    new IllegalStateException(\"Invalid AtmosphereResourceEventListener \" + listener, t));\n                        }\n                    }\n\n                    Broadcaster broadcaster = (Broadcaster) servletReq.getAttribute(INJECTED_BROADCASTER);\n                    \/\/ @Subscribe\n                    if (action == Action.SUBSCRIBE) {\n                        Class<Broadcaster> c = null;\n                        try {\n                            c = (Class<Broadcaster>) Class.forName((String) servletReq.getAttribute(ApplicationConfig.BROADCASTER_CLASS));\n                        } catch (Throwable e) {\n                            throw new IllegalStateException(e.getMessage());\n                        }\n                        broadcaster = BroadcasterFactory.getDefault().lookup(c, topic, true);\n                    }\n\n                    \/\/ Tracking is enabled by default\n                    supportTrackable = servletReq.getAttribute(ApplicationConfig.SUPPORT_TRACKABLE) != null;\n                    \/\/ Register our TrackableResource\n                    isTracked = response.getEntity() != null ? TrackableResource.class.isAssignableFrom(response.getEntity().getClass()) : supportTrackable;\n\n                    if (isTracked) {\n                        trackableResource = preTrack(request, response);\n                    } else {\n                        trackableResource = null;\n                    }\n\n                    suspend(resumeOnBroadcast, outputJunk, timeout, request, response,\n                            broadcaster, r, scope);\n\n                    \/\/ Associate the tracked resource.\n                    if (isTracked && trackableResource != null) {\n                        postTrack(trackableResource, r);\n                    }\n                    break;\n                case RESUME:\n                    if (response.getEntity() != null) {\n                        try {\n                            response.write();\n                        } catch (IOException ex) {\n                            throw new WebApplicationException(ex);\n                        }\n                    }\n\n                    boolean sessionSupported = (Boolean) servletReq.getAttribute(FrameworkConfig.SUPPORT_SESSION);\n                    if (sessionSupported) {\n                        r = (AtmosphereResource) servletReq.getSession().getAttribute(SUSPENDED_RESOURCE);\n                    } else {\n                        String path = response.getContainerRequest().getPath();\n                        r = resumeCandidates.remove(path.substring(path.lastIndexOf(\"\/\") + 1));\n                    }\n\n                    if (r != null) {\n                        resume(r);\n                    } else {\n                        throw new WebApplicationException(\n                                new IllegalStateException(\"Unable to retrieve suspended Response. \" +\n                                        \"Either session-support is not enabled in atmosphere.xml or the\" +\n                                        \"path used to resume is invalid.\"));\n\n                    }\n                    break;\n                case BROADCAST:\n                case PUBLISH:\n                case RESUME_ON_BROADCAST:\n                    AtmosphereResource ar = (AtmosphereResource) servletReq.getAttribute(SUSPENDED_RESOURCE);\n                    if (ar != null) {\n                        r = ar;\n                    }\n\n                    if (action == Action.PUBLISH) {\n                        Class<Broadcaster> c = null;\n                        try {\n                            c = (Class<Broadcaster>) Class.forName((String) servletReq.getAttribute(ApplicationConfig.BROADCASTER_CLASS));\n                        } catch (Throwable e) {\n                            throw new IllegalStateException(e.getMessage());\n                        }\n                        r.setBroadcaster(BroadcasterFactory.getDefault().lookup(c, topic, true));\n                    }\n\n                    broadcast(response, r, timeout);\n                    break;\n                case SCHEDULE:\n                case SCHEDULE_RESUME:\n                    Object o = response.getEntity();\n                    Broadcaster b = r.getBroadcaster();\n                    if (response.getEntity() instanceof Broadcastable) {\n                        b = ((Broadcastable) response.getEntity()).getBroadcaster();\n                        o = ((Broadcastable) response.getEntity()).getMessage();\n                        response.setEntity(((Broadcastable) response.getEntity()).getResponseMessage());\n                    }\n\n                    if (response.getEntity() != null) {\n                        try {\n                            response.write();\n                        } catch (IOException ex) {\n                            throw new WebApplicationException(ex);\n                        }\n                    }\n\n                    if (action == Action.SCHEDULE_RESUME) {\n                        configureResumeOnBroadcast(b);\n                    }\n\n                    b.scheduleFixedBroadcast(o, waitFor, timeout, TimeUnit.SECONDS);\n                    break;\n            }\n\n            return response;\n        }\n","new_comment_raw":"@return the  ContainerResponse","old_comment_raw":"@return the ContainerResponse","label":0,"pre_label":1,"AST_level":18,"line_counts":260,"new_code_token_num":1483},{"new_code_raw":"public static String export() { RequestLog current = RLOG.get(); record(new Durations(current.aggregateDurations())); record(new Threads(current.threadIds)); return LogFormatterProvider.getInstance().format(current.info); }","old_code_raw":"public static String export() {\n    RequestLog current = RLOG.get();\n    record(new Durations(current.aggregateDurations()));\n    record(new Threads(current.threadIds));\n    try {\n        return current.mapper.writeValueAsString(current.info);\n    } catch (JsonProcessingException jpe) {\n        String msg = String.format(STR, current.logId);\n        LOG.warn(msg, jpe);\n        return msg;\n    }\n}","new_comment_raw":"@return log object as a formatted string","old_comment_raw":"@return log object as a JSON formatted string","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":48},{"new_code_raw":"public Boolean apply(WebDriver webDriver) { return elements.stream().allMatch(ExpectedConditions::isInvisible); }","old_code_raw":"      public Boolean apply(WebDriver webDriver) {\n        for (WebElement element : elements) {\n          try {\n            if (element.isDisplayed()) {\n              return false;\n            }\n          } catch (StaleElementReferenceException ignored) {\n            \/\/ We can assume a stale element isn't displayed.\n          }\n        }\n        return true;\n      }\n","new_comment_raw":"@return Boolean true when all elements are not visible anymore","old_comment_raw":"@return Boolean true when all elements are not visible anymore","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"private static Gobbling gobble(Treepath<SyntacticTree> gobbleStart, int indentation) { Preconditions.checkArgument(gobbleStart.getTreeAtEnd().isOneOf(_PLACEHOLDER_)); Treepath<SyntacticTree> start = gobbleStart; do { if (TreepathTools.hasNextSibling(start)) { final Treepath<SyntacticTree> next = TreepathTools.getNextSibling(start); if (isRawItem(next)) { final Treepath<SyntacticTree> minusNext = TreepathTools.removeNextSibling(start); return new Gobbling(minusNext, makeEmbeddedListItem(next), indentation); } else { final SyntacticTree nextTree = next.getTreeAtEnd(); if (nextTree.isOneOf(WHITESPACE_, LINE_BREAK_)) { start = TreepathTools.removeNextSibling(start); if (nextTree.isOneOf(WHITESPACE_)) { indentation = getWhitespaceLength(next); } continue; } } } return new Gobbling(start); } while (true); }","old_code_raw":"private static Gobbling gobble(Treepath<SyntacticTree> gobbleStart) {\n    if (null == gobbleStart) {\n        return null;\n    }\n    Preconditions.checkArgument(gobbleStart.getTreeAtEnd().isOneOf(_PLACEHOLDER_));\n    gobbleStart = TreepathTools.getNextSibling(gobbleStart);\n    do {\n        if (isRawItem(gobbleStart)) {\n            if (TreepathTools.hasNextSibling(gobbleStart)) {\n                final Treepath<SyntacticTree> nextStart = TreepathTools.getNextSibling(gobbleStart);\n                final Treepath<SyntacticTree> nextStartMinusPrevious = TreepathTools.removePreviousSibling(nextStart);\n                return new Gobbling(nextStartMinusPrevious, makeEmbeddedListItem(gobbleStart), true);\n            } else {\n                final Treepath<SyntacticTree> minusPrevious = TreepathTools.removeEnd(gobbleStart);\n                return new Gobbling(minusPrevious, makeEmbeddedListItem(gobbleStart), false);\n            }\n        } else if (gobbleStart.getTreeAtEnd().isOneOf(WHITESPACE_, LINE_BREAK_)) {\n            if (TreepathTools.hasNextSibling(gobbleStart)) {\n                gobbleStart = TreepathTools.getNextSibling(gobbleStart);\n            }\n        } else {\n            return null;\n        }\n    } while (true);\n}","new_comment_raw":"@return a {@code Gobbling} object containing the result of the gobble.","old_comment_raw":"@return null if {@code gobbleStart} was null, or a {@code Gobbling} object containing the result of the gobble. {@code Gobbling#treepathMinusGobbled} still refers to the _PLACEHOLDER_ but some separators and one raw item have been removed. {@code Gobbling#gobbledTree} is the result of the gobbling","label":1,"pre_label":0,"AST_level":16,"line_counts":23,"new_code_token_num":148},{"new_code_raw":"public String getId() { if (sid != null && !sid.isEmpty() && !sid.equals(SID_DEFAULT_VAL)) { return sid; } else if (dataCenterInfo instanceof UniqueIdentifier) { return ((UniqueIdentifier) dataCenterInfo).getId(); } else { return hostName; } }","old_code_raw":"    public String getId() {\n        if (instanceId != null && !instanceId.isEmpty()) {\n            return instanceId;\n        } else if (dataCenterInfo instanceof UniqueIdentifier) {\n            return ((UniqueIdentifier) dataCenterInfo).getId();\n        } else {\n            return hostName;\n        }\n    }\n","new_comment_raw":"@return the unique id.","old_comment_raw":"@return the unique id.","label":0,"pre_label":1,"AST_level":8,"line_counts":10,"new_code_token_num":59},{"new_code_raw":"Node getAssignedValue() { return (parent.getType() == Token.FUNCTION) ? parent : NodeUtil.getAssignedValue(getNameNode()); }","old_code_raw":"Node getAssignedValue() {\n    return NodeUtil.getAssignedValue(getNameNode());\n}","new_comment_raw":"@return For an assignment, variable declaration, or function declaration return the assigned value, otherwise null.","old_comment_raw":"@return For an assignment or variable declaration return the assigned value, otherwise null.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":26},{"new_code_raw":"public Interval withPeriodAfterStart(ReadablePeriod period) { if (period == null) { return withDurationAfterStart(null); } Chronology chrono = getChronology(); long startMillis = getStartMillis(); long endMillis = chrono.add(period, startMillis, 1); return new Interval(startMillis, endMillis, chrono); }","old_code_raw":"    public Interval withPeriodAfterStart(ReadablePeriod period) {\n        if (period == null) {\n            return this;\n        }\n        long startMillis = getStartMillis();\n        long endMillis = getChronology().add(period, startMillis, 1);\n        return new Interval(startMillis, endMillis);\n    }\n","new_comment_raw":"@return an interval with the start from this interval and a calculated end","old_comment_raw":"@return an interval with the start from this interval and a calculated end","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":57},{"new_code_raw":"public BooleanExpression endsWith(Expression<String> str) { return BooleanOperation.create(Ops.ENDS_WITH, mixin, str); }","old_code_raw":"    public BooleanExpression endsWith(Expression<String> str) {\n        return BooleanOperation.create(Ops.ENDS_WITH, this, str);\n    }\n","new_comment_raw":"@return this.endsWith(str)","old_comment_raw":"@return this.endsWith(str)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"@Action(value = STR) public String execute() throws Exception { LOG.info(STR + id); SocialAuthManager manager; if (userSession.get(STR) != null) { manager = (SocialAuthManager) userSession.get(STR); if (STR.equals(mode)) { manager.disconnectProvider(id); return STR; } } else { InputStream in = SocialAuthenticationAction.class.getClassLoader().getResourceAsStream(STR); SocialAuthConfig conf = SocialAuthConfig.getDefault(); conf.load(in); manager = new SocialAuthManager(); manager.setSocialAuthConfig(conf); userSession.put(STR, manager); } String returnToUrl = RequestUtils.getServletPath(request); System.out.println(returnToUrl); returnToUrl = UrlHelper.buildUrl(STR, request, response, null, null, true, true, true); url = manager.getAuthenticationUrl(id, returnToUrl); LOG.info(STR + url); if (url != null) { return STR; } return STR; }","old_code_raw":"@Override\npublic ActionForward execute(final ActionMapping mapping, final ActionForm form, final HttpServletRequest request, final HttpServletResponse response) throws Exception {\n    AuthForm authForm = (AuthForm) form;\n    String id = authForm.getId();\n    SocialAuthManager manager;\n    if (authForm.getSocialAuthManager() != null) {\n        manager = authForm.getSocialAuthManager();\n        if (STR.equals(request.getParameter(STR))) {\n            manager.disconnectProvider(id);\n            return mapping.findForward(STR);\n        }\n    } else {\n        InputStream in = SocialAuthenticationAction.class.getClassLoader().getResourceAsStream(STR);\n        SocialAuthConfig conf = SocialAuthConfig.getDefault();\n        conf.load(in);\n        manager = new SocialAuthManager();\n        manager.setSocialAuthConfig(conf);\n        authForm.setSocialAuthManager(manager);\n    }\n    String returnToUrl = RequestUtils.absoluteURL(request, STR).toString();\n    String url = manager.getAuthenticationUrl(id, returnToUrl);\n    LOG.info(STR + url);\n    if (url != null) {\n        ActionForward fwd = new ActionForward(STR, url, true);\n        return fwd;\n    }\n    return mapping.findForward(STR);\n}","new_comment_raw":"@return String where the action should flow","old_comment_raw":"@return ActionForward where the action should flow","label":1,"pre_label":0,"AST_level":9,"line_counts":28,"new_code_token_num":182},{"new_code_raw":"public Connection manualDisconnect() { if ( ! isLogicallyConnected() ) { throw new IllegalStateException( \"cannot manually disconnect because not logically connected.\" ); } batcher.closeStatements(); return connection.manualDisconnect(); }","old_code_raw":"\tpublic Connection manualDisconnect() {\n\t\treturn cleanup();\n\t}\n","new_comment_raw":"@return The connection mantained here at time of disconnect. Null if there was no connection cached internally.","old_comment_raw":"@return The connection mantained here at time of disconnect. Null if there was no connection cached internally.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":42},{"new_code_raw":"public boolean next() throws SQLException { if ( ! initialSchemaLoaded ) { throw new IllegalStateException( \"next() called but loadInitialSchema() was not called\" ); } assert afterFirstBatch : \"afterFirstBatch still false in next()\"; if ( afterLastRow ) { \/\/ We're already after end of rows\/records--just report that after end. return false; } else if ( returnTrueForNextCallToNext ) { ++currentRowNumber; \/\/ We have a deferred \"not after end\" to report--reset and report that. returnTrueForNextCallToNext = false; return true; } else { accessors.clearLastColumnIndexedInRow(); boolean res = nextRowInternally(); if (res) { ++ currentRowNumber; } return res; } }","old_code_raw":"  public boolean next() throws SQLException {\n    if ( ! initialSchemaLoaded ) {\n      throw new IllegalStateException(\n          \"next() called but loadInitialSchema() was not called\" );\n    }\n    assert afterFirstBatch : \"afterFirstBatch still false in next()\";\n\n    if ( afterLastRow ) {\n      \/\/ We're already after end of rows\/records--just report that after end.\n      return false;\n    }\n    else if ( returnTrueForNextCallToNext ) {\n      \/\/ We have a deferred \"not after end\" to report--reset and report that.\n      returnTrueForNextCallToNext = false;\n      return true;\n    }\n    else {\n      accessors.clearLastColumnIndexedInRow();\n      return nextRowInternally();\n    }\n  }\n","new_comment_raw":"@return whether cursor is positioned at a row (false when after end of results)","old_comment_raw":"@return whether cursor is positioned at a row (false when after end of results)","label":0,"pre_label":1,"AST_level":9,"line_counts":26,"new_code_token_num":139},{"new_code_raw":"public MediaList getMediaList() { synchronized (this) { if (mMediaList != null) { mMediaList.retain(); return mMediaList; } } final MediaList mediaList = new MediaList(this); synchronized (this) { mMediaList = mediaList; mMediaList.retain(); return mMediaList; } }","old_code_raw":"public synchronized MediaList getMediaList() {\n    if (mMediaList == null && !isReleased())\n        mMediaList = new MediaList(this);\n    return mMediaList;\n}","new_comment_raw":"@return MediaList. This MediaList should be released with {@link #release()}.","old_comment_raw":"@return MediaList, Should NOT be released.","label":1,"pre_label":0,"AST_level":7,"line_counts":14,"new_code_token_num":55},{"new_code_raw":"public EurekaInstanceConfig getEurekaInstanceConfig() { return eurekaInstanceConfig.get(); }","old_code_raw":"    public EurekaInstanceConfig getEurekaInstanceConfig() {\n        return eurekaInstanceConfig;\n    }\n","new_comment_raw":"@return the instance of  EurekaInstanceConfig this instance was initialized with.","old_comment_raw":"@return the instance of EurekaInstanceConfig this instance was initialized with.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<CalendarList> getCalendarList(@Optional @Default(STR) final boolean showHidden, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<CalendarList>() { @Override public List<CalendarList> doGetPage() throws IOException { com.google.api.services.calendar.Calendar.CalendarList.List calendars = client.calendarList().list(); com.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(pagingConfiguration.getFetchSize()).setPageToken(this.getPageToken()).setShowHidden(showHidden).execute(); setPageToken(list.getNextPageToken()); return CalendarList.valueOf(list.getItems(), CalendarList.class); } }; }","old_code_raw":"@Processor\n@Inject\n@OAuthProtected\n@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)\npublic List<CalendarList> getCalendarList(MuleMessage message, @Optional @Default(STR) int maxResults, @Optional String pageToken, @Optional @Default(STR) boolean showHidden) throws IOException {\n    com.google.api.services.calendar.Calendar.CalendarList.List calendars = this.client.calendarList().list();\n    com.google.api.services.calendar.model.CalendarList list = calendars.setMaxResults(maxResults).setPageToken(pageToken).setShowHidden(showHidden).execute();\n    this.saveNextPageToken(list, message);\n    return CalendarList.valueOf(list.getItems(), CalendarList.class);\n}","new_comment_raw":"@return a paginated iterator with instances of {@link org.mule.module.google.calendar.model.CalendarList}","old_comment_raw":"@return a list with instances of {@link org.mule.module.google.calendar.model.CalendarList}","label":1,"pre_label":0,"AST_level":14,"line_counts":16,"new_code_token_num":127},{"new_code_raw":"public int getAttribLocation(String name) { \/\/ return gl.glGetAttribLocation(programObject, name); return pgl.getAttribLocation(programObject, name); }","old_code_raw":"  public int getAttribLocation(String name) {\n    return (gl.glGetAttribLocation(programObject, name));\n  }\n","new_comment_raw":"@return int","old_comment_raw":"@return int","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":29},{"new_code_raw":"@Override public final String toString() { StringBuilder sb = new StringBuilder(); sb.append(STR); Iterator<E> it = iterator(); if (it.hasNext()) { for (; ; ) { Object e = it.next(); sb.append(e == this ? STR : e); if (!it.hasNext()) { break; } sb.append(STR).append(STR); } } return sb.append(STR).toString(); }","old_code_raw":"@Override\npublic String toString() {\n    Node<K, V>[] t;\n    int f = (t = table) == null ? NUM : t.length;\n    Traverser<K, V> it = new Traverser<K, V>(t, f, NUM, f);\n    StringBuilder sb = new StringBuilder();\n    sb.append(STR);\n    Node<K, V> p;\n    if ((p = it.advance()) != null) {\n        for (; ; ) {\n            K k = p.key;\n            V v = p.val;\n            sb.append(k == this ? STR : k);\n            sb.append(STR);\n            sb.append(v == this ? STR : v);\n            if ((p = it.advance()) == null) {\n                break;\n            }\n            sb.append(STR).append(STR);\n        }\n    }\n    return sb.append(STR).toString();\n}","new_comment_raw":"@return a string representation of this collection","old_comment_raw":"@return a string representation of this map","label":1,"pre_label":0,"AST_level":11,"line_counts":17,"new_code_token_num":96},{"new_code_raw":"public static SqlTypeFamily getFamilyForJdbcType(int jdbcType) { return JDBC_TYPE_TO_FAMILY.get(jdbcType); }","old_code_raw":"  public static SqlTypeFamily getFamilyForJdbcType(int jdbcType) {\n    return jdbcTypeToFamily[jdbcType - SqlTypeName.MIN_JDBC_TYPE];\n  }\n","new_comment_raw":"@return containing family","old_comment_raw":"@return containing family","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public final DBCompareColExpr in(Collection<?> values) { if (values == null || values.isEmpty()) return cmp(DBCmpType.EQUAL, null); return cmp(DBCmpType.IN, values); }","old_code_raw":"public DBCompareColExpr in(Object value) {\n    return cmp(DBCmpType.IN, listToArray(value));\n}","new_comment_raw":"@return a DBCompareColExpr for the \"in\" operator","old_comment_raw":"@return the new DBCompareColExpr object","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":40},{"new_code_raw":"protected Object convertUnsignedTinyint(Column column, Field fieldDefn, Object data){ return convertValue(column, fieldDefn, data, (short)0, (r) -> { if (data instanceof Short) { r.deliver(MySqlUnsignedIntegerConverter.convertUnsignedTinyint((short)data)); } else if (data instanceof Number) { r.deliver(MySqlUnsignedIntegerConverter.convertUnsignedTinyint(((Number)data).shortValue())); } else { \/\/We continue with the original converting method (smallint) since we have an unsigned Tinyint r.deliver(convertSmallInt(column, fieldDefn, data)); } }); }","old_code_raw":"    protected Object convertUnsignedTinyint(Column column, Field fieldDefn, Object data){\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return (short) 0;\n        }\n\n        if (data instanceof Short) {\n            return MySqlUnsignedIntegerConverter.convertUnsignedTinyint((short) data);\n        }\n        else if (data instanceof Number) {\n            return MySqlUnsignedIntegerConverter.convertUnsignedTinyint(((Number) data).shortValue());\n        }\n        else {\n            \/\/We continue with the original converting method (smallint) since we have an unsigned Tinyint\n            return convertSmallInt(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":13,"line_counts":15,"new_code_token_num":119},{"new_code_raw":"public Map<String, String> getAdditionalHttpHeaders() { return Collections.unmodifiableMap(additionalHttpHeaders); }","old_code_raw":"public Map<String, String> getAdditionalHttpHeaders() {\n    return additionalHttpHeaders == null ? null : Collections.unmodifiableMap(additionalHttpHeaders);\n}","new_comment_raw":"@return a read-only view of the additional HTTP headers which will be included in every request to the server.","old_comment_raw":"@return a read-only view of the additional HTTP headers which will be included in every request to the server, or null if no headers have been added","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"@Processor public Customer getCustomer(final String resourceUri) { return getClientProvider().getClient(Customer.class).getByResourceUri(resourceUri); }","old_code_raw":"@Processor\npublic Customer getCustomer(final String id) {\n    return getClientProvider().getClient(Customer.class).getById(id);\n}","new_comment_raw":"@return the customer with the given resourceUri, or null if it doesn't exist","old_comment_raw":"@return the customer with the given id, or null if it doesn't exist","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"private ZapTextArea getTxtDescription() { if (txtDescription == null) { txtDescription = new ZapTextArea(); txtDescription.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED)); txtDescription.setLineWrap(true); txtDescription.setFont(new java.awt.Font(\"Dialog\", java.awt.Font.PLAIN, 11)); } return txtDescription; }","old_code_raw":"\tprivate JTextArea getTxtDescription() {\n\t\tif (txtDescription == null) {\n\t\t\ttxtDescription = new JTextArea();\n\t\t\ttxtDescription.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));\n\t\t\ttxtDescription.setLineWrap(true);\n\t\t\ttxtDescription.setFont(new java.awt.Font(\"Dialog\", java.awt.Font.PLAIN, 11));\n\t\t}\n\t\treturn txtDescription;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextArea","old_comment_raw":"@return javax.swing.JTextArea","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":66},{"new_code_raw":"public static String getSqlTypeName(final MajorType type) { if (type.getMode() == DataMode.REPEATED || type.getMinorType() == MinorType.LIST) { return \"ARRAY\"; } switch (type.getMinorType()) { \/\/ Standard SQL atomic data types: case BIT: return \"BOOLEAN\"; case SMALLINT: return \"SMALLINT\"; case INT: return \"INTEGER\"; case BIGINT: return \"BIGINT\"; case FLOAT4: return \"FLOAT\"; case FLOAT8: return \"DOUBLE\"; case DECIMAL9: case DECIMAL18: case DECIMAL28DENSE: case DECIMAL28SPARSE: case DECIMAL38DENSE: case DECIMAL38SPARSE: return \"DECIMAL\"; case VARCHAR: return \"CHARACTER VARYING\"; case FIXEDCHAR: return \"CHARACTER\"; case VAR16CHAR: return \"NATIONAL CHARACTER VARYING\"; case FIXED16CHAR: return \"NATIONAL CHARACTER\"; case VARBINARY: return \"BINARY VARYING\"; case FIXEDBINARY: return \"BINARY\"; case DATE: return \"DATE\"; case TIME: return \"TIME\"; case TIMETZ: return \"TIME WITH TIME ZONE\"; case TIMESTAMP: return \"TIMESTAMP\"; case TIMESTAMPTZ: return \"TIMESTAMP WITH TIME ZONE\"; case INTERVALYEAR: return \"INTERVAL YEAR TO MONTH\"; case INTERVALDAY: return \"INTERVAL DAY TO SECOND\"; \/\/ Non-standard SQL atomic data types: case INTERVAL: return \"INTERVAL\"; case MONEY: return \"DECIMAL\"; case TINYINT: return \"TINYINT\"; \/\/ Composite types and other types that are not atomic types (SQL standard \/\/ or not) except ARRAY types (handled above): case MAP: return \"MAP\"; case LATE: return \"ANY\"; case NULL: return \"NULL\"; case UNION: return \"UNION\"; case GENERIC_OBJECT: return \"JAVA_OBJECT\"; \/\/ Internal types not actually used at level of SQL types(?): case UINT1: return \"TINYINT\"; case UINT2: return \"SMALLINT\"; case UINT4: return \"INTEGER\"; case UINT8: return \"BIGINT\"; default: throw new AssertionError( \"Unexpected\/unhandled MinorType value \" + type.getMinorType() ); } }","old_code_raw":"  public static String getSqlTypeName(final MajorType type) {\n    if (type.getMode() == DataMode.REPEATED || type.getMinorType() == MinorType.LIST) {\n      return \"ARRAY\";\n    }\n\n    switch (type.getMinorType()) {\n\n      \/\/ Standard SQL atomic data types:\n\n      case BIT:             return \"BOOLEAN\";\n\n      case SMALLINT:        return \"SMALLINT\";\n      case INT:             return \"INTEGER\";\n      case BIGINT:          return \"BIGINT\";\n\n      case FLOAT4:          return \"FLOAT\";\n      case FLOAT8:          return \"DOUBLE\";\n\n      case DECIMAL9:\n      case DECIMAL18:\n      case DECIMAL28DENSE:\n      case DECIMAL28SPARSE:\n      case DECIMAL38DENSE:\n      case DECIMAL38SPARSE: return \"DECIMAL\";\n\n      case VARCHAR:         return \"CHARACTER VARYING\";\n      case FIXEDCHAR:       return \"CHARACTER\";\n\n      case VAR16CHAR:       return \"NATIONAL CHARACTER VARYING\";\n      case FIXED16CHAR:     return \"NATIONAL CHARACTER\";\n\n      case VARBINARY:       return \"BINARY VARYING\";\n      case FIXEDBINARY:     return \"BINARY\";\n\n      case DATE:            return \"DATE\";\n      case TIME:            return \"TIME\";\n      case TIMETZ:          return \"TIME WITH TIME ZONE\";\n      case TIMESTAMP:       return \"TIMESTAMP\";\n      case TIMESTAMPTZ:     return \"TIMESTAMP WITH TIME ZONE\";\n\n      case INTERVALYEAR:    return \"INTERVAL YEAR TO MONTH\";\n      case INTERVALDAY:     return \"INTERVAL DAY TO SECOND\";\n\n      \/\/ Non-standard SQL atomic data types:\n\n      case INTERVAL:        return \"INTERVAL\";\n      case MONEY:           return \"DECIMAL\";\n      case TINYINT:         return \"TINYINT\";\n\n      \/\/ Composite types and other types that are not atomic types (SQL standard\n      \/\/ or not) except ARRAY types (handled above):\n\n      case MAP:             return \"MAP\";\n      case LATE:            return \"ANY\";\n      case NULL:            return \"NULL\";\n      case UNION:           return \"UNION\";\n\n      \/\/ Internal types not actually used at level of SQL types(?):\n\n      case UINT1:          return \"TINYINT\";\n      case UINT2:          return \"SMALLINT\";\n      case UINT4:          return \"INTEGER\";\n      case UINT8:          return \"BIGINT\";\n\n      default:\n        throw new AssertionError(\n            \"Unexpected\/unhandled MinorType value \" + type.getMinorType() );\n    }\n  }\n","new_comment_raw":"@return canonical keyword sequence for SQL data type (leading keywords in corresponding  ; what  INFORMATION_SCHEMA.COLUMNS.TYPE_NAME would list)","old_comment_raw":"@return canonical keyword sequence for SQL data type (leading keywords in corresponding ; what INFORMATION_SCHEMA.COLUMNS.TYPE_NAME would list)","label":0,"pre_label":1,"AST_level":8,"line_counts":71,"new_code_token_num":414},{"new_code_raw":"boolean recordRead(int bufferIndex, Node<K, V> node) { final AtomicLong counter = readBufferWriteCount()[bufferIndex]; final long writeCount = counter.get(); final int index = (int) (writeCount & READ_BUFFER_INDEX_MASK); AtomicReference<Node<K, V>> slot = readBuffers()[bufferIndex][index]; if (slot.get() != null) { return false; } else if (slot.compareAndSet(null, node)) { counter.lazySet(writeCount + NUM); } return true; }","old_code_raw":"long recordRead(int bufferIndex, Node<K, V> node) {\n    final AtomicLong counter = readBufferWriteCount()[bufferIndex];\n    final long writeCount = counter.get();\n    counter.lazySet(writeCount + NUM);\n    final int index = (int) (writeCount & READ_BUFFER_INDEX_MASK);\n    readBuffers()[bufferIndex][index].lazySet(node);\n    return writeCount;\n}","new_comment_raw":"@return if draining the read buffer can be delayed","old_comment_raw":"@return the number of writes on the chosen read buffer","label":1,"pre_label":0,"AST_level":9,"line_counts":12,"new_code_token_num":98},{"new_code_raw":"public boolean hasOptions() { return !options.isEmpty(); }","old_code_raw":"    public boolean hasOptions() {\n      return options.size() > 0;\n    }\n","new_comment_raw":"@return true if any options are set in this instance.","old_comment_raw":"@return true if any options are set in this instance.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"Context findNewNode(final VirtualHost.HostEntry entry) { return electNode(entry.getContexts(), false, null); }","old_code_raw":"Node findNewNode(final VirtualHost.HostEntry entry) {\n    return electNode(entry.getContexts(), false, null);\n}","new_comment_raw":"@return the context, {@code null} if not found","old_comment_raw":"@return the node, {@code null} if no node could be found","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":23},{"new_code_raw":"public static RelNode createFilter(RelNode child, RexNode condition) { return createFilter(child, condition, RelFactories.DEFAULT_FILTER_FACTORY); }","old_code_raw":"  public static RelNode createFilter(RelNode child, RexNode condition) {\n    return new FilterRel(child.getCluster(), child, condition);\n  }\n","new_comment_raw":"@return Relational expression","old_comment_raw":"@return Relational expression","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public ImmutableDFA buildDFA() { if (_cachedInstance == null) { if (initialState != null) { _cachedInstance = new ImmutableDFA(); _cachedInstance.transitions = new HashMap<State, Map<Object, State>>(transitions); _cachedInstance.initialState = initialState; } } return _cachedInstance; }","old_code_raw":"public ImmutableDFA buildDFA() {\n    ImmutableDFA instance = null;\n    if (initialState != null) {\n        instance = new ImmutableDFA();\n        instance.transitions = new HashMap<State, Map<Object, State>>(transitions);\n        instance.initialState = initialState;\n    }\n    return instance;\n}","new_comment_raw":"@return an instance of ImmutableDFA; null if no valid ImmutableDFA can be created.","old_comment_raw":"@return an instance of ImmutableDFA; null if the builder haven't got enough data to create a valid ImmutableDFA instance.","label":1,"pre_label":0,"AST_level":14,"line_counts":10,"new_code_token_num":49},{"new_code_raw":"private String resolveStringValue(List<Annotation> annotations) throws InstantiationException, IllegalAccessException { String retValue = null; if (annotations == null || annotations.isEmpty()) { retValue = strategy.getStringValue(); } else { for (Annotation annotation : annotations) { if (!PodamStringValue.class.isAssignableFrom(annotation .getClass())) { continue; } \/\/ A specific value takes precedence over the length PodamStringValue podamAnnotation = (PodamStringValue) annotation; if (podamAnnotation.strValue() != null && podamAnnotation.strValue().length() > 0) { retValue = podamAnnotation.strValue(); } else { retValue = strategy.getStringOfLength(podamAnnotation .length()); } } if (retValue == null) { retValue = strategy.getStringValue(); } } return retValue; }","old_code_raw":"\tprivate String resolveStringValue(List<Annotation> annotations)\n\t\t\tthrows InstantiationException, IllegalAccessException {\n\n\t\tString retValue = null;\n\n\t\tif (annotations == null || annotations.isEmpty()) {\n\n\t\t\tretValue = strategy.getStringValue();\n\n\t\t} else {\n\n\t\t\t\/\/ If a Podam attribute strategy has been defined, this takes\n\t\t\t\/\/ precedence and supersedes all other strategies\n\t\t\tPodamAttributeStrategy attributeStrategyAnnotation = containsAttributeStrategyAnnotation(annotations);\n\n\t\t\tif (attributeStrategyAnnotation != null) {\n\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tAttributeDataStrategy<String> attributeStrategy = (AttributeDataStrategy<String>) attributeStrategyAnnotation\n\t\t\t\t\t\t.value().newInstance();\n\n\t\t\t\tMethod attributeStrategyMethod = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tattributeStrategyMethod = attributeStrategy\n\t\t\t\t\t\t\t.getClass()\n\t\t\t\t\t\t\t.getMethod(\n\t\t\t\t\t\t\t\t\tPodamConstants.PODAM_ATTRIBUTE_STRATEGY_METHOD_NAME,\n\t\t\t\t\t\t\t\t\tnew Class<?>[]{});\n\n\t\t\t\t\tif (!String.class.isAssignableFrom(attributeStrategyMethod\n\t\t\t\t\t\t\t.getReturnType())) {\n\t\t\t\t\t\tString errMsg = \"The type of the Podam Attribute Strategy is not String but \"\n\t\t\t\t\t\t\t\t+ attributeStrategyMethod.getReturnType()\n\t\t\t\t\t\t\t\t\t\t.getName()\n\t\t\t\t\t\t\t\t+ \". An exception will be thrown.\";\n\t\t\t\t\t\tLOG.error(errMsg);\n\t\t\t\t\t\tthrow new IllegalArgumentException(errMsg);\n\t\t\t\t\t}\n\n\t\t\t\t\tretValue = attributeStrategy.getValue();\n\n\t\t\t\t\treturn retValue;\n\n\t\t\t\t} catch (SecurityException e) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"A security issue occurred while retrieving the Podam Attribute Strategy details\",\n\t\t\t\t\t\t\te);\n\t\t\t\t} catch (NoSuchMethodException e) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"It seems the Podam Attribute Annotation is of the wrong type\",\n\t\t\t\t\t\t\te);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t\/\/ Otherwise we proceed as normal\n\t\t\tfor (Annotation annotation : annotations) {\n\n\t\t\t\tif (!PodamStringValue.class.isAssignableFrom(annotation\n\t\t\t\t\t\t.getClass())) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t\/\/ A specific value takes precedence over the length\n\t\t\t\tPodamStringValue podamAnnotation = (PodamStringValue) annotation;\n\n\t\t\t\tif (podamAnnotation.strValue() != null\n\t\t\t\t\t\t&& podamAnnotation.strValue().length() > 0) {\n\n\t\t\t\t\tretValue = podamAnnotation.strValue();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tretValue = strategy.getStringOfLength(podamAnnotation\n\t\t\t\t\t\t\t.length());\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (retValue == null) {\n\t\t\t\tretValue = strategy.getStringValue();\n\t\t\t}\n\n\t\t}\n\n\t\treturn retValue;\n\t}\n","new_comment_raw":"@return a String value, eventually customised by annotations","old_comment_raw":"@return a String value, eventually customised by annotations","label":0,"pre_label":1,"AST_level":12,"line_counts":44,"new_code_token_num":139},{"new_code_raw":"public String createSessionId(final String sessionId, final String memcachedId) { if (memcachedId == null) { return sessionId; } final int idx = sessionId.indexOf(STR); if (idx < NUM) { return sessionId + STR + memcachedId; } else { return sessionId.substring(NUM, idx) + STR + memcachedId + sessionId.substring(idx); } }","old_code_raw":"public String createSessionId(final String sessionId, final String memcachedId) {\n    final int idx = sessionId.indexOf(STR);\n    if (idx < NUM) {\n        return sessionId + STR + memcachedId;\n    } else {\n        return sessionId.substring(NUM, idx) + STR + memcachedId + sessionId.substring(idx);\n    }\n}","new_comment_raw":"@return the sessionId which now contains the memcachedId if one was provided, otherwise the sessionId unmodified.","old_comment_raw":"@return the sessionId which now contains the memcachedId.","label":1,"pre_label":0,"AST_level":10,"line_counts":11,"new_code_token_num":69},{"new_code_raw":"protected final long currentTimeMillis() { return nanosToMillis(ticker.read()); }","old_code_raw":"protected long currentTimeMillis() {\n    return nanoToMillis(ticker.read());\n}","new_comment_raw":"@return the current time in milliseconds","old_comment_raw":"@return an approximate of the current time in milliseconds","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"public boolean searchToggleButton(String text, int minimumNumberOfMatches) { return searcher.searchWithTimeoutFor(ToggleButton.class, text, minimumNumberOfMatches, true, false); }","old_code_raw":"\tpublic boolean searchToggleButton(String text, int minimumNumberOfMatches) {\n\t\tboolean found = searcher.searchWithTimeoutFor(ToggleButton.class, text, minimumNumberOfMatches, true, false);\n\t\treturn found;\n\t}\n","new_comment_raw":"@return  true if a  ToggleButton with the given text is found a given number of times and  false if it is not found","old_comment_raw":"@return true if a ToggleButton with the given text is found a given number of times and false if it is not found","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":28},{"new_code_raw":"public Date getTimeStamp() { return timeStamp; }","old_code_raw":"public String getTimeStamp() {\n    return timeStamp;\n}","new_comment_raw":"@return a date instance representing the timestamp","old_comment_raw":"@return a string of the format \"Thu Oct 18 20:21:13 2001\"","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public static Schema getOutputValueSchema(Configuration conf) { String schemaString = conf.get(CONF_OUTPUT_VALUE_SCHEMA); return schemaString != null ? new Schema.Parser().parse(schemaString) : null; }","old_code_raw":"  public static Schema getOutputValueSchema(Configuration conf) {\n    String schemaString = conf.get(CONF_OUTPUT_VALUE_SCHEMA);\n    return schemaString != null ? Schema.parse(schemaString) : null;\n  }\n","new_comment_raw":"@return The job output value schema, or null if not set.","old_comment_raw":"@return The job output value schema, or null if not set.","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"public DateTime roundHalfCeilingCopy() { DateTime instant = iInstant; return instant.withMillis(iField.roundHalfCeiling(instant.getMillis())); }","old_code_raw":"    public DateTime roundHalfCeilingCopy() {\n        DateTime instant = iInstant;\n        return (DateTime)instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));\n    }\n","new_comment_raw":"@return a copy of the DateTime with the field value changed","old_comment_raw":"@return a copy of the DateTime with the field value changed","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws RestClientException { return fakeOuterCompositeSerializeWithHttpInfo(body).getBody(); }","old_code_raw":"    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws RestClientException {\n        Object postBody = body;\n        \n        String path = apiClient.expandPath(\"\/fake\/outer\/composite\", Collections.<String, Object>emptyMap());\n\n        final MultiValueMap<String, String> queryParams = new LinkedMultiValueMap<String, String>();\n        final HttpHeaders headerParams = new HttpHeaders();\n        final MultiValueMap<String, Object> formParams = new LinkedMultiValueMap<String, Object>();\n\n        final String[] accepts = { \n            \"*\/*\"\n        };\n        final List<MediaType> accept = apiClient.selectHeaderAccept(accepts);\n        final String[] contentTypes = { };\n        final MediaType contentType = apiClient.selectHeaderContentType(contentTypes);\n\n        String[] authNames = new String[] {  };\n\n        ParameterizedTypeReference<OuterComposite> returnType = new ParameterizedTypeReference<OuterComposite>() {};\n        return apiClient.invokeAPI(path, HttpMethod.POST, queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    }\n","new_comment_raw":"@return OuterComposite","old_comment_raw":"@return OuterComposite","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public Sentence caseless() { return new Sentence(this.docFn, impl.build(), Document.CASELESS_PROPS); }","old_code_raw":"  public Sentence caseless() {\n    this.defaultProps = Document.CASELESS_PROPS;\n    return this;\n  }\n","new_comment_raw":"@return A new sentence with the default properties swapped out.","old_comment_raw":"@return This same sentence, but with the default properties swapped out.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean isBreakpoint(Message aMessage, boolean isRequest, boolean onlyIfInScope) { if (aMessage.isForceIntercept()) { \/\/ The browser told us to do it Your Honour return true; } if (onlyIfInScope && ! aMessage.isInScope()) { return false; } if (isBreakOnAllRequests(aMessage, isRequest)) { \/\/ Break on all requests return true; } else if (isBreakOnAllResponses(aMessage, isRequest)) { \/\/ Break on all responses return true; } else if (isBreakOnStepping(aMessage, isRequest)) { \/\/ Stopping through all requests and responses return true; } return isBreakOnEnabledBreakpoint(aMessage, isRequest, onlyIfInScope); }","old_code_raw":"    public boolean isBreakpoint(Message aMessage, boolean isRequest, boolean onlyIfInScope) {\n    \tif (onlyIfInScope && ! aMessage.isInScope()) {\n    \t\treturn false;\n    \t}\n    \t\n        if (isBreakOnAllRequests(aMessage, isRequest)) {\n            \/\/ Break on all requests\n            return true;\n        } else if (isBreakOnAllResponses(aMessage, isRequest)) {\n            \/\/ Break on all responses\n            return true;\n        } else if (isBreakOnStepping(aMessage, isRequest)) {\n            \/\/ Stopping through all requests and responses\n            return true;\n        }\n        \n        return isBreakOnEnabledBreakpoint(aMessage, isRequest, onlyIfInScope);\n    }\n","new_comment_raw":"@return True if a breakpoint for given message exists.","old_comment_raw":"@return True if a breakpoint for given message exists.","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":128},{"new_code_raw":"@Override public int onReceiveLiquid(int type, int vol, byte side) { if (type == this.type) { int rejectedVolume = Math.max((this.getStoredLiquid(type) + vol) - this.capacity, NUM); this.liquidStored = vol - rejectedVolume; return rejectedVolume; } return vol; }","old_code_raw":"@Override\npublic int onReceiveLiquid(int type, int amt, byte side) {\n    if (type == this.type) {\n        int rejectedLiquid = Math.max((this.getStoredLiquid(type) + amt) - this.capacity, NUM);\n        this.liquidStored += watt - rejectedElectricity;\n        return rejectedLiquid;\n    }\n    return watt;\n}","new_comment_raw":"@return vol - The amount of rejected power to be sent back into the conductor","old_comment_raw":"@return watt - The amount of rejected power to be sent back into the conductor","label":1,"pre_label":0,"AST_level":12,"line_counts":9,"new_code_token_num":58},{"new_code_raw":"static List<File> getLogs(File logDir) { List<File> result = Lists.newArrayList(); File[] files = logDir.listFiles(); if(files == null) { if(!logDir.isDirectory()) { String msg = \"Path \" + logDir + \" is not a directory: \"; msg += \"File = \" + logDir.isFile() + \", \"; msg += \"Exists = \" + logDir.exists() + \", \"; msg += \"Writable = \" + logDir.canWrite(); throw new IllegalStateException(msg); } return result; } for (File file : files) { String name = file.getName(); if (pattern.matcher(name).matches()) { result.add(file); } } return result; }","old_code_raw":"  static List<File> getLogs(File logDir) {\n    List<File> result = Lists.newArrayList();\n    for (File file : logDir.listFiles()) {\n      String name = file.getName();\n      if (pattern.matcher(name).matches()) {\n        result.add(file);\n      }\n    }\n    return result;\n  }\n","new_comment_raw":"@return List of data files within logDir","old_comment_raw":"@return List of data files within logDir","label":0,"pre_label":1,"AST_level":11,"line_counts":22,"new_code_token_num":149},{"new_code_raw":"public VContextMenu getContextMenu() { if (contextMenu == null) { contextMenu = new VContextMenu(); DOM.setElementProperty(contextMenu.getElement(), STR, STR); } return contextMenu; }","old_code_raw":"public IContextMenu getContextMenu() {\n    if (contextMenu == null) {\n        contextMenu = new IContextMenu();\n        DOM.setElementProperty(contextMenu.getElement(), STR, STR);\n    }\n    return contextMenu;\n}","new_comment_raw":"@return VContextMenu object","old_comment_raw":"@return IContextMenu object","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":36},{"new_code_raw":"public AvroCollector getCollector(String namedOutput, Reporter reporter) throws IOException { return getCollector(namedOutput, null, reporter,namedOutput,null); }","old_code_raw":"  public AvroCollector getCollector(String namedOutput, Reporter reporter)\n    throws IOException {\n    return getCollector(namedOutput, null, reporter);\n  }\n","new_comment_raw":"@return the output collector for the given named output","old_comment_raw":"@return the output collector for the given named output","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":28},{"new_code_raw":"public static ChatMessageType of(int type) { return CHAT_MESSAGE_TYPES.getOrDefault(type, UNKNOWN); }","old_code_raw":"\tpublic static ChatMessageType of(int type)\n\t{\n\t\tfor (ChatMessageType ct : ChatMessageType.values())\n\t\t{\n\t\t\tif (ct.type == type)\n\t\t\t{\n\t\t\t\treturn ct;\n\t\t\t}\n\t\t}\n\t\treturn UNKNOWN;\n\t}\n","new_comment_raw":"@return appropriate message type, or  #UNKNOWN","old_comment_raw":"@return appropriate message type, or #UNKNOWN","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":19},{"new_code_raw":"public static String formatOtherKey(String fullName) { return formatKey(fullName, false, true, false, false); }","old_code_raw":"public static String formatOtherKey(String fullName) {\n    return formatKey(fullName, true, false, false, false);\n}","new_comment_raw":"@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = true, formatHyphen = false, firstCase = false","old_comment_raw":"@return {@link #formatKey(String, boolean, boolean, boolean)} formatAt = true, formatColon = false, formatHyphen = false, firstCase = false","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":24},{"new_code_raw":"public int get(DateTimeField field) { for (int i = 0, isize = getFieldSize(); i < isize; i++) { if (getField(i) == field) { return getValue(i); } } throw new IllegalArgumentException(\"Field '\" + field + \"' is not supported\"); }","old_code_raw":"    public int get(DateTimeField field) {\n        for (int i = 0; i < iFields.length; i++) {\n            if (iFields[i] == field) {\n                return iValues[i];\n            }\n        }\n        throw new IllegalArgumentException(\"Field '\" + field + \"' is not supported\");\n    }\n","new_comment_raw":"@return the value of that field","old_comment_raw":"@return the value of that field","label":0,"pre_label":1,"AST_level":9,"line_counts":9,"new_code_token_num":64},{"new_code_raw":"protected Object convertSmallInt(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; } if (data instanceof Short) return data; if (data instanceof Number) { Number value = (Number) data; return new Short(value.shortValue()); } if (data instanceof Boolean) { return ((Boolean) data).booleanValue() ? SHORT_TRUE : SHORT_FALSE; } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertSmallInt(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        if (data instanceof Short) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Short(value.shortValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? SHORT_TRUE : SHORT_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":19,"new_code_token_num":118},{"new_code_raw":"@NonNull public static InstantRunVerifierStatus verifyMethod(MethodNode method) { VerifierMethodVisitor mv = new VerifierMethodVisitor(method); method.accept(mv); return mv.incompatibleChange.or(InstantRunVerifierStatus.COMPATIBLE); }","old_code_raw":"@Nullable\npublic static IncompatibleChange verifyMethod(MethodNode method) {\n    VerifierMethodVisitor mv = new VerifierMethodVisitor(method);\n    method.accept(mv);\n    return mv.incompatibleChange.orNull();\n}","new_comment_raw":"@return a {@link InstantRunVerifierStatus} instance or null if the method is not making any blacklisted calls.","old_comment_raw":"@return a {@link IncompatibleChange} instance or null if the method is not making any blacklisted calls.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":35},{"new_code_raw":"public AspectRatio inverse() { \/\/noinspection SuspiciousNameCombination return AspectRatio.of(mY, mX); }","old_code_raw":"    public AspectRatio inverse() {\n        \/\/noinspection SuspiciousNameCombination\n        return new AspectRatio(mY, mX);\n    }\n","new_comment_raw":"@return The inverse of this  AspectRatio.","old_comment_raw":"@return The inverse of this AspectRatio.","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":20},{"new_code_raw":"public Object getResult() { return this.result; }","old_code_raw":"public Presentable getResult() {\n    return this.result;\n}","new_comment_raw":"@return An object.","old_comment_raw":"@return A {@link Presentable} object.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public BigDecimal fakeOuterNumberSerialize(BigDecimal body) throws ApiException { ApiResponse<BigDecimal> localVarResp = fakeOuterNumberSerializeWithHttpInfo(body); return localVarResp.getData(); }","old_code_raw":"    public BigDecimal fakeOuterNumberSerialize(BigDecimal body) throws ApiException {\n        ApiResponse<BigDecimal> resp = fakeOuterNumberSerializeWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"@return BigDecimal","old_comment_raw":"@return BigDecimal","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"private static final int isReferenceRelated(IType cv1Target, IType cv2Source) throws DOMException { IType t = SemanticUtil.getNestedType(cv1Target, TYPEDEFS | REFERENCES); IType s = SemanticUtil.getNestedType(cv2Source, TYPEDEFS | REFERENCES); if (t instanceof IPointerType && s instanceof IPointerType) { t = ((IPointerType) t).getType(); s = ((IPointerType) s).getType(); } else { t = t instanceof IQualifierType ? ((IQualifierType) t).getType() : t; s = s instanceof IQualifierType ? ((IQualifierType) s).getType() : s; if (t instanceof ICPPClassType && s instanceof ICPPClassType) { return calculateInheritanceDepth(CPPSemantics.MAX_INHERITANCE_DEPTH, s, t); } } if (t == s || (t != null && s != null && t.isSameType(s))) { return NUM; } return -NUM; }","old_code_raw":"private static final boolean isReferenceRelated(IType cv1t1, IType cv2t2) throws DOMException {\n    IType t1 = SemanticUtil.getUltimateTypeUptoPointers(cv1t1);\n    IType t2 = SemanticUtil.getUltimateTypeUptoPointers(cv2t2);\n    if (t1 instanceof IPointerType && t2 instanceof IPointerType) {\n        IType ptt1 = ((IPointerType) t1).getType();\n        IType ptt2 = ((IPointerType) t2).getType();\n        return ptt1 != null && ptt2 != null ? ptt1.isSameType(ptt2) : ptt1 == ptt2;\n    }\n    t1 = t1 instanceof IQualifierType ? ((IQualifierType) t1).getType() : t1;\n    t2 = t2 instanceof IQualifierType ? ((IQualifierType) t2).getType() : t2;\n    if (t1 instanceof ICPPClassType && t2 instanceof ICPPClassType) {\n        return calculateInheritanceDepth(CPPSemantics.MAX_INHERITANCE_DEPTH, t2, t1) >= NUM;\n    }\n    return t1 != null && t2 != null ? t1.isSameType(t2) : t1 == t2;\n}","new_comment_raw":"@return inheritance distance, or -1, if <code>cv1t1<\/code> is not reference-related to <code>cv2t2<\/code>","old_comment_raw":"@return whether <code>cv1t1<\/code> is reference-related to <code>cv2t2<\/code>","label":1,"pre_label":0,"AST_level":9,"line_counts":18,"new_code_token_num":169},{"new_code_raw":"private boolean searchForButton(String regex, int matches) { return searchFor(Button.class, regex, matches); }","old_code_raw":"\tprivate boolean searchForButton(String regex, int matches) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher matcher;\n\t\tArrayList<Button> buttonList = viewFetcher.getCurrentViews(Button.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(Button button : buttonList){\n\t\t\tmatcher = p.matcher(button.getText().toString());\n\t\t\tif(matcher.find()){\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches = 0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroller.scroll(Scroller.Direction.DOWN))\n\t\t{\n\t\t\treturn searchForButton(regex, matches);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex);\n\t\t\tcountMatches = 0;\n\t\t\treturn false;\n\t\t}\n\n\t}\n","new_comment_raw":"@return true if a button with the given text is found a given number of times and false if it is not found","old_comment_raw":"@return true if a button with the given text is found a given number of times and false if it is not found","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"static Drawable maybeApplyLeafRounding(@Nullable Drawable drawable, @Nullable RoundingParams roundingParams, Resources resources) { if (drawable == null || roundingParams == null || roundingParams.getRoundingMethod() != RoundingParams.RoundingMethod.BITMAP_ONLY) { return drawable; } if (drawable instanceof ForwardingDrawable) { DrawableParent parent = findDrawableParentForLeaf((ForwardingDrawable) drawable); Drawable child = parent.setDrawable(sEmptyDrawable); child = applyLeafRounding(child, roundingParams, resources); parent.setDrawable(child); return drawable; } else { return applyLeafRounding(drawable, roundingParams, resources); } }","old_code_raw":"static Drawable maybeApplyLeafRounding(@Nullable Drawable drawable, @Nullable RoundingParams roundingParams, Resources resources) {\n    if (drawable == null || roundingParams == null || roundingParams.getRoundingMethod() != RoundingParams.RoundingMethod.BITMAP_ONLY) {\n        return drawable;\n    }\n    if (drawable instanceof BitmapDrawable || drawable instanceof ColorDrawable) {\n        return applyLeafRounding(drawable, roundingParams, resources);\n    } else {\n        Drawable parent = drawable;\n        Drawable child = parent.getCurrent();\n        while (child != null && parent != child) {\n            if (parent instanceof ForwardingDrawable && (child instanceof BitmapDrawable || child instanceof ColorDrawable)) {\n                ((ForwardingDrawable) parent).setDrawable(sEmptyDrawable);\n                child = applyLeafRounding(child, roundingParams, resources);\n                ((ForwardingDrawable) parent).setDrawable(child);\n                break;\n            }\n            parent = child;\n            child = parent.getCurrent();\n        }\n    }\n    return drawable;\n}","new_comment_raw":"@return the rounded drawable, or the original drawable if the rounding didn't take place or it took place on a drawable's child","old_comment_raw":"@return the wrapping rounded drawable, or the original drawable if the wrapping didn't take place or it took place on a drawable's child","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":101},{"new_code_raw":"public static boolean isTextBasedContentType(String contentType) { return contentType != null && (contentType.startsWith(STR) || contentType.startsWith(STR)); }","old_code_raw":"public static boolean isTextBasedContentType(String contentType) {\n    return contentType.startsWith(STR) || contentType.startsWith(STR);\n}","new_comment_raw":"@return whether it is not {@code null} and text-based","old_comment_raw":"@return whether it is text","label":1,"pre_label":0,"AST_level":7,"line_counts":3,"new_code_token_num":31},{"new_code_raw":"public DateTimeField yearOfCentury() { return UnsupportedDateTimeField.getInstance(DateTimeFieldType.yearOfCentury(), years()); }","old_code_raw":"    public DateTimeField yearOfCentury() {\n        return UnsupportedDateTimeField.getInstance(\"yearOfCentury\", years());\n    }\n","new_comment_raw":"@return DateTimeField or UnsupportedDateTimeField if unsupported","old_comment_raw":"@return DateTimeField or UnsupportedDateTimeField if unsupported","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public IBuildConfiguration[] getBuildConfigurations(IProject project, boolean makeCopy) { IBuildConfiguration[] configs = cachedBuildConfigs; if (configs != null && !project.equals(configs[NUM].getProject())) configs = null; if (configs == null) { if (configNames.length == NUM) configs = new IBuildConfiguration[] { new BuildConfiguration(project) }; else { configs = new IBuildConfiguration[configNames.length]; for (int i = NUM; i < configs.length; i++) configs[i] = new BuildConfiguration(project, configNames[i]); } cachedBuildConfigs = configs; } return makeCopy ? (IBuildConfiguration[]) configs.clone() : configs; }","old_code_raw":"public IBuildConfiguration[] getBuildConfigurations(boolean makeCopy) {\n    if (buildConfigs.length == NUM)\n        return EMPTY_BUILD_CONFIGS;\n    return makeCopy ? (IBuildConfiguration[]) buildConfigs.clone() : buildConfigs;\n}","new_comment_raw":"@return the project configurations","old_comment_raw":"@return the project configurations of an empty array if none exist.","label":1,"pre_label":0,"AST_level":13,"line_counts":15,"new_code_token_num":127},{"new_code_raw":"public Dimension getViewSize() { return device.getSize(); }","old_code_raw":"\tpublic Dimension getViewSize() {\n\t\tif (viewSize == null) {\n\t\t\treturn getLargestVideoFormat().getSize();\n\t\t}\n\t\treturn viewSize;\n\t}\n","new_comment_raw":"@return Webcam view size (picture size) in pixels.","old_comment_raw":"@return Webcam view size (picture size) in pixels.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public String getInputTag() { final TagView inputTagView = getInputTagView(); if (inputTagView != null) { return inputTagView.getText().toString(); } return null; }","old_code_raw":"protected TagView getInputTag() {\n    if (isAppendMode) {\n        final int inputTagIndex = getChildCount() - NUM;\n        TagView inputTag = (TagView) getChildAt(inputTagIndex);\n        if (inputTag != null && inputTag.mState == TagView.STATE_INPUT) {\n            return inputTag;\n        } else {\n            return null;\n        }\n    } else {\n        return null;\n    }\n}","new_comment_raw":"@return the INPUT state tag view or null if not exists","old_comment_raw":"@return The INPUT state tag or null if none.","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":34},{"new_code_raw":"protected ReactGateway createReactGateway() { return new ReactGateway(this, isDebug(), this::createReactNativeHost); }","old_code_raw":"\tprotected ReactGateway createReactGateway() {\n\t    return new ReactGateway(this, isDebug(), createReactNativeHost());\n    }\n","new_comment_raw":"@return a singleton  ReactGateway","old_comment_raw":"@return a singleton ReactGateway","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"static MongoDatabasePolicy create() { final MongoClient client; if (MongoAssertions.useMongo()) { client = new MongoClient(); } else if (MongoAssertions.useFongo()) { client = new Fongo(MongoDatabasePolicy.class.getSimpleName()).getMongo(); } else { throw new UnsupportedOperationException(STR); } return new MongoDatabasePolicy(client); }","old_code_raw":"static MongoDatabaseRule create() {\n    final MongoClient client;\n    if (MongoAssertions.useMongo()) {\n        client = new MongoClient();\n    } else if (MongoAssertions.useFongo()) {\n        client = new Fongo(MongoDatabaseRule.class.getSimpleName()).getMongo();\n    } else {\n        throw new UnsupportedOperationException(STR);\n    }\n    return new MongoDatabaseRule(client);\n}","new_comment_raw":"@return new instance of the policy to be used by unit tests","old_comment_raw":"@return new instance of the rule to be used by unit tests","label":1,"pre_label":0,"AST_level":10,"line_counts":11,"new_code_token_num":67},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(\"<\", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext(\">\", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { handleHyphenatedNumber(yytext()); return getNext(removeFromNumber(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(\"\\u2022\", yytext()); } case 90: break; case 25: { return getNext(\"\\u2122\", yytext()); } case 91: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 98: break; case 33: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 102: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 114: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 127: break; case 62: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 131: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 67: break;\n        case 2: \n          { return getNext(\"<\", yytext());\n          }\n        case 68: break;\n        case 3: \n          { return getNext();\n          }\n        case 69: break;\n        case 4: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n          }\n        case 70: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 71: break;\n        case 6: \n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 72: break;\n        case 7: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 73: break;\n        case 8: \n          { return handleQuotes(yytext(), false);\n          }\n        case 74: break;\n        case 9: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 75: break;\n        case 10: \n          { return getNext(\">\", yytext());\n          }\n        case 76: break;\n        case 11: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 77: break;\n        case 12: \n          { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n          }\n        case 78: break;\n        case 13: \n          { return handleEllipsis(yytext());\n          }\n        case 79: break;\n        case 14: \n          { return normalizeFractions(yytext());\n          }\n        case 80: break;\n        case 15: \n          { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 81: break;\n        case 16: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 82: break;\n        case 17: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 83: break;\n        case 18: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 84: break;\n        case 19: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 85: break;\n        case 20: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 86: break;\n        case 21: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 87: break;\n        case 22: \n          { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 88: break;\n        case 23: \n          { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n          }\n        case 89: break;\n        case 24: \n          { return getNext(\"\\u2022\", yytext());\n          }\n        case 90: break;\n        case 25: \n          { return getNext(\"\\u2122\", yytext());\n          }\n        case 91: break;\n        case 26: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 15;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 16;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 92: break;\n        case 27: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 93: break;\n        case 28: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), true);\n          }\n        case 94: break;\n        case 29: \n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 95: break;\n        case 30: \n          { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 96: break;\n        case 31: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n          }\n        case 97: break;\n        case 32: \n          { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 98: break;\n        case 33: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 99: break;\n        case 34: \n          { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n          }\n        case 100: break;\n        case 35: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n          }\n        case 101: break;\n        case 36: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n          }\n        case 102: break;\n        case 37: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return handleQuotes(yytext(), false);\n          }\n        case 103: break;\n        case 38: \n          { return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 104: break;\n        case 39: \n          { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      String newText = yytext();\n                      return getNext(newText, newText);\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, txt);\n          }\n        case 105: break;\n        case 40: \n          { return getNormalizedAmpNext();\n          }\n        case 106: break;\n        case 41: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 107: break;\n        case 42: \n          { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n          }\n        case 108: break;\n        case 43: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n          }\n        case 109: break;\n        case 44: \n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 110: break;\n        case 45: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 17;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 16;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 111: break;\n        case 46: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 112: break;\n        case 47: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 10;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 11;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAbbrev3();\n          }\n        case 113: break;\n        case 48: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 20;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 22;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n          }\n        case 114: break;\n        case 49: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 18;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 19;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 115: break;\n        case 50: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 10;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 11;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAbbrev3();\n          }\n        case 116: break;\n        case 51: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 20;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 21;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n          }\n        case 117: break;\n        case 52: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 118: break;\n        case 53: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n          }\n        case 119: break;\n        case 54: \n          { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n          }\n        case 120: break;\n        case 55: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNormalizedAmpNext();\n          }\n        case 121: break;\n        case 56: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 9;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAcronym();\n          }\n        case 122: break;\n        case 57: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 123: break;\n        case 58: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 12;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 14;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAbbrev1();\n          }\n        case 124: break;\n        case 59: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAcronym();\n          }\n        case 125: break;\n        case 60: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 12;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 13;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return processAbbrev1();\n          }\n        case 126: break;\n        case 61: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 127: break;\n        case 62: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return getNext();\n          }\n        case 128: break;\n        case 63: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return getNext();\n          }\n        case 129: break;\n        case 64: \n          { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 130: break;\n        case 65: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 23;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 25;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n          }\n        case 131: break;\n        case 66: \n          \/\/ general lookahead, find correct zzMarkedPos\n          { int zzFState = 23;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n            while (zzFPos <= zzMarkedPos) {\n              zzFinL[zzFPos++] = false;\n            }\n\n            zzFState = 24;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n          }\n        case 132: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":19,"line_counts":966,"new_code_token_num":6274},{"new_code_raw":"protected Project getRightChild(RelOptRuleCall call) { return call.rel(NUM); }","old_code_raw":"protected ProjectRelBase getRightChild(RelOptRuleCall call) {\n    return call.rel(NUM);\n}","new_comment_raw":"@return LogicalProject corresponding to the right child","old_comment_raw":"@return ProjectRel corresponding to the right child","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"public boolean onKeyDown(int keyCode, KeyEvent event) { if (LOG_KEY_EVENTS) { Log.w(TAG, \"onKeyDown \" + keyCode); } if (handleControlKey(keyCode, true)) { return true; } else if (handleFnKey(keyCode, true)) { return true; } else if (isSystemKey(keyCode, event)) { if (! isInterceptedSystemKey(keyCode) ) { \/\/ Don't intercept the system keys return super.onKeyDown(keyCode, event); } } \/\/ Translate the keyCode into an ASCII character. try { mKeyListener.keyDown(keyCode, event, getKeypadApplicationMode()); } catch (IOException e) { \/\/ Ignore I\/O exceptions } return true; }","old_code_raw":"    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (LOG_KEY_EVENTS) {\n            Log.w(TAG, \"onKeyDown \" + keyCode);\n        }\n        if (keyCode == KeyEvent.KEYCODE_MENU) {\n            return super.onKeyDown(keyCode,  event);\n        }\n        if (mTermKeyListener == null) {\n            mTermKeyListener = new TermKeyListener(mControlKeyCode, mFnKeyCode, mBackKeyCharacter, mAltSendsEsc, getKeypadApplicationMode());\n        }\n        boolean isHandled = mTermKeyListener.keyDown(event);\n        if (isHandled) {\n            byte[] seq = mTermKeyListener.extractCharSequence();\n            if (seq != null) {\n                mTermSession.write(seq, 0, seq.length);\n            }\n        } else if (isSystemKey(keyCode, event)) {\n            if (! isInterceptedSystemKey(keyCode) ) {\n                \/\/ Don't intercept the system keys\n                isHandled = super.onKeyDown(keyCode, event);\n            }\n        }\n        return isHandled;\n    }\n","new_comment_raw":"@return Whether the event was handled.","old_comment_raw":"@return Whether the event was handled.","label":0,"pre_label":1,"AST_level":11,"line_counts":25,"new_code_token_num":140},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<TaskList> getTaskLists(final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<TaskList>() { @Override protected List<TaskList> doGetPage() throws IOException { TaskLists list = client.tasklists().list().setMaxResults(new Long(pagingConfiguration.getFetchSize())).setPageToken(this.getPageToken()).execute(); this.setPageToken(list.getNextPageToken()); return TaskList.valueOf(list.getItems(), TaskList.class); } }; }","old_code_raw":"@Processor\n@OAuthProtected\n@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)\n@Inject\npublic List<TaskList> getTaskLists(MuleMessage message, @Optional @Default(STR) long maxResults, @Optional String pageToken) throws IOException {\n    TaskLists list = this.client.tasklists().list().setMaxResults(maxResults).setPageToken(pageToken).execute();\n    PaginationUtils.savePageToken(NEXT_PAGE_TOKEN, list.getNextPageToken(), message);\n    return TaskList.valueOf(list.getItems(), TaskList.class);\n}","new_comment_raw":"@return an auto paginated iterator with instances of {@link org.mule.module.google.task.model.TaskList}","old_comment_raw":"@return a list with instances of {@link org.mule.module.google.task.model.TaskList}","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":100},{"new_code_raw":"public static TypeRuntimeWiring newTypeWiring(String typeName, UnaryOperator<Builder> builderFunction) { return builderFunction.apply(newTypeWiring(typeName)).build(); }","old_code_raw":"    public static TypeRuntimeWiring newTypeWiring(UnaryOperator<Builder> builderFunction) {\n        return builderFunction.apply(newTypeWiring()).build();\n    }\n","new_comment_raw":"@return the same builder back please","old_comment_raw":"@return the same builder back please","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"@Override public Object getItem(int position) { return ((DeviceAdminListItem) (mAdmins.get(position))).info; }","old_code_raw":"@Override\npublic Object getItem(int position) {\n    if (position < NUM) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    int adminPosition = position;\n    final int n = mAdminsByProfile.size();\n    int i = NUM;\n    for (; i < n; ++i) {\n        final int listSize = mAdminsByProfile.valueAt(i).size() + NUM;\n        if (adminPosition < listSize) {\n            break;\n        }\n        adminPosition -= listSize;\n    }\n    if (i == n) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    if (adminPosition == NUM) {\n        Resources res = getActivity().getResources();\n        if (mAdminsByProfile.keyAt(i) == UserHandle.myUserId()) {\n            return res.getString(R.string.personal_device_admin_title);\n        } else {\n            return res.getString(R.string.managed_device_admin_title);\n        }\n    } else {\n        return mAdminsByProfile.valueAt(i).get(adminPosition - NUM);\n    }\n}","new_comment_raw":"@return DeviceAdminInfo object for actual device admins.","old_comment_raw":"@return a String object for title items and a DeviceAdminInfo object for actual device admins.","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public static BooleanTemplate booleanTemplate(Template template, ImmutableList<?> args) { return new BooleanTemplate(template, args); }","old_code_raw":"    public static BooleanTemplate booleanTemplate(Template template, ImmutableList<?> args) {\n        return new BooleanTemplate(template, ImmutableList.copyOf(args));\n    }\n","new_comment_raw":"@return template expression","old_comment_raw":"@return template expression","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean isPendingStop() { return status.get() == PENDING_STOP; }","old_code_raw":"    public boolean isPendingStop() {\n        return pendingStop.get();\n    }\n","new_comment_raw":"@return true if the Connection needs to stop","old_comment_raw":"@return true if the Connection needs to stop","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public static String getId(final Widget widget) { String result = (String) widget.getData(CUSTOM_WIDGET_ID); if (result == null) { result = getAdapter(widget).getId(); } return result; }","old_code_raw":"public static String getId(final Widget widget) {\n    return getAdapter(widget).getId();\n}","new_comment_raw":"@return the id for the given <code>widget<\/code>","old_comment_raw":"@return the id","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":41},{"new_code_raw":"@Restricted(DoNotUse.class) @Deprecated @NonNull public List<? extends Action> getAllActions() { return Collections.emptyList(); }","old_code_raw":"@NonNull\n@Exported(name = STR)\npublic List<? extends Action> getAllActions() {\n    List<Action> actions = new ArrayList<Action>();\n    for (TransientActionFactory<?> taf : ExtensionList.lookup(TransientActionFactory.class)) {\n        if (taf.type().isInstance(this)) {\n            try {\n                actions.addAll(createFor(taf));\n            } catch (Exception e) {\n                LOGGER.log(Level.SEVERE, STR + taf + STR + this, e);\n            }\n        }\n    }\n    return Collections.unmodifiableList(actions);\n}","new_comment_raw":"@return an empty list","old_comment_raw":"@return a list of all actions associated with this branch (by default, an unmodifiable list searching {@link TransientActionFactory}s)","label":1,"pre_label":0,"AST_level":5,"line_counts":6,"new_code_token_num":26},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<Comment> listComments(final String fileId, @Optional @Default(STR) final boolean includeDeleted, @Optional @Default(STR) final int maxResults, @Optional final String updatedMin, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<Comment>() { @Override protected List<Comment> doGetPage() throws IOException { CommentList response = client.comments().list(fileId).setIncludeDeleted(includeDeleted).setMaxResults(maxResults).setPageToken(this.getPageToken()).setUpdatedMin(updatedMin).execute(); this.setPageToken(response.getNextPageToken()); return Comment.valueOf(response.getItems(), Comment.class); } }; }","old_code_raw":"@Processor\n@OAuthProtected\n@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)\n@Inject\npublic List<Comment> listComments(MuleMessage message, String fileId, @Optional @Default(STR) boolean includeDeleted, @Optional @Default(STR) int maxResults, @Optional @Default(STR) String pageToken, @Optional String updatedMin) throws IOException {\n    CommentList response = this.client.comments().list(fileId).setIncludeDeleted(includeDeleted).setMaxResults(maxResults).setPageToken(pageToken).setUpdatedMin(updatedMin).execute();\n    PaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n    return Comment.valueOf(response.getItems(), Comment.class);\n}","new_comment_raw":"@return a paginated iterator with instances of {@link org.mule.module.google.drive.model.Comment}","old_comment_raw":"@return a list with instances of {@link org.mule.module.google.drive.model.Comment}","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":134},{"new_code_raw":"public static String readFully(InputStream inputStream) throws IOException { return readFully(inputStream, new UnsynchronizedBuffer(1024)); }","old_code_raw":"  public static String readFully(InputStream inputStream) throws IOException {\n    return _readFully(inputStream).toString();\n  }\n","new_comment_raw":"@return Plugin instance","old_comment_raw":"@return Plugin instance","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) { final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex); Map<String, String> ehr13606values = retrieveValues(composition, compositionIndex); return buildBody(ehr13606values); }","old_code_raw":"protected MedicationMedicalRecordBodyType mapBody(final EHREXTRACT ehrExtract, final int compositionIndex) {\n    final COMPOSITION composition = ehrExtract.getAllCompositions().get(compositionIndex);\n    final MedicationMedicalRecordBodyType bodyType = new MedicationMedicalRecordBodyType();\n    AdditionalPatientInformationType apit = new AdditionalPatientInformationType();\n    apit.setDateOfBirth(STR);\n    CVType gender = new CVType();\n    gender.setCode(STR);\n    gender.setCodeSystem(STR);\n    gender.setDisplayName(STR);\n    gender.setOriginalText(STR);\n    apit.setGender(gender);\n    bodyType.setAdditionalPatientInformation(apit);\n    MedicationPrescriptionType mpt = new MedicationPrescriptionType();\n    mpt.setDispensationAuthorization(new DispensationAuthorizationType());\n    mpt.setEndOfTreatment(STR);\n    mpt.setEndOfTreatmentReason(new CVType());\n    mpt.setEvaluator(new HealthcareProfessionalType());\n    mpt.setPrecedingPrescriptionId(new IIType());\n    mpt.setPrescriber(new HealthcareProfessionalType());\n    mpt.setPrescriptionChainId(new IIType());\n    mpt.setPrescriptionId(new IIType());\n    mpt.setPrescriptionStatus(new CVType());\n    mpt.setSelfMedication(false);\n    mpt.setStartOfFirstTreatment(STR);\n    mpt.setSucceedingPrescriptionId(new IIType());\n    mpt.setTypeOfPrescription(TypeOfPrescriptionEnum.INS\u00c4TTNING);\n    bodyType.setMedicationPrescription(mpt);\n    for (final CONTENT content : composition.getContent()) {\n        for (final ITEM item : ((ENTRY) content).getItems()) {\n            log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + (item instanceof ELEMENT ? STR : STR));\n            switch(item.getMeaning().getCode()) {\n                case STR:\n                    mpt.setStartOfTreatment(STR);\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    mpt.setPrescriptionNote(STR);\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    mpt.setEvaluationTime(STR);\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    mpt.setTreatmentPurpose(STR);\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue());\n                    CLUSTER c = (CLUSTER) item;\n                    List<ITEM> parts = c.getParts();\n                    for (ITEM part : parts) {\n                        log.debug(part.getMeaning().getCode());\n                        if (STR.equals(part.getMeaning().getCode())) {\n                            c = (CLUSTER) part;\n                            List<ITEM> dosparts = c.getParts();\n                            for (ITEM dospart : dosparts) {\n                                log.debug(dospart.getMeaning().getCode() + STR + dospart.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) dospart));\n                            }\n                        }\n                    }\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue());\n                    c = (CLUSTER) item;\n                    parts = c.getParts();\n                    for (ITEM part : parts) {\n                        log.debug(part.getMeaning().getCode());\n                        switch(item.getMeaning().getCode()) {\n                            case STR:\n                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));\n                                break;\n                            case STR:\n                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));\n                                break;\n                            case STR:\n                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));\n                                break;\n                            case STR:\n                                log.debug(part.getMeaning().getCode() + STR + part.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) part));\n                                break;\n                        }\n                    }\n                    break;\n                case STR:\n                    mpt.setStartOfTreatment(STR);\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n                case STR:\n                    log.debug(item.getMeaning().getCode() + STR + item.getMeaning().getDisplayName().getValue() + STR + EHRUtil.getElementTextValue((ELEMENT) item));\n                    break;\n            }\n        }\n    }\n    return bodyType;\n}","new_comment_raw":"@return a new MedicationMedicalRecord","old_comment_raw":"@return the target body information.","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":44},{"new_code_raw":"public TreeGraphNode headWordNode() { TreeGraphNode hwn = safeCast(label.get(TreeCoreAnnotations.HeadWordAnnotation.class)); if (hwn == null || (hwn.treeGraph() != null && !(hwn.treeGraph().equals(this.treeGraph())))) { return null; } return hwn; }","old_code_raw":"  public TreeGraphNode headWordNode() {\n    return headWordNode;\n   }\n","new_comment_raw":"@return the node containing the head word for this node","old_comment_raw":"@return the node containing the head word for this node","label":0,"pre_label":1,"AST_level":8,"line_counts":8,"new_code_token_num":59},{"new_code_raw":"public int getCommitTime() { return commitTime; }","old_code_raw":"public long getCommitTime() {\n    return commitTime;\n}","new_comment_raw":"@return time, expressed as seconds since the epoch.","old_comment_raw":"@return time, expressed as milliseconds since the epoch.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public CyclicCoreLabel label() { return label; }","old_code_raw":"  public CoreLabel label() {\n    return label;\n  }\n","new_comment_raw":"@return the label of the node","old_comment_raw":"@return the label of the node","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public FailoverListComposite getFailoverList() { return failoverList != null ? failoverList : new FailoverListComposite(new ArrayList<ServerEntry>()); }","old_code_raw":"public FailoverListComposite getFailoverList() {\n    return failoverList;\n}","new_comment_raw":"@return the FailoverListComposite assigned to it by the server (will not be <code>null<\/code> but may be empty)","old_comment_raw":"@return the FailoverListComposite assigned to it by the server","label":1,"pre_label":0,"AST_level":9,"line_counts":3,"new_code_token_num":24},{"new_code_raw":"private Sheet getSheet() { int sheetIndex = 0; if (!readerConfig.sheetName.isEmpty()) { sheetIndex = workbook.getSheetIndex(readerConfig.sheetName); } \/\/If the sheet name is not valid, throw user exception if (sheetIndex == -1) { throw UserException .validationError() .message(\"Could not open sheet \" + readerConfig.sheetName) .build(logger); } else { return workbook.getSheetAt(sheetIndex); } }","old_code_raw":"  private XSSFSheet getSheet() {\n    int sheetIndex = 0;\n    if (!readerConfig.sheetName.isEmpty()) {\n      sheetIndex = workbook.getSheetIndex(readerConfig.sheetName);\n    }\n\n    \/\/If the sheet name is not valid, throw user exception\n    if (sheetIndex == -1) {\n      throw UserException\n        .validationError()\n        .message(\"Could not open sheet \" + readerConfig.sheetName)\n        .build(logger);\n    } else {\n      return workbook.getSheetAt(sheetIndex);\n    }\n  }\n","new_comment_raw":"@return Sheet The selected sheet","old_comment_raw":"@return XSSFSheet The selected sheet","label":1,"pre_label":0,"AST_level":9,"line_counts":17,"new_code_token_num":83},{"new_code_raw":"public static String getReconcileHashCode(TreeMap<String, AtomicInteger> instanceCountMap) { String reconcileHashCode = \"\"; for (Map.Entry<String, AtomicInteger> mapEntry : instanceCountMap .entrySet()) { reconcileHashCode = reconcileHashCode + mapEntry.getKey() + STATUS_DELIMITER + mapEntry.getValue().get() + STATUS_DELIMITER; } return reconcileHashCode; }","old_code_raw":"    public String getReconcileHashCode() {\n        TreeMap<String, AtomicInteger> instanceCountMap = new TreeMap<String, AtomicInteger>();\n        populateInstanceCountMap(instanceCountMap);\n        return getReconcileHashCode(instanceCountMap);\n    }\n","new_comment_raw":"@return the hash code for this instance","old_comment_raw":"@return the internal hash code representation indicating the information about the instances.","label":1,"pre_label":0,"AST_level":11,"line_counts":11,"new_code_token_num":57},{"new_code_raw":"public String toDefaultValueWithParam(String name, Property p) { return \" = data.\" + name + \";\"; }","old_code_raw":"    public String toDefaultValueWithParam(String name, Property p) {\n        if (p instanceof StringProperty) {\n            return \" = data.\" + name + \";\";\n        } else if (p instanceof BooleanProperty) {\n            return \" = data.\" + name + \";\";\n        } else if (p instanceof DateProperty) {\n            return \" = data.\" + name + \";\";\n        } else if (p instanceof DateTimeProperty) {\n            return \" = data.\" + name + \";\";\n        } else if (p instanceof DoubleProperty) {\n            DoubleProperty dp = (DoubleProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \" = data.\" + name + \";\";\n        } else if (p instanceof FloatProperty) {\n            FloatProperty dp = (FloatProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \" = data.\" + name + \";\";\n        } else if (p instanceof IntegerProperty) {\n            IntegerProperty dp = (IntegerProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \" = data.\" + name + \";\";\n        } else if (p instanceof LongProperty) {\n            LongProperty dp = (LongProperty) p;\n            if (dp.getDefault() != null) {\n                return dp.getDefault().toString();\n            }\n            return \" = data.\" + name + \";\";\n        } else {\n            return \" = data.\" + name + \";\";\n        }\n    }\n","new_comment_raw":"@return string presentation of the default value of the property","old_comment_raw":"@return string presentation of the default value of the property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public final int querySingleInt(String sqlCmd, Connection conn) { return querySingleInt(sqlCmd, null, NUM, conn); }","old_code_raw":"public final int querySingleInt(String sqlCmd, Connection conn) {\n    return querySingleInt(sqlCmd, NUM, conn);\n}","new_comment_raw":"@return the result as a int value","old_comment_raw":"@return the result as a int value, if no result the int value 0","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":25},{"new_code_raw":"public String getSubject() { SubjectHeader subject = (SubjectHeader) getStackMessage().getHeader(SubjectHeader.NAME); if (subject != null) { return subject.getSubject(); } else { return STR; } }","old_code_raw":"public String getSubject() {\n    SubjectHeader subject = (SubjectHeader) getStackMessage().getHeader(SubjectHeader.NAME);\n    if (subject != null) {\n        return subject.getSubject();\n    } else {\n        return null;\n    }\n}","new_comment_raw":"@return Subject or empty","old_comment_raw":"@return Subject or null if there is no subject","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":41},{"new_code_raw":"protected boolean authenticate(ContainerRequestContext requestContext, C credentials, String scheme) { try { if (credentials == null) { return false; } final Optional<P> principal = authenticator.authenticate(credentials); if (!principal.isPresent()) { return false; } boolean secure = requestContext.getSecurityContext().isSecure(); requestContext.setSecurityContext(new SecurityContext() { @Override public Principal getUserPrincipal() { return principal.get(); } @Override public boolean isUserInRole(String role) { return authorizer.authorize(principal.get(), role); } @Override public boolean isSecure() { return secure; } @Override public String getAuthenticationScheme() { return scheme; } }); return true; } catch (AuthenticationException e) { logger.warn(\"Error authenticating credentials\", e); throw new InternalServerErrorException(); } }","old_code_raw":"    protected boolean authenticate(ContainerRequestContext requestContext, C credentials, String scheme) {\n        try {\n            if (credentials == null) {\n                return false;\n            }\n\n            final Optional<P> principal = authenticator.authenticate(credentials);\n            if (!principal.isPresent()) {\n                return false;\n            }\n\n            requestContext.setSecurityContext(new SecurityContext() {\n                @Override\n                public Principal getUserPrincipal() {\n                    return principal.get();\n                }\n\n                @Override\n                public boolean isUserInRole(String role) {\n                    return authorizer.authorize(principal.get(), role);\n                }\n\n                @Override\n                public boolean isSecure() {\n                    return requestContext.getSecurityContext().isSecure();\n                }\n\n                @Override\n                public String getAuthenticationScheme() {\n                    return scheme;\n                }\n            });\n            return true;\n        } catch (AuthenticationException e) {\n            logger.warn(\"Error authenticating credentials\", e);\n            throw new InternalServerErrorException();\n        }\n    }\n","new_comment_raw":"@return  true, if the request is authenticated, otherwise  false","old_comment_raw":"@return true, if the request is authenticated, otherwise false","label":0,"pre_label":1,"AST_level":10,"line_counts":40,"new_code_token_num":162},{"new_code_raw":"public ResourceTestRule build() { return new ResourceTestRule(buildResource()); }","old_code_raw":"public ResourceTestRule build() {\n    return new ResourceTestRule(new ResourceTestJerseyConfiguration(singletons, providers, properties, mapper, validator, clientConfigurator, testContainerFactory, registerDefaultExceptionMappers));\n}","new_comment_raw":"@return a new {@link ResourceExtension}","old_comment_raw":"@return a new {@link ResourceTestRule}","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"protected static String buildMessage(String msg) { StackTraceElement caller = new Throwable().fillInStackTrace().getStackTrace()[2]; return new StringBuilder() .append(caller.getFileName()) .append(\".\") .append(caller.getMethodName()) .append(\"(): \") .append(msg).toString(); }","old_code_raw":"    protected static String buildMessage(String msg) {\n        StackTraceElement caller = new Throwable().fillInStackTrace().getStackTrace()[2];\n\n        return new StringBuilder()\n                .append(caller.getClassName())\n                .append(\".\")\n                .append(caller.getMethodName())\n                .append(\"(): \")\n                .append(msg).toString();\n    }\n","new_comment_raw":"@return Message String","old_comment_raw":"@return Message String","label":0,"pre_label":1,"AST_level":7,"line_counts":11,"new_code_token_num":66},{"new_code_raw":"public long getResponseContentLength() { String contentLengthString = responseHeaders.getFirst(Headers.CONTENT_LENGTH); if (contentLengthString == null) { return -NUM; } return Long.parseLong(contentLengthString); }","old_code_raw":"public Long getResponseContentLength() {\n    String contentLengthString = responseHeaders.getFirst(Headers.CONTENT_LENGTH);\n    if (contentLengthString == null) {\n        return null;\n    }\n    return Long.parseLong(contentLengthString);\n}","new_comment_raw":"@return The content length of the response, or <code>-1<\/code> if it has not been set","old_comment_raw":"@return The content length of the response, or <code>null<\/code> if it has not been set","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":34},{"new_code_raw":"public String getSelectedIndex(String selectLocator) { return (String) seleneseMethods.get(\"getSelectedIndex\").apply(driver, selectLocator); }","old_code_raw":"  public String getSelectedIndex(String selectLocator) {\n    List<WebElement> options = getOptions(selectLocator);\n\n    for (int i = 0; i < options.size(); i++) {\n      WebElement option = options.get(i);\n      if (option.isSelected())\n        return String.valueOf(i);\n    }\n\n    throw new SeleniumException(\"No option is selected: \" + selectLocator);\n  }\n","new_comment_raw":"@return the selected option index in the specified select drop-down","old_comment_raw":"@return the selected option index in the specified select drop-down","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"protected List<Map<Object, Object>> filterViewCollection(Collection<Map<Object, Object>> result, Set viewFilter) { List<Map<Object, Object>> newCollection = new ArrayList<Map<Object, Object>>(); for (Iterator<Map<Object, Object>> i = result.iterator(); i.hasNext(); ) { newCollection.add(filterView(i.next())); } return newCollection; }","old_code_raw":"protected List filterViewCollection(Collection result, Set viewFilter) {\n    List newCollection = new ArrayList();\n    for (Iterator i = result.iterator(); i.hasNext(); ) {\n        newCollection.add(filterView((Map) i.next()));\n    }\n    return newCollection;\n}","new_comment_raw":"@return list of objects whose view has been filtered","old_comment_raw":"@return lsit of objects whose view has been filtered","label":1,"pre_label":0,"AST_level":10,"line_counts":7,"new_code_token_num":71},{"new_code_raw":"public boolean report(Location location) { if (lastReport != null) { if (location.getTime() - lastReport.getTime() < locationRequest.getFastestInterval()) { return true; } if (location.distanceTo(lastReport) < locationRequest.getSmallestDesplacement()) { return true; } } Log.d(TAG, \"sending Location: \" + location); if (listener != null) { try { listener.onLocationChanged(location); } catch (RemoteException e) { return false; } } else if (pendingIntent != null) { Intent intent = new Intent(); intent.putExtra(\"com.google.android.location.LOCATION\", location); try { pendingIntent.send(context, 0, intent); } catch (PendingIntent.CanceledException e) { return false; } } else if (callback != null) { try { callback.onLocationResult(LocationResult.create(Arrays.asList(location))); } catch (RemoteException e) { return false; } } lastReport = location; numReports++; return numReports < locationRequest.getNumUpdates(); }","old_code_raw":"    public boolean report(Location location) {\n        if (lastReport != null) {\n            if (location.getTime() - lastReport.getTime() < locationRequest.getFastestInterval()) {\n                return true;\n            }\n            if (location.distanceTo(lastReport) < locationRequest.getSmallestDesplacement()) {\n                return true;\n            }\n        }\n        Log.d(TAG, \"sending Location: \" + location);\n        if (listener != null) {\n            try {\n                listener.onLocationChanged(location);\n            } catch (RemoteException e) {\n                return false;\n            }\n        } else if (pendingIntent != null) {\n            Intent intent = new Intent();\n            intent.putExtra(\"com.google.android.location.LOCATION\", location);\n            try {\n                pendingIntent.send(context, 0, intent);\n            } catch (PendingIntent.CanceledException e) {\n                return false;\n            }\n        }\n        lastReport = location;\n        numReports++;\n        return numReports < locationRequest.getNumUpdates();\n    }\n","new_comment_raw":"@return whether to continue sending reports to this  LocationRequestHelper","old_comment_raw":"@return whether to continue sending reports to this LocationRequestHelper","label":0,"pre_label":1,"AST_level":12,"line_counts":36,"new_code_token_num":200},{"new_code_raw":"public static String sanitizeCSV(String csv) { String[] tokens = csv.split(\",\"); return Arrays.stream(tokens) .map(String::trim) .filter(StringUtils::isNotEmpty) .collect(Collectors.joining(\",\")); }","old_code_raw":"  public static String sanitizeCSV(String csv) {\n    \/\/ tokenize\n    String[] tokens = csv.split(\",\");\n    ArrayList<String> sanitizedTokens = new ArrayList<String>(tokens.length);\n    \/\/ check for empties\n    for (String s : tokens) {\n      String trimmedToken = s.trim();\n      if (trimmedToken.length() != 0) {\n        sanitizedTokens.add(trimmedToken);\n      }\n    }\n    String result = \"\";\n    if (sanitizedTokens.size() != 0) {\n      result = Joiner.on(\",\").join(sanitizedTokens);\n    }\n    return result;\n  }\n","new_comment_raw":"@return The sanitized CSV string","old_comment_raw":"@return The sanitized CSV string","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":53},{"new_code_raw":"public Number getXpathCount(String xpath) { return (Number) seleneseMethods.get(\"getXpathCount\").apply(driver, xpath); }","old_code_raw":"  public Number getXpathCount(String xpath) {\n    return driver.findElements(By.xpath(xpath)).size();\n  }\n","new_comment_raw":"@return the number of nodes that match the specified xpath","old_comment_raw":"@return the number of nodes that match the specified xpath","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public SessionFactoryImpl getEntityManagerFactory() { return sessionFactory; }","old_code_raw":"\tpublic  EntityManagerFactoryImpl getEntityManagerFactory() {\n\t\treturn entityManagerFactory;\n\t}\n","new_comment_raw":"@return The underlying  SessionFactoryImpl","old_comment_raw":"@return The underlying EntityManagerFactoryImpl","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public static HashMap getXmlRpcWorkflowInstance(WorkflowInstance wInst) { HashMap workflowInstance = new HashMap(); workflowInstance.put(STR, wInst.getCurrentTaskId()); workflowInstance.put(STR, wInst.getStatus()); workflowInstance.put(STR, wInst.getId()); workflowInstance.put(STR, getXmlRpcWorkflow(wInst.getWorkflow())); workflowInstance.put(STR, wInst.getStartDateTimeIsoStr() != null ? wInst.getStartDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getEndDateTimeIsoStr() != null ? wInst.getEndDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getCurrentTaskStartDateTimeIsoStr() != null ? wInst.getCurrentTaskStartDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getCurrentTaskEndDateTimeIsoStr() != null ? wInst.getCurrentTaskEndDateTimeIsoStr() : STR); workflowInstance.put(STR, wInst.getSharedContext() != null ? wInst.getSharedContext().getMap() : new HashMap()); workflowInstance.put(STR, wInst.getPriority() != null ? String.valueOf(wInst.getPriority().getValue()) : String.valueOf(Priority.getDefault().getValue())); return workflowInstance; }","old_code_raw":"public static Hashtable getXmlRpcWorkflowInstance(WorkflowInstance wInst) {\n    Hashtable workflowInstance = new Hashtable();\n    workflowInstance.put(STR, wInst.getCurrentTaskId());\n    workflowInstance.put(STR, wInst.getStatus());\n    workflowInstance.put(STR, wInst.getId());\n    workflowInstance.put(STR, getXmlRpcWorkflow(wInst.getWorkflow()));\n    workflowInstance.put(STR, wInst.getStartDateTimeIsoStr() != null ? wInst.getStartDateTimeIsoStr() : STR);\n    workflowInstance.put(STR, wInst.getEndDateTimeIsoStr() != null ? wInst.getEndDateTimeIsoStr() : STR);\n    workflowInstance.put(STR, wInst.getCurrentTaskStartDateTimeIsoStr() != null ? wInst.getCurrentTaskStartDateTimeIsoStr() : STR);\n    workflowInstance.put(STR, wInst.getCurrentTaskEndDateTimeIsoStr() != null ? wInst.getCurrentTaskEndDateTimeIsoStr() : STR);\n    workflowInstance.put(STR, wInst.getSharedContext() != null ? wInst.getSharedContext().getMap() : new Hashtable());\n    workflowInstance.put(STR, wInst.getPriority() != null ? String.valueOf(wInst.getPriority().getValue()) : String.valueOf(Priority.getDefault().getValue()));\n    return workflowInstance;\n}","new_comment_raw":"@return A {@link HashMap} representation of a {@link WorkflowInstance}.","old_comment_raw":"@return A {@link Hashtable} representation of a {@link WorkflowInstance}.","label":1,"pre_label":0,"AST_level":8,"line_counts":14,"new_code_token_num":210},{"new_code_raw":"public ZapTextField getTxtPattern() { if (txtPattern == null) { txtPattern = new ZapTextField(); } return txtPattern; }","old_code_raw":"\tpublic JTextField getTxtPattern() {\n\t\tif (txtPattern == null) {\n\t\t\ttxtPattern = new JTextField();\n\t\t}\n\t\treturn txtPattern;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public CodegenType getTag() { return CodegenType.SERVER; }","old_code_raw":"    public CodegenType getTag() {\n        return CodegenType.CLIENT;\n    }\n","new_comment_raw":"@return the CodegenType for this generator","old_comment_raw":"@return the CodegenType for this generator","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"private Way getWayForNode(Node n) { Way way = null; for (Way w : Main.ds.ways) { int i = w.nodes.indexOf(n); if (i == -NUM) continue; if (i == NUM || i == w.nodes.size() - NUM) { if (way != null) return null; way = w; } } return way; }","old_code_raw":"private Way getWayForNode(Node n) {\n    Way way = null;\n    for (Way w : Main.ds.ways) {\n        for (Segment s : w.segments) {\n            if (s.from == n || s.to == n) {\n                if (way != null)\n                    return null;\n                if (s.from == s.to)\n                    return null;\n                way = w;\n            }\n        }\n    }\n    return way;\n}","new_comment_raw":"@return If the node is the end of exactly one way, return this. <code>null<\/code> otherwise.","old_comment_raw":"@return If the node is part of exactly one way, return this. <code>null<\/code> otherwise.","label":1,"pre_label":0,"AST_level":9,"line_counts":14,"new_code_token_num":73},{"new_code_raw":"public static String quote(String name) { if ( name == null || name.length() == 0 || isQuoted( name ) ) { return name; } else { return new StringBuffer( name.length() + 2 ).append('`').append( name ).append( '`' ).toString(); } }","old_code_raw":"\tpublic static String quote(String name) {\n\t\tif ( name == null || name.length() == 0 || isQuoted( name ) ) {\n\t\t\treturn name;\n\t\t}\n\t\telse {\n\t\t\treturn new StringBuilder( name.length() + 2 ).append('`').append( name ).append( '`' ).toString();\n\t\t}\n\t}\n","new_comment_raw":"@return The quoted version.","old_comment_raw":"@return The quoted version.","label":0,"pre_label":1,"AST_level":8,"line_counts":9,"new_code_token_num":65},{"new_code_raw":"List<String> getTempFiles() { List<String> tempFiles = new ArrayList<String>(); for (Entry<ManagedFile, FilePath> entry : file2Path.entrySet()) { boolean noTargetGiven = StringUtils.isBlank(entry.getKey().targetLocation); if (noTargetGiven) { tempFiles.add(entry.getValue().getRemote()); } } return tempFiles; }","old_code_raw":"public List<FilePath> getTempFiles() {\n    List<FilePath> tempFiles = new ArrayList<FilePath>();\n    for (Entry<ManagedFile, FilePath> entry : file2Path.entrySet()) {\n        boolean noTargetGiven = StringUtils.isBlank(entry.getKey().targetLocation);\n        if (noTargetGiven) {\n            tempFiles.add(entry.getValue());\n        }\n    }\n    return tempFiles;\n}","new_comment_raw":"@return a list of paths to the temp files (remotes)","old_comment_raw":"@return a list of temp files","label":1,"pre_label":0,"AST_level":10,"line_counts":10,"new_code_token_num":64},{"new_code_raw":"public RexNode apply(Integer i) { return rexBuilder.makeCall( SqlStdOperatorTable.EQUALS, leftKeys[i], bb.convertExpression( call.getOperands()[i])); }","old_code_raw":"                      public RexNode apply(Integer i) {\n                        return rexBuilder.makeCall(\n                            SqlStdOperatorTable.equalsOperator,\n                            leftKeys[i],\n                            bb.convertExpression(\n                                call.getOperands()[i]));\n                      }\n","new_comment_raw":"@return converted expression","old_comment_raw":"@return converted expression","label":0,"pre_label":1,"AST_level":8,"line_counts":8,"new_code_token_num":34},{"new_code_raw":"private SourceRange getResultRange(String identPattern) { int offset = resultCode.indexOf(identPattern); assertThat(offset).describedAs(identPattern + STR + resultCode).isPositive(); String identifier = identPattern.substring(NUM, NOT_IDENTIFIER_MATCHER.indexIn(identPattern)); return new SourceRange(offset, identifier.length()); }","old_code_raw":"private SourceRange getResultRange(String wordPattern) {\n    int offset = resultCode.indexOf(wordPattern);\n    assertThat(offset).describedAs(wordPattern + STR + resultCode).isPositive();\n    String word = StringUtils.substringBefore(wordPattern, STR);\n    return new SourceRange(offset, word.length());\n}","new_comment_raw":"@return the {@link SourceRange} of \"identPattern\" in {@link #resultCode}.","old_comment_raw":"@return the {@link SourceRange} of \"wordPattern\" in {@link #resultCode}.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":59},{"new_code_raw":"protected boolean authenticate(ContainerRequestContext requestContext, C credentials, String scheme) { try { if (credentials == null) { return false; } final Optional<P> principal = authenticator.authenticate(credentials); if (!principal.isPresent()) { return false; } requestContext.setSecurityContext(new SecurityContext() { @Override public Principal getUserPrincipal() { return principal.get(); } @Override public boolean isUserInRole(String role) { return authorizer.authorize(principal.get(), role); } @Override public boolean isSecure() { return requestContext.getSecurityContext().isSecure(); } @Override public String getAuthenticationScheme() { return scheme; } }); return true; } catch (AuthenticationException e) { logger.warn(\"Error authenticating credentials\", e); throw new InternalServerErrorException(); } }","old_code_raw":"    protected boolean authenticate(ContainerRequestContext requestContext, C credentials, String scheme) {\n        try {\n            if (credentials == null) {\n                return false;\n            }\n\n            final Optional<P> principal = authenticator.authenticate(credentials);\n            if (!principal.isPresent()) {\n                return false;\n            }\n\n            final SecurityContext securityContext = requestContext.getSecurityContext();\n            final boolean secure = securityContext != null && securityContext.isSecure();\n            \n            requestContext.setSecurityContext(new SecurityContext() {\n                @Override\n                public Principal getUserPrincipal() {\n                    return principal.get();\n                }\n\n                @Override\n                public boolean isUserInRole(String role) {\n                    return authorizer.authorize(principal.get(), role);\n                }\n\n                @Override\n                public boolean isSecure() {\n                    return secure;\n                }\n\n                @Override\n                public String getAuthenticationScheme() {\n                    return scheme;\n                }\n            });\n            return true;\n        } catch (AuthenticationException e) {\n            logger.warn(\"Error authenticating credentials\", e);\n            throw new InternalServerErrorException();\n        }\n    }\n","new_comment_raw":"@return  true, if the request is authenticated, otherwise  false","old_comment_raw":"@return true, if the request is authenticated, otherwise false","label":0,"pre_label":1,"AST_level":10,"line_counts":39,"new_code_token_num":158},{"new_code_raw":"public ApiResponse<Void> updatePetWithFormWithHttpInfo(Long petId, String name, String status) throws ApiException { okhttp3.Call localVarCall = updatePetWithFormValidateBeforeCall(petId, name, status, null, null); return localVarApiClient.execute(localVarCall); }","old_code_raw":"    public ApiResponse<Void> updatePetWithFormWithHttpInfo(Long petId, String name, String status) throws ApiException {\n        okhttp3.Call call = updatePetWithFormValidateBeforeCall(petId, name, status, null, null);\n        return apiClient.execute(call);\n    }\n","new_comment_raw":"@return ApiResponse&lt;Void&gt;","old_comment_raw":"@return ApiResponse&lt;Void&gt;","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":41},{"new_code_raw":"public static MatchFinder allOf(final MatchFinder... finders) { return new MatchFinder() { @Override public boolean matches(UiElement element) { for (MatchFinder finder : finders) { if (!finder.matches(element)) { return false; } } return true; } @Override public String toString() { return STR + Joiner.on(STR).join(finders) + STR; } }; }","old_code_raw":"public static ElementMatcher allOf(final ElementMatcher... matchers) {\n    return new ElementMatcher() {\n\n        @Override\n        public boolean matches(UiElement element) {\n            for (ElementMatcher matcher : matchers) {\n                if (!matcher.matches(element)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            return STR + Joiner.on(STR).join(matchers) + STR;\n        }\n    };\n}","new_comment_raw":"@return a finder that is the logical conjunction of given finders","old_comment_raw":"@return a matcher that is the logical conjunction of given matchers","label":1,"pre_label":0,"AST_level":11,"line_counts":19,"new_code_token_num":80},{"new_code_raw":"private int updateRedundancy() { int numBucketHosts = getNumInitializedBuckets(); if (!isClosed()) { redundancyTracker.updateStatistics(numBucketHosts); } return numBucketHosts; }","old_code_raw":"private int updateRedundancy() {\n    int desiredRedundancy = this.pRegion.getRedundantCopies();\n    int numBucketHosts = getNumInitializedBuckets();\n    if (isClosed()) {\n        return numBucketHosts;\n    }\n    int actualRedundancy = numBucketHosts - NUM;\n    this.redundancy = actualRedundancy;\n    if (this.redundancySatisfied && numBucketHosts > NUM && actualRedundancy < desiredRedundancy) {\n        incLowRedundancyBucketCount(NUM);\n        this.redundancySatisfied = false;\n    } else if (!this.redundancySatisfied && numBucketHosts > NUM && actualRedundancy >= desiredRedundancy) {\n        incLowRedundancyBucketCount(-NUM);\n        this.redundancySatisfied = true;\n        this.redundancyEverSatisfied = true;\n    }\n    return numBucketHosts;\n}","new_comment_raw":"@return number of current bucket hosts","old_comment_raw":"@return current number of hosts for this bucket","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":31},{"new_code_raw":"public DateTime setCopy(int value) { DateTime instant = iInstant; return (DateTime)instant.withMillis(iField.set(instant.getMillis(), value)); }","old_code_raw":"    public DateTime setCopy(int value) {\n        DateTime instant = iInstant;\n        return (DateTime)instant.toCopy(iField.set(instant.getMillis(), value));\n    }\n","new_comment_raw":"@return a copy of the DateTime with the field value changed","old_comment_raw":"@return a copy of the DateTime with the field value changed","label":0,"pre_label":1,"AST_level":7,"line_counts":5,"new_code_token_num":32},{"new_code_raw":"public ApiResponse<Client> testClassnameWithHttpInfo(Client body) throws ApiException { okhttp3.Call localVarCall = testClassnameValidateBeforeCall(body, null, null); Type localVarReturnType = new TypeToken<Client>(){}.getType(); return localVarApiClient.execute(localVarCall, localVarReturnType); }","old_code_raw":"    public ApiResponse<Client> testClassnameWithHttpInfo(Client body) throws ApiException {\n        okhttp3.Call call = testClassnameValidateBeforeCall(body, null, null);\n        Type localVarReturnType = new TypeToken<Client>(){}.getType();\n        return apiClient.execute(call, localVarReturnType);\n    }\n","new_comment_raw":"@return ApiResponse&lt;Client&gt;","old_comment_raw":"@return ApiResponse&lt;Client&gt;","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":46},{"new_code_raw":"public ApnsServiceBuilder asQueued() { return asQueued(Executors.defaultThreadFactory()); }","old_code_raw":"    public ApnsServiceBuilder asQueued() {\n        this.isQueued = true;\n        return this;\n    }\n","new_comment_raw":"@return this","old_comment_raw":"@return this","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public static GrammaticalRelation getAcl(String aclString) { \/* Check for nmod subtypes which are not stored in the `nmods` map. *\/ if (aclString.equals(\"relcl\")) { return RELATIVE_CLAUSE_MODIFIER; } GrammaticalRelation result = acls.get(aclString); if (result == null) { synchronized(acls) { result = acls.get(aclString); if (result == null) { result = new GrammaticalRelation(Language.UniversalEnglish, \"acl\", \"acl_preposition\", CLAUSAL_MODIFIER, aclString); acls.put(aclString, result); threadSafeAddRelation(result); } } } return result; }","old_code_raw":"  public static GrammaticalRelation getAcl(String aclString) {\n    GrammaticalRelation result = acls.get(aclString);\n    if (result == null) {\n      synchronized(acls) {\n        result = acls.get(aclString);\n        if (result == null) {\n          result = new GrammaticalRelation(Language.UniversalEnglish, \"acl\", \"acl_preposition\", CLAUSAL_MODIFIER, aclString);\n          acls.put(aclString, result);\n          threadSafeAddRelation(result);\n        }\n      }\n    }\n    return result;\n  }\n","new_comment_raw":"@return A grammatical relation for this preposition","old_comment_raw":"@return A grammatical relation for this preposition","label":0,"pre_label":1,"AST_level":11,"line_counts":21,"new_code_token_num":112},{"new_code_raw":"public int compare(Pair<E, Double> a, Pair<E, Double> b) { int candidate = Double.compare(a.second, b.second); if (candidate == 0.0 && a.first instanceof Comparable && b.first instanceof Comparable) { \/\/ Try to create a stable ordering, breaking ties with the key's natural order return ((Comparable) a.first).compareTo(b.first); } else { return candidate; } }","old_code_raw":"      public int compare(Pair<E, Double> a, Pair<E, Double> b) {\n        return Double.compare(b.second, a.second);\n      }\n","new_comment_raw":"@return A List of the keys in c, sorted from highest count to lowest.","old_comment_raw":"@return A List of the keys in c, sorted from highest count to lowest.","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":88},{"new_code_raw":"public FlyoutFragment getTrashFragment() { return mTrashFragment; }","old_code_raw":"public TrashFragment getTrashFragment() {\n    return mTrashFragment;\n}","new_comment_raw":"@return The currently attached trash {@link FlyoutFragment}.","old_comment_raw":"@return The currently attached {@link TrashFragment}.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public TimeOfDay setCopy(int value) { int[] newValues = iTimeOfDay.getValues(); newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, value); return new TimeOfDay(iTimeOfDay, newValues); }","old_code_raw":"        public TimeOfDay setCopy(int value) {\n            int[] newValues = iInstant.getValues();\n            getField().set(iInstant, iFieldIndex, newValues, value);\n            return new TimeOfDay(iInstant, newValues);\n        }\n","new_comment_raw":"@return a copy of the TimeOfDay with the field value changed","old_comment_raw":"@return a copy of the TimeOfDay with the field value changed","label":0,"pre_label":1,"AST_level":7,"line_counts":6,"new_code_token_num":42},{"new_code_raw":"public byte[] getObjectDigest() { if (holder.getObjectDigestInfo() != null) { return holder.getObjectDigestInfo().getObjectDigest().getBytes(); } return null; }","old_code_raw":"public byte[] getObjectDigest() {\n    if (holder.getObjectDigestInfo() != null) {\n        holder.getObjectDigestInfo().getObjectDigest().getBytes();\n    }\n    return null;\n}","new_comment_raw":"@return The hash or <code>null<\/code> if ObjectDigestInfo is absent.","old_comment_raw":"@return The hash or <code>null<\/code> if no object digest info is set.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":35},{"new_code_raw":"public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil) throws StandardException { if (this.isNull()) { return SQLBoolean.unknownTruthValue(); } if (SanityManager.DEBUG) { SanityManager.ASSERT(sqlxUtil != null, STR); } try { return new SQLBoolean(sqlxUtil.evalXQExpression(this)); } catch (Exception xe) { if (xe instanceof StandardException) throw (StandardException) xe; else { throw StandardException.newException(SQLState.LANG_UNEXPECTED_XML_EXCEPTION, xe); } } }","old_code_raw":"public BooleanDataValue XMLExists(StringDataValue xExpr, XMLDataValue xml) throws StandardException {\n    if ((xExpr == null) || xExpr.isNull())\n        return SQLBoolean.unknownTruthValue();\n    if ((xml == null) || xml.isNull())\n        return SQLBoolean.unknownTruthValue();\n    return new SQLBoolean(xml.exists(xExpr.getString()));\n}","new_comment_raw":"@return True if evaluation of the query expression stored in sqlxUtil returns at least one node for this XML value; unknown if the xml value is NULL; false otherwise.","old_comment_raw":"@return True if the received query expression matches at least one node in the received XML value; unknown if either the query expression or the xml value is null; false otherwise.","label":1,"pre_label":0,"AST_level":9,"line_counts":17,"new_code_token_num":89},{"new_code_raw":"public short get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public short get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public Property centuryOfEra() { return new Property(this, getChronology().centuryOfEra()); }","old_code_raw":"    public ReadWritableInstantFieldProperty centuryOfEra() {\n        return new ReadWritableInstantFieldProperty(this, getChronology().centuryOfEra());\n    }\n","new_comment_raw":"@return the year of era property","old_comment_raw":"@return the year of era property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) { return appendDecimal(DateTimeFieldType.yearOfCentury(), minDigits, maxDigits); }","old_code_raw":"    public DateTimeFormatterBuilder appendYearOfCentury(final int minDigits, final int maxDigits) {\n        return appendDecimal(iChronoUTC.yearOfCentury(), minDigits, maxDigits);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public TimePeriod withFieldsNormalized() { return new TimePeriod(toDurationMillis(), getPeriodType()); }","old_code_raw":"    public TimePeriod withFieldsNormalized() {\n        return new TimePeriod(toDurationMillis(), getDurationType());\n    }\n","new_comment_raw":"@return the new period instance","old_comment_raw":"@return the new period instance","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public int getStack(int k) { int nStack = getStackSize(); return (k >= NUM && k < nStack) ? stack.get(nStack - NUM - k) : Config.NONEXIST; }","old_code_raw":"public int getStack(int k) {\n    int nStack = getStackSize();\n    return (k >= NUM && k < nStack) ? stack.get(nStack - NUM - k) : CONST.NONEXIST;\n}","new_comment_raw":"@return Sentence index or {@link Config#NONEXIST} if stack doesn't have an element at this index","old_comment_raw":"@return Sentence index or {@link CONST#NONEXIST} if stack doesn't have an element at this index","label":1,"pre_label":0,"AST_level":8,"line_counts":4,"new_code_token_num":38},{"new_code_raw":"public int toStatusCode(Throwable thrown) { if (thrown == null) { return SUCCESS; } else if (thrown instanceof InvalidCookieDomainException) { return INVALID_COOKIE_DOMAIN; } else if (thrown instanceof UnableToSetCookieException) { return UNABLE_TO_SET_COOKIE; } else if (thrown instanceof NoSuchWindowException) { return NO_SUCH_WINDOW; } else if (thrown instanceof InvalidSelectorException) { return INVALID_SELECTOR_ERROR; } else if (thrown instanceof NoSuchElementException) { return NO_SUCH_ELEMENT; } else if (thrown instanceof NoSuchFrameException) { return NO_SUCH_FRAME; } else if (thrown instanceof StaleElementReferenceException) { return STALE_ELEMENT_REFERENCE; } else if (thrown instanceof ElementNotVisibleException) { return ELEMENT_NOT_VISIBLE; } else if (thrown instanceof InvalidElementStateException) { return INVALID_ELEMENT_STATE; } else if (thrown instanceof XPathLookupException) { return XPATH_LOOKUP_ERROR; } else if (thrown instanceof TimeoutException) { return ASYNC_SCRIPT_TIMEOUT; } else if (thrown instanceof InvalidCoordinatesException) { return INVALID_ELEMENT_COORDINATES; } else if (thrown instanceof ImeNotAvailableException) { return IME_NOT_AVAILABLE; } else if (thrown instanceof ImeActivationFailedException) { return IME_ENGINE_ACTIVATION_FAILED; } else if (thrown instanceof NoAlertPresentException) { return NO_ALERT_PRESENT; } else if (thrown instanceof UnhandledAlertException) { return UNEXPECTED_ALERT_PRESENT; } else if (thrown instanceof MoveTargetOutOfBoundsException) { return MOVE_TARGET_OUT_OF_BOUNDS; } else { return UNHANDLED_ERROR; } }","old_code_raw":"  public int toStatusCode(Throwable thrown) {\n    if (thrown == null) {\n      return SUCCESS;\n    } else if (thrown instanceof InvalidCookieDomainException) {\n      return INVALID_COOKIE_DOMAIN;\n    } else if (thrown instanceof UnableToSetCookieException) {\n      return UNABLE_TO_SET_COOKIE;\n    } else if (thrown instanceof NoSuchWindowException) {\n      return NO_SUCH_WINDOW;\n    } else if (thrown instanceof InvalidSelectorException) {\n      return INVALID_SELECTOR_ERROR;\n    } else if (thrown instanceof NoSuchElementException) {\n      return NO_SUCH_ELEMENT;\n    } else if (thrown instanceof NoSuchFrameException) {\n      return NO_SUCH_FRAME;\n    } else if (thrown instanceof StaleElementReferenceException) {\n      return STALE_ELEMENT_REFERENCE;\n    } else if (thrown instanceof ElementNotVisibleException) {\n      return ELEMENT_NOT_VISIBLE;\n    } else if (thrown instanceof InvalidElementStateException) {\n      return INVALID_ELEMENT_STATE;\n    } else if (thrown instanceof XPathLookupException) {\n      return XPATH_LOOKUP_ERROR;\n    } else if (thrown instanceof TimeoutException) {\n      return ASYNC_SCRIPT_TIMEOUT;\n    } else if (thrown instanceof InvalidCoordinatesException) {\n      return INVALID_ELEMENT_COORDINATES;\n    } else if (thrown instanceof ImeNotAvailableException) {\n      return IME_NOT_AVAILABLE;\n    } else if (thrown instanceof ImeActivationFailedException) {\n      return IME_ENGINE_ACTIVATION_FAILED;\n    } else if (thrown instanceof NoAlertPresentException) {\n      return NO_ALERT_PRESENT;\n    } else if (thrown instanceof MoveTargetOutOfBoundsException) {\n      return MOVE_TARGET_OUT_OF_BOUNDS;\n    } else {\n      return UNHANDLED_ERROR;\n    }\n  }\n","new_comment_raw":"@return The corresponding status code for the given thrown error.","old_comment_raw":"@return The corresponding status code for the given thrown error.","label":0,"pre_label":1,"AST_level":23,"line_counts":42,"new_code_token_num":229},{"new_code_raw":"public ComponentType introspect(Class<?> implClass) throws ConfigurationLoadException { ComponentType compType = factory.createComponentType(); return introspect(implClass, compType); }","old_code_raw":"public ComponentInfo introspect(Class<?> implClass) throws ConfigurationLoadException {\n    ComponentInfo compType = factory.createComponentInfo();\n    return introspect(implClass, compType);\n}","new_comment_raw":"@return ComponentType representing the implementation type metadata","old_comment_raw":"@return ComponentInfo representing the implementation type metadata","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"public ArrayList<ToggleButton> getCurrentToggleButtons() { return ensureArrayListOrNull(viewFetcher.getCurrentViews(ToggleButton.class)); }","old_code_raw":"\tpublic ArrayList<ToggleButton> getCurrentToggleButtons() {\n\t\tArrayList<ToggleButton> toggleButtonList = viewFetcher.getCurrentViews(ToggleButton.class);\n\t\treturn toggleButtonList;\n\t}\n","new_comment_raw":"@return a  List of the  ToggleButtons contained in the current  Activity","old_comment_raw":"@return a List of the ToggleButtons contained in the current Activity","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"protected long[] executeBatchInternal() throws SQLException { for (int i = NUM; i < connection.maxRetriesPerExecute; i++) { try { return connection.prepareAndUpdateBatch(this, batchedSql).updateCounts; } catch (NoSuchStatementException e) { resetStatement(); } } throw new RuntimeException(STR + connection.maxRetriesPerExecute + STR); }","old_code_raw":"protected int[] executeBatchInternal() throws SQLException {\n    for (int i = NUM; i < connection.maxRetriesPerExecute; i++) {\n        try {\n            Meta.ExecuteBatchResult result = connection.prepareAndUpdateBatch(this, batchedSql);\n            return result.updateCounts;\n        } catch (NoSuchStatementException e) {\n            resetStatement();\n        }\n    }\n    throw new RuntimeException(STR + connection.maxRetriesPerExecute + STR);\n}","new_comment_raw":"@return an array of long mapping to the update count per SQL command.","old_comment_raw":"@return an array of integers mapping to the update count per SQL command.","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":63},{"new_code_raw":"public static String optimizeImage(Context context, String path) { if (context == null || TextUtils.isEmpty(path)) { return path; } File file = new File(path); if (!file.exists()) { return path; } String mimeType = MediaUtils.getMediaFileMimeType(file); if (mimeType.equals(STR)) { return path; } Uri imageUri = Uri.parse(path); if (imageUri == null) { return path; } String fileName = MediaUtils.getMediaFileName(file, mimeType); String fileExtension = MimeTypeMap.getFileExtensionFromUrl(fileName).toLowerCase(); int[] dimensions = getImageSize(imageUri, context); int selectedWidth = dimensions[NUM]; final int maxImageWidth = NUM; if (selectedWidth > maxImageWidth) { selectedWidth = maxImageWidth; } int orientation = getImageOrientation(context, path); File resizedImageFile; FileOutputStream out; try { resizedImageFile = File.createTempFile(STR, STR + fileExtension); out = new FileOutputStream(resizedImageFile); } catch (IOException e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } catch (SecurityException e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } try { boolean res = resizeImageAndWriteToStream(context, imageUri, fileExtension, selectedWidth, orientation, NUM, out); if (!res) { AppLog.w(AppLog.T.MEDIA, STR); return path; } } catch (IOException e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } catch (OutOfMemoryError e) { AppLog.e(AppLog.T.MEDIA, STR); return path; } finally { try { out.flush(); out.close(); } catch (IOException e) { } } String tempFilePath = resizedImageFile.getPath(); if (!TextUtils.isEmpty(tempFilePath)) { return tempFilePath; } else { AppLog.e(AppLog.T.MEDIA, STR); } return path; }","old_code_raw":"public static String optimizeImage(Context context, String path) {\n    File file = new File(path);\n    if (!file.exists()) {\n        return path;\n    }\n    String mimeType = MediaUtils.getMediaFileMimeType(file);\n    if (mimeType.equals(STR)) {\n        return path;\n    }\n    String fileName = MediaUtils.getMediaFileName(file, mimeType);\n    String fileExtension = MimeTypeMap.getFileExtensionFromUrl(fileName).toLowerCase();\n    int[] dimensions = getImageSize(Uri.fromFile(file), context);\n    int orientation = getImageOrientation(context, path);\n    Uri imageUri = Uri.parse(path);\n    if (context == null || imageUri == null) {\n        return path;\n    }\n    File resizedImageFile;\n    FileOutputStream out;\n    try {\n        resizedImageFile = File.createTempFile(STR, STR + fileExtension);\n        out = new FileOutputStream(resizedImageFile);\n    } catch (IOException e) {\n        AppLog.e(AppLog.T.MEDIA, STR);\n        return path;\n    } catch (SecurityException e) {\n        AppLog.e(AppLog.T.MEDIA, STR);\n        return path;\n    }\n    try {\n        boolean res = resizeImageAndWriteToStream(context, imageUri, fileExtension, dimensions[NUM], orientation, NUM, out);\n        if (!res) {\n            AppLog.w(AppLog.T.MEDIA, STR);\n            return path;\n        }\n    } catch (IOException e) {\n        AppLog.e(AppLog.T.MEDIA, STR);\n        return path;\n    } catch (OutOfMemoryError e) {\n        AppLog.e(AppLog.T.MEDIA, STR);\n        return path;\n    } finally {\n        try {\n            out.flush();\n            out.close();\n        } catch (IOException e) {\n        }\n    }\n    String tempFilePath = resizedImageFile.getPath();\n    if (!TextUtils.isEmpty(tempFilePath)) {\n        return tempFilePath;\n    } else {\n        AppLog.e(AppLog.T.MEDIA, STR);\n    }\n    return path;\n}","new_comment_raw":"@return the path to the optimized image","old_comment_raw":"@return the path to the optmized image","label":1,"pre_label":0,"AST_level":8,"line_counts":64,"new_code_token_num":362},{"new_code_raw":"public T setDecodeAllFrames(boolean decodeAllFrames) { mDecodeAllFrames = decodeAllFrames; return getThis(); }","old_code_raw":"  public ImageDecodeOptionsBuilder setDecodeAllFrames(boolean decodeAllFrames) {\n    mDecodeAllFrames = decodeAllFrames;\n    return this;\n  }\n","new_comment_raw":"@return this builder","old_comment_raw":"@return this builder","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public int getJdbcId() { return jdbcId; }","old_code_raw":"    public int getJdbcId() {\n        return jdbc;\n    }\n","new_comment_raw":"@return JDBC id of the type as reported by JDBC metadata","old_comment_raw":"@return JDBC id of the type as reported by JDBC metadata","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public boolean isInMeleeDistance(WorldPoint other) { return isInMeleeDistance(new WorldArea(other, NUM, NUM)); }","old_code_raw":"public boolean isInMeleeDistance(WorldArea other) {\n    if (other == null || this.getPlane() != other.getPlane()) {\n        return false;\n    }\n    Point distances = getAxisDistances(other);\n    return distances.getX() + distances.getY() == NUM;\n}","new_comment_raw":"@return true if in melee distance, false otherwise","old_comment_raw":"@return Returns true if it is in melee distance","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":23},{"new_code_raw":"public Node parseXML(String text, Document doc) { return null; }","old_code_raw":"public DocumentFragment parseXML(String text, Document doc) {\n    return null;\n}","new_comment_raw":"@return The document\/document fragment or null on error.","old_comment_raw":"@return The document fragment or null on error.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":15},{"new_code_raw":"protected static String getStartingMessage() { DateFormat dateFormat = SimpleDateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM); StringBuilder strBuilder = new StringBuilder(200); strBuilder.append(Constant.PROGRAM_NAME).append(' ').append(Constant.PROGRAM_VERSION); strBuilder.append(\" started \"); strBuilder.append(dateFormat.format(new Date())); return strBuilder.toString(); }","old_code_raw":"    protected static String getStartingMessage() {\n        return Constant.PROGRAM_NAME + \" \" + Constant.PROGRAM_VERSION + \" started.\";\n    }\n","new_comment_raw":"@return the starting message","old_comment_raw":"@return the starting message","label":0,"pre_label":1,"AST_level":7,"line_counts":9,"new_code_token_num":72},{"new_code_raw":"protected TheInnerClass newTheInnerClass( ) { return this.injectMembers(new TheInnerClass()); }","old_code_raw":"  protected TheInnerClass newTheInnerClass( ) {\n    return new TheInnerClass();\n  }\n","new_comment_raw":"@return an instance of the inner class, at runtime the generated subclass (or replacement) of the template inner class","old_comment_raw":"@return an instance of the inner class, at runtime the generated subclass (or replacement) of the template inner class","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) { try { return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class}) .newInstance(config); } catch (final Exception e) { logger.error(\"Failed to create AsyncSupportt class: {}, error: {}\", targetClass, e); Throwable cause = e.getCause(); if (cause != null) { logger.error(\"Real error: {}, error: {}\", targetClass, cause); } logger.error(\"Switching to BlockingIO\"); return new BlockingIOCometSupport(config); } }","old_code_raw":"    public AsyncSupport newCometSupport(final Class<? extends AsyncSupport> targetClass) {\n        try {\n            return (AsyncSupport) targetClass.getDeclaredConstructor(new Class[]{AtmosphereConfig.class})\n                    .newInstance(config);\n        } catch (final Exception e) {\n            logger.warn(\"Failed to create AsyncSupport class: {}, error: {}\", targetClass, e);\n            return null; \/\/ All callers are expected to handle null return value\n        }\n    }\n","new_comment_raw":"@return an instance of the specified class or null if the class cannot be instantiated","old_comment_raw":"@return an instance of the specified class or null if the class cannot be instantiated","label":0,"pre_label":1,"AST_level":10,"line_counts":16,"new_code_token_num":122},{"new_code_raw":"public static RelNode swap(JoinRelBase join, boolean swapOuterJoins) { final JoinRelType joinType = join.getJoinType(); if (!swapOuterJoins && joinType != JoinRelType.INNER) { return null; } final RexBuilder rexBuilder = join.getCluster().getRexBuilder(); final RelDataType leftRowType = join.getLeft().getRowType(); final RelDataType rightRowType = join.getRight().getRowType(); final VariableReplacer variableReplacer = new VariableReplacer(rexBuilder, leftRowType, rightRowType); final RexNode oldCondition = join.getCondition(); RexNode condition = variableReplacer.go(oldCondition); \/\/ NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the \/\/ swap. This way, we will generate one semijoin for the original \/\/ join, and one for the swapped join, and no more. This \/\/ doesn't prevent us from seeing any new combinations assuming \/\/ that the planner tries the desired order (semijoins after swaps). JoinRelBase newJoin = join.copy(join.getTraitSet(), condition, join.getRight(), join.getLeft(), joinType.swap()); final List<RexNode> exps = RelOptUtil.createSwappedJoinExprs(newJoin, join, true); return CalcRel.createProject( newJoin, exps, join.getRowType().getFieldNames(), true); }","old_code_raw":"  public static RelNode swap(JoinRelBase join, boolean swapOuterJoins) {\n    JoinRelType joinType = join.getJoinType();\n    switch (joinType) {\n    case LEFT:\n      if (!swapOuterJoins) {\n        return null;\n      }\n      joinType = JoinRelType.RIGHT;\n      break;\n    case RIGHT:\n      if (!swapOuterJoins) {\n        return null;\n      }\n      joinType = JoinRelType.LEFT;\n      break;\n    }\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RelDataType leftRowType = join.getLeft().getRowType();\n    final RelDataType rightRowType = join.getRight().getRowType();\n    final VariableReplacer variableReplacer =\n        new VariableReplacer(rexBuilder, leftRowType, rightRowType);\n    final RexNode oldCondition = join.getCondition();\n    RexNode condition = variableReplacer.go(oldCondition);\n\n    \/\/ NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the\n    \/\/ swap.  This way, we will generate one semijoin for the original\n    \/\/ join, and one for the swapped join, and no more.  This\n    \/\/ doesn't prevent us from seeing any new combinations assuming\n    \/\/ that the planner tries the desired order (semijoins after swaps).\n    JoinRelBase newJoin =\n        join.copy(\n            join.getTraitSet(),\n            condition,\n            join.getRight(),\n            join.getLeft());\n    final List<RexNode> exps =\n        RelOptUtil.createSwappedJoinExprs(newJoin, join, true);\n    return CalcRel.createProject(\n        newJoin,\n        exps,\n        join.getRowType().getFieldNames(),\n        true);\n  }\n","new_comment_raw":"@return swapped join if swapping possible; else null","old_comment_raw":"@return swapped join if swapping possible; else null","label":0,"pre_label":1,"AST_level":6,"line_counts":30,"new_code_token_num":232},{"new_code_raw":"public static LogicalExpression getHash64Expression(LogicalExpression field, LogicalExpression seed, boolean hashAsDouble) { return createHash64Expression(ImmutableList.of(field), seed, HASH_HELPER_LOGICAL_EXPRESSION, hashAsDouble); }","old_code_raw":"  public static LogicalExpression getHash64Expression(LogicalExpression field, LogicalExpression seed, boolean hashAsDouble) {\n    return createHash64Expression(ImmutableList.of(field), seed, HASH_HELPER_LOGICALEXPRESSION, hashAsDouble);\n  }\n","new_comment_raw":"@return hash expression","old_comment_raw":"@return hash expression","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":32},{"new_code_raw":"public Future<HttpResponse> executeAsync(Executor executor) { FutureTask<HttpResponse> future = new FutureTask<HttpResponse>(new Callable<HttpResponse>() { public HttpResponse call() throws Exception { return execute(); } }); executor.execute(future); return future; }","old_code_raw":"public Future<HttpResponse> executeAsync(Executor exec) {\n    final SettableFuture<HttpResponse> future = SettableFuture.create();\n    exec.execute(new Runnable() {\n\n        public void run() {\n            try {\n                future.set(execute());\n            } catch (IOException ex) {\n                future.setException(ex);\n            }\n        }\n    });\n    return future;\n}","new_comment_raw":"@return future for accessing the HTTP response","old_comment_raw":"@return A future for accessing the results of the asynchronous request.","label":1,"pre_label":0,"AST_level":9,"line_counts":10,"new_code_token_num":49},{"new_code_raw":"public static List<RelHint> getRelHint(HintStrategyTable hintStrategies, SqlNodeList sqlHints) { if (sqlHints == null || sqlHints.size() == 0) { return ImmutableList.of(); } final ImmutableList.Builder<RelHint> relHints = ImmutableList.builder(); for (SqlNode node : sqlHints) { assert node instanceof SqlHint; final SqlHint sqlHint = (SqlHint) node; final String hintName = sqlHint.getName(); final List<Integer> inheritPath = new ArrayList<>(); RelHint relHint; switch (sqlHint.getOptionFormat()) { case EMPTY: relHint = RelHint.of(inheritPath, hintName); break; case LITERAL_LIST: case ID_LIST: relHint = RelHint.of(inheritPath, hintName, sqlHint.getOptionList()); break; case KV_LIST: relHint = RelHint.of(inheritPath, hintName, sqlHint.getOptionKVPairs()); break; default: throw new AssertionError(\"Unexpected hint option format\"); } if (hintStrategies.validateHint(relHint)) { \/\/ Skips the hint if the validation fails. relHints.add(relHint); } } return relHints.build(); }","old_code_raw":"  public static List<RelHint> getRelHint(HintStrategyTable hintStrategies, SqlNodeList sqlHints) {\n    final List<RelHint> relHints = new ArrayList<>();\n    if (sqlHints == null || sqlHints.size() == 0) {\n      return relHints;\n    }\n    for (SqlNode node : sqlHints) {\n      assert node instanceof SqlHint;\n      final SqlHint sqlHint = (SqlHint) node;\n      final String hintName = sqlHint.getName();\n      final List<Integer> inheritPath = new ArrayList<>();\n      RelHint relHint;\n      switch (sqlHint.getOptionFormat()) {\n      case EMPTY:\n        relHint = RelHint.of(inheritPath, hintName);\n        break;\n      case LITERAL_LIST:\n      case ID_LIST:\n        relHint = RelHint.of(inheritPath, hintName, sqlHint.getOptionList());\n        break;\n      case KV_LIST:\n        relHint = RelHint.of(inheritPath, hintName, sqlHint.getOptionKVPairs());\n        break;\n      default:\n        throw new AssertionError(\"Unexpected hint option format\");\n      }\n      if (hintStrategies.validateHint(relHint)) {\n        \/\/ Skips the hint if the validation fails.\n        relHints.add(relHint);\n      }\n    }\n    return ImmutableList.copyOf(relHints);\n  }\n","new_comment_raw":"@return the  RelHint list","old_comment_raw":"@return the RelHint list","label":0,"pre_label":1,"AST_level":10,"line_counts":33,"new_code_token_num":195},{"new_code_raw":"public Env getApolloEnv() { return EnvUtils.transformEnv(Foundation.server().getEnvType()); }","old_code_raw":"  public Env getApolloEnv() {\n    Env env = EnvUtils.transformEnv(Foundation.server().getEnvType());\n    if (env == null) {\n      String path = isOSWindows() ? \"C:\\\\opt\\\\settings\\\\server.properties\" :\n          \"\/opt\/settings\/server.properties\";\n      String message = String.format(\"env is not set, please make sure it is set in %s!\", path);\n      logger.error(message);\n      throw new ApolloConfigException(message);\n    }\n    return env;\n  }\n","new_comment_raw":"@return the env, UNKNOWN if env is not set or invalid","old_comment_raw":"@return the env","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public boolean hasLoadingCollectionEntries() { return ( collectionLoadContexts != null && !collectionLoadContexts.isEmpty() ); }","old_code_raw":"\tpublic boolean hasLoadingCollectionEntries() {\n\t\treturn ( xrefLoadingCollectionEntries != null && !xrefLoadingCollectionEntries.isEmpty() );\n\t}\n","new_comment_raw":"@return True if we currently hold state pertaining to loading collections; false otherwise.","old_comment_raw":"@return True if we currently hold state pertaining to loading collections; false otherwise.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"private File[] getDirectoryHistory() { return Settings.instance().getDirectoryHistory(); }","old_code_raw":"private File[] getDirectoryHistory() {\n    File[] dirhist = Settings.instance().getDirectoryHistory();\n    if (dirhist == null || dirhist.length == NUM)\n        return new File[] { new File(STR).getAbsoluteFile() };\n    else\n        return dirhist;\n}","new_comment_raw":"@return current directory history. Should never return null.","old_comment_raw":"@return current directory history, or if empty, only current directory (as File[0]).","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public Double getEnumNumber() { if (enumNumber == null) { return null; } return enumNumber.value(); }","old_code_raw":"  public EnumNumberEnum getEnumNumber() {\n    return enumNumber;\n  }\n","new_comment_raw":"@return enumNumber","old_comment_raw":"@return enumNumber","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public char get(WithAttributes withAttributes) { return withAttributes.getAttributes().get(this); }","old_code_raw":"public char get(WithAttributes attributes) {\n    return attributes.getAttributes().get(this);\n}","new_comment_raw":"@return the value of this attribute if this attribute is present in the extracted map. Otherwise {@link #getDefaultValue()}","old_comment_raw":"@return the value of this attribute if this attribute is present in the map. Otherwise {@link #getDefaultValue()}","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":19},{"new_code_raw":"public static InvalidOperationBehavior parse(String value) { if (value == null) { return null; } value = value.trim(); for (InvalidOperationBehavior option : InvalidOperationBehavior.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }","old_code_raw":"        public static InvalidOperationBehavior parse(String value, String defaultValue) {\n            InvalidOperationBehavior mode = parse(value);\n            if (mode == null && defaultValue != null) mode = parse(defaultValue);\n            return mode;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found","old_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":57},{"new_code_raw":"public static String getHost(OpenAPI openAPI, final Map<String, String> userDefinedVariables) { if (openAPI.getServers() != null && openAPI.getServers().size() > 0) { return sanitizeUrl(getServerURL(openAPI.getServers().get(0), userDefinedVariables).toString()); } return LOCAL_HOST; }","old_code_raw":"    public static String getHost(OpenAPI openAPI) {\n        if (openAPI.getServers() != null && openAPI.getServers().size() > 0) {\n            return sanitizeUrl(getServerURL(openAPI.getServers().get(0)).toString());\n        }\n        return LOCAL_HOST;\n    }\n","new_comment_raw":"@return host","old_comment_raw":"@return host","label":0,"pre_label":1,"AST_level":10,"line_counts":7,"new_code_token_num":62},{"new_code_raw":"public Bundle getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) { @Override public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) { \/\/ Post at front of queue ignoring sync barriers to make sure it gets \/\/ processed before the next frame. postAtFrontOfQueueAsynchronously(v.getHandler(), () -> { mAnimator = new AnimatorSet(); setCurrentAnimator(mAnimator); mAnimator.play(getLauncherAnimators(v)); mAnimator.play(getWindowAnimators(v, targets)); mAnimator.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { \/\/ Reset launcher to normal state v.setVisibility(View.VISIBLE); ((ViewGroup) mDragLayer.getParent()).removeView(mFloatingView); mDragLayer.setAlpha(1f); mDragLayer.setTranslationY(0f); View appsView = mLauncher.getAppsView(); appsView.setAlpha(1f); appsView.setTranslationY(0f); finishedCallback.run(); } }); mAnimator.start(); \/\/ Because t=0 has the app icon in its original spot, we can skip the \/\/ first frame and have the same movement one frame earlier. mAnimator.setCurrentPlayTime(REFRESH_RATE_MS); }); } }; return ActivityOptionsCompat.makeRemoteAnimation( new RemoteAnimationAdapterCompat(runner, 500, 380)).toBundle(); } catch (NoClassDefFoundError e) { \/\/ Gracefully fall back to default launch options if the user's platform doesn't \/\/ have the latest changes. } } return getDefaultActivityLaunchOptions(launcher, v); }","old_code_raw":"    public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) {\n        if (hasControlRemoteAppTransitionPermission()) {\n            try {\n                RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mHandler) {\n\n                    @Override\n                    public AnimatorSet getAnimator(RemoteAnimationTargetCompat[] targetCompats) {\n                        AnimatorSet anim = new AnimatorSet();\n\n\n                        if (!composeRecentsLaunchAnimator(v, targetCompats, anim)) {\n                            \/\/ Set the state animation first so that any state listeners are called\n                            \/\/ before our internal listeners.\n                            mLauncher.getStateManager().setCurrentAnimation(anim);\n\n                            anim.play(getIconAnimator(v));\n                            if (launcherIsATargetWithMode(targetCompats, MODE_CLOSING)) {\n                                anim.play(getLauncherContentAnimator(false \/* show *\/));\n                            }\n                            anim.play(getWindowAnimators(v, targetCompats));\n                        }\n                        return anim;\n                    }\n                };\n\n                int duration = findTaskViewToLaunch(launcher, v, null) != null\n                        ? RECENTS_LAUNCH_DURATION : APP_LAUNCH_DURATION;\n                int statusBarTransitionDelay = duration - STATUS_BAR_TRANSITION_DURATION;\n                return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(\n                        runner, duration, statusBarTransitionDelay));\n            } catch (NoClassDefFoundError e) {\n                \/\/ Gracefully fall back to default launch options if the user's platform doesn't\n                \/\/ have the latest changes.\n            }\n        }\n        return getDefaultActivityLaunchOptions(launcher, v);\n    }\n","new_comment_raw":"@return A Bundle with remote animations that controls how the window of the opening targets are displayed.","old_comment_raw":"@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.","label":1,"pre_label":0,"AST_level":19,"line_counts":49,"new_code_token_num":300},{"new_code_raw":"protected Object convertYearToInt(Column column, Field fieldDefn, Object data) { return convertValue(column, fieldDefn, data, 0, (r) -> { Object mutData = data; if (data instanceof java.time.Year) { \/\/ The MySQL binlog always returns a Year object ... r.deliver(adjustYear(((java.time.Year) data).getValue())); } else if (data instanceof java.sql.Date) { \/\/ MySQL JDBC driver sometimes returns a Java SQL Date object ... r.deliver(adjustYear(((java.sql.Date) data).getYear())); } else if (data instanceof String) { mutData = Integer.parseInt((String) data); } if (mutData instanceof Number) { \/\/ MySQL JDBC driver sometimes returns a short ... r.deliver(adjustYear(((Number) mutData).intValue())); } }); }","old_code_raw":"    protected Object convertYearToInt(Column column, Field fieldDefn, Object data) {\n        if (data == null && !fieldDefn.schema().isOptional()) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0;\n        }\n        if (data instanceof java.time.Year) {\n            \/\/ The MySQL binlog always returns a Year object ...\n            return adjustYear(((java.time.Year) data).getValue());\n        }\n        if (data instanceof java.sql.Date) {\n            \/\/ MySQL JDBC driver sometimes returns a Java SQL Date object ...\n            return adjustYear(((java.sql.Date) data).getYear());\n        }\n        if (data instanceof String) {\n            data = Integer.parseInt((String) data);\n        }\n        if (data instanceof Number) {\n            \/\/ MySQL JDBC driver sometimes returns a short ...\n            return adjustYear(((Number) data).intValue());\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":15,"line_counts":21,"new_code_token_num":172},{"new_code_raw":"public Dictionary getProperties() { return m_properties; }","old_code_raw":"public Properties getProperties() {\n    return m_properties;\n}","new_comment_raw":"@return the properties as a Dictionary","old_comment_raw":"@return the property descriptors as a Collection","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public float getY() { if (top == null) { calculateTop(); } return top.floatValue(); }","old_code_raw":"public float getY() {\n    return center[NUM];\n}","new_comment_raw":"@return The y position of the top of this shape.","old_comment_raw":"@return The y location of the center of this circle","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":24},{"new_code_raw":"public static boolean supportsRefCursors(DatabaseMetaData meta) { \/\/ Standard JDBC REF_CURSOR support was not added until Java 8, so we need to use reflection to attempt to \/\/ access these fields\/methods... try { return (Boolean) meta.getClass().getMethod( \"supportsRefCursors\" ).invoke( null ); } catch (NoSuchMethodException e) { log.trace( \"JDBC DatabaseMetaData class does not define supportsRefCursors method...\" ); } catch (Exception e) { log.debug( \"Unexpected error trying to gauge level of JDBC REF_CURSOR support : \" + e.getMessage() ); } return false; }","old_code_raw":"\tpublic static boolean supportsRefCursors(DatabaseMetaData meta) {\n\t\t\/\/ Standard JDBC REF_CURSOR support was not added until Java 8, so we need to use reflection to attempt to\n\t\t\/\/ access these fields\/methods...\n\t\ttry {\n\t\t\treturn ( (Boolean) meta.getClass().getMethod( \"supportsRefCursors\" ).invoke( null ) ).booleanValue();\n\t\t}\n\t\tcatch (NoSuchMethodException e) {\n\t\t\tlog.trace( \"JDBC DatabaseMetaData class does not define supportsRefCursors method...\" );\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.debug( \"Unexpected error trying to gauge level of JDBC REF_CURSOR support : \" + e.getMessage() );\n\t\t}\n\t\treturn false;\n\t}\n","new_comment_raw":"@return  true if the metadata indicates that the driver defines REF_CURSOR support","old_comment_raw":"@return true if the metadata indicates that the driver defines REF_CURSOR support","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":116},{"new_code_raw":"public ResultSetMetaData getMetaData() throws SQLException { try { debugCodeCall(STR); checkClosed(); ResultInterface result = command.getMetaData(); if (result == null) { return null; } int id = getNextId(TraceObject.RESULT_SET_META_DATA); if (debug()) { debugCodeAssign(STR, TraceObject.RESULT_SET_META_DATA, id); debugCodeCall(STR); } JdbcResultSetMetaData meta = new JdbcResultSetMetaData(null, this, result, session.getTrace(), id); return meta; } catch (Throwable e) { throw logAndConvert(e); } }","old_code_raw":"public ResultSetMetaData getMetaData() throws SQLException {\n    try {\n        debugCodeCall(STR);\n        checkClosed();\n        return null;\n    } catch (Throwable e) {\n        throw logAndConvert(e);\n    }\n}","new_comment_raw":"@return the meta data or null if this is not a query","old_comment_raw":"@return null as the method is not supported","label":1,"pre_label":0,"AST_level":8,"line_counts":19,"new_code_token_num":104},{"new_code_raw":"@Deprecated public long getNumBytesUploaded() { return totalBytesServerReceived; }","old_code_raw":"public long getNumBytesUploaded() {\n    return bytesUploaded;\n}","new_comment_raw":"@return the number of bytes the server received so far","old_comment_raw":"@return the number of bytes uploaded","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public static SchemaGenSource interpret(String value) { if ( StringHelper.isEmpty( value ) ) { \/\/ empty is in fact valid as means to interpret default value based on other settings return null; } if ( METADATA.externalName.equals( value ) ) { return METADATA; } else if ( SCRIPT.externalName.equals( value ) ) { return SCRIPT; } else if ( METADATA_THEN_SCRIPT.externalName.equals( value ) ) { return METADATA_THEN_SCRIPT; } else if ( SCRIPT_THEN_METADATA.externalName.equals( value ) ) { return SCRIPT_THEN_METADATA; } throw new IllegalArgumentException( \"Unrecognized schema generation source value : \" + value ); }","old_code_raw":"\tpublic static SchemaGenSource interpret(String value) {\n\t\tif ( StringHelper.isEmpty( value ) ) {\n\t\t\t\/\/ empty is in fact valid as means to interpret default value based on other settings\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( METADATA.externalName.equals( value ) ) {\n\t\t\treturn METADATA;\n\t\t}\n\t\telse if ( SCRIPTS.externalName.equals( value ) ) {\n\t\t\treturn SCRIPTS;\n\t\t}\n\t\telse if ( METADATA_THEN_SCRIPTS.externalName.equals( value ) ) {\n\t\t\treturn METADATA_THEN_SCRIPTS;\n\t\t}\n\t\telse if ( SCRIPTS_THEN_METADATA.externalName.equals( value ) ) {\n\t\t\treturn SCRIPTS_THEN_METADATA;\n\t\t}\n\n\t\tthrow new IllegalArgumentException( \"Unrecognized schema generation source value : \" + value );\n\t}\n","new_comment_raw":"@return The matching enum value. An empty value will return  null.","old_comment_raw":"@return The matching enum value. An empty value will return null.","label":0,"pre_label":1,"AST_level":9,"line_counts":22,"new_code_token_num":115},{"new_code_raw":"public boolean isWifiConnected(Context context) { if (context != null) { ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) { Network[] networks = mConnectivityManager.getAllNetworks(); for (Network network : networks) { NetworkInfo networkInfo = mConnectivityManager.getNetworkInfo(network); if (networkInfo != null && networkInfo.getType() == ConnectivityManager.TYPE_WIFI) return networkInfo.isAvailable() && networkInfo.isConnected(); } } else { @SuppressWarnings(\"deprecation\") NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); return mWiFiNetworkInfo != null && mWiFiNetworkInfo.isAvailable() && mWiFiNetworkInfo.isConnected(); } } return false; }","old_code_raw":"    public boolean isWifiConnected(Context context) {\n        if (context != null) {\n            ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n                Network[] networks = mConnectivityManager.getAllNetworks();\n                for (Network network : networks) {\n                    NetworkInfo networkInfo = mConnectivityManager.getNetworkInfo(network);\n                    if (networkInfo.getType() == ConnectivityManager.TYPE_WIFI)\n                        return networkInfo.isAvailable() && networkInfo.isConnected();\n                }\n            } else {\n                @SuppressWarnings(\"deprecation\")\n                NetworkInfo mWiFiNetworkInfo = mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);\n                if (mWiFiNetworkInfo != null)\n                    return mWiFiNetworkInfo.isAvailable() && mWiFiNetworkInfo.isConnected();\n            }\n        }\n        return false;\n    }\n","new_comment_raw":"@return Open return true, close returns false","old_comment_raw":"@return Open return true, close returns false","label":0,"pre_label":1,"AST_level":12,"line_counts":19,"new_code_token_num":131},{"new_code_raw":"public double getRotX() { return Math.toDegrees(mOrientation.getRotationX()); }","old_code_raw":"public double getRotX() {\n    return mOrientation.getRotationX();\n}","new_comment_raw":"@return double The roll Euler angle in degrees.","old_comment_raw":"@return double The roll Euler angle.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":17},{"new_code_raw":"@Override public void createRecord(DBRecord rec, Connection conn) { throw new NotImplementedException(this, STR); }","old_code_raw":"@Override\npublic boolean createRecord(DBRecord rec, Connection conn) {\n    return error(Errors.NotImplemented, STR);\n}","new_comment_raw":"@return a not implemented error","old_comment_raw":"@return an error, because querys could't add new records to the database","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean highlightNode(ASTGenerator astGenerator){ if(!(Node instanceof SimpleName)){ return false; } SimpleName nodeName = (SimpleName) Node; try { \/\/TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline() int javaLineNumber = getLineNumber(nodeName); int pdeOffs[] = astGenerator.errorCheckerService .calculateTabIndexAndLineNumber(javaLineNumber); PlainDocument javaSource = new PlainDocument(); javaSource.insertString(0, astGenerator.errorCheckerService.sourceCode, null); Element lineElement = javaSource.getDefaultRootElement() .getElement(javaLineNumber-1); if(lineElement == null) { log(lineNumber + \" line element null while highlighting \" + nodeName); return false; } String javaLine = javaSource.getText(lineElement.getStartOffset(), lineElement.getEndOffset() - lineElement.getStartOffset()); astGenerator.editor.getSketch().setCurrentCode(pdeOffs[0]); String pdeLine = astGenerator.editor.getLineText(pdeOffs[1]); String lookingFor = nodeName.toString(); log(lookingFor + \", \" + nodeName.getStartPosition()); log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\" + lineElement.getEndOffset()); log(pdeOffs[1] + \" PL \" + pdeLine); if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) { logE(\"Logical error in highLightNode(). Please file a bug report.\"); return false; } OffsetMatcher ofm = new OffsetMatcher(pdeLine, javaLine); int highlightStart = ofm.getPdeOffForJavaOff(nodeName.getStartPosition() - lineElement.getStartOffset(), nodeName.getLength()); if (highlightStart == -1) { logE(\"Logical error in highLightNode() during offset matching. \" + \"Please file a bug report.\"); return false; } int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]); highlightStart += lso; astGenerator.editor.setSelection(highlightStart, highlightStart + nodeName.getLength()); \/* \/\/ First find the name in the java line, and marks its index Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\"); Matcher matcher = toFind.matcher(javaLine); int count = 0, index = 0; int lsto = lineElement.getStartOffset(); while(matcher.find()){ count++; \/\/log(matcher.start() + lsto); if(lsto + matcher.start() == nodeName.getStartPosition()) break; } log(\"count=\" + count); index = 0; \/\/ find the same name in the pde line by its index and get its offsets matcher = toFind.matcher(pdeLine); while(matcher.find()){ count--; if(count == 0){ log(\"Found on pde line lso: \" + matcher.start()); index = matcher.end(); break; } } log(\"pde lso \" + (index - lookingFor.length())); int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]); astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso + index); *\/ return true; } catch (BadLocationException e) { logE(\"BLE in highLightNode() for \" + nodeName); e.printStackTrace(); } return false; }","old_code_raw":"  public boolean highlightNode(ASTGenerator astGenerator){\n    if(!(Node instanceof SimpleName)){\n      return false; \n    }\n    SimpleName nodeName = (SimpleName) Node;\n    try {\n      \/\/TODO: Redundant code. See ASTGenerator.getJavaSourceCodeline()\n      int javaLineNumber = getLineNumber(nodeName);\n      int pdeOffs[] = astGenerator.errorCheckerService\n          .calculateTabIndexAndLineNumber(javaLineNumber);\n      PlainDocument javaSource = new PlainDocument();\n      javaSource.insertString(0, astGenerator.errorCheckerService.sourceCode, null);\n      Element lineElement = javaSource.getDefaultRootElement()\n          .getElement(javaLineNumber-1);\n      if(lineElement == null) {\n        log(lineNumber + \" line element null while highlighting \" + nodeName);\n        return false;\n      }\n      \n      String javaLine = javaSource.getText(lineElement.getStartOffset(),\n                                           lineElement.getEndOffset()\n                                               - lineElement.getStartOffset());\n      astGenerator.editor.getSketch().setCurrentCode(pdeOffs[0]);\n      String pdeLine = astGenerator.editor.getLineText(pdeOffs[1]);\n      String lookingFor = nodeName.toString();\n      log(lookingFor + \", \" + nodeName.getStartPosition());\n      log(javaLineNumber +\" JL \" + javaLine + \" LSO \" + lineElement.getStartOffset() + \",\"\n          + lineElement.getEndOffset());\n      log(pdeOffs[1] + \" PL \" + pdeLine);\n      if (!javaLine.contains(lookingFor) || !pdeLine.contains(lookingFor)) {\n        logE(\"Logical error in highLightNode(). Please file a bug report.\");\n        return false;\n      }\n      \n      \/\/ First find the name in the java line, and marks its index\n      Pattern toFind = Pattern.compile(\"\\\\b\" + nodeName.toString() + \"\\\\b\");\n      Matcher matcher = toFind.matcher(javaLine);\n      int count = 0, index = 0;\n      int lsto = lineElement.getStartOffset();\n      while(matcher.find()){\n        count++;\n        \/\/log(matcher.start() + lsto);\n        if(lsto + matcher.start() == nodeName.getStartPosition())\n          break;\n      }\n      log(\"count=\" + count);\n      index = 0;\n      \/\/ find the same name in the pde line by its index and get its offsets\n      matcher = toFind.matcher(pdeLine);\n      while(matcher.find()){\n        count--;\n        if(count == 0){\n          log(\"Found on pde line lso: \" + matcher.start());\n          index = matcher.end();\n          break;\n        }\n      }\n      log(\"pde lso \" + (index - lookingFor.length()));\n      \n      int lso = astGenerator.editor.ta.getLineStartOffset(pdeOffs[1]);\n      astGenerator.editor.setSelection(lso + index - lookingFor.length(), lso\n          + index);\n      return true;\n    } catch (BadLocationException e) {\n      logE(\"BLE in highLightNode() for \" + nodeName);\n      e.printStackTrace();\n    }\n    return false;\n  }\n","new_comment_raw":"@return - true if highlighting was successful","old_comment_raw":"@return - true if highlighting was successful","label":0,"pre_label":1,"AST_level":12,"line_counts":85,"new_code_token_num":629},{"new_code_raw":"protected SqlStatementLogger sqlStatementLogger() { return sqlStatementLogger; }","old_code_raw":"\tprotected SqlStatementLogger sqlStatementLogger() {\n\t\treturn jdbcCoordinator.getTransactionCoordinator()\n\t\t\t\t.getTransactionContext()\n\t\t\t\t.getTransactionEnvironment()\n\t\t\t\t.getJdbcServices()\n\t\t\t\t.getSqlStatementLogger();\n\t}\n","new_comment_raw":"@return The underlying JDBC services.","old_comment_raw":"@return The underlying JDBC services.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"protected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException { try { List errors = new ArrayList(); Document document = xmlHelper.createSAXReader( resourceName, errors, entityResolver ) .read( new InputSource( stream ) ); if ( errors.size() != 0 ) { throw new MappingException( \"invalid configuration\", (Throwable) errors.get( 0 ) ); } doConfigure( document ); } catch (DocumentException e) { throw new HibernateException( \"Could not parse configuration: \" + resourceName, e ); } finally { try { stream.close(); } catch (IOException ioe) { log.warn( \"could not close input stream for: \" + resourceName, ioe ); } } return this; }","old_code_raw":"\tprotected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException {\n\n\t\torg.dom4j.Document doc;\n\t\ttry {\n\t\t\tList errors = new ArrayList();\n\t\t\tdoc = xmlHelper.createSAXReader( resourceName, errors, entityResolver )\n\t\t\t\t\t.read( new InputSource( stream ) );\n\t\t\tif ( errors.size() != 0 ) {\n\t\t\t\tthrow new MappingException(\n\t\t\t\t\t\t\"invalid configuration\",\n\t\t\t\t\t\t(Throwable) errors.get( 0 )\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tcatch (DocumentException e) {\n\t\t\tthrow new HibernateException(\n\t\t\t\t\t\"Could not parse configuration: \" + resourceName,\n\t\t\t\t\te\n\t\t\t\t);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tlog.warn( \"could not close input stream for: \" + resourceName, ioe );\n\t\t\t}\n\t\t}\n\n\t\treturn doConfigure( doc );\n\n\t}\n","new_comment_raw":"@return this for method chaining","old_comment_raw":"@return A configuration configured via the stream","label":1,"pre_label":0,"AST_level":10,"line_counts":24,"new_code_token_num":142},{"new_code_raw":"public Observable<Connectivity> observeNetworkConnectivity(final Context context) { final NetworkObservingStrategy strategy; final boolean isAtLeastLollipop = Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP; if (isAtLeastLollipop) { strategy = new LollipopNetworkObservingStrategy(); } else { strategy = new PreLollipopNetworkObservingStrategy(); } return observeNetworkConnectivity(context, strategy); }","old_code_raw":"public Observable<ConnectivityStatus> observeNetworkConnectivity(final Context context) {\n    final IntentFilter filter = new IntentFilter();\n    filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);\n    return Observable.create(new Observable.OnSubscribe<ConnectivityStatus>() {\n\n        @Override\n        public void call(final Subscriber<? super ConnectivityStatus> subscriber) {\n            final BroadcastReceiver receiver = new BroadcastReceiver() {\n\n                @Override\n                public void onReceive(Context context, Intent intent) {\n                    final ConnectivityStatus newStatus = getConnectivityStatus(context);\n                    if (newStatus != status) {\n                        status = newStatus;\n                        subscriber.onNext(newStatus);\n                    }\n                }\n            };\n            context.registerReceiver(receiver, filter);\n            subscriber.add(unsubscribeInUiThread(new Action0() {\n\n                @Override\n                public void call() {\n                    context.unregisterReceiver(receiver);\n                }\n            }));\n        }\n    }).defaultIfEmpty(ConnectivityStatus.OFFLINE);\n}","new_comment_raw":"@return RxJava Observable with Connectivity class containing information about network state, type and name","old_comment_raw":"@return RxJava Observable with ConnectivityStatus","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":54},{"new_code_raw":"private String saveScriptAndForward(String id, String name, String comment, String script, boolean nonAdministerUsing, String originCatalogName, String originId, Parameter[] parameters) throws IOException { script = script == null ? STR : script; if (StringUtils.isEmpty(id)) { throw new IllegalArgumentException(STR); } final String displayName = name == null ? id : name; final String finalFileName = fixFileName(originCatalogName, id); File newScriptFile = new File(getScriptDirectory(), finalFileName); Writer writer = new FileWriter(newScriptFile); writer.write(script); writer.close(); Script newScript = null; if (!StringUtils.isEmpty(originId)) { newScript = new Script(finalFileName, displayName, comment, true, originCatalogName, originId, new SimpleDateFormat(STR).format(new Date()), parameters); } else { newScript = new Script(finalFileName, displayName, comment, nonAdministerUsing, parameters); } ScriptlerConfiguration cfg = getConfiguration(); cfg.addOrReplace(newScript); cfg.save(); return finalFileName; }","old_code_raw":"private String saveScriptAndForward(String name, String comment, String script, boolean nonAdministerUsing, String originCatalogName, String originId, Parameter[] parameters) throws IOException {\n    if (StringUtils.isEmpty(script) || StringUtils.isEmpty(name)) {\n        throw new IllegalArgumentException(STR);\n    }\n    final String finalName = fixFileName(originCatalogName, name);\n    File newScriptFile = new File(getScriptDirectory(), finalName);\n    Writer writer = new FileWriter(newScriptFile);\n    writer.write(script);\n    writer.close();\n    Script newScript = null;\n    if (!StringUtils.isEmpty(originId)) {\n        newScript = new Script(finalName, comment, true, originCatalogName, originId, new SimpleDateFormat(STR).format(new Date()), parameters);\n    } else {\n        newScript = new Script(finalName, comment, nonAdministerUsing, parameters);\n    }\n    ScriptlerConfiguration cfg = getConfiguration();\n    cfg.addOrReplace(newScript);\n    cfg.save();\n    return finalName;\n}","new_comment_raw":"@return the final name of the saved script - which is also the id of the script!","old_comment_raw":"@return the final name of the saved script","label":1,"pre_label":0,"AST_level":11,"line_counts":22,"new_code_token_num":195},{"new_code_raw":"public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException { ApiResponse<OuterComposite> localVarResp = fakeOuterCompositeSerializeWithHttpInfo(body); return localVarResp.getData(); }","old_code_raw":"    public OuterComposite fakeOuterCompositeSerialize(OuterComposite body) throws ApiException {\n        ApiResponse<OuterComposite> resp = fakeOuterCompositeSerializeWithHttpInfo(body);\n        return resp.getData();\n    }\n","new_comment_raw":"@return OuterComposite","old_comment_raw":"@return OuterComposite","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public Timer getTimer(TimerDesc timerDesc) { return getTimer(timerDesc.getName(), timerDesc.getDurationUnit(), timerDesc.getTimeUnit()); }","old_code_raw":"public Timer getTimer(String name) {\n    return getTimer(name, TimeUnit.MILLISECONDS, TimeUnit.SECONDS);\n}","new_comment_raw":"@return new {@link Timer}","old_comment_raw":"@return a new {@link com.yammer.metrics.core.Timer}","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":28},{"new_code_raw":"public List<Pet> findPetsByStatus (List<String> status) throws ApiException { Object postBody = null; \/\/ create path and map variables String path = \"\/pet\/findByStatus\".replaceAll(\"\\\\{format\\\\}\",\"json\"); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); queryParams.addAll(apiClient.parameterToPairs(\"multi\", \"status\", status)); final String[] accepts = { \"application\/json\", \"application\/xml\" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { \"petstore_auth\" }; TypeRef returnType = new TypeRef<List<Pet>>() {}; return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"  public List<Pet> findPetsByStatus (List<String> status) throws ApiException {\n    Object postBody = null;\n    \n\n    \/\/ create path and map variables\n    String path = \"\/pet\/findByStatus\".replaceAll(\"\\\\{format\\\\}\",\"json\");\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, String> formParams = new HashMap<String, String>();\n\n    \n    queryParams.addAll(apiClient.parameterToPairs(\"multi\", \"status\", status));\n    \n\n    \n\n    final String[] accepts = {\n      \"application\/json\", \"application\/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    if(contentType.startsWith(\"multipart\/form-data\")) {\n      boolean hasFields = false;\n      FormDataMultiPart mp = new FormDataMultiPart();\n      \n      if(hasFields)\n        postBody = mp;\n    }\n    else {\n      \n    }\n\n    try {\n      String[] authNames = new String[] { \"petstore_auth\" };\n      String response = apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames);\n      if(response != null){\n        return (List<Pet>) apiClient.deserialize(response, \"array\", Pet.class);\n      }\n      else {\n        return null;\n      }\n    } catch (ApiException ex) {\n      throw ex;\n    }\n  }\n","new_comment_raw":"@return List","old_comment_raw":"@return List","label":0,"pre_label":1,"AST_level":10,"line_counts":37,"new_code_token_num":203},{"new_code_raw":"public Order placeOrder(Order body) throws ApiException { Call call = placeOrderCall(body); Type returnType = new TypeToken<Order>(){}.getType(); return apiClient.execute(call, returnType); }","old_code_raw":"  public Order placeOrder(Order body) throws ApiException {\n    ApiResponse<Order> resp = placeOrderWithHttpInfo(body);\n    return resp.getData();\n  }\n","new_comment_raw":"@return Order","old_comment_raw":"@return Order","label":0,"pre_label":1,"AST_level":8,"line_counts":6,"new_code_token_num":40},{"new_code_raw":"public int getRotation() { Double angle = new Integer(currentRotation).doubleValue() \/ new Integer(Settings.getHandlerRotation()).doubleValue(); angle *= NUM; return angle.intValue(); }","old_code_raw":"public int getRotation() {\n    return this.currentRotation;\n}","new_comment_raw":"@return Value between 0 and 360 degrees","old_comment_raw":"@return Value between 0 and 2000","label":1,"pre_label":0,"AST_level":7,"line_counts":5,"new_code_token_num":40},{"new_code_raw":"public String toString() { return ISOPeriodFormat.getInstance().standard().print(toPeriod()); }","old_code_raw":"    public String toString() {\n        return ISOTimePeriodFormat.getInstance().standard().print(toTimePeriod());\n    }\n","new_comment_raw":"@return the value as an ISO8601 string","old_comment_raw":"@return the value as an ISO8601 string","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public GremlinPipeline add(final Pipe pipe) { this.addPipe(pipe); return this; }","old_code_raw":"public T add(final Pipe pipe) {\n    this.addPipe(pipe);\n    return (T) this;\n}","new_comment_raw":"@return the extended Pipeline","old_comment_raw":"@return the extended FluentPipeline","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public PeriodType withWeeksRemoved() { return withFieldRemoved(2, \"NoWeeks\"); }","old_code_raw":"    public PeriodType withWeeksRemoved() {\n        if (!weeks().isSupported()) {\n            return this;\n        }\n        return MaskedType.mask(this, 1 << 2);\n    }\n","new_comment_raw":"@return a new period type that supports the original set of fields except weeks","old_comment_raw":"@return a new period type that supports the original set of fields except weeks","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public List<TaggedWord> apply(List<? extends HasWord> in) { TestSentence testSentence = new TestSentence(this); return testSentence.tagSentence(in, false); }","old_code_raw":"  public ArrayList<TaggedWord> apply(List<? extends HasWord> in) {\n    TestSentence testSentence = new TestSentence(this);\n    return testSentence.tagSentence(in, false);\n  }\n","new_comment_raw":"@return A Sentence of TaggedWord","old_comment_raw":"@return A Sentence of TaggedWord","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public static BigDecimal getBigDecimal(Boolean data) { return data.booleanValue() ? BigDecimal.ONE : BigDecimal.ZERO; }","old_code_raw":"    public static BigDecimal getBigDecimal(Boolean data) {\n        return data.booleanValue() ? BIGDECIMAL_ONE : BIGDECIMAL_ZERO;\n    }\n","new_comment_raw":"@return bigDecimal 0 or 1","old_comment_raw":"@return bigDecimal 0 or 1","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"public String[] punctuationWords() { return punctWords; }","old_code_raw":"  public String[] punctuationWords() {\n    return frenchPunctWords;\n  }\n","new_comment_raw":"@return The punctuation words","old_comment_raw":"@return The punctuation words","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public AccessType getAccessType() { if (isPublic()) { return AccessType.ACC_PUBLIC; } if (isPrivate()) { return AccessType.ACC_PRIVATE; } if (isProtected()) { return AccessType.ACC_PROTECTED; } return AccessType.ACC_PACKAGE; }","old_code_raw":"public int getAccessType() {\n    if (isPublic()) {\n        return ACC_PUBLIC;\n    }\n    if (isPrivate()) {\n        return ACC_PRIVATE;\n    }\n    if (isProtected()) {\n        return ACC_PROTECTED;\n    }\n    return ACC_PACKAGE;\n}","new_comment_raw":"@return a value of {@link AccessType}.","old_comment_raw":"@return one of {@link #ACC_PRIVATE}, {@link #ACC_PROTECTED}, {@link #ACC_PACKAGE} or {@link #ACC_PUBLIC}.","label":1,"pre_label":0,"AST_level":6,"line_counts":12,"new_code_token_num":47},{"new_code_raw":"public static DateTimeFormatter dateHourMinuteSecondMillis() { return Constants.dhmsl; }","old_code_raw":"    public static DateTimeFormatter dateHourMinuteSecondMillis() {\n        if (dhmsl == null) {\n            dhmsl = new DateTimeFormatterBuilder()\n                .append(date())\n                .append(literalTElement())\n                .append(hourMinuteSecondMillis())\n                .toFormatter();\n        }\n        return dhmsl;\n    }\n","new_comment_raw":"@return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS","old_comment_raw":"@return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSS","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"public Property weekyear() { return new Property(this, getChronology().weekyear()); }","old_code_raw":"    public ReadWritableInstantFieldProperty weekyear() {\n        return new ReadWritableInstantFieldProperty(this, getChronology().weekyear());\n    }\n","new_comment_raw":"@return the year of a week based year property","old_comment_raw":"@return the year of a week based year property","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":21},{"new_code_raw":"private static File findBinary(String... binaryNames) { final String[] paths = System.getenv(\"PATH\").split(File.pathSeparator); for (String binaryName : binaryNames) { for (String path : paths) { File file = new File(path, binaryName); if (file.exists()) { return file; } if (Platform.getCurrent().is(Platform.WINDOWS)) { File exe = new File(path, binaryName + \".exe\"); if (exe.exists()) { return exe; } } } } return null; }","old_code_raw":"  private static File findBinary(String... binaryNames) {\n    final String[] paths = System.getenv(\"PATH\").split(File.pathSeparator);\n    for (String binaryName : binaryNames) {\n      for (String path : paths) {\n        File file = new File(path, binaryName);\n        if (file.exists()) {\n          return file;\n        }\n      }\n    }\n    return null;\n  }\n","new_comment_raw":"@return the first binary found matching that name.","old_comment_raw":"@return the first binary found matching that name.","label":0,"pre_label":1,"AST_level":13,"line_counts":19,"new_code_token_num":111},{"new_code_raw":"@Action(value = STR) public String execute() throws Exception { if (statusMessage == null || statusMessage.trim().length() == NUM) { request.setAttribute(STR, STR); return STR; } SASFHelper helper = SASFStaticHelper.getHelper(request); SocialAuthManager manager = helper.getAuthManager(); AuthProvider provider = null; if (manager != null) { provider = manager.getCurrentAuthProvider(); } if (provider != null) { try { provider.updateStatus(statusMessage); request.setAttribute(STR, STR); return STR; } catch (SocialAuthException e) { request.setAttribute(STR, e.getMessage()); e.printStackTrace(); } } return STR; }","old_code_raw":"@Override\npublic ActionForward execute(final ActionMapping mapping, final ActionForm form, final HttpServletRequest request, final HttpServletResponse response) throws Exception {\n    String statusMsg = request.getParameter(STR);\n    if (statusMsg == null || statusMsg.trim().length() == NUM) {\n        request.setAttribute(STR, STR);\n        return mapping.findForward(STR);\n    }\n    SASFHelper helper = SASFStaticHelper.getHelper(request);\n    SocialAuthManager manager = helper.getAuthManager();\n    AuthProvider provider = null;\n    if (manager != null) {\n        provider = manager.getCurrentAuthProvider();\n    }\n    if (provider != null) {\n        try {\n            provider.updateStatus(statusMsg);\n            request.setAttribute(STR, STR);\n            return mapping.findForward(STR);\n        } catch (SocialAuthException e) {\n            request.setAttribute(STR, e.getMessage());\n            e.printStackTrace();\n        }\n    }\n    return mapping.findForward(STR);\n}","new_comment_raw":"@return String where the action should flow","old_comment_raw":"@return ActionForward where the action should flow","label":1,"pre_label":0,"AST_level":9,"line_counts":24,"new_code_token_num":130},{"new_code_raw":"@Processor @OAuthProtected @OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class) @Paged public PagingDelegate<Change> listChanges(@Optional @Default(STR) final boolean includeDeleted, @Optional @Default(STR) final boolean includeSubscribed, @Optional @Default(STR) final int maxResults, @Optional final Long startChangeId, final PagingConfiguration pagingConfiguration) throws IOException { return new TokenBasedPagingDelegate<Change>() { @Override protected List<Change> doGetPage() throws IOException { ChangeList response = client.changes().list().setIncludeDeleted(includeDeleted).setIncludeSubscribed(includeSubscribed).setMaxResults(maxResults).setPageToken(this.getPageToken()).setStartChangeId(startChangeId).execute(); this.setPageToken(response.getNextPageToken()); return Change.valueOf(response.getItems(), Change.class); } }; }","old_code_raw":"@Processor\n@OAuthProtected\n@OAuthInvalidateAccessTokenOn(exception = OAuthTokenExpiredException.class)\n@Inject\npublic List<Change> listChanges(MuleMessage message, @Optional @Default(STR) boolean includeDeleted, @Optional @Default(STR) boolean includeSubscribed, @Optional @Default(STR) int maxResults, @Optional @Default(STR) String pageToken, @Optional Long startChangeId) throws IOException {\n    ChangeList response = this.client.changes().list().setIncludeDeleted(includeDeleted).setIncludeSubscribed(includeSubscribed).setMaxResults(maxResults).setPageToken(pageToken).setStartChangeId(startChangeId).execute();\n    PaginationUtils.savePageToken(NEXT_PAGE_TOKEN, response.getNextPageToken(), message);\n    return Change.valueOf(response.getItems(), Change.class);\n}","new_comment_raw":"@return a paginated iterator with instances of {@link org.mule.module.google.drive.model.File}","old_comment_raw":"@return a list with instance of {@link org.mule.module.google.drive.model.Change}","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":144},{"new_code_raw":"public static Builder newExecutionInput(String query) { return new Builder().query(query); }","old_code_raw":"    public static Builder newExecutionInput() {\n        return new Builder();\n    }\n","new_comment_raw":"@return a new builder of ExecutionInput objects","old_comment_raw":"@return a new builder of ExecutionInput objects","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public synchronized IConfigurationElement[] getContainerExtensions(String containerid, String[] containerPaths) { if (extensions == null) processProxyExtensionExtensionPoint(); return (IConfigurationElement[]) extensions.containerPathContributions.getContributors(containerid, containerPaths); }","old_code_raw":"public synchronized IConfigurationElement[] getContainerExtensions(String containerid) {\n    if (containerToExtensions == null)\n        processProxyExtensionExtensionPoint();\n    return (IConfigurationElement[]) containerToExtensions.get(containerid);\n}","new_comment_raw":"@return Array of configuration elements.","old_comment_raw":"@return Array of extension registration elements or <code>null<\/code> if this container has no contributions.","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":41},{"new_code_raw":"public boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) { return searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible); }","old_code_raw":"\tpublic boolean searchButton(String text, int minimumNumberOfMatches, boolean onlyVisible) {\n\t\tboolean found = searcher.searchWithTimeoutFor(Button.class, text, minimumNumberOfMatches, true, onlyVisible);\n\t\treturn found;\n\t}\n","new_comment_raw":"@return  true if a  Button with the given text is found a given number of times and  false if it is not found","old_comment_raw":"@return true if a Button with the given text is found a given number of times and false if it is not found","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public boolean dependsOn(Collection<AddOn> addOns) { if (dependencies == null || dependencies.getAddOns().isEmpty()) { return false; } for (AddOn addOn : addOns) { if (dependsOn(addOn)) { return true; } } return false; }","old_code_raw":"public boolean dependsOn(AddOn addOn) {\n    if (dependencies == null || dependencies.getAddOns().isEmpty()) {\n        return false;\n    }\n    return dependsOn(dependencies.getAddOns(), addOn);\n}","new_comment_raw":"@return {@code true} if it depends on any of the given add-ons, {@code false} otherwise.","old_comment_raw":"@return {@code true} if it depends on the given add-on, {@code false} otherwise.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":53},{"new_code_raw":"public static GrammaticalRelation valueOf(Object o) { if (o instanceof GrammaticalRelation) { return (GrammaticalRelation) o; } else if (o instanceof String) { return valueOf((String) o); } else { return null; } }","old_code_raw":"  public static GrammaticalRelation valueOf(Object o) {\n    if (o instanceof GrammaticalRelation) {\n      return (GrammaticalRelation) o;\n    } else if (o instanceof Class) {\n      try {\n        return getRelation((Class<? extends GrammaticalRelationAnnotation>) o);\n      } catch (Exception e) {\n        return null;\n      }\n    } else if (o instanceof String) {\n      return valueOf((String) o);\n    } else {\n      return null;\n    }\n  }\n","new_comment_raw":"@return The EnglishGrammaticalRelation with that name","old_comment_raw":"@return The EnglishGrammaticalRelation with that name","label":0,"pre_label":1,"AST_level":9,"line_counts":10,"new_code_token_num":48},{"new_code_raw":"public static boolean deleteDir(File dir) { if (dir.isDirectory()) { String[] children = dir.list(); if (children == null) { return false; } for (String aChildren : children) { boolean success = deleteDir(new File(dir, aChildren)); if (!success) { return false; } } } return dir.delete(); }","old_code_raw":"  public static boolean deleteDir(File dir) {\n    if (dir.isDirectory()) {\n      String[] children = dir.list();\n      for (String aChildren : children) {\n        boolean success = deleteDir(new File(dir, aChildren));\n        if (!success)\n          return false;\n      }\n    }\n\n    return dir.delete();\n  }\n","new_comment_raw":"@return true on success; false, otherwise.","old_comment_raw":"@return true on success; false, otherwise.","label":0,"pre_label":1,"AST_level":11,"line_counts":17,"new_code_token_num":76},{"new_code_raw":"@Deprecated public Object getField() { return getValue(); }","old_code_raw":"public Object getField() {\n    return field;\n}","new_comment_raw":"@return the value for this accumulator","old_comment_raw":"@return the field for this accumulator","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public static Builder create() { return new Builder() { private Properties props = new Properties(); @Override public Builder with(String key, String value) { props.setProperty(key, value); return this; } @Override public Builder withDefault(String key, String value) { if (!props.containsKey(key)) { props.setProperty(key, value); } return this; } @Override public Builder apply(Consumer<Builder> function) { function.accept(this); return this; } @Override public JdbcConfiguration build() { return JdbcConfiguration.adapt(Configuration.from(props)); } @Override public String toString() { return props.toString(); } }; }","old_code_raw":"    public static Builder create() {\n        return new Builder() {\n            private Properties props = new Properties();\n\n            @Override\n            public Builder with(String key, String value) {\n                props.setProperty(key, value);\n                return this;\n            }\n\n            @Override\n            public JdbcConfiguration build() {\n                return JdbcConfiguration.adapt(Configuration.from(props));\n            }\n\n            @Override\n            public String toString() {\n                return props.toString();\n            }\n        };\n    }\n","new_comment_raw":"@return the configuration builder","old_comment_raw":"@return the configuration builder","label":0,"pre_label":1,"AST_level":10,"line_counts":36,"new_code_token_num":141},{"new_code_raw":"public String getAuthorizationUrl(Map<String, String> additionalParams) { return createAuthorizationUrlBuilder() .additionalParams(additionalParams) .build(); }","old_code_raw":"    public String getAuthorizationUrl(String state, Map<String, String> additionalParams, PKCE pkce) {\n        return createAuthorizationUrlBuilder()\n                .state(state)\n                .additionalParams(additionalParams)\n                .pkce(pkce)\n                .build();\n    }\n","new_comment_raw":"@return the URL where you should redirect your users","old_comment_raw":"@return url","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":24},{"new_code_raw":"protected Object defaultValue(Field field) throws IOException { JsonNode defaultJsonValue = field.defaultValue(); if (defaultJsonValue == null) { throw new AvroRuntimeException(\"Field \" + field + \" not set and has no default value\"); } if (defaultJsonValue.isNull() && (field.schema().getType() == Type.NULL || (field.schema().getType() == Type.UNION && field.schema().getTypes().get(0).getType() == Type.NULL))) { return null; } \/\/ Get the default value Object defaultValue = null; \/\/ First try to get the default value from cache: ConcurrentMap<Integer, Object> defaultSchemaValues = DEFAULT_VALUE_CACHE.get(schema.getFullName()); if (defaultSchemaValues == null) { DEFAULT_VALUE_CACHE.putIfAbsent(schema.getFullName(), new ConcurrentHashMap<Integer, Object>(fields.length)); defaultSchemaValues = DEFAULT_VALUE_CACHE.get(schema.getFullName()); } defaultValue = defaultSchemaValues.get(field.pos()); \/\/ If not cached, get the default Java value by encoding the default JSON \/\/ value and then decoding it: if (defaultValue == null) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); encoder = EncoderFactory.get().binaryEncoder(baos, encoder); ResolvingGrammarGenerator.encode( encoder, field.schema(), defaultJsonValue); encoder.flush(); decoder = DecoderFactory.get().binaryDecoder( baos.toByteArray(), decoder); defaultValue = data.createDatumReader( field.schema()).read(null, decoder); defaultSchemaValues.putIfAbsent(field.pos(), defaultValue); } \/\/ Make a deep copy of the default value so that subsequent mutations \/\/ will not affect the default value cache: return data.deepCopy(field.schema(), defaultValue); }","old_code_raw":"  protected Object defaultValue(Field field) throws IOException {    \n    if (field.schema().getType() == Type.NULL) {\n      return null;\n    }\n    \n    JsonNode defaultJsonValue = field.defaultValue();\n    if (defaultJsonValue == null) {\n      return null;\n    }\n    \n    \/\/ Get the default value\n    Object defaultValue = null;\n    \n    \/\/ First try to get the default value from cache:\n    ConcurrentMap<Integer, Object> defaultSchemaValues = \n      DEFAULT_VALUE_CACHE.get(schema.getFullName());\n    if (defaultSchemaValues == null) {\n      DEFAULT_VALUE_CACHE.putIfAbsent(schema.getFullName(), \n          new ConcurrentHashMap<Integer, Object>(fields.length));\n      defaultSchemaValues = DEFAULT_VALUE_CACHE.get(schema.getFullName());\n    }\n    defaultValue = defaultSchemaValues.get(field.pos());\n    \n    \/\/ If not cached, get the default Java value by encoding the default JSON\n    \/\/ value and then decoding it:\n    if (defaultValue == null) {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      encoder = EncoderFactory.get().binaryEncoder(baos, encoder);\n      ResolvingGrammarGenerator.encode(\n          encoder, field.schema(), defaultJsonValue);\n      encoder.flush();\n      decoder = DecoderFactory.get().binaryDecoder(\n          baos.toByteArray(), decoder);\n      defaultValue = data.createDatumReader(\n          field.schema()).read(null, decoder);\n      defaultSchemaValues.putIfAbsent(field.pos(), defaultValue);\n    }\n    \n    \/\/ Make a deep copy of the default value so that subsequent mutations \n    \/\/ will not affect the default value cache:\n    return data.deepCopy(field.schema(), defaultValue);\n  }\n","new_comment_raw":"@return the default value associated with the given field, or null if none is specified in the schema.","old_comment_raw":"@return the default value associated with the given field, or null if none is specified in the schema.","label":0,"pre_label":1,"AST_level":10,"line_counts":45,"new_code_token_num":330},{"new_code_raw":"public BrowserLauncher getBrowserLauncher(String browser, String sessionId) { if (browser == null) throw new IllegalArgumentException(\"browser may not be null\"); for (Iterator<String> iterator = supportedBrowsers.keySet().iterator(); iterator.hasNext();) { String name = iterator.next(); Class<? extends BrowserLauncher> c = supportedBrowsers.get(name); Pattern pat = Pattern.compile(\"^\\\\*\" + name + \"( .*)?$\"); Matcher mat = pat.matcher(browser); if (mat.find()) { String browserStartCommand; if (browser.equals(\"*\" + name)) { browserStartCommand = null; } else { browserStartCommand = mat.group(1).substring(1); } return createBrowserLauncher(c, browserStartCommand, sessionId); } } Matcher CustomMatcher = CUSTOM_PATTERN.matcher(browser); if (CustomMatcher.find()) { String browserStartCommand = CustomMatcher.group(1); if (browserStartCommand == null) { throw new RuntimeException(\"You must specify the path to an executable when using *custom!\\n\\n\"); } browserStartCommand = browserStartCommand.substring(1); return new DestroyableRuntimeExecutingBrowserLauncher(browserStartCommand, sessionId); } throw browserNotSupported(browser); }","old_code_raw":"    public BrowserLauncher getBrowserLauncher(String browser, String sessionId, CommandQueue queue) {\n        if (browser == null) throw new IllegalArgumentException(\"browser may not be null\");\n\n        for (Iterator<String> iterator = supportedBrowsers.keySet().iterator(); iterator.hasNext();) {\n            String name = iterator.next();\n            Class<? extends BrowserLauncher> c = supportedBrowsers.get(name);\n            Pattern pat = Pattern.compile(\"^\\\\*\" + name + \"( .*)?$\");\n            Matcher mat = pat.matcher(browser);\n            if (mat.find()) {\n                String browserStartCommand;\n                if (browser.equals(\"*\" + name)) {\n                    browserStartCommand = null;\n                } else {\n                    browserStartCommand = mat.group(1).substring(1);\n                }\n                return createBrowserLauncher(c, browserStartCommand, sessionId, queue);\n            }\n        }\n        Matcher CustomMatcher = CUSTOM_PATTERN.matcher(browser);\n        if (CustomMatcher.find()) {\n            String browserStartCommand = CustomMatcher.group(1);\n            if (browserStartCommand == null) {\n                throw new RuntimeException(\"You must specify the path to an executable when using *custom!\\n\\n\");\n            }\n            browserStartCommand = browserStartCommand.substring(1);\n            return new DestroyableRuntimeExecutingBrowserLauncher(browserStartCommand, sessionId);\n        }\n        throw browserNotSupported(browser);\n    }\n","new_comment_raw":"@return the BrowserLauncher ready to launch","old_comment_raw":"@return the BrowserLauncher ready to launch","label":0,"pre_label":1,"AST_level":13,"line_counts":30,"new_code_token_num":232},{"new_code_raw":"public final Entity getEntity() { return entity; }","old_code_raw":"public final BranchingInputStream getEntity() {\n    return entity;\n}","new_comment_raw":"@return The entity.","old_comment_raw":"@return The entity as an input stream.","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public int yylex() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { if (DBG) System.err.printf(\"Accepting |%s|%n\", yytext()); return ACCEPT; } case 4: break; case 2: { return IGNORE; } case 5: break; case 3: { if (DBG) System.err.printf(\"Ignoring |%s|%n\", yytext()); return IGNORE; } case 6: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; return YYEOF; } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public int yylex() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { if (DBG) System.err.printf(\"Accepting |%s|, staying in YYINITIAL%n\", yytext());\n                          return ACCEPT;\n          }\n        case 19: break;\n        case 2: \n          { return IGNORE;\n          }\n        case 20: break;\n        case 3: \n          { reportError(yytext());\n          }\n        case 21: break;\n        case 4: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, staying in YYINITIAL%n\", yytext());\n                          return IGNORE;\n          }\n        case 22: break;\n        case 5: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to DATETIME%n\", yytext());\n                          yybegin(DATETIME); return IGNORE;\n          }\n        case 23: break;\n        case 6: \n          { yybegin(DATEINHEADER); return IGNORE;\n          }\n        case 24: break;\n        case 7: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to DOCNO%n\", yytext());\n                          yybegin(DOCNO); return IGNORE;\n          }\n        case 25: break;\n        case 8: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to SRCID%n\", yytext());\n                          yybegin(SRCID); return IGNORE;\n          }\n        case 26: break;\n        case 9: \n          { \/\/System.err.println(\"Transitioning to YYINITIAL\");\n                   yybegin(YYINITIAL); return IGNORE;\n          }\n        case 27: break;\n        case 10: \n          { yybegin(HEADER); return IGNORE;\n          }\n        case 28: break;\n        case 11: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to HEADER%n\", yytext());\n                          yybegin(HEADER); return IGNORE;\n          }\n        case 29: break;\n        case 12: \n          { \/\/ System.err.println(\"Transitioning to YYINITIAL\");\n                  yybegin(YYINITIAL); return IGNORE;\n          }\n        case 30: break;\n        case 13: \n          { \/\/System.err.println(\"In SRCID; Transitioning to YYINITIAL\");\n                yybegin(YYINITIAL); return IGNORE;\n          }\n        case 31: break;\n        case 14: \n          { \/\/System.err.println(\"Transitioning to YYINITIAL\");\n                yybegin(YYINITIAL); return IGNORE;\n          }\n        case 32: break;\n        case 15: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to DOCTYPE%n\", yytext());\n                          yybegin(DOCTYPE); return IGNORE;\n          }\n        case 33: break;\n        case 16: \n          { if (DBG) System.err.printf(\"Ignoring |%s|, moving to PREAMBLE%n\", yytext());\n                          yybegin(PREAMBLE); return IGNORE;\n          }\n        case 34: break;\n        case 17: \n          { \/\/System.err.println(\"Transitioning to YYINITIAL\");\n                  yybegin(YYINITIAL); return IGNORE;\n          }\n        case 35: break;\n        case 18: \n          { yybegin(YYINITIAL); return IGNORE;\n          }\n        case 36: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n            return YYEOF;\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":102,"new_code_token_num":415},{"new_code_raw":"public SessionFactory buildSessionFactory() throws HibernateException { log.debug( \"Preparing to build session factory with filters : \" + filterDefinitions ); secondPassCompile(); if ( ! metadataSourceQueue.isEmpty() ) { log.warn( \"mapping metadata cache was not completely processed\" ); } enableLegacyHibernateValidator(); enableBeanValidation(); enableHibernateSearch(); validate(); Environment.verifyProperties( properties ); Properties copy = new Properties(); copy.putAll( properties ); ConfigurationHelper.resolvePlaceHolders( copy ); Settings settings = buildSettings( copy ); return new SessionFactoryImpl( this, mapping, settings, getInitializedEventListeners(), sessionFactoryObserver ); }","old_code_raw":"\tpublic SessionFactory buildSessionFactory(ServicesRegistry serviceRegistry) throws HibernateException {\n\t\tlog.debug( \"Preparing to build session factory with filters : \" + filterDefinitions );\n\n\t\tsecondPassCompile();\n\t\tif ( ! metadataSourceQueue.isEmpty() ) {\n\t\t\tlog.warn( \"mapping metadata cache was not completely processed\" );\n\t\t}\n\n\t\tenableLegacyHibernateValidator();\n\t\tenableBeanValidation();\n\t\tenableHibernateSearch();\n\n\t\tvalidate();\n\t\tEnvironment.verifyProperties( properties );\n\t\tProperties copy = new Properties();\n\t\tcopy.putAll( properties );\n\t\tConfigurationHelper.resolvePlaceHolders( copy );\n\t\tSettings settings = buildSettings( copy, serviceRegistry.getService( JdbcServices.class ) );\n\n\t\treturn new SessionFactoryImpl(\n\t\t\t\tthis,\n\t\t\t\tmapping,\n\t\t\t\tserviceRegistry,\n\t\t\t\tsettings,\n\t\t\t\tgetInitializedEventListeners(),\n\t\t\t\tsessionFactoryObserver\n\t\t\t);\n\t}\n","new_comment_raw":"@return The build  SessionFactory","old_comment_raw":"@return The build SessionFactory","label":0,"pre_label":1,"AST_level":7,"line_counts":28,"new_code_token_num":119},{"new_code_raw":"private ConnectionJDBC getConnection() throws SQLException { return (ConnectionJDBC) statement.getConnection(); }","old_code_raw":"private ConnectionJDBC2 getConnection() throws SQLException {\n    return (ConnectionJDBC2) statement.getConnection();\n}","new_comment_raw":"@return {@link ConnectionJDBC} object.","old_comment_raw":"@return {@link ConnectionJDBC2} object.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"public Method getWriteMethod(String name) { return writeMethods.get(name); }","old_code_raw":"    public Method getWriteMethod(String name) {\n        return (Method) writeMethods.get(name);\n    }\n","new_comment_raw":"@return the mutator method for the property, or null","old_comment_raw":"@return the mutator method for the property, or null","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"private ZapTextField getTxtProxyIp() { if (txtProxyIp == null) { txtProxyIp = new ZapTextField(); txtProxyIp.setText(\"\"); } return txtProxyIp; }","old_code_raw":"\tprivate JTextField getTxtProxyIp() {\n\t\tif (txtProxyIp == null) {\n\t\t\ttxtProxyIp = new JTextField();\n\t\t\ttxtProxyIp.setText(\"\");\n\t\t}\n\t\treturn txtProxyIp;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":30},{"new_code_raw":"public DurationType getDurationType(Object object) { return DurationType.getMillisType(); }","old_code_raw":"    public DurationType getDurationType(Object object) {\n        return DurationType.getAverageYearMonthType();\n    }\n","new_comment_raw":"@return the duration type, never null","old_comment_raw":"@return the duration type, never null","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public static String getEventTypeFromMI(MIBreakpoint miBreakpoint) { if (miBreakpoint.getWhat().equals(STR)) { return EventBreakpoint.CATCH; } else if (miBreakpoint.getWhat().equals(STR)) { return EventBreakpoint.THROW; } return null; }","old_code_raw":"public static String getEventTypeFromMI(MIBreakpoint miBreakpoint) {\n    if (miBreakpoint.getWhat().equals(STR)) {\n        return Catchpoint.CATCH;\n    } else if (miBreakpoint.getWhat().equals(STR)) {\n        return Catchpoint.THROW;\n    }\n    return null;\n}","new_comment_raw":"@return null if unknown type, null cannot be used to create valid EventBreakpoint","old_comment_raw":"@return null if unknown type, null cannot be used to create valid Catchpoint","label":1,"pre_label":0,"AST_level":7,"line_counts":8,"new_code_token_num":48},{"new_code_raw":"public Level getLevel(String logType) { return prefs.get(logType) == null ? Level.OFF : prefs.get(logType); }","old_code_raw":"  public Level getLevel(String logType) {\n    return prefs.get(logType);\n  }\n","new_comment_raw":"@return the  Level for the given  LogType if enabled. Otherwise returns  Level.OFF.","old_comment_raw":"@return the Level for the given LogType if enabled. Otherwise returns NULL.","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"public static final String makeFilename(String input) { if (input == null) return null; if (input.equals(STR)) return STR; if (input.equals(STR)) return STR; return input.replaceAll(STR, STR).toLowerCase(); }","old_code_raw":"public static final String makeFilename(String input) {\n    return input.replaceAll(STR, STR);\n}","new_comment_raw":"@return input value without any characters that might not be allowed for a filename converted to lowercase","old_comment_raw":"@return input value without any characters that might not be allowed for a filename","label":1,"pre_label":0,"AST_level":5,"line_counts":9,"new_code_token_num":53},{"new_code_raw":"public String toVarName(String name) { if (reservedWords.contains(name)) { return escapeReservedWord(name); } else if (((CharSequence) name).chars().anyMatch(character -> specialCharReplacements.keySet().contains( \"\" + ((char) character)))) { return escapeSpecialCharacters(name, null, null); } else { return name; } }","old_code_raw":"    public String toVarName(String name) {\n        if (reservedWords.contains(name)) {\n            return escapeReservedWord(name);\n        } else {\n            return name;\n        }\n    }\n","new_comment_raw":"@return the sanitized variable name","old_comment_raw":"@return the sanitized variable name","label":0,"pre_label":1,"AST_level":8,"line_counts":10,"new_code_token_num":77},{"new_code_raw":"protected EngineParameterMetaData getParameterMetaData() throws SQLException { if (stmtPmeta != null) return stmtPmeta; stmtPmeta = ((EnginePreparedStatement) ps).getEmbedParameterSetMetaData(); return stmtPmeta; }","old_code_raw":"protected EmbedParameterSetMetaData getParameterMetaData() throws SQLException {\n    if (stmtPmeta != null)\n        return stmtPmeta;\n    EmbedParameterSetMetaData pmeta = null;\n    Class[] getParameterMetaDataParam = {};\n    try {\n        Method sh = getPreparedStatement().getClass().getMethod(STR, getParameterMetaDataParam);\n        pmeta = (EmbedParameterSetMetaData) sh.invoke(getPreparedStatement(), null);\n        stmtPmeta = pmeta;\n    } catch (Exception e) {\n        handleReflectionException(e);\n    }\n    return stmtPmeta;\n}","new_comment_raw":"@return EngineParameterMetaData for the prepared statement. Note: there is no separate BrokeredParameterSetMetaData.","old_comment_raw":"@return EmbedParameterSetMetaData for the prepared statement. Note: there is no separate BrokeredParameterSetMetaData.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":32},{"new_code_raw":"public static boolean removeWorkspaceOrFolderItem(Launcher launcher, ItemInfo item, View view) { if (item instanceof ShortcutInfo) { LauncherModel.deleteItemFromDatabase(launcher, item); } else if (item instanceof FolderInfo) { FolderInfo folder = (FolderInfo) item; launcher.removeFolder(folder); LauncherModel.deleteFolderContentsFromDatabase(launcher, folder); } else if (item instanceof LauncherAppWidgetInfo) { final LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) item; \/\/ Remove the widget from the workspace launcher.removeAppWidget(widget); LauncherModel.deleteItemFromDatabase(launcher, widget); final LauncherAppWidgetHost appWidgetHost = launcher.getAppWidgetHost(); if (appWidgetHost != null && !widget.isCustomWidget() && widget.isWidgetIdValid()) { \/\/ Deleting an app widget ID is a void call but writes to disk before returning \/\/ to the caller... new AsyncTask<Void, Void, Void>() { public Void doInBackground(Void ... args) { appWidgetHost.deleteAppWidgetId(widget.appWidgetId); return null; } }.executeOnExecutor(Utilities.THREAD_POOL_EXECUTOR); } } else { return false; } if (view != null) { launcher.getWorkspace().removeWorkspaceItem(view); launcher.getWorkspace().stripEmptyScreens(); } return true; }","old_code_raw":"    public static boolean removeWorkspaceOrFolderItem(Launcher launcher, ItemInfo item, View view) {\n        \/\/ Remove the item from launcher and the db, we can ignore the containerInfo in this call\n        \/\/ because we already remove the drag view from the folder (if the drag originated from\n        \/\/ a folder) in Folder.beginDrag()\n        launcher.removeItem(view, null, item, true \/* deleteFromDb *\/);\n        launcher.getWorkspace().stripEmptyScreens();\n        return true;\n    }\n","new_comment_raw":"@return true if the item was removed.","old_comment_raw":"@return true if the item was removed.","label":0,"pre_label":1,"AST_level":14,"line_counts":38,"new_code_token_num":222},{"new_code_raw":"protected final Map<K, V> copyMap(Map<K, Expirable<V>> map) { ClassLoader classLoader = cacheManager.getClassLoader(); return map.entrySet().stream().collect(toMap(entry -> copier.copy(entry.getKey(), classLoader), entry -> copier.copy(entry.getValue().get(), classLoader))); }","old_code_raw":"protected final Map<K, V> copyMap(Map<K, Expirable<V>> map) {\n    ClassLoader classLoader = cacheManager.getClassLoader();\n    return map.entrySet().stream().collect(Collectors.toMap(entry -> copier.copy(entry.getKey(), classLoader), entry -> copier.copy(entry.getValue().get(), classLoader)));\n}","new_comment_raw":"@return a deep or shallow copy of the mappings depending on the store by value setting","old_comment_raw":"@return a copy of the mappings if storing by value or the same instance if by reference","label":1,"pre_label":0,"AST_level":10,"line_counts":4,"new_code_token_num":67},{"new_code_raw":"public boolean equals(Object obj) { if (this == obj) { return true; } else if (obj instanceof UnsupportedDurationField) { UnsupportedDurationField other = (UnsupportedDurationField) obj; if (other.getName() == null) { return (getName() == null); } return (other.getName().equals(getName())); } return false; }","old_code_raw":"    public boolean equals(Object obj) {\n        if (obj instanceof UnsupportedDurationField) {\n            return (((UnsupportedDurationField) obj).getName().equals(getName()));\n        }\n        return false;\n    }\n","new_comment_raw":"@return true if equal","old_comment_raw":"@return true if equal","label":0,"pre_label":1,"AST_level":10,"line_counts":13,"new_code_token_num":70},{"new_code_raw":"static public IStructuredTextExpert getExpert(String type, StructuredTextEnvironment environment) { IStructuredTextExpert expert; if (environment == null) environment = StructuredTextEnvironment.DEFAULT; synchronized (sharedExperts) { Map experts = (Map) sharedExperts.get(type); if (experts == null) { experts = new HashMap(); sharedExperts.put(type, experts); } expert = (IStructuredTextExpert) experts.get(environment); if (expert == null) { StructuredTextTypeHandler handler = StructuredTextTypeHandlerFactory.getHandler(type); if (handler == null) throw new IllegalArgumentException(STR); expert = new StructuredTextImpl(handler, environment, false); experts.put(type, expert); } } return expert; }","old_code_raw":"static public ISTextExpert getExpert(String type, STextEnvironment environment) {\n    ISTextExpert expert;\n    if (environment == null)\n        environment = STextEnvironment.DEFAULT;\n    synchronized (sharedExperts) {\n        Map experts = (Map) sharedExperts.get(type);\n        if (experts == null) {\n            experts = new HashMap();\n            sharedExperts.put(type, experts);\n        }\n        expert = (ISTextExpert) experts.get(environment);\n        if (expert == null) {\n            STextTypeHandler handler = STextTypeHandlerFactory.getHandler(type);\n            if (handler == null)\n                throw new IllegalArgumentException(STR);\n            expert = new STextImpl(handler, environment, false);\n            experts.put(type, expert);\n        }\n    }\n    return expert;\n}","new_comment_raw":"@return the IStructuredTextExpert instance.","old_comment_raw":"@return the ISTextExpert instance.","label":1,"pre_label":0,"AST_level":9,"line_counts":21,"new_code_token_num":122},{"new_code_raw":"protected SqlSelect createSourceSelectForDelete(SqlDelete call) { final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO); selectList.add(SqlIdentifier.star(SqlParserPos.ZERO)); SqlNode sourceTable = call.getTargetTable(); if (call.getAlias() != null) { sourceTable = SqlValidatorUtil.addAlias( sourceTable, call.getAlias().getSimple()); } return new SqlSelect(SqlParserPos.ZERO, null, selectList, sourceTable, call.getCondition(), null, null, null, null, null, null, null); }","old_code_raw":"  protected SqlSelect createSourceSelectForDelete(SqlDelete call) {\n    final SqlNodeList selectList = new SqlNodeList(SqlParserPos.ZERO);\n    selectList.add(SqlIdentifier.star(SqlParserPos.ZERO));\n    SqlNode sourceTable = call.getTargetTable();\n    if (call.getAlias() != null) {\n      sourceTable =\n          SqlValidatorUtil.addAlias(\n              sourceTable,\n              call.getAlias().getSimple());\n    }\n    return new SqlSelect(SqlParserPos.ZERO, null, selectList, sourceTable,\n        call.getCondition(), null, null, null, null, null, null);\n  }\n","new_comment_raw":"@return select statement","old_comment_raw":"@return select statement","label":0,"pre_label":1,"AST_level":9,"line_counts":14,"new_code_token_num":96},{"new_code_raw":"public Actions release(WebElement target) { if (isBuildingActions()) { action.addAction(new ButtonReleaseAction(jsonMouse, (Locatable) target)); } return moveInTicks(target, 0, 0).tick(defaultMouse.createPointerUp(LEFT.asArg())); }","old_code_raw":"  public Actions release(WebElement target) {\n    if (isBuildingActions()) {\n      action.addAction(new ButtonReleaseAction(jsonMouse, (Locatable) target));\n      return this;\n    }\n    return moveToElement(target).release();\n  }\n","new_comment_raw":"@return A self reference.","old_comment_raw":"@return A self reference.","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":53},{"new_code_raw":"public T setMinDecodeIntervalMs(int intervalMs) { mMinDecodeIntervalMs = intervalMs; return getThis(); }","old_code_raw":"  public ImageDecodeOptionsBuilder setMinDecodeIntervalMs(int intervalMs) {\n    mMinDecodeIntervalMs = intervalMs;\n    return this;\n  }\n","new_comment_raw":"@return this builder","old_comment_raw":"@return this builder","label":0,"pre_label":1,"AST_level":5,"line_counts":5,"new_code_token_num":17},{"new_code_raw":"public long getId() { return id; }","old_code_raw":"  public int getId() {\n    return id;\n  }\n","new_comment_raw":"@return integer id","old_comment_raw":"@return integer id","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"private ZapTextField getTxtFind() { if (txtFind == null) { txtFind = new ZapTextField(); txtFind.setMinimumSize(new java.awt.Dimension(120,24)); txtFind.setPreferredSize(new java.awt.Dimension(120,24)); } return txtFind; }","old_code_raw":"\tprivate JTextField getTxtFind() {\n\t\tif (txtFind == null) {\n\t\t\ttxtFind = new JTextField();\n\t\t\ttxtFind.setMinimumSize(new java.awt.Dimension(120,24));\n\t\t\ttxtFind.setPreferredSize(new java.awt.Dimension(120,24));\n\t\t}\n\t\treturn txtFind;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":10,"line_counts":9,"new_code_token_num":51},{"new_code_raw":"public static fb_status findByValue(int value) { switch (value) { case 0: return DEAD; case 1: return STARTING; case 2: return ALIVE; case 3: return STOPPING; case 4: return STOPPED; case 5: return WARNING; default: return null; } }","old_code_raw":"  public static fb_status findByValue(int value) { \n    return BY_VALUE.get(value);\n  }\n","new_comment_raw":"@return null if the value is not found.","old_comment_raw":"@return null if the value is not found.","label":0,"pre_label":1,"AST_level":6,"line_counts":19,"new_code_token_num":57},{"new_code_raw":"public static boolean isBlank(String... originalStrArray) { if (null == originalStrArray || NUM == originalStrArray.length) return true; for (int i = NUM; i < originalStrArray.length; i++) { if (isBlank(originalStrArray[i])) return true; } return false; }","old_code_raw":"public static boolean isBlank(String originalStr) {\n    if (null == originalStr) {\n        return true;\n    }\n    if (originalStr.contains(BaseConstant.WORD_SEPARATOR)) {\n        return false;\n    }\n    return trimToEmpty(originalStr).isEmpty();\n}","new_comment_raw":"@return true if have one blank at least.","old_comment_raw":"@return true or false;","label":1,"pre_label":0,"AST_level":9,"line_counts":9,"new_code_token_num":55},{"new_code_raw":"public boolean searchForText(String regex, int matches, boolean scroll) { sleeper.sleep(); inst.waitForIdleSync(); Pattern p = Pattern.compile(regex); Matcher matcher; ArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class); if(matches == 0) matches = 1; for(TextView textView : textViewList){ matcher = p.matcher(textView.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroll && scroller.scroll(Scroller.Direction.DOWN)) { return searchForText(regex, matches, scroll); } else { if (countMatches > 0) Log.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + regex); countMatches=0; return false; } }","old_code_raw":"\tpublic boolean searchForText(String search, int matches, boolean scroll) {\n\t\tsleeper.sleep();\n\t\tinst.waitForIdleSync();\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tArrayList<TextView> textViewList = viewFetcher.getCurrentViews(TextView.class);\n\t\tif(matches == 0)\n\t\t\tmatches = 1;\n\t\tfor(TextView textView : textViewList){\n\t\t\tmatcher = p.matcher(textView.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t\tif (countMatches == matches) {\n\t\t\t\tcountMatches=0;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (scroll && scroller.scroll(Scroller.Direction.DOWN)) {\n\t\t\treturn searchForText(search, matches, scroll);\n\t\t} else {\n\t\t\tif (countMatches > 0)\n\t\t\t\tLog.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search);\n\t\t\tcountMatches=0;\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n","new_comment_raw":"@return true if regex string is found a given number of times and false if the regex string is not found","old_comment_raw":"@return true if search string is found a given number of times and false if the search string is not found","label":1,"pre_label":0,"AST_level":11,"line_counts":30,"new_code_token_num":162},{"new_code_raw":"public boolean equals(Object obj) { if (this == obj) { return true; } if (obj instanceof PeriodType == false) { return false; } PeriodType other = (PeriodType) obj; return (Arrays.equals(iTypes, other.iTypes)); }","old_code_raw":"    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof PeriodType)) {\n            return false;\n        }\n        PeriodType other = (PeriodType)obj;\n        Chronology chrono = getChronology();\n        if (chrono == null) {\n            if (other.getChronology() != null) {\n                return false;\n            }\n        } else if (!chrono.equals(other.getChronology())) {\n            return false;\n        }\n        return years().equals(other.years())\n            && months().equals(other.months())\n            && weeks().equals(other.weeks())\n            && days().equals(other.days())\n            && hours().equals(other.hours())\n            && minutes().equals(other.minutes())\n            && seconds().equals(other.seconds())\n            && millis().equals(other.millis());\n    }\n","new_comment_raw":"@return true if equal","old_comment_raw":"@return true if equal","label":0,"pre_label":1,"AST_level":6,"line_counts":11,"new_code_token_num":50},{"new_code_raw":"public String getCharset() { if (charset != null) { return charset.name(); } return DEFAULT_CHARSET; }","old_code_raw":"public String getCharset() {\n    return charset;\n}","new_comment_raw":"@return the name of the charset, never {@code null}","old_comment_raw":"@return Returns the charset.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":24},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(\"<\", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext(\">\", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { handleHyphenatedNumber(yytext()); return getNext(removeFromNumber(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(\"\\u2022\", yytext()); } case 90: break; case 25: { return getNext(\"\\u2122\", yytext()); } case 91: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 98: break; case 33: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 102: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 114: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 127: break; case 62: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 131: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            \/\/ prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            \/\/ System.err.println(\"At end of text making after: |\" + str + \"|\");\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n            \/\/ System.err.println(\"prevWord is |\" + prevWord.get(CoreAnnotations.TextAnnotation.class) + \"|, its after is |\" +\n            \/\/         prevWord.get(CoreAnnotations.AfterAnnotation.class) + \"|\");\n            prevWordAfter.setLength(0);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\",\n                          yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 74: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 75: break;\n          case 3: \n            { return getNext();\n            }\n          case 76: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 77: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(AbstractTokenizer.NEWLINE_TOKEN, yytext()); \/\/ for tokenizing newliens\n                  } else if (invertible) {\n                    \/\/ System.err.println(\"Appending newline: |\" + yytext() + \"|\");\n                    prevWordAfter.append(yytext());\n                  }\n            }\n          case 78: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} (2) to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 79: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 80: break;\n          case 8: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (3) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 81: break;\n          case 9: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 82: break;\n          case 10: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 11: \n            { return getNext(\">\", yytext());\n            }\n          case 84: break;\n          case 12: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 85: break;\n          case 13: \n            { handleHyphenatedNumber(yytext());\n                          if (DEBUG) { logger.info(\"Used {NUMBER} to recognize \" + yytext() + \" as \" + removeFromNumber(yytext())); }\n                          return getNext(removeFromNumber(yytext()), yytext());\n            }\n          case 86: break;\n          case 14: \n            { return handleEllipsis(yytext());\n            }\n          case 87: break;\n          case 15: \n            { \/\/ breakByHyphens(yytext()); \/\/ this is causing fail of attempted to pushback too much!\n                  String tok = yytext();\n                  \/* A THING can contain quote like O'Malley *\/\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {THING} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 88: break;\n          case 16: \n            { String txt = yytext();\n                  String norm = normalizeFractions(yytext());\n                  if (DEBUG) { logger.info(\"Used {FRAC2} to recognize \" + txt + \" as \" + norm +\n                                       \"; normalizeFractions=\" + normalizeFractions +\n                                       \", escapeForwardSlashAsterisk=\" + escapeForwardSlashAsterisk); }\n                  return getNext(norm, txt);\n            }\n          case 89: break;\n          case 17: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n                        } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 90: break;\n          case 18: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 91: break;\n          case 19: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 92: break;\n          case 20: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 93: break;\n          case 21: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 94: break;\n          case 22: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 95: break;\n          case 23: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 96: break;\n          case 24: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 97: break;\n          case 25: \n            { String tok = yytext();\n                        String norm = processCp1252misc(tok);\n                        if (DEBUG) { logger.info(\"Used {CP1252_MISC_SYMBOL} to recognize \" + tok + \" as \" + norm); }\n                        return getNext(norm, tok);\n            }\n          case 98: break;\n          case 26: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 99: break;\n          case 27: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 100: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 101: break;\n          case 29: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {REDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 102: break;\n          case 30: \n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {APOWORD} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 103: break;\n          case 31: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                                   String norm = handleQuotes(tok, true);\n                                   if (DEBUG) { logger.info(\"Used {DBLQUOT} to recognize \" + tok + \" as \" + norm +\n                                                            \"; probablyLeft=\" + true); }\n                                   return getNext(norm, tok);\n            }\n          case 104: break;\n          case 32: \n            { String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {PROG_LANGS} to recognize \" + tok + \" as \" + tok); }\n                    return getNext(tok, tok);\n            }\n          case 105: break;\n          case 33: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 106: break;\n          case 34: \n            { breakByHyphens(yytext());\n                  if (DEBUG) { logger.info(\"Used {HTHING} to recognize \" + yytext() + \" as \" + removeSoftHyphens(yytext())); }\n                  return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 107: break;\n          case 35: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tok = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tok = Americanize.americanize(tok);\n                          }\n                          if (DEBUG) { logger.info(\"Used {WORD} to recognize \" + origTxt + \" as \" + tok +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(tok, origTxt);\n            }\n          case 108: break;\n          case 36: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 109: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 110: break;\n          case 38: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 111: break;\n          case 39: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 112: break;\n          case 40: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 113: break;\n          case 41: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {REDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 114: break;\n          case 42: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { \/\/ Extra context is to not match on ones like 'd but you do want words like \"a\"\n                  \/\/ can't have digit here because of cases like '90s\n                  String tok = yytext();\n                  \/* invert single quote - often but not always right *\/\n                  String norm = handleQuotes(tok, true);\n                  if (DEBUG) { logger.info(\"Used {QUOTES} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + true); }\n                  return getNext(norm, tok);\n            }\n          case 115: break;\n          case 43: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 116: break;\n          case 44: \n            { String tok = yytext();\n                  String norm = handleQuotes(tok, false);\n                  if (DEBUG) { logger.info(\"Used {SREDAUX} (2) to recognize \" + tok + \" as \" + norm +\n                                           \"; probablyLeft=\" + false); }\n                  return getNext(norm, tok);\n            }\n          case 117: break;\n          case 45: \n            { if (splitAssimilations) {\n                      yypushback(2);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 118: break;\n          case 46: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      return getNext();\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, yytext());\n            }\n          case 119: break;\n          case 47: \n            { return getNormalizedAmpNext();\n            }\n          case 120: break;\n          case 48: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 121: break;\n          case 49: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 122: break;\n          case 50: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 123: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 124: break;\n          case 52: \n            { String txt = yytext();\n                  String normTok = txt;\n                  if (escapeForwardSlashAsterisk) {\n                    normTok = delimit(normTok, '*');\n                  }\n                  if (DEBUG) { logger.info(\"Used {SWEARING} to recognize \" + txt + \" as \" + normTok); }\n                  return getNext(normTok, txt);\n            }\n          case 125: break;\n          case 53: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                          String norm = handleQuotes(tok, false);\n                          if (DEBUG) { logger.info(\"Used {SREDAUX} to recognize \" + tok + \" as \" + norm +\n                                                   \"; probablyLeft=\" + false); }\n                          return getNext(norm, tok);\n            }\n          case 126: break;\n          case 54: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 127: break;\n          case 55: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 128: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 129: break;\n          case 57: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 130: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 59: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 132: break;\n          case 60: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String tok = yytext();\n                  breakByHyphens(tok);\n                  tok = yytext();\n                  String norm = removeSoftHyphens(tok);\n                  if (DEBUG) { logger.info(\"Used {HTHING} (2) to recognize \" + tok + \" as \" + norm); }\n                  return getNext(norm, tok);\n            }\n          case 133: break;\n          case 61: \n            { if (splitAssimilations) {\n                      yypushback(3);\n                    }\n                    String tok = yytext();\n                    if (DEBUG) { logger.info(\"Used {ASSIMILATIONS3} to recognize \" + tok + \" as \" + tok +\n                            \"; splitAssimilations=\" + splitAssimilations); }\n                    return getNext(tok, tok);\n            }\n          case 134: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 135: break;\n          case 63: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 136: break;\n          case 64: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 137: break;\n          case 65: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 138: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 139: break;\n          case 67: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 140: break;\n          case 68: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 141: break;\n          case 69: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 142: break;\n          case 70: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 143: break;\n          case 71: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          if (DEBUG) { logger.info(\"Used {PHONE} to recognize \" + yytext() + \" as \" + txt); }\n                          return getNext(txt, yytext());\n            }\n          case 144: break;\n          case 72: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 145: break;\n          case 73: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 146: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":19,"line_counts":966,"new_code_token_num":6274},{"new_code_raw":"@Override public Refactoring getParent() { return this.parent; }","old_code_raw":"@Override\npublic EmfRefactoring getParent() {\n    return this.parent;\n}","new_comment_raw":"@return Refactoring supported by the controller.","old_comment_raw":"@return EmfRefactoring supported by the controller.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":13},{"new_code_raw":"public <V extends Visitor<? super X>> V visit(V visitor) { for (X x : this) { visitor.visit(x); } return visitor; }","old_code_raw":"public <P extends Visitor<? super X>> P visit(P predicate) {\n    for (X x : this) {\n        predicate.visit(x);\n    }\n    return predicate;\n}","new_comment_raw":"@return {@code visitor}","old_comment_raw":"@return {@code predicate}","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":33},{"new_code_raw":"public Object convert(Column column, String value) { if (value == null) { return value; } \/\/ boolean is also TINYINT(1) if (\"TINYINT\".equals(column.typeName())) { if (\"true\".equalsIgnoreCase(value) || \"false\".equalsIgnoreCase(value)) { return convertToBoolean(value); } } switch (column.jdbcType()) { case Types.DATE: return convertToLocalDate(column, value); case Types.TIMESTAMP: return convertToLocalDateTime(column, value); case Types.TIMESTAMP_WITH_TIMEZONE: return convertToTimestamp(column, value); case Types.TIME: return convertToDuration(column, value); case Types.BOOLEAN: return convertToBoolean(value); case Types.BIT: return convertToBits(column, value); case Types.NUMERIC: case Types.DECIMAL: return convertToDecimal(column, value); case Types.FLOAT: case Types.DOUBLE: case Types.REAL: return convertToDouble(value); } return value; }","old_code_raw":"    public Object convert(Column column, String value) {\n        if (value == null) {\n            return value;\n        }\n        switch (column.jdbcType()) {\n        case Types.DATE:\n            return convertToLocalDate(column, value);\n        case Types.TIMESTAMP:\n            return convertToLocalDateTime(column, value);\n        case Types.TIMESTAMP_WITH_TIMEZONE:\n            return convertToTimestamp(column, value);\n        case Types.TIME:\n            return convertToDuration(column, value);\n        case Types.BOOLEAN:\n            return convertToBoolean(value);\n        case Types.BIT:\n            return convertToBits(column, value);\n\n        case Types.NUMERIC:\n        case Types.DECIMAL:\n            return convertToDecimal(column, value);\n\n        case Types.FLOAT:\n        case Types.DOUBLE:\n        case Types.REAL:\n            return convertToDouble(value);\n        }\n        return value;\n    }\n","new_comment_raw":"@return value converted to a Java type","old_comment_raw":"@return value converted to a Java type","label":0,"pre_label":1,"AST_level":9,"line_counts":37,"new_code_token_num":189},{"new_code_raw":"private String prepareQueryString(String groupPath, String jobName, Properties options) { List<NameValuePair> parameters = new ArrayList<NameValuePair>(); parameters.add(new BasicNameValuePair(STR, groupPath)); parameters.add(new BasicNameValuePair(STR, jobName)); if (options != null) { for (Entry<Object, Object> option : options.entrySet()) { parameters.add(new BasicNameValuePair(STR + option.getKey(), String.valueOf(option.getValue()))); } } return URLEncodedUtils.format(parameters, HTTP.UTF_8); }","old_code_raw":"private NameValuePair[] prepareQueryString(String groupPath, String jobName, Properties options) {\n    List<NameValuePair> queryString = new ArrayList<NameValuePair>();\n    queryString.add(new NameValuePair(STR, groupPath));\n    queryString.add(new NameValuePair(STR, jobName));\n    if (options != null) {\n        for (Entry<Object, Object> option : options.entrySet()) {\n            queryString.add(new NameValuePair(STR + option.getKey(), String.valueOf(option.getValue())));\n        }\n    }\n    return queryString.toArray(new NameValuePair[queryString.size()]);\n}","new_comment_raw":"@return an url-encoded string","old_comment_raw":"@return an array of {@link NameValuePair}, won't be null or empty (at least 2 entries : group and job)","label":1,"pre_label":0,"AST_level":11,"line_counts":11,"new_code_token_num":105},{"new_code_raw":"public boolean addFile(File sourceFile) { String filename = sourceFile.getName(); File destFile = null; String codeExtension = null; boolean replacement = false; \/\/ if the file appears to be code related, drop it \/\/ into the code folder, instead of the data folder if (filename.toLowerCase().endsWith(\".class\") || filename.toLowerCase().endsWith(\".jar\") || filename.toLowerCase().endsWith(\".dll\") || filename.toLowerCase().endsWith(\".jnilib\") || filename.toLowerCase().endsWith(\".so\")) { \/\/if (!codeFolder.exists()) codeFolder.mkdirs(); prepareCodeFolder(); destFile = new File(codeFolder, filename); } else { for (String extension : getExtensions()) { String lower = filename.toLowerCase(); if (lower.endsWith(\".\" + extension)) { destFile = new File(this.folder, filename); codeExtension = extension; } } if (codeExtension == null) { prepareDataFolder(); destFile = new File(dataFolder, filename); } } \/\/ check whether this file already exists if (destFile.exists()) { Object[] options = { \"OK\", \"Cancel\" }; String prompt = \"Replace the existing version of \" + filename + \"?\"; int result = JOptionPane.showOptionDialog(editor, prompt, \"Replace\", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]); if (result == JOptionPane.YES_OPTION) { replacement = true; } else { return false; } } \/\/ If it's a replacement, delete the old file first, \/\/ otherwise case changes will not be preserved. \/\/ http:\/\/dev.processing.org\/bugs\/show_bug.cgi?id=969 if (replacement) { boolean muchSuccess = destFile.delete(); if (!muchSuccess) { Base.showWarning(\"Error adding file\", \"Could not delete the existing '\" + filename + \"' file.\", null); return false; } } \/\/ make sure they aren't the same file if ((codeExtension == null) && sourceFile.equals(destFile)) { Base.showWarning(\"You can't fool me\", \"This file has already been copied to the\\n\" + \"location from which where you're trying to add it.\\n\" + \"I ain't not doin nuthin'.\", null); return false; } \/\/ in case the user is \"adding\" the code in an attempt \/\/ to update the sketch's tabs if (!sourceFile.equals(destFile)) { try { Base.copyFile(sourceFile, destFile); } catch (IOException e) { Base.showWarning(\"Error adding file\", \"Could not add '\" + filename + \"' to the sketch.\", e); return false; } } if (codeExtension != null) { SketchCode newCode = new SketchCode(destFile, codeExtension); if (replacement) { replaceCode(newCode); } else { insertCode(newCode); sortCode(); } setCurrentCode(filename); editor.header.repaint(); if (editor.untitled) { \/\/ TODO probably not necessary? problematic? \/\/ Mark the new code as modified so that the sketch is saved current.setModified(true); } } else { if (editor.untitled) { \/\/ TODO probably not necessary? problematic? \/\/ If a file has been added, mark the main code as modified so \/\/ that the sketch is properly saved. code[0].setModified(true); } } return true; }","old_code_raw":"  public boolean addFile(File sourceFile) {\n    String filename = sourceFile.getName();\n    File destFile = null;\n    String codeExtension = null;\n    boolean replacement = false;\n\n    \/\/ if the file appears to be code related, drop it\n    \/\/ into the code folder, instead of the data folder\n    if (filename.toLowerCase().endsWith(\".class\") ||\n        filename.toLowerCase().endsWith(\".jar\") ||\n        filename.toLowerCase().endsWith(\".dll\") ||\n        filename.toLowerCase().endsWith(\".jnilib\") ||\n        filename.toLowerCase().endsWith(\".so\")) {\n\n      \/\/if (!codeFolder.exists()) codeFolder.mkdirs();\n      prepareCodeFolder();\n      destFile = new File(codeFolder, filename);\n\n    } else {\n      for (String extension : getExtensions()) {\n        String lower = filename.toLowerCase();\n        if (lower.endsWith(\".\" + extension)) {\n          destFile = new File(this.folder, filename);\n          codeExtension = extension;\n        }\n      }\n      if (codeExtension == null) {\n        prepareDataFolder();\n        destFile = new File(dataFolder, filename);\n      }\n    }\n\n    \/\/ check whether this file already exists\n    if (destFile.exists()) {\n      Object[] options = { \"OK\", \"Cancel\" };\n      String prompt = \"Replace the existing version of \" + filename + \"?\";\n      int result = JOptionPane.showOptionDialog(editor,\n                                                prompt,\n                                                \"Replace\",\n                                                JOptionPane.YES_NO_OPTION,\n                                                JOptionPane.QUESTION_MESSAGE,\n                                                null,\n                                                options,\n                                                options[0]);\n      if (result == JOptionPane.YES_OPTION) {\n        replacement = true;\n      } else {\n        return false;\n      }\n    }\n\n    \/\/ make sure they aren't the same file\n    if ((codeExtension == null) && sourceFile.equals(destFile)) {\n      Base.showWarning(\"You can't fool me\",\n                       \"This file has already been copied to the\\n\" +\n                       \"location from which where you're trying to add it.\\n\" +\n                       \"I ain't not doin nuthin'.\", null);\n      return false;\n    }\n\n    \/\/ in case the user is \"adding\" the code in an attempt\n    \/\/ to update the sketch's tabs\n    if (!sourceFile.equals(destFile)) {\n      try {\n        Base.copyFile(sourceFile, destFile);\n\n      } catch (IOException e) {\n        Base.showWarning(\"Error adding file\",\n                         \"Could not add '\" + filename + \"' to the sketch.\", e);\n        return false;\n      }\n    }\n\n    if (codeExtension != null) {\n      SketchCode newCode = new SketchCode(destFile, codeExtension);\n\n      if (replacement) {\n        replaceCode(newCode);\n\n      } else {\n        insertCode(newCode);\n        sortCode();\n      }\n      setCurrentCode(filename);\n      editor.header.repaint();\n      if (editor.untitled) {  \/\/ TODO probably not necessary? problematic?\n        \/\/ Mark the new code as modified so that the sketch is saved\n        current.setModified(true);\n      }\n\n    } else {\n      if (editor.untitled) {  \/\/ TODO probably not necessary? problematic?\n        \/\/ If a file has been added, mark the main code as modified so\n        \/\/ that the sketch is properly saved.\n        code[0].setModified(true);\n      }\n    }\n    return true;\n  }\n","new_comment_raw":"@return true if successful.","old_comment_raw":"@return true if successful.","label":0,"pre_label":1,"AST_level":13,"line_counts":113,"new_code_token_num":708},{"new_code_raw":"public static final Weblogger getRoller() { if (rollerInstance == null) { throw new IllegalStateException(STR); } return rollerInstance; }","old_code_raw":"public static final Roller getRoller() {\n    if (rollerInstance == null) {\n        throw new IllegalStateException(STR);\n    }\n    return rollerInstance;\n}","new_comment_raw":"@return Weblogger An instance of Weblogger.","old_comment_raw":"@return Roller An instance of Roller.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":26},{"new_code_raw":"protected Object convertTimeToMillisPastMidnight(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0; \/\/ return epoch } try { return Time.toMilliOfDay(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimeToMillisPastMidnight(Column column, Field fieldDefn, Object data) {\n        if ( data == null ) return null;\n        try {\n            return Time.toMilliOfDay(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":82},{"new_code_raw":"public TraversalControl visitDocument(Document node, TraverserContext<Node> context) { Document changedNode = node.transform(builder -> { List<Definition> definitions = sort(node.getDefinitions(), comparingDefinitions()); builder.definitions(definitions); }); return changeNode(context, changedNode); }","old_code_raw":"            public TraversalControl visitDocument(Document node, TraverserContext<Node> context) {\n                Document changedNode = node.transform(builder -> {\n                    List<Definition> definitions = sort(node.getDefinitions(), comparingDefinitions());\n                    builder.definitions(definitions);\n                });\n                return newNode(context, changedNode);\n            }\n","new_comment_raw":"@return a new sorted node (because  graphql.language.Nodes are immutable)","old_comment_raw":"@return a new sorted node (because graphql.language.Nodes are immutable)","label":0,"pre_label":1,"AST_level":10,"line_counts":8,"new_code_token_num":53},{"new_code_raw":"public boolean updateComponent(Widget component, UIDL uidl, boolean manageCaption) { if (!widgetFactory.isCorrectImplementation(component, uidl)) { Layout parent = getParentLayout(component); if (parent != null) { Widget w = widgetFactory.createWidget(uidl); registerPaintable(uidl.getId(), (Paintable) w); parent.replaceChildComponent(component, w); ((Paintable) w).updateFromUIDL(uidl, this); return true; } } if (manageCaption) { Layout parent = getParentLayout(component); if (parent != null) parent.updateCaption(component, uidl); } if (component instanceof FocusWidget) ((FocusWidget) component).setEnabled(!uidl.getBooleanAttribute(STR)); boolean visible = !uidl.getBooleanAttribute(STR); component.setVisible(visible); if (!visible) return true; return false; }","old_code_raw":"public boolean updateComponent(Widget component, UIDL uidl, boolean manageCaption) {\n    if (manageCaption) {\n        Layout parent = getParentLayout(component);\n        if (parent != null)\n            parent.updateCaption(component, uidl);\n    }\n    boolean visible = !uidl.getBooleanAttribute(STR);\n    component.setVisible(visible);\n    if (!visible)\n        return true;\n    if (widgetFactory.isCorrectImplementation(component, uidl))\n        return false;\n    Layout parent = getParentLayout(component);\n    if (parent == null)\n        return false;\n    Widget w = widgetFactory.createWidget(uidl);\n    registerPaintable(uidl.getId(), (Paintable) w);\n    parent.replaceChildComponent(component, w);\n    ((Paintable) w).updateFromUIDL(uidl, this);\n    return true;\n}","new_comment_raw":"@return Returns true iff no further painting is needed by caller","old_comment_raw":"@return Returns true","label":1,"pre_label":0,"AST_level":10,"line_counts":24,"new_code_token_num":163},{"new_code_raw":"public String getSynonymSource(String anOwner, String aSynonym) { if (this.synonymReader == null) return STR; String result = null; try { result = this.synonymReader.getSynonymSource(this.dbConnection.getSqlConnection(), anOwner, aSynonym); } catch (Exception e) { result = STR; } return result; }","old_code_raw":"public String getSynonymSource(String anOwner, String aSynonym) {\n    if (!this.isOracle)\n        return STR;\n    String result = null;\n    try {\n        result = SynonymReader.getSynonymSource(this.dbConnection.getSqlConnection(), anOwner, aSynonym);\n    } catch (Exception e) {\n        result = STR;\n    }\n    return result;\n}","new_comment_raw":"@return the SQL to create the synonym.","old_comment_raw":"@return the SQL to create the synonym. If the DBMS is not Oracle an empty String","label":1,"pre_label":0,"AST_level":9,"line_counts":11,"new_code_token_num":57},{"new_code_raw":"public static Map mapOfSize(int size) { return new HashMap( determineProperSizing( size ), LOAD_FACTOR ); }","old_code_raw":"\tpublic static Map mapOfSize(int size) {\n\t\tfinal int currentSize = (int) (size \/ 0.75f);\n\t\treturn new HashMap( Math.max( currentSize+ 1, 16), 0.75f );\n\t}\n","new_comment_raw":"@return The sized map.","old_comment_raw":"@return The sized map.","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":22},{"new_code_raw":"protected TokenResponse executeRefreshToken() throws IOException { if (refreshToken == null) { return null; } return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl), refreshToken).setClientAuthentication(clientAuthentication).setRequestInitializer(requestInitializer).execute(); }","old_code_raw":"protected TokenResponse executeRefreshToken() throws IOException {\n    return new RefreshTokenRequest(transport, jsonFactory, new GenericUrl(tokenServerEncodedUrl), refreshToken).setClientAuthentication(clientAuthentication).setRequestInitializer(requestInitializer).execute();\n}","new_comment_raw":"@return successful response from the token server or {@code null} if it is not possible to refresh the access token","old_comment_raw":"@return whether a new access token was successfully retrieved","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":47},{"new_code_raw":"public List<Lattice> addQuery(RelNode r) { \/\/ Push filters into joins and towards leaves final HepPlanner planner = new HepPlanner(PROGRAM, null, true, null, RelOptCostImpl.FACTORY); planner.setRoot(r); final RelNode r2 = planner.findBestExp(); final Query q = new Query(space); final Frame frame = frame(q, r2); if (frame == null) { return ImmutableList.of(); } final AttributedDirectedGraph<TableRef, StepRef> g = AttributedDirectedGraph.create(new StepRef.Factory()); final Multimap<Pair<TableRef, TableRef>, IntPair> map = LinkedListMultimap.create(); for (TableRef tableRef : frame.tableRefs) { g.addVertex(tableRef); } for (Hop hop : frame.hops) { map.put(Pair.of(hop.source.t, hop.target.t), IntPair.of(hop.source.c, hop.target.c)); } for (Map.Entry<Pair<TableRef, TableRef>, Collection<IntPair>> e : map.asMap().entrySet()) { final TableRef source = e.getKey().left; final TableRef target = e.getKey().right; final StepRef stepRef = q.stepRef(source, target, ImmutableList.copyOf(e.getValue())); g.addVertex(stepRef.source()); g.addVertex(stepRef.target()); g.addEdge(stepRef.source(), stepRef.target(), stepRef.step, stepRef.ordinalInQuery); } \/\/ If the join graph is cyclic, we can't use it. final Set<TableRef> cycles = new CycleDetector<>(g).findCycles(); if (!cycles.isEmpty()) { return ImmutableList.of(); } \/\/ Translate the query graph to mutable nodes final Map<TableRef, MutableNode> nodes = new IdentityHashMap<>(); final Map<List, MutableNode> nodesByParent = new HashMap<>(); final List<MutableNode> rootNodes = new ArrayList<>(); for (TableRef tableRef : TopologicalOrderIterator.of(g)) { final List<StepRef> edges = g.getInwardEdges(tableRef); final MutableNode node; switch (edges.size()) { case 0: node = new MutableNode(tableRef.table); rootNodes.add(node); break; case 1: final StepRef edge = edges.get(0); final MutableNode parent = nodes.get(edge.source()); final List key = ImmutableList.of(parent, tableRef.table, edge.step.keys); final MutableNode existingNode = nodesByParent.get(key); if (existingNode == null) { node = new MutableNode(tableRef.table, parent, edge.step); nodesByParent.put(key, node); } else { node = existingNode; } break; default: for (StepRef edge2 : edges) { final MutableNode parent2 = nodes.get(edge2.source()); final MutableNode node2 = new MutableNode(tableRef.table, parent2, edge2.step); parent2.children.add(node2); } node = null; break; } nodes.put(tableRef, node); } \/\/ Transcribe the hierarchy of mutable nodes to immutable nodes final List<Lattice> lattices = new ArrayList<>(); for (MutableNode rootNode : rootNodes) { if (rootNode.isCyclic()) { continue; } final CalciteSchema rootSchema = CalciteSchema.createRootSchema(false); final Lattice.Builder latticeBuilder = new Lattice.Builder(space, rootSchema, rootNode); final List<MutableNode> flatNodes = new ArrayList<>(); rootNode.flatten(flatNodes); for (MutableMeasure measure : frame.measures) { for (ColRef arg : measure.arguments) { if (arg == null) { \/\/ Cannot handle expressions, e.g. \"sum(x + 1)\" yet return ImmutableList.of(); } } latticeBuilder.addMeasure( new Lattice.Measure(measure.aggregate, measure.distinct, measure.name, Lists.transform(measure.arguments, colRef -> { final Lattice.Column column; if (colRef instanceof BaseColRef) { final BaseColRef baseColRef = (BaseColRef) colRef; final MutableNode node = nodes.get(baseColRef.t); final int table = flatNodes.indexOf(node); column = latticeBuilder.column(table, baseColRef.c); } else if (colRef instanceof DerivedColRef) { final DerivedColRef derivedColRef = (DerivedColRef) colRef; final String alias = deriveAlias(measure, derivedColRef); column = latticeBuilder.expression(derivedColRef.e, alias, derivedColRef.tableAliases()); } else { throw new AssertionError(\"expression in measure\"); } latticeBuilder.use(column, true); return column; }))); } for (int i = 0; i < frame.columnCount; i++) { final ColRef c = frame.column(i); if (c instanceof DerivedColRef) { final DerivedColRef derivedColRef = (DerivedColRef) c; final Lattice.Column expression = latticeBuilder.expression(derivedColRef.e, derivedColRef.alias, derivedColRef.tableAliases()); latticeBuilder.use(expression, false); } } final Lattice lattice0 = latticeBuilder.build(); final Lattice lattice1 = findMatch(lattice0, rootNode); lattices.add(lattice1); } return ImmutableList.copyOf(lattices); }","old_code_raw":"  public List<Lattice> addQuery(RelNode r) {\n    \/\/ Push filters into joins and towards leaves\n    final HepPlanner planner =\n        new HepPlanner(PROGRAM, null, true, null, RelOptCostImpl.FACTORY);\n    planner.setRoot(r);\n    final RelNode r2 = planner.findBestExp();\n\n    final Query q = new Query(space);\n    final Frame frame = frame(q, r2);\n    if (frame == null) {\n      return ImmutableList.of();\n    }\n    final AttributedDirectedGraph<TableRef, StepRef> g =\n        AttributedDirectedGraph.create(new StepRef.Factory());\n    final Multimap<Pair<TableRef, TableRef>, IntPair> map =\n        LinkedListMultimap.create();\n    for (TableRef tableRef : frame.tableRefs) {\n      g.addVertex(tableRef);\n    }\n    for (Hop hop : frame.hops) {\n      map.put(Pair.of(hop.source.t, hop.target.t),\n          IntPair.of(hop.source.c, hop.target.c));\n    }\n    for (Map.Entry<Pair<TableRef, TableRef>, Collection<IntPair>> e\n        : map.asMap().entrySet()) {\n      final TableRef source = e.getKey().left;\n      final TableRef target = e.getKey().right;\n      final StepRef stepRef =\n          q.stepRef(source, target, ImmutableList.copyOf(e.getValue()));\n      g.addVertex(stepRef.source());\n      g.addVertex(stepRef.target());\n      g.addEdge(stepRef.source(), stepRef.target(), stepRef.step,\n          stepRef.ordinalInQuery);\n    }\n\n    \/\/ If the join graph is cyclic, we can't use it.\n    final Set<TableRef> cycles = new CycleDetector<>(g).findCycles();\n    if (!cycles.isEmpty()) {\n      return ImmutableList.of();\n    }\n\n    \/\/ Translate the query graph to mutable nodes\n    final Map<TableRef, MutableNode> nodes = new IdentityHashMap<>();\n    final Map<List, MutableNode> nodesByParent = new HashMap<>();\n    final List<MutableNode> rootNodes = new ArrayList<>();\n    for (TableRef tableRef : TopologicalOrderIterator.of(g)) {\n      final List<StepRef> edges = g.getInwardEdges(tableRef);\n      final MutableNode node;\n      switch (edges.size()) {\n      case 0:\n        node = new MutableNode(tableRef.table);\n        rootNodes.add(node);\n        break;\n      case 1:\n        final StepRef edge = edges.get(0);\n        final MutableNode parent = nodes.get(edge.source());\n        final List key =\n            ImmutableList.of(parent, tableRef.table, edge.step.keys);\n        final MutableNode existingNode = nodesByParent.get(key);\n        if (existingNode == null) {\n          node = new MutableNode(tableRef.table, parent, edge.step);\n          nodesByParent.put(key, node);\n        } else {\n          node = existingNode;\n        }\n        break;\n      default:\n        for (StepRef edge2 : edges) {\n          final MutableNode parent2 = nodes.get(edge2.source());\n          final MutableNode node2 =\n              new MutableNode(tableRef.table, parent2, edge2.step);\n          parent2.children.add(node2);\n        }\n        node = null;\n        break;\n      }\n      nodes.put(tableRef, node);\n    }\n\n    \/\/ Transcribe the hierarchy of mutable nodes to immutable nodes\n    final List<Lattice> lattices = new ArrayList<>();\n    for (MutableNode rootNode : rootNodes) {\n      if (rootNode.isCyclic()) {\n        continue;\n      }\n      final CalciteSchema rootSchema = CalciteSchema.createRootSchema(false);\n      final Lattice.Builder latticeBuilder =\n          new Lattice.Builder(space, rootSchema, rootNode);\n\n      final List<MutableNode> flatNodes = new ArrayList<>();\n      rootNode.flatten(flatNodes);\n\n      for (MutableMeasure measure : frame.measures) {\n        for (ColRef arg : measure.arguments) {\n          if (arg == null) {\n            \/\/ Cannot handle expressions, e.g. \"sum(x + 1)\" yet\n            return ImmutableList.of();\n          }\n        }\n        latticeBuilder.addMeasure(\n            new Lattice.Measure(measure.aggregate, measure.distinct,\n                measure.name,\n                Lists.transform(measure.arguments, colRef -> {\n                  if (colRef instanceof BaseColRef) {\n                    final BaseColRef baseColRef = (BaseColRef) colRef;\n                    final MutableNode node = nodes.get(baseColRef.t);\n                    final int table = flatNodes.indexOf(node);\n                    return latticeBuilder.column(table, baseColRef.c);\n                  } else if (colRef instanceof DerivedColRef) {\n                    final DerivedColRef derivedColRef =\n                        (DerivedColRef) colRef;\n                    final String alias = deriveAlias(measure, derivedColRef);\n                    return latticeBuilder.expression(derivedColRef.e, alias,\n                        derivedColRef.tableAliases());\n                  } else {\n                    throw new AssertionError(\"expression in measure\");\n                  }\n                })));\n      }\n\n      for (int i = 0; i < frame.columnCount; i++) {\n        final ColRef c = frame.column(i);\n        if (c instanceof DerivedColRef) {\n          final DerivedColRef derivedColRef = (DerivedColRef) c;\n          final Lattice.Column expression =\n              latticeBuilder.expression(derivedColRef.e,\n                  derivedColRef.alias, derivedColRef.tableAliases());\n        }\n      }\n\n      final Lattice lattice0 = latticeBuilder.build();\n      final Lattice lattice1 = findMatch(lattice0, rootNode);\n      lattices.add(lattice1);\n    }\n    return ImmutableList.copyOf(lattices);\n  }\n","new_comment_raw":"@return A list of join graphs: usually 1; more if the query contains a cartesian product; zero if the query graph is cyclic","old_comment_raw":"@return A list of join graphs: usually 1; more if the query contains a cartesian product; zero if the query graph is cyclic","label":0,"pre_label":1,"AST_level":18,"line_counts":141,"new_code_token_num":923},{"new_code_raw":"public static StringTemplate stringTemplate(Template template, ImmutableList<?> args) { return new StringTemplate(template, args); }","old_code_raw":"    public static StringTemplate stringTemplate(Template template, ImmutableList<?> args) {\n        return new StringTemplate(template, ImmutableList.copyOf(args));\n    }\n","new_comment_raw":"@return template expression","old_comment_raw":"@return template expression","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public String getDestinationFilter() { if (this.destinationFilter == null) { if (dynamicallyIncludedDestinations != null && !dynamicallyIncludedDestinations.isEmpty()) { StringBuffer filter = new StringBuffer(); String delimiter = \"\"; for (ActiveMQDestination destination : dynamicallyIncludedDestinations) { if (!destination.isTemporary()) { filter.append(delimiter); filter.append(AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX); filter.append(destination.getDestinationTypeAsString()); filter.append(\".\"); filter.append(destination.getPhysicalName()); delimiter = \",\"; } } return filter.toString(); } else { return AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX + \">\"; } } else { \/\/ prepend consumer advisory prefix \/\/ to keep backward compatibility if (!this.destinationFilter.startsWith(AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX)) { return AdvisorySupport.CONSUMER_ADVISORY_TOPIC_PREFIX + this.destinationFilter; } else { return this.destinationFilter; } } }","old_code_raw":"    public String getDestinationFilter() {\n        return this.destinationFilter;\n    }\n","new_comment_raw":"@return the destinationFilter","old_comment_raw":"@return the destinationFilter","label":0,"pre_label":1,"AST_level":13,"line_counts":30,"new_code_token_num":162},{"new_code_raw":"static boolean observe(@Nullable final Object object) { return !(object instanceof ComponentObservable) || asComponentObservable(object).observe(); }","old_code_raw":"static boolean observe(@Nonnull final Object object) {\n    return asComponentObservable(object).observe();\n}","new_comment_raw":"@return false if the component is not disposing or disposed, true otherwise.","old_comment_raw":"@return true if the component is \"alive\" a.k.a. not disposing or disposed.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":29},{"new_code_raw":"public Button getButton(int index) { return getter.getView(Button.class, index); }","old_code_raw":"\tpublic Button getButton(int index) {\n\t\tButton button = getter.getView(Button.class, index);\n\t\treturn button;\n\t}\n","new_comment_raw":"@return the  Button with a specified index or  null if index is invalid","old_comment_raw":"@return the Button with a specified index or null if index is invalid","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public static int[] toArray(final BitSet bitSet) { final int[] integers = new int[bitSet.cardinality()]; int j = NUM; for (int i = bitSet.nextSetBit(NUM); i >= NUM; i = bitSet.nextSetBit(i + NUM)) { integers[j++] = i; } return integers; }","old_code_raw":"public static Integer[] toArray(final BitSet bitSet) {\n    final List<Integer> list = toList(bitSet);\n    return list.toArray(new Integer[list.size()]);\n}","new_comment_raw":"@return Array of set bits","old_comment_raw":"@return List of set bits","label":1,"pre_label":0,"AST_level":9,"line_counts":8,"new_code_token_num":66},{"new_code_raw":"public static Set getAllInterfaces(List objects) { Set interfaces = new HashSet(); for (Iterator iterator = objects.iterator(); iterator.hasNext(); ) { Object o = iterator.next(); Class clazz = o.getClass(); getInterfaces(clazz, interfaces); } return interfaces; }","old_code_raw":"public static Class[] getAllInterfaces(List objects) {\n    Set interfaces = new HashSet();\n    for (Iterator iterator = objects.iterator(); iterator.hasNext(); ) {\n        Object o = iterator.next();\n        Class clazz = o.getClass();\n        getInterfaces(clazz, interfaces);\n    }\n    return (Class[]) interfaces.toArray(new Class[interfaces.size()]);\n}","new_comment_raw":"@return a {@link Set} of interfaces.","old_comment_raw":"@return an array of interfaces.","label":1,"pre_label":0,"AST_level":7,"line_counts":9,"new_code_token_num":58},{"new_code_raw":"public PendingMessageCursor getSubscriberPendingMessageCursor(Broker broker,String clientId, String name, int maxBatchSize, Subscription sub) { return new StoreDurableSubscriberCursor(broker,clientId, name, maxBatchSize, sub); }","old_code_raw":"    public PendingMessageCursor getSubscriberPendingMessageCursor(String clientId, String name, Store tmpStorage, int maxBatchSize, Subscription sub) {\n        return new StoreDurableSubscriberCursor(clientId, name, tmpStorage, maxBatchSize, sub);\n    }\n","new_comment_raw":"@return the Pending Message cursor","old_comment_raw":"@return the Pending Message cursor","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":36},{"new_code_raw":"public IBuildConfiguration[] getBuildOrder() { if (buildOrder != null) return buildOrder; String[] order = description.getBuildOrder(false); if (order != null) { LinkedHashSet configs = new LinkedHashSet(); for (int i = NUM; i < order.length; i++) { IProject project = getRoot().getProject(order[i]); if (project.isAccessible()) configs.add(((Project) project).internalGetActiveBuildConfig()); } configs.addAll(Arrays.asList(vertexOrderToProjectBuildConfigOrder(computeActiveBuildConfigurationOrder()).buildConfigurations)); IBuildConfiguration[] bo = new IBuildConfiguration[configs.size()]; configs.toArray(bo); this.buildOrder = bo; } else buildOrder = vertexOrderToProjectBuildConfigOrder(computeActiveBuildConfigurationOrder()).buildConfigurations; return buildOrder; }","old_code_raw":"public IProject[] getBuildOrder() {\n    if (buildOrder != null) {\n        return buildOrder;\n    }\n    String[] order = description.getBuildOrder(false);\n    if (order != null) {\n        List projectList = new ArrayList(order.length);\n        for (int i = NUM; i < order.length; i++) {\n            IProject project = getRoot().getProject(order[i]);\n            if (project.isAccessible()) {\n                projectList.add(project);\n            }\n        }\n        buildOrder = new IProject[projectList.size()];\n        projectList.toArray(buildOrder);\n    } else {\n        buildOrder = computeFullProjectOrder().projects;\n    }\n    return buildOrder;\n}","new_comment_raw":"@return the list of currently open projects active buildConfigs (and the project buildConfigs they depend on) in the workspace in the order in which they would be built by <code>IWorkspace.build<\/code>.","old_comment_raw":"@return the list of currently open projects in the workspace in the order in which they would be built by <code>IWorkspace.build<\/code>.","label":1,"pre_label":0,"AST_level":13,"line_counts":19,"new_code_token_num":145},{"new_code_raw":"public boolean transform(Canvas canvas, View child) { final RevealValues revealData = targets.get(child); return revealData != null && revealData.applyTransformation(canvas, child); }","old_code_raw":"    boolean transform(Canvas canvas, View child) {\n      if (child != target || !animating) {\n        return false;\n      }\n\n      path.reset();\n      path.addCircle(centerX, centerY, radius, Path.Direction.CW);\n\n      canvas.clipPath(path, Region.Op.DIFFERENCE);\n      return true;\n    }\n","new_comment_raw":"@return True if transformation was successfully applied on referenced child, otherwise child be not the target and therefore animation was skipped","old_comment_raw":"@return True if transformation was successfully applied on referenced child, otherwise child be not the target and therefore animation was skipped","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":35},{"new_code_raw":"protected Account getServiceCredentials() { return this.account; }","old_code_raw":"protected ServiceCredentials getServiceCredentials() {\n    return this.serviceCredentials;\n}","new_comment_raw":"@return {@link com.jakeapp.core.domain.Account} if they are already set.","old_comment_raw":"@return {@link ServiceCredentials} if they are already set.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public final static AtmosphereRequest wrap(HttpServletRequest request) { \/\/ Do not rewrap. if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) { return AtmosphereRequest.class.cast(request); } Builder b = new Builder(); Enumeration<String> e = request.getAttributeNames(); String s; while (e.hasMoreElements()) { s = e.nextElement(); b.localAttributes.put(s, request.getAttribute(s)); } return b.request(request).build(); }","old_code_raw":"    public final static AtmosphereRequest wrap(HttpServletRequest request) {\n        \/\/ Do not rewrap.\n        if (AtmosphereRequest.class.isAssignableFrom(request.getClass())) {\n            return AtmosphereRequest.class.cast(request);\n        }\n        return new Builder().request(request).build();\n    }\n","new_comment_raw":"@return an  AtmosphereRequest","old_comment_raw":"@return an AtmosphereRequest","label":0,"pre_label":1,"AST_level":8,"line_counts":16,"new_code_token_num":94},{"new_code_raw":"private SQLRowValues getTree(SQLRow row, boolean archived) { check(row); final SQLRowValues res = row.asRowValues(); try { this.forDescendantsDo(res, new ChildProcessor<SQLRowValues>() { public void process(SQLRowValues parent, SQLField joint, SQLRowValues desc) throws SQLException { desc.put(joint.getName(), parent); } }, true, false, archived); } catch (SQLException e) { e.printStackTrace(); } return res; }","old_code_raw":"private List<SQLRow> getTree(SQLRow row, boolean archived) {\n    check(row);\n    final List<SQLRow> descsAndMe = new ArrayList<SQLRow>();\n    try {\n        this.forDescendantsDo(row, new ChildProcessor<SQLRow>() {\n\n            public void process(SQLRow parent, SQLField joint, SQLRow desc) throws SQLException {\n                descsAndMe.add(desc);\n            }\n        }, true, true, archived);\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    if (row.isArchived() == archived)\n        descsAndMe.add(row);\n    return descsAndMe;\n}","new_comment_raw":"@return the asked tree.","old_comment_raw":"@return a List of SQLRow.","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":91},{"new_code_raw":"private StreamEvent findIfActualMin(AttributeDetails latestEvent) { int indexCurrentMin = valueStack.indexOf(currentMin); int postBound = valueStack.indexOf(latestEvent) - indexCurrentMin; if (postBound > maxPostBound) { currentMin.notEligibleForRealMin(); return null; } if (maxPreBound == NUM) { StreamEvent outputEvent = eventStack.get(indexCurrentMin); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { STR, NUM, postBound }); currentMin.sentOutputAsRealMin(); return outputEvent; } int preBound = NUM; double dThreshold = currentMin.getValue() + currentMin.getValue() * preBoundChange \/ NUM; while (preBound <= maxPreBound && indexCurrentMin - preBound >= NUM) { if (valueStack.get(indexCurrentMin - preBound).getValue() >= dThreshold) { StreamEvent outputEvent = eventStack.get(indexCurrentMin); complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { STR, preBound, postBound }); currentMin.sentOutputAsRealMin(); return outputEvent; } ++preBound; } currentMin.notEligibleForRealMin(); return null; }","old_code_raw":"private StreamEvent findIfActualMin(attributeDetails latestEvent) {\n    int indexCurrentMin = valueStack.indexOf(currentMin);\n    int actual_L = valueStack.indexOf(latestEvent) - indexCurrentMin;\n    if (actual_L > L) {\n        currentMin.notEligibleForRealMin();\n        return null;\n    }\n    int actual_l = NUM;\n    double dThreshold = currentMin.getValue() + currentMin.getValue() * d \/ NUM;\n    while (actual_l <= l && indexCurrentMin - actual_l >= NUM) {\n        if (valueStack.get(indexCurrentMin - actual_l).getValue() >= dThreshold) {\n            StreamEvent outputEvent = eventStack.get(indexCurrentMin);\n            complexEventPopulater.populateComplexEvent(outputEvent, new Object[] { STR, actual_l, actual_L });\n            currentMin.sentOutputAsRealMin();\n            return outputEvent;\n        }\n        ++actual_l;\n    }\n    currentMin.notEligibleForRealMin();\n    return null;\n}","new_comment_raw":"@return if preBoundChange, maxPostBound conditions are met, send stream event output with extrema type, preBound (distance at which a value satisfying preBoundChange condition is found), postBound (distance at which a value satisfying postBoundChange condition is found)","old_comment_raw":"@return if d, L conditions are met, send stream event output with extrema type, actual_l (distance at which a value satisfying d condition is found), actual_L (distance at which a value satisfying D condition is found)","label":1,"pre_label":0,"AST_level":11,"line_counts":27,"new_code_token_num":178},{"new_code_raw":"public static Seconds parseSeconds(String periodStr) { throw ExceptionUtils.unsupportedInGwt(); \/\/ if (periodStr == null) { \/\/ return Seconds.ZERO; \/\/ } \/\/ Period p = PARSER.parsePeriod(periodStr); \/\/ return Seconds.seconds(p.getSeconds()); }","old_code_raw":"    public static Seconds parseSeconds(String periodStr) {\n        if (periodStr == null) {\n            return Seconds.ZERO;\n        }\n        Period p = PARSER.parsePeriod(periodStr);\n        return Seconds.seconds(p.getSeconds());\n    }\n","new_comment_raw":"@return the period in seconds","old_comment_raw":"@return the period in seconds","label":0,"pre_label":1,"AST_level":4,"line_counts":9,"new_code_token_num":55},{"new_code_raw":"public Date getStart() { if (records.size() == NUM) { return new Date(); } else { Date first = records.get(NUM).getDate(); for (Entry e : records) { if (e.getDate().before(first)) { first = e.getDate(); } } return first; } }","old_code_raw":"public Date getStart() {\n    if (records.size() == NUM) {\n        return null;\n    } else {\n        Date first = records.get(NUM).getDate();\n        for (Entry e : records) {\n            if (e.getDate().before(first)) {\n                first = e.getDate();\n            }\n        }\n        return first;\n    }\n}","new_comment_raw":"@return The time of the first record, or the current time if there are no records","old_comment_raw":"@return The time of the first record or null if there are no records","label":1,"pre_label":0,"AST_level":11,"line_counts":13,"new_code_token_num":68},{"new_code_raw":"public String next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) zzInput = zzBufferL[zzCurrentPosL++]; else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = zzBufferL[zzCurrentPosL++]; } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 180: { return(stem(3,\"te\",\"ed\")); } case 373: break; case 298: { return(stem(1,\"a\",\"s\")); } case 374: break; case 94: { return(stem(3,\"ide\",\"ed\")); } case 375: break; case 126: { return(stem(2,\"al\",\"s\")); } case 376: break; case 15: { return(null_stem()); } case 377: break; case 293: { return(stem(2,\"la\",\"s\")); } case 378: break; case 38: { return(stem(3,\"will\",\"\")); } case 379: break; case 8: { yybegin(scan); if (option(tag_output)) return yytext(); } case 380: break; case 11: { return cnull_stem(); } case 381: break; case 72: { return(stem(3,\"eel\",\"ed\")); } case 382: break; case 173: { return(stem(3,\"eal\",\"ed\")); } case 383: break; case 177: { return(stem(4,\"ake\",\"en\")); } case 384: break; case 134: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"I\",\"\")); } case 385: break; case 133: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(1,\"y\",\"\")); } case 386: break; case 259: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return(stem(1,\"y\",\"\")); } case 387: break; case 89: { return(stem(3,\"ay\",\"ed\")); } case 388: break; case 272: { return(stem(3,\"se\",\"ed\")); } case 389: break; case 95: { return(stem(3,\"ise\",\"ed\")); } case 390: break; case 236: { return(stem(3,\"ike\",\"ed\")); } case 391: break; case 29: { return(ynull_stem()); } case 392: break; case 111: { return(stem(3,\"ell\",\"ed\")); } case 393: break; case 10: { return(stem(1,\"us\",\"s\")); } case 394: break; case 1: { return(common_noun_stem()); } case 395: break; case 13: \/\/ lookahead expression with fixed lookahead length yypushback(1); { return(common_noun_stem()); } case 396: break; case 70: { return(stem(3,\"ly\",\"ed\")); } case 397: break; case 67: { return(stem(3,\"ive\",\"ed\")); } case 398: break; case 356: { return(stem(3,\"is\",\"s\")); } case 399: break; case 239: { return(stem(5,\"eek\",\"ed\")); } case 400: break; case 160: { return(stem(3,\"ar\",\"ed\")); } case 401: break; case 267: { return(stem(4,\"ame\",\"ed\")); } case 402: break; case 33: { return(stem(3,\"see\",\"ed\")); } case 403: break; case 151: { return(stem(3,\"epe\",\"ed\")); } case 404: break; case 21: { return(stem(3,\"get\",\"ed\")); } case 405: break; case 352: { return(stem(8,\"-de-sac\",\"s\")); } case 406: break; case 370: { return(stem(12,\"-in-the-box\",\"s\")); } case 407: break; case 266: { return(stem(5,\"ing\",\"ed\")); } case 408: break; case 182: { return(stem(2,\"i\",\"s\")); } case 409: break; case 162: { return(stem(3,\"an\",\"ed\")); } case 410: break; case 30: { return(stem(3,\"red\",\"ed\")); } case 411: break; case 51: { return(stem(3,\"e\",\"ing\")); } case 412: break; case 214: { return(stem(3,\"ass\",\"ed\")); } case 413: break; case 249: { return(stem(2,\"re\",\"s\")); } case 414: break; case 65: { return(stem(2,\"e\",\"s\")); } case 415: break; case 78: { return(stem(3,\"o\",\"en\")); } case 416: break; case 155: { return(stem(5,\"do\",\"ed\")); } case 417: break; case 71: { return(stem(3,\"all\",\"ed\")); } case 418: break; case 125: { return(stem(2,\"ra\",\"s\")); } case 419: break; case 212: { return(stem(6,\"clepe\",\"ed\")); } case 420: break; case 256: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return(stem(1,\"\",\"\")); } case 421: break; case 60: { return(stem(3,\"ear\",\"ed\")); } case 422: break; case 63: { return(stem(3,\"ome\",\"ed\")); } case 423: break; case 52: { return(stem(1,\"\",\"ed\")); } case 424: break; case 157: { return(stem(3,\"eeze\",\"ed\")); } case 425: break; case 27: { return(stem(3,\"light\",\"ed\")); } case 426: break; case 139: { return(stem(3,\"y\",\"s\")); } case 427: break; case 296: { return(stem(2,\"zo\",\"s\")); } case 428: break; case 31: { return(stem(3,\"run\",\"ed\")); } case 429: break; case 46: { return(stem(2,\"an\",\"s\")); } case 430: break; case 333: { return(stem(3,\"ix\",\"ed\")); } case 431: break; case 304: { return(stem(4,\"g\",\"ing\")); } case 432: break; case 57: { return(stem(3,\"end\",\"ed\")); } case 433: break; case 131: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 7; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return(proper_name_stem()); } case 434: break; case 50: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 1; { return(proper_name_stem()); } case 435: break; case 55: { return(stem(3,\"low\",\"ed\")); } case 436: break; case 193: { return(stem(2,\"ny\",\"s\")); } case 437: break; case 138: { return(stem(3,\"y\",\"ed\")); } case 438: break; case 104: { return(stem(3,\"mite\",\"ed\")); } case 439: break; case 305: { return(stem(3,\"d\",\"en\")); } case 440: break; case 14: { return(stem(2,\"e\",\"ed\")); } case 441: break; case 100: { return(stem(3,\"hoot\",\"ed\")); } case 442: break; case 185: { return(stem(2,\"so\",\"s\")); } case 443: break; case 341: { return(stem(2,\"r\",\"s\")); } case 444: break; case 231: { return(stem(5,\"elt\",\"en\")); } case 445: break; case 225: { return(stem(4,\"eeze\",\"en\")); } case 446: break; case 332: { return(stem(4,\"y\",\"ing\")); } case 447: break; case 130: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzInput = zzBufferL[zzFPos++]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = zzBufferL[--zzFPos]; zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { yybegin(noun); yypushback(yylength()); return(next()); } case 448: break; case 81: { return(stem(3,\"ew\",\"en\")); } case 449: break; case 113: { return(stem(3,\"aw\",\"en\")); } case 450: break; case 49: \/\/ lookahead expression with fixed lookahead length yypushback(2); { yybegin(verb); yypushback(yylength()); return(next()); } case 451: break; case 314: { return(stem(3,\"ship\",\"ed\")); } case 452: break; case 335: { return(stem(1,\"de\",\"s\")); } case 453: break; case 365: { return(stem(9,\"-mutuel\",\"s\")); } case 454: break; case 371: { return(stem(14,\"y-in-waiting\",\"s\")); } case 455: break; case 9: { return(stem(2,\"be\",\"\")); } case 456: break; case 206: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"be\",\"\")); } case 457: break; case 69: { return(stem(3,\"lee\",\"ed\")); } case 458: break; case 40: { return(stem(1,\"um\",\"s\")); } case 459: break; case 56: { return(stem(3,\"reed\",\"ed\")); } case 460: break; case 163: { return(stem(3,\"ap\",\"ed\")); } case 461: break; case 344: { return(stem(2,\"te\",\"s\")); } case 462: break; case 197: { return(stem(3,\"f\",\"s\")); } case 463: break; case 200: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"can\",\"\")); } case 464: break; case 300: { return(stem(2,\"lio\",\"s\")); } case 465: break; case 108: { return(stem(3,\"wim\",\"en\")); } case 466: break; case 91: { return(stem(3,\"ow\",\"en\")); } case 467: break; case 321: { return(stem(2,\"g\",\"s\")); } case 468: break; case 228: { return(semi_reg_stem(1,\"\")); } case 469: break; case 275: { return(stem(2,\"gue\",\"s\")); } case 470: break; case 143: { return(stem(3,\"ei\",\"ed\")); } case 471: break; case 37: { return(stem(3,\"eat\",\"ed\")); } case 472: break; case 17: { return(stem(3,\"bid\",\"ed\")); } case 473: break; case 217: { return(stem(3,\"\",\"en\")); } case 474: break; case 355: { return(stem(10,\"an-at-arms\",\"s\")); } case 475: break; case 132: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"we\",\"\")); } case 476: break; case 244: { return(stem(2,\"ron\",\"s\")); } case 477: break; case 338: { return(stem(2,\"non\",\"s\")); } case 478: break; case 196: { return(stem(2,\"uum\",\"s\")); } case 479: break; case 24: { return(stem(3,\"have\",\"ed\")); } case 480: break; case 345: { return(stem(3,\"ff\",\"s\")); } case 481: break; case 251: { return(stem(2,\"mum\",\"s\")); } case 482: break; case 242: { return(stem(2,\"ie\",\"ed\")); } case 483: break; case 273: { return(stem(2,\"ee\",\"ed\")); } case 484: break; case 334: { return(stem(2,\"do\",\"s\")); } case 485: break; case 262: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"do\",\"s\")); } case 486: break; case 361: { return(stem(6,\"-doux\",\"s\")); } case 487: break; case 299: { return(stem(3,\"ly\",\"s\")); } case 488: break; case 224: { return(stem(4,\"w\",\"ed\")); } case 489: break; case 237: { return(stem(4,\"eal\",\"en\")); } case 490: break; case 253: { return(stem(6,\"m.p.\",\"s\")); } case 491: break; case 45: { return(stem(2,\"\",\"s\")); } case 492: break; case 347: { return(stem(9,\"an-of-war\",\"s\")); } case 493: break; case 90: { return(stem(3,\"ie\",\"en\")); } case 494: break; case 121: { return(stem(2,\"tum\",\"s\")); } case 495: break; case 199: { return(stem(5,\"eyrir\",\"s\")); } case 496: break; case 110: { return(stem(3,\"ee\",\"en\")); } case 497: break; case 204: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"will\",\"\")); } case 498: break; case 250: { return(stem(2,\"ia\",\"s\")); } case 499: break; case 255: { return(stem(3,\"s\",\"s\")); } case 500: break; case 44: { return(stem(2,\"uo\",\"s\")); } case 501: break; case 226: { return(stem(5,\"ight\",\"ed\")); } case 502: break; case 124: { return(stem(3,\"ouse\",\"s\")); } case 503: break; case 359: { return(stem(2,\"t\",\"s\")); } case 504: break; case 7: { return(stem(2,\"be\",\"s\")); } case 505: break; case 260: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"be\",\"s\")); } case 506: break; case 53: { return(semi_reg_stem(0,\"e\")); } case 507: break; case 357: { return(stem(8,\"-in-law\",\"s\")); } case 508: break; case 181: { return(stem(4,\".\",\"s\")); } case 509: break; case 169: { return(stem(3,\"ay\",\"en\")); } case 510: break; case 165: { return(stem(3,\"se\",\"en\")); } case 511: break; case 39: { return(stem(3,\"have\",\"\")); } case 512: break; case 3: { \/\/ The first word isn't stemmed separately, but the second half can be String stem = common_noun_stem(); String n = next(); if (n == null) { return stem; } else { return stem.concat(n); } } case 513: break; case 166: { return(stem(3,\"ine\",\"ed\")); } case 514: break; case 278: { return(stem(5,\"ink\",\"ed\")); } case 515: break; case 326: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 4; { return(stem(4,\"be\",\"ed\")); } case 516: break; case 116: { return(stem(4,\"be\",\"ed\")); } case 517: break; case 360: { return(stem(9,\"-down\",\"ing\")); } case 518: break; case 297: { return(stem(3,\"en\",\"s\")); } case 519: break; case 148: { return(stem(4,\"ear\",\"en\")); } case 520: break; case 362: { return(stem(8,\"-de-lys\",\"s\")); } case 521: break; case 115: { return(stem(4,\"go\",\"ed\")); } case 522: break; case 309: { return(stem(4,\"y\",\"ed\")); } case 523: break; case 42: { return(stem(2,\"a\",\"s\")); } case 524: break; case 189: { return(stem(3,\"x\",\"s\")); } case 525: break; case 61: { return(stem(3,\"id\",\"ed\")); } case 526: break; case 83: { return(stem(4,\"have\",\"s\")); } case 527: break; case 59: { return(stem(3,\"ear\",\"en\")); } case 528: break; case 96: { return(stem(3,\"eeve\",\"ed\")); } case 529: break; case 76: { return(stem(3,\"ild\",\"ed\")); } case 530: break; case 354: { return(stem(10,\"anservant\",\"s\")); } case 531: break; case 202: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,\"he\",\"\")); } case 532: break; case 254: { return(stem(4,\"ex\",\"s\")); } case 533: break; case 150: { return(stem(3,\"oose\",\"ed\")); } case 534: break; case 336: { return(stem(4,\"-in\",\"s\")); } case 535: break; case 285: { return(stem(6,\"ork\",\"ed\")); } case 536: break; case 144: { return(stem(3,\"eak\",\"ed\")); } case 537: break; case 112: { return(stem(3,\"ink\",\"ed\")); } case 538: break; case 241: { return(stem(3,\"a\",\"ed\")); } case 539: break; case 141: { return(stem(3,\"rn\",\"ed\")); } case 540: break; case 330: { return(stem(6,\"-up\",\"ed\")); } case 541: break; case 156: { return(stem(3,\"y\",\"en\")); } case 542: break; case 119: { return(stem(2,\"um\",\"s\")); } case 543: break; case 222: { return(stem(4,\"tch\",\"ed\")); } case 544: break; case 88: { return(stem(3,\"ose\",\"ed\")); } case 545: break; case 25: { return(stem(3,\"have\",\"s\")); } case 546: break; case 101: { return(stem(3,\"hit\",\"ed\")); } case 547: break; case 122: { return(stem(3,\"oot\",\"s\")); } case 548: break; case 68: { return(stem(4,\"do\",\"s\")); } case 549: break; case 97: { return(stem(3,\"ing\",\"ed\")); } case 550: break; case 246: { return(stem(3,\"denum\",\"s\")); } case 551: break; case 353: { return(stem(6,\"-over\",\"s\")); } case 552: break; case 191: { return(stem(1,\"s\",\"s\")); } case 553: break; case 34: { return(stem(3,\"win\",\"ed\")); } case 554: break; case 82: { return(stem(3,\"eave\",\"ed\")); } case 555: break; case 343: { return(stem(7,\"-up\",\"ing\")); } case 556: break; case 74: { return(stem(3,\"eld\",\"ed\")); } case 557: break; case 289: { return(stem(4,\"yatid\",\"s\")); } case 558: break; case 342: { return(stem(4,\"us\",\"s\")); } case 559: break; case 291: { return(stem(1,\"o\",\"s\")); } case 560: break; case 127: { return(stem(2,\"lo\",\"s\")); } case 561: break; case 103: { return(stem(3,\"lide\",\"ed\")); } case 562: break; case 41: { return(stem(2,\".\",\"s\")); } case 563: break; case 175: { return(stem(3,\"and\",\"ed\")); } case 564: break; case 223: { return(stem(3,\"am\",\"ed\")); } case 565: break; case 114: { return(stem(3,\"read\",\"ed\")); } case 566: break; case 263: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"have\",\"s\")); } case 567: break; case 350: { return(stem(8,\"-down\",\"ed\")); } case 568: break; case 209: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"have\",\"ed\")); } case 569: break; case 137: { return(stem(3,\"\",\"ing\")); } case 570: break; case 146: { return(stem(5,\"be\",\"ing\")); } case 571: break; case 219: { return(stem(4,\"te\",\"ing\")); } case 572: break; case 322: { return(stem(4,\"isee\",\"s\")); } case 573: break; case 118: { return(stem(1,\"on\",\"s\")); } case 574: break; case 117: { return(stem(2,\"\",\"ed\")); } case 575: break; case 307: { return(stem(4,\"y\",\"s\")); } case 576: break; case 346: { return(stem(4,\"-on\",\"s\")); } case 577: break; case 337: { return(stem(8,\"onsieur\",\"s\")); } case 578: break; case 178: { return(stem(4,\"eave\",\"en\")); } case 579: break; case 248: { return(stem(3,\"us\",\"s\")); } case 580: break; case 366: { return(stem(9,\"-de-camp\",\"s\")); } case 581: break; case 201: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,\"she\",\"\")); } case 582: break; case 64: { return(stem(3,\"raw\",\"ed\")); } case 583: break; case 317: { return(stem(2,\"cio\",\"s\")); } case 584: break; case 372: { return(stem(11,\"y-general\",\"s\")); } case 585: break; case 320: { return(stem(2,\"eum\",\"s\")); } case 586: break; case 369: { return(stem(9,\"-at-arms\",\"s\")); } case 587: break; case 315: { return(stem(2,\"ion\",\"s\")); } case 588: break; case 368: { return(stem(11,\"erfamilias\",\"s\")); } case 589: break; case 328: { return(stem(6,\"-down\",\"s\")); } case 590: break; case 288: { return(stem(1,\"x\",\"s\")); } case 591: break; case 323: { return(stem(2,\"oan\",\"s\")); } case 592: break; case 306: { return(stem(5,\"eech\",\"ed\")); } case 593: break; case 73: { return(stem(3,\"row\",\"ed\")); } case 594: break; case 4: { return yytext(); } case 595: break; case 292: { return(stem(2,\"ro\",\"s\")); } case 596: break; case 252: { return(stem(3,\"ey\",\"s\")); } case 597: break; case 324: { return(stem(2,\"ton\",\"s\")); } case 598: break; case 5: { return(stem(1,\"\",\"s\")); } case 599: break; case 303: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,\"be\",\"\")); } case 600: break; case 36: { return(stem(3,\"be\",\"\")); } case 601: break; case 229: { return(stem(5,\"et\",\"en\")); } case 602: break; case 99: { return(stem(3,\"hoe\",\"ed\")); } case 603: break; case 164: { return(stem(3,\"de\",\"en\")); } case 604: break; case 43: { return(xnull_stem()); } case 605: break; case 363: { return(stem(8,\"-de-lis\",\"s\")); } case 606: break; case 207: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"have\",\"\")); } case 607: break; case 271: { return(stem(5,\"ivy\",\"s\")); } case 608: break; case 238: { return(stem(3,\"ge\",\"ed\")); } case 609: break; case 233: { return(stem(3,\"ce\",\"ed\")); } case 610: break; case 176: { return(stem(3,\"ke\",\"en\")); } case 611: break; case 105: { return(stem(3,\"pin\",\"ed\")); } case 612: break; case 287: { return(stem(2,\"no\",\"s\")); } case 613: break; case 312: { return(semi_reg_stem(0,\"ue\")); } case 614: break; case 235: { return(stem(3,\"il\",\"ed\")); } case 615: break; case 351: { return(stem(2,\"l\",\"s\")); } case 616: break; case 167: { return(semi_reg_stem(0,\"\")); } case 617: break; case 159: { return(stem(3,\"ve\",\"en\")); } case 618: break; case 203: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(2,\"e\",\"\")); } case 619: break; case 234: { return(stem(5,\"ink\",\"en\")); } case 620: break; case 145: { return(stem(3,\"gin\",\"ed\")); } case 621: break; case 286: { return(stem(5,\"y\",\"ed\")); } case 622: break; case 205: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,\"we\",\"\")); } case 623: break; case 171: { return(stem(3,\"ill\",\"ed\")); } case 624: break; case 232: { return(stem(3,\"ue\",\"ed\")); } case 625: break; case 245: { return(stem(1,\"i\",\"s\")); } case 626: break; case 183: { return(stem(2,\"d\",\"s\")); } case 627: break; case 19: { return(stem(3,\"do\",\"ed\")); } case 628: break; case 58: { return(stem(4,\"be\",\"en\")); } case 629: break; case 270: { return(stem(5,\"ivy\",\"ed\")); } case 630: break; case 168: { return(stem(3,\"i\",\"ed\")); } case 631: break; case 187: { return(stem(1,\"e\",\"s\")); } case 632: break; case 340: { return(stem(2,\"le\",\"s\")); } case 633: break; case 280: { return(stem(5,\"ead\",\"en\")); } case 634: break; case 301: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 5; { return(stem(2,\"y\",\"\")); } case 635: break; case 149: { return(stem(3,\"rse\",\"ed\")); } case 636: break; case 66: { return(stem(4,\"do\",\"en\")); } case 637: break; case 170: { return(stem(3,\"ite\",\"ed\")); } case 638: break; case 227: { return(stem(3,\"l\",\"en\")); } case 639: break; case 128: { return(stem(4,\"ABC\",\"s\")); } case 640: break; case 106: { return(stem(3,\"peed\",\"ed\")); } case 641: break; case 215: { return(stem(4,\"eak\",\"en\")); } case 642: break; case 28: { return(stem(3,\"meet\",\"ed\")); } case 643: break; case 348: { return(stem(4,\"-by\",\"s\")); } case 644: break; case 135: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(1, \"\", \"n\")); } case 645: break; case 325: { return(stem(4,\"s\",\"s\")); } case 646: break; case 318: { return(stem(3,\"esis\",\"s\")); } case 647: break; case 230: { return(stem(3,\"ey\",\"ed\")); } case 648: break; case 142: { return(stem(3,\"ess\",\"ed\")); } case 649: break; case 218: { return(stem(3,\"e\",\"en\")); } case 650: break; case 349: { return(stem(4,\"o\",\"s\")); } case 651: break; case 152: { return(stem(4,\"are\",\"ed\")); } case 652: break; case 147: { return(stem(4,\"ind\",\"ed\")); } case 653: break; case 172: { return(stem(3,\"ick\",\"ed\")); } case 654: break; case 153: { return(stem(4,\"ie\",\"ing\")); } case 655: break; case 107: { return(stem(3,\"pit\",\"ed\")); } case 656: break; case 184: { return(stem(2,\"u\",\"s\")); } case 657: break; case 129: { return(stem(2,\"to\",\"s\")); } case 658: break; case 268: { return(stem(3,\"ride\",\"ed\")); } case 659: break; case 186: { return(stem(2,\"denum\",\"s\")); } case 660: break; case 290: { return(stem(4,\"sbok\",\"s\")); } case 661: break; case 308: { return(stem(6,\"ivy\",\"ing\")); } case 662: break; case 367: { return(stem(13,\"ademoiselle\",\"s\")); } case 663: break; case 195: { return(stem(4,\"ooth\",\"s\")); } case 664: break; case 20: { return(stem(3,\"feed\",\"ed\")); } case 665: break; case 98: { return(stem(3,\"ink\",\"en\")); } case 666: break; case 92: { return(stem(3,\"ake\",\"ed\")); } case 667: break; case 62: { return(stem(3,\"lothe\",\"ed\")); } case 668: break; case 18: { return(stem(3,\"dig\",\"ed\")); } case 669: break; case 279: { return(stem(4,\"k\",\"ed\")); } case 670: break; case 194: { return(stem(2,\"po\",\"s\")); } case 671: break; case 221: { return(stem(3,\"ose\",\"en\")); } case 672: break; case 174: { return(stem(3,\"ave\",\"ed\")); } case 673: break; case 77: { return(stem(3,\"ird\",\"ed\")); } case 674: break; case 161: { return(stem(3,\"in\",\"ed\")); } case 675: break; case 210: { return(stem(4,\"\",\"ing\")); } case 676: break; case 85: { return(stem(3,\"en\",\"ed\")); } case 677: break; case 87: { return(stem(3,\"o\",\"ed\")); } case 678: break; case 281: { return(stem(3,\"mel\",\"s\")); } case 679: break; case 274: { return(stem(4,\"-up\",\"s\")); } case 680: break; case 12: { return(stem(2,\"is\",\"s\")); } case 681: break; case 23: { return(stem(3,\"hide\",\"ed\")); } case 682: break; case 93: { return(stem(3,\"ing\",\"en\")); } case 683: break; case 257: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,\"not\",\"\")); } case 684: break; case 283: { return(stem(4,\"i\",\"ing\")); } case 685: break; case 243: { return(stem(4,\"e\",\"ing\")); } case 686: break; case 284: { return(stem(4,\"a\",\"ing\")); } case 687: break; case 136: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"'s\",\"\")); } case 688: break; case 264: { return(condub_stem(3,\"\",\"ing\")); } case 689: break; case 120: { return(stem(3,\"a\",\"s\")); } case 690: break; case 327: { return(stem(4,\"l\",\"ing\")); } case 691: break; case 316: { return(stem(2,\"ne\",\"s\")); } case 692: break; case 247: { return(stem(3,\"ur\",\"s\")); } case 693: break; case 198: { return(stem(2,\"b\",\"s\")); } case 694: break; case 220: { return(stem(5,\"uy\",\"ed\")); } case 695: break; case 258: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,\"shall\",\"\")); } case 696: break; case 190: { return(stem(3,\"fe\",\"s\")); } case 697: break; case 216: { return(stem(2,\"\",\"en\")); } case 698: break; case 311: { return(stem(5,\"ify\",\"s\")); } case 699: break; case 313: { return(stem(5,\"k\",\"ing\")); } case 700: break; case 6: { return(cnull_stem()); } case 701: break; case 80: { return(stem(3,\"old\",\"ed\")); } case 702: break; case 339: { return(stem(4,\"ese\",\"s\")); } case 703: break; case 2: { String str = yytext(); int first = str.charAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s) - this may be because your text isn't using _ as a tag delimiter\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); LOGGER.warning(msg); } case 704: break; case 294: { return(stem(2,\"dum\",\"s\")); } case 705: break; case 47: { return(stem(2,\"s\",\"s\")); } case 706: break; case 329: { return(stem(5,\"y\",\"ing\")); } case 707: break; case 358: { return(stem(6,\"-lit\",\"s\")); } case 708: break; case 158: { return(stem(3,\"ip\",\"ed\")); } case 709: break; case 79: { return(stem(3,\"ang\",\"ed\")); } case 710: break; case 331: { return(stem(6,\"ify\",\"ing\")); } case 711: break; case 295: { return(stem(4,\"belly\",\"s\")); } case 712: break; case 188: { return(stem(4,\"oose\",\"s\")); } case 713: break; case 282: { return(stem(4,\"ge\",\"ing\")); } case 714: break; case 109: { return(stem(3,\"wim\",\"ed\")); } case 715: break; case 179: { return(stem(3,\"t\",\"en\")); } case 716: break; case 276: { return(stem(4,\"ue\",\"ing\")); } case 717: break; case 48: { return(stem(2,\"vum\",\"s\")); } case 718: break; case 123: { return(stem(2,\"rum\",\"s\")); } case 719: break; case 192: { return(stem(2,\"num\",\"s\")); } case 720: break; case 102: { return(stem(3,\"lay\",\"ed\")); } case 721: break; case 277: { return(stem(5,\"ell\",\"en\")); } case 722: break; case 140: { return(stem(3,\"\",\"ed\")); } case 723: break; case 261: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"as\",\"\")); } case 724: break; case 16: { return(stem(3,\"bite\",\"ed\")); } case 725: break; case 154: { return(stem(3,\"al\",\"ed\")); } case 726: break; case 213: { return(stem(3,\"\",\"s\")); } case 727: break; case 302: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 3; { return(stem(3,\"be\",\"ed\")); } case 728: break; case 35: { return(stem(3,\"be\",\"ed\")); } case 729: break; case 32: { return(stem(3,\"sit\",\"ed\")); } case 730: break; case 240: { return(stem(5,\"each\",\"ed\")); } case 731: break; case 364: { return(stem(9,\"-a-terre\",\"s\")); } case 732: break; case 84: { return(stem(3,\"now\",\"ed\")); } case 733: break; case 22: { return(stem(3,\"gin\",\"en\")); } case 734: break; case 269: { return(stem(3,\"ie\",\"ed\")); } case 735: break; case 75: { return(stem(3,\"ee\",\"ed\")); } case 736: break; case 86: { return(stem(3,\"eep\",\"ed\")); } case 737: break; case 208: \/\/ lookahead expression with fixed base length zzMarkedPos = zzStartRead + 2; { return(stem(2,\"would\",\"\")); } case 738: break; case 54: { return(stem(3,\"leed\",\"ed\")); } case 739: break; case 26: { return(stem(3,\"lead\",\"ed\")); } case 740: break; case 265: { return(stem(7,\"clepe\",\"ed\")); } case 741: break; case 319: { return(stem(4,\"eps\",\"s\")); } case 742: break; case 310: { return(stem(5,\"ify\",\"ed\")); } case 743: break; case 211: { return(condub_stem(2,\"\",\"ed\")); } case 744: break; default: if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { return null; } } else { zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public String next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 1: \n          { return(common_noun_stem());\n          }\n        case 382: break;\n        case 2: \n          { return(stem(1,\"be\",\"\"));\n          }\n        case 383: break;\n        case 3: \n          { return(stem(1,\"have\",\"\"));\n          }\n        case 384: break;\n        case 4: \n          { String str = yytext();\n                            int first = str.charAt(0);\n\t                          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s) - this may be because your text isn't using _ as a tag delimiter\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n                  LOGGER.warning(msg);\n          }\n        case 385: break;\n        case 5: \n          { \/\/ The first word isn't stemmed separately, but the second half can be\n                            String stem = common_noun_stem();\n                            String n = next();\n                            if (n == null) {\n                              return stem;\n                            } else {\n                              return stem.concat(n);\n                            }\n          }\n        case 386: break;\n        case 6: \n          { return yytext();\n          }\n        case 387: break;\n        case 7: \n          { return(stem(1,\"\",\"s\"));\n          }\n        case 388: break;\n        case 8: \n          { return(cnull_stem());\n          }\n        case 389: break;\n        case 9: \n          { return(stem(1,\"o\",\"\"));\n          }\n        case 390: break;\n        case 10: \n          { return(stem(2,\"know\",\"\"));\n          }\n        case 391: break;\n        case 11: \n          { return(stem(2,\"be\",\"\"));\n          }\n        case 392: break;\n        case 12: \n          { return(stem(2,\"have\",\"\"));\n          }\n        case 393: break;\n        case 13: \n          { return(stem(2,\"be\",\"s\"));\n          }\n        case 394: break;\n        case 14: \n          { yybegin(scan); if (option(tag_output)) return yytext();\n          }\n        case 395: break;\n        case 15: \n          { return(stem(1,\"us\",\"s\"));\n          }\n        case 396: break;\n        case 16: \n          { return cnull_stem();\n          }\n        case 397: break;\n        case 17: \n          { return(stem(2,\"is\",\"s\"));\n          }\n        case 398: break;\n        case 18: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return(common_noun_stem());\n          }\n        case 399: break;\n        case 19: \n          { return(stem(2,\"e\",\"ed\"));\n          }\n        case 400: break;\n        case 20: \n          { return(null_stem());\n          }\n        case 401: break;\n        case 21: \n          { return(stem(3,\"bite\",\"ed\"));\n          }\n        case 402: break;\n        case 22: \n          { return(stem(3,\"bid\",\"ed\"));\n          }\n        case 403: break;\n        case 23: \n          { return(stem(3,\"dig\",\"ed\"));\n          }\n        case 404: break;\n        case 24: \n          { return(stem(3,\"do\",\"ed\"));\n          }\n        case 405: break;\n        case 25: \n          { return(stem(3,\"feed\",\"ed\"));\n          }\n        case 406: break;\n        case 26: \n          { return(stem(3,\"get\",\"ed\"));\n          }\n        case 407: break;\n        case 27: \n          { return(stem(3,\"gin\",\"en\"));\n          }\n        case 408: break;\n        case 28: \n          { return(stem(3,\"hide\",\"ed\"));\n          }\n        case 409: break;\n        case 29: \n          { return(stem(1,\"ve\",\"ed\"));\n          }\n        case 410: break;\n        case 30: \n          { return(stem(1,\"ve\",\"s\"));\n          }\n        case 411: break;\n        case 31: \n          { return(stem(3,\"lead\",\"ed\"));\n          }\n        case 412: break;\n        case 32: \n          { return(stem(3,\"light\",\"ed\"));\n          }\n        case 413: break;\n        case 33: \n          { return(stem(3,\"meet\",\"ed\"));\n          }\n        case 414: break;\n        case 34: \n          { return(ynull_stem());\n          }\n        case 415: break;\n        case 35: \n          { return(stem(3,\"red\",\"ed\"));\n          }\n        case 416: break;\n        case 36: \n          { return(stem(3,\"run\",\"ed\"));\n          }\n        case 417: break;\n        case 37: \n          { return(stem(3,\"sit\",\"ed\"));\n          }\n        case 418: break;\n        case 38: \n          { return(stem(3,\"see\",\"ed\"));\n          }\n        case 419: break;\n        case 39: \n          { return(stem(3,\"win\",\"ed\"));\n          }\n        case 420: break;\n        case 40: \n          { return(stem(3,\"be\",\"ed\"));\n          }\n        case 421: break;\n        case 41: \n          { return(stem(3,\"be\",\"\"));\n          }\n        case 422: break;\n        case 42: \n          { return(stem(3,\"eat\",\"ed\"));\n          }\n        case 423: break;\n        case 43: \n          { return(stem(3,\"will\",\"\"));\n          }\n        case 424: break;\n        case 44: \n          { return(stem(3,\"have\",\"\"));\n          }\n        case 425: break;\n        case 45: \n          { return(stem(1,\"um\",\"s\"));\n          }\n        case 426: break;\n        case 46: \n          { return(stem(2,\".\",\"s\"));\n          }\n        case 427: break;\n        case 47: \n          { return(stem(2,\"a\",\"s\"));\n          }\n        case 428: break;\n        case 48: \n          { return(xnull_stem());\n          }\n        case 429: break;\n        case 49: \n          { return(stem(2,\"uo\",\"s\"));\n          }\n        case 430: break;\n        case 50: \n          { return(stem(2,\"\",\"s\"));\n          }\n        case 431: break;\n        case 51: \n          { return(stem(2,\"an\",\"s\"));\n          }\n        case 432: break;\n        case 52: \n          { return(stem(2,\"s\",\"s\"));\n          }\n        case 433: break;\n        case 53: \n          { return(stem(2,\"vum\",\"s\"));\n          }\n        case 434: break;\n        case 54: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(2);\n          { yybegin(verb); yypushback(yylength()); return(next());\n          }\n        case 435: break;\n        case 55: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { return(proper_name_stem());\n          }\n        case 436: break;\n        case 56: \n          { return(stem(3,\"e\",\"ing\"));\n          }\n        case 437: break;\n        case 57: \n          { return(stem(1,\"\",\"ed\"));\n          }\n        case 438: break;\n        case 58: \n          { return(semi_reg_stem(0,\"e\"));\n          }\n        case 439: break;\n        case 59: \n          { return(stem(3,\"leed\",\"ed\"));\n          }\n        case 440: break;\n        case 60: \n          { return(stem(3,\"low\",\"ed\"));\n          }\n        case 441: break;\n        case 61: \n          { return(stem(3,\"reed\",\"ed\"));\n          }\n        case 442: break;\n        case 62: \n          { return(stem(3,\"end\",\"ed\"));\n          }\n        case 443: break;\n        case 63: \n          { return(stem(4,\"be\",\"en\"));\n          }\n        case 444: break;\n        case 64: \n          { return(stem(3,\"ear\",\"en\"));\n          }\n        case 445: break;\n        case 65: \n          { return(stem(3,\"ear\",\"ed\"));\n          }\n        case 446: break;\n        case 66: \n          { return(stem(3,\"id\",\"ed\"));\n          }\n        case 447: break;\n        case 67: \n          { return(stem(3,\"lothe\",\"ed\"));\n          }\n        case 448: break;\n        case 68: \n          { return(stem(3,\"ome\",\"ed\"));\n          }\n        case 449: break;\n        case 69: \n          { return(stem(3,\"raw\",\"ed\"));\n          }\n        case 450: break;\n        case 70: \n          { return(stem(2,\"e\",\"s\"));\n          }\n        case 451: break;\n        case 71: \n          { return(stem(4,\"do\",\"en\"));\n          }\n        case 452: break;\n        case 72: \n          { return(stem(3,\"ive\",\"ed\"));\n          }\n        case 453: break;\n        case 73: \n          { return(stem(3,\"lee\",\"ed\"));\n          }\n        case 454: break;\n        case 74: \n          { return(stem(3,\"ly\",\"ed\"));\n          }\n        case 455: break;\n        case 75: \n          { return(stem(3,\"all\",\"ed\"));\n          }\n        case 456: break;\n        case 76: \n          { return(stem(3,\"eel\",\"ed\"));\n          }\n        case 457: break;\n        case 77: \n          { return(stem(3,\"row\",\"ed\"));\n          }\n        case 458: break;\n        case 78: \n          { return(stem(3,\"eld\",\"ed\"));\n          }\n        case 459: break;\n        case 79: \n          { return(stem(3,\"ee\",\"ed\"));\n          }\n        case 460: break;\n        case 80: \n          { return(stem(3,\"ild\",\"ed\"));\n          }\n        case 461: break;\n        case 81: \n          { return(stem(3,\"ird\",\"ed\"));\n          }\n        case 462: break;\n        case 82: \n          { return(stem(3,\"o\",\"en\"));\n          }\n        case 463: break;\n        case 83: \n          { return(stem(3,\"ang\",\"ed\"));\n          }\n        case 464: break;\n        case 84: \n          { return(stem(3,\"old\",\"ed\"));\n          }\n        case 465: break;\n        case 85: \n          { return(stem(3,\"ew\",\"en\"));\n          }\n        case 466: break;\n        case 86: \n          { return(stem(3,\"eave\",\"ed\"));\n          }\n        case 467: break;\n        case 87: \n          { return(stem(2,\"ve\",\"s\"));\n          }\n        case 468: break;\n        case 88: \n          { return(stem(3,\"now\",\"ed\"));\n          }\n        case 469: break;\n        case 89: \n          { return(stem(3,\"en\",\"ed\"));\n          }\n        case 470: break;\n        case 90: \n          { return(stem(3,\"eep\",\"ed\"));\n          }\n        case 471: break;\n        case 91: \n          { return(stem(3,\"o\",\"ed\"));\n          }\n        case 472: break;\n        case 92: \n          { return(stem(3,\"ose\",\"ed\"));\n          }\n        case 473: break;\n        case 93: \n          { return(stem(3,\"ay\",\"ed\"));\n          }\n        case 474: break;\n        case 94: \n          { return(stem(3,\"ie\",\"en\"));\n          }\n        case 475: break;\n        case 95: \n          { return(stem(3,\"ow\",\"en\"));\n          }\n        case 476: break;\n        case 96: \n          { return(stem(3,\"ake\",\"ed\"));\n          }\n        case 477: break;\n        case 97: \n          { return(stem(3,\"ing\",\"en\"));\n          }\n        case 478: break;\n        case 98: \n          { return(stem(3,\"ide\",\"ed\"));\n          }\n        case 479: break;\n        case 99: \n          { return(stem(3,\"ise\",\"ed\"));\n          }\n        case 480: break;\n        case 100: \n          { return(stem(3,\"eeve\",\"ed\"));\n          }\n        case 481: break;\n        case 101: \n          { return(stem(3,\"ing\",\"ed\"));\n          }\n        case 482: break;\n        case 102: \n          { return(stem(3,\"ink\",\"en\"));\n          }\n        case 483: break;\n        case 103: \n          { return(stem(3,\"hoe\",\"ed\"));\n          }\n        case 484: break;\n        case 104: \n          { return(stem(3,\"hoot\",\"ed\"));\n          }\n        case 485: break;\n        case 105: \n          { return(stem(3,\"hit\",\"ed\"));\n          }\n        case 486: break;\n        case 106: \n          { return(stem(3,\"lay\",\"ed\"));\n          }\n        case 487: break;\n        case 107: \n          { return(stem(3,\"lide\",\"ed\"));\n          }\n        case 488: break;\n        case 108: \n          { return(stem(3,\"mite\",\"ed\"));\n          }\n        case 489: break;\n        case 109: \n          { return(stem(3,\"pin\",\"ed\"));\n          }\n        case 490: break;\n        case 110: \n          { return(stem(3,\"peed\",\"ed\"));\n          }\n        case 491: break;\n        case 111: \n          { return(stem(3,\"pit\",\"ed\"));\n          }\n        case 492: break;\n        case 112: \n          { return(stem(3,\"wim\",\"en\"));\n          }\n        case 493: break;\n        case 113: \n          { return(stem(3,\"wim\",\"ed\"));\n          }\n        case 494: break;\n        case 114: \n          { return(stem(3,\"ee\",\"en\"));\n          }\n        case 495: break;\n        case 115: \n          { return(stem(3,\"ell\",\"ed\"));\n          }\n        case 496: break;\n        case 116: \n          { return(stem(3,\"ink\",\"ed\"));\n          }\n        case 497: break;\n        case 117: \n          { return(stem(3,\"aw\",\"en\"));\n          }\n        case 498: break;\n        case 118: \n          { return(stem(3,\"read\",\"ed\"));\n          }\n        case 499: break;\n        case 119: \n          { return(stem(4,\"go\",\"ed\"));\n          }\n        case 500: break;\n        case 120: \n          { return(stem(4,\"be\",\"ed\"));\n          }\n        case 501: break;\n        case 121: \n          { return(stem(2,\"\",\"ed\"));\n          }\n        case 502: break;\n        case 122: \n          { return(stem(1,\"on\",\"s\"));\n          }\n        case 503: break;\n        case 123: \n          { return(stem(2,\"um\",\"s\"));\n          }\n        case 504: break;\n        case 124: \n          { return(stem(3,\"a\",\"s\"));\n          }\n        case 505: break;\n        case 125: \n          { return(stem(2,\"tum\",\"s\"));\n          }\n        case 506: break;\n        case 126: \n          { return(stem(3,\"oot\",\"s\"));\n          }\n        case 507: break;\n        case 127: \n          { return(stem(2,\"rum\",\"s\"));\n          }\n        case 508: break;\n        case 128: \n          { return(stem(3,\"ouse\",\"s\"));\n          }\n        case 509: break;\n        case 129: \n          { return(stem(2,\"ra\",\"s\"));\n          }\n        case 510: break;\n        case 130: \n          { return(stem(2,\"al\",\"s\"));\n          }\n        case 511: break;\n        case 131: \n          { return(stem(2,\"lo\",\"s\"));\n          }\n        case 512: break;\n        case 132: \n          { return(stem(4,\"ABC\",\"s\"));\n          }\n        case 513: break;\n        case 133: \n          { return(stem(2,\"to\",\"s\"));\n          }\n        case 514: break;\n        case 134: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"we\",\"\"));\n          }\n        case 515: break;\n        case 135: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { return(stem(1,\"would\",\"\"));\n          }\n        case 516: break;\n        case 136: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(1,\"y\",\"\"));\n          }\n        case 517: break;\n        case 137: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"I\",\"\"));\n          }\n        case 518: break;\n        case 138: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { return(stem(1,\"not\",\"\"));\n          }\n        case 519: break;\n        case 139: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(1, \"\", \"n\"));\n          }\n        case 520: break;\n        case 140: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"'s\",\"\"));\n          }\n        case 521: break;\n        case 141: \n          { return(stem(3,\"\",\"ing\"));\n          }\n        case 522: break;\n        case 142: \n          { return(stem(3,\"y\",\"ed\"));\n          }\n        case 523: break;\n        case 143: \n          { return(stem(3,\"y\",\"s\"));\n          }\n        case 524: break;\n        case 144: \n          { return(stem(3,\"\",\"ed\"));\n          }\n        case 525: break;\n        case 145: \n          { return(stem(3,\"rn\",\"ed\"));\n          }\n        case 526: break;\n        case 146: \n          { return(stem(3,\"ess\",\"ed\"));\n          }\n        case 527: break;\n        case 147: \n          { return(stem(3,\"ei\",\"ed\"));\n          }\n        case 528: break;\n        case 148: \n          { return(stem(3,\"eak\",\"ed\"));\n          }\n        case 529: break;\n        case 149: \n          { return(stem(3,\"gin\",\"ed\"));\n          }\n        case 530: break;\n        case 150: \n          { return(stem(5,\"be\",\"ing\"));\n          }\n        case 531: break;\n        case 151: \n          { return(stem(4,\"ind\",\"ed\"));\n          }\n        case 532: break;\n        case 152: \n          { return(stem(4,\"ear\",\"en\"));\n          }\n        case 533: break;\n        case 153: \n          { return(stem(3,\"rse\",\"ed\"));\n          }\n        case 534: break;\n        case 154: \n          { return(stem(3,\"oose\",\"ed\"));\n          }\n        case 535: break;\n        case 155: \n          { return(stem(3,\"epe\",\"ed\"));\n          }\n        case 536: break;\n        case 156: \n          { return(stem(4,\"are\",\"ed\"));\n          }\n        case 537: break;\n        case 157: \n          { return(stem(4,\"ie\",\"ing\"));\n          }\n        case 538: break;\n        case 158: \n          { return(stem(3,\"al\",\"ed\"));\n          }\n        case 539: break;\n        case 159: \n          { return(stem(5,\"do\",\"ed\"));\n          }\n        case 540: break;\n        case 160: \n          { return(stem(3,\"y\",\"en\"));\n          }\n        case 541: break;\n        case 161: \n          { return(stem(3,\"eeze\",\"ed\"));\n          }\n        case 542: break;\n        case 162: \n          { return(stem(3,\"ip\",\"ed\"));\n          }\n        case 543: break;\n        case 163: \n          { return(stem(3,\"ve\",\"en\"));\n          }\n        case 544: break;\n        case 164: \n          { return(stem(3,\"ar\",\"ed\"));\n          }\n        case 545: break;\n        case 165: \n          { return(stem(3,\"in\",\"ed\"));\n          }\n        case 546: break;\n        case 166: \n          { return(stem(3,\"an\",\"ed\"));\n          }\n        case 547: break;\n        case 167: \n          { return(stem(3,\"ap\",\"ed\"));\n          }\n        case 548: break;\n        case 168: \n          { return(stem(3,\"de\",\"en\"));\n          }\n        case 549: break;\n        case 169: \n          { return(stem(3,\"se\",\"en\"));\n          }\n        case 550: break;\n        case 170: \n          { return(stem(3,\"ine\",\"ed\"));\n          }\n        case 551: break;\n        case 171: \n          { return(semi_reg_stem(0,\"\"));\n          }\n        case 552: break;\n        case 172: \n          { return(stem(3,\"i\",\"ed\"));\n          }\n        case 553: break;\n        case 173: \n          { return(stem(3,\"ay\",\"en\"));\n          }\n        case 554: break;\n        case 174: \n          { return(stem(3,\"ite\",\"ed\"));\n          }\n        case 555: break;\n        case 175: \n          { return(stem(3,\"ill\",\"ed\"));\n          }\n        case 556: break;\n        case 176: \n          { return(stem(3,\"ick\",\"ed\"));\n          }\n        case 557: break;\n        case 177: \n          { return(stem(3,\"eal\",\"ed\"));\n          }\n        case 558: break;\n        case 178: \n          { return(stem(3,\"ave\",\"ed\"));\n          }\n        case 559: break;\n        case 179: \n          { return(stem(3,\"and\",\"ed\"));\n          }\n        case 560: break;\n        case 180: \n          { return(stem(3,\"ke\",\"en\"));\n          }\n        case 561: break;\n        case 181: \n          { return(stem(4,\"ake\",\"en\"));\n          }\n        case 562: break;\n        case 182: \n          { return(stem(4,\"eave\",\"en\"));\n          }\n        case 563: break;\n        case 183: \n          { return(stem(3,\"t\",\"en\"));\n          }\n        case 564: break;\n        case 184: \n          { return(stem(3,\"te\",\"ed\"));\n          }\n        case 565: break;\n        case 185: \n          { return(stem(4,\".\",\"s\"));\n          }\n        case 566: break;\n        case 186: \n          { return(stem(2,\"i\",\"s\"));\n          }\n        case 567: break;\n        case 187: \n          { return(stem(2,\"d\",\"s\"));\n          }\n        case 568: break;\n        case 188: \n          { return(stem(2,\"u\",\"s\"));\n          }\n        case 569: break;\n        case 189: \n          { return(stem(2,\"so\",\"s\"));\n          }\n        case 570: break;\n        case 190: \n          { return(stem(2,\"denum\",\"s\"));\n          }\n        case 571: break;\n        case 191: \n          { return(stem(1,\"e\",\"s\"));\n          }\n        case 572: break;\n        case 192: \n          { return(stem(4,\"oose\",\"s\"));\n          }\n        case 573: break;\n        case 193: \n          { return(stem(3,\"x\",\"s\"));\n          }\n        case 574: break;\n        case 194: \n          { return(stem(3,\"fe\",\"s\"));\n          }\n        case 575: break;\n        case 195: \n          { return(stem(1,\"s\",\"s\"));\n          }\n        case 576: break;\n        case 196: \n          { return(stem(2,\"num\",\"s\"));\n          }\n        case 577: break;\n        case 197: \n          { return(stem(2,\"ny\",\"s\"));\n          }\n        case 578: break;\n        case 198: \n          { return(stem(2,\"po\",\"s\"));\n          }\n        case 579: break;\n        case 199: \n          { return(stem(4,\"ooth\",\"s\"));\n          }\n        case 580: break;\n        case 200: \n          { return(stem(2,\"uum\",\"s\"));\n          }\n        case 581: break;\n        case 201: \n          { return(stem(3,\"f\",\"s\"));\n          }\n        case 582: break;\n        case 202: \n          { return(stem(2,\"b\",\"s\"));\n          }\n        case 583: break;\n        case 203: \n          { return(stem(5,\"eyrir\",\"s\"));\n          }\n        case 584: break;\n        case 204: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(4);\n          { yybegin(noun); yypushback(yylength()); return(next());\n          }\n        case 585: break;\n        case 205: \n          \/\/ lookahead expression with fixed lookahead length\n          yypushback(4);\n          { return(proper_name_stem());\n          }\n        case 586: break;\n        case 206: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"can\",\"\"));\n          }\n        case 587: break;\n        case 207: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return(stem(3,\"she\",\"\"));\n          }\n        case 588: break;\n        case 208: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return(stem(3,\"he\",\"\"));\n          }\n        case 589: break;\n        case 209: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return(stem(2,\"e\",\"\"));\n          }\n        case 590: break;\n        case 210: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"will\",\"\"));\n          }\n        case 591: break;\n        case 211: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 1;\n          { return(stem(1,\"be\",\"s\"));\n          }\n        case 592: break;\n        case 212: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return(stem(3,\"we\",\"\"));\n          }\n        case 593: break;\n        case 213: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"be\",\"\"));\n          }\n        case 594: break;\n        case 214: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"have\",\"\"));\n          }\n        case 595: break;\n        case 215: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"would\",\"\"));\n          }\n        case 596: break;\n        case 216: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"have\",\"ed\"));\n          }\n        case 597: break;\n        case 217: \n          { return(stem(4,\"\",\"ing\"));\n          }\n        case 598: break;\n        case 218: \n          { return(condub_stem(2,\"\",\"ed\"));\n          }\n        case 599: break;\n        case 219: \n          { return(stem(6,\"clepe\",\"ed\"));\n          }\n        case 600: break;\n        case 220: \n          { return(stem(3,\"\",\"s\"));\n          }\n        case 601: break;\n        case 221: \n          { return(stem(3,\"ass\",\"ed\"));\n          }\n        case 602: break;\n        case 222: \n          { return(stem(4,\"eak\",\"en\"));\n          }\n        case 603: break;\n        case 223: \n          { return(stem(2,\"\",\"en\"));\n          }\n        case 604: break;\n        case 224: \n          { return(stem(3,\"\",\"en\"));\n          }\n        case 605: break;\n        case 225: \n          { return(stem(3,\"e\",\"en\"));\n          }\n        case 606: break;\n        case 226: \n          { return(stem(4,\"te\",\"ing\"));\n          }\n        case 607: break;\n        case 227: \n          { return(stem(5,\"uy\",\"ed\"));\n          }\n        case 608: break;\n        case 228: \n          { return(stem(3,\"ose\",\"en\"));\n          }\n        case 609: break;\n        case 229: \n          { return(stem(4,\"tch\",\"ed\"));\n          }\n        case 610: break;\n        case 230: \n          { return(stem(3,\"am\",\"ed\"));\n          }\n        case 611: break;\n        case 231: \n          { return(stem(4,\"w\",\"ed\"));\n          }\n        case 612: break;\n        case 232: \n          { return(stem(4,\"eeze\",\"en\"));\n          }\n        case 613: break;\n        case 233: \n          { return(stem(5,\"ight\",\"ed\"));\n          }\n        case 614: break;\n        case 234: \n          { return(stem(3,\"l\",\"en\"));\n          }\n        case 615: break;\n        case 235: \n          { return(semi_reg_stem(1,\"\"));\n          }\n        case 616: break;\n        case 236: \n          { return(stem(5,\"et\",\"en\"));\n          }\n        case 617: break;\n        case 237: \n          { return(stem(3,\"ey\",\"ed\"));\n          }\n        case 618: break;\n        case 238: \n          { return(stem(5,\"elt\",\"en\"));\n          }\n        case 619: break;\n        case 239: \n          { return(stem(3,\"ue\",\"ed\"));\n          }\n        case 620: break;\n        case 240: \n          { return(stem(3,\"ce\",\"ed\"));\n          }\n        case 621: break;\n        case 241: \n          { return(stem(5,\"ink\",\"en\"));\n          }\n        case 622: break;\n        case 242: \n          { return(stem(3,\"il\",\"ed\"));\n          }\n        case 623: break;\n        case 243: \n          { return(stem(3,\"ike\",\"ed\"));\n          }\n        case 624: break;\n        case 244: \n          { return(stem(4,\"eal\",\"en\"));\n          }\n        case 625: break;\n        case 245: \n          { return(stem(3,\"ge\",\"ed\"));\n          }\n        case 626: break;\n        case 246: \n          { return(stem(5,\"eek\",\"ed\"));\n          }\n        case 627: break;\n        case 247: \n          { return(stem(5,\"each\",\"ed\"));\n          }\n        case 628: break;\n        case 248: \n          { return(stem(3,\"a\",\"ed\"));\n          }\n        case 629: break;\n        case 249: \n          { return(stem(2,\"ie\",\"ed\"));\n          }\n        case 630: break;\n        case 250: \n          { return(stem(4,\"e\",\"ing\"));\n          }\n        case 631: break;\n        case 251: \n          { return(stem(2,\"ron\",\"s\"));\n          }\n        case 632: break;\n        case 252: \n          { return(stem(1,\"i\",\"s\"));\n          }\n        case 633: break;\n        case 253: \n          { return(stem(3,\"denum\",\"s\"));\n          }\n        case 634: break;\n        case 254: \n          { return(stem(3,\"ur\",\"s\"));\n          }\n        case 635: break;\n        case 255: \n          { return(stem(3,\"us\",\"s\"));\n          }\n        case 636: break;\n        case 256: \n          { return(stem(2,\"re\",\"s\"));\n          }\n        case 637: break;\n        case 257: \n          { return(stem(2,\"ia\",\"s\"));\n          }\n        case 638: break;\n        case 258: \n          { return(stem(2,\"mum\",\"s\"));\n          }\n        case 639: break;\n        case 259: \n          { return(stem(3,\"ey\",\"s\"));\n          }\n        case 640: break;\n        case 260: \n          { return(stem(6,\"m.p.\",\"s\"));\n          }\n        case 641: break;\n        case 261: \n          { return(stem(4,\"ex\",\"s\"));\n          }\n        case 642: break;\n        case 262: \n          { return(stem(3,\"s\",\"s\"));\n          }\n        case 643: break;\n        case 263: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 4;\n          { return(stem(1,\"\",\"\"));\n          }\n        case 644: break;\n        case 264: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return(stem(3,\"not\",\"\"));\n          }\n        case 645: break;\n        case 265: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return(stem(3,\"shall\",\"\"));\n          }\n        case 646: break;\n        case 266: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 4;\n          { return(stem(1,\"y\",\"\"));\n          }\n        case 647: break;\n        case 267: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"be\",\"s\"));\n          }\n        case 648: break;\n        case 268: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return(stem(3,\"will\",\"\"));\n          }\n        case 649: break;\n        case 269: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"as\",\"\"));\n          }\n        case 650: break;\n        case 270: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"do\",\"s\"));\n          }\n        case 651: break;\n        case 271: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 2;\n          { return(stem(2,\"have\",\"s\"));\n          }\n        case 652: break;\n        case 272: \n          { return(condub_stem(3,\"\",\"ing\"));\n          }\n        case 653: break;\n        case 273: \n          { return(stem(7,\"clepe\",\"ed\"));\n          }\n        case 654: break;\n        case 274: \n          { return(stem(5,\"ing\",\"ed\"));\n          }\n        case 655: break;\n        case 275: \n          { return(stem(4,\"ame\",\"ed\"));\n          }\n        case 656: break;\n        case 276: \n          { return(stem(3,\"ride\",\"ed\"));\n          }\n        case 657: break;\n        case 277: \n          { return(stem(3,\"ie\",\"ed\"));\n          }\n        case 658: break;\n        case 278: \n          { return(stem(5,\"ivy\",\"ed\"));\n          }\n        case 659: break;\n        case 279: \n          { return(stem(5,\"ivy\",\"s\"));\n          }\n        case 660: break;\n        case 280: \n          { return(stem(3,\"se\",\"ed\"));\n          }\n        case 661: break;\n        case 281: \n          { return(stem(2,\"ee\",\"ed\"));\n          }\n        case 662: break;\n        case 282: \n          { return(stem(4,\"-up\",\"s\"));\n          }\n        case 663: break;\n        case 283: \n          { return(stem(2,\"gue\",\"s\"));\n          }\n        case 664: break;\n        case 284: \n          { return(stem(4,\"ue\",\"ing\"));\n          }\n        case 665: break;\n        case 285: \n          { return(stem(5,\"ell\",\"en\"));\n          }\n        case 666: break;\n        case 286: \n          { return(stem(5,\"ink\",\"ed\"));\n          }\n        case 667: break;\n        case 287: \n          { return(stem(4,\"k\",\"ed\"));\n          }\n        case 668: break;\n        case 288: \n          { return(stem(5,\"ead\",\"en\"));\n          }\n        case 669: break;\n        case 289: \n          { return(stem(3,\"mel\",\"s\"));\n          }\n        case 670: break;\n        case 290: \n          { return(stem(4,\"ge\",\"ing\"));\n          }\n        case 671: break;\n        case 291: \n          { return(stem(4,\"i\",\"ing\"));\n          }\n        case 672: break;\n        case 292: \n          { return(stem(4,\"a\",\"ing\"));\n          }\n        case 673: break;\n        case 293: \n          { return(stem(6,\"ork\",\"ed\"));\n          }\n        case 674: break;\n        case 294: \n          { return(stem(5,\"y\",\"ed\"));\n          }\n        case 675: break;\n        case 295: \n          { return(stem(2,\"no\",\"s\"));\n          }\n        case 676: break;\n        case 296: \n          { return(stem(1,\"x\",\"s\"));\n          }\n        case 677: break;\n        case 297: \n          { return(stem(4,\"yatid\",\"s\"));\n          }\n        case 678: break;\n        case 298: \n          { return(stem(4,\"sbok\",\"s\"));\n          }\n        case 679: break;\n        case 299: \n          { return(stem(1,\"o\",\"s\"));\n          }\n        case 680: break;\n        case 300: \n          { return(stem(2,\"ro\",\"s\"));\n          }\n        case 681: break;\n        case 301: \n          { return(stem(2,\"la\",\"s\"));\n          }\n        case 682: break;\n        case 302: \n          { return(stem(2,\"dum\",\"s\"));\n          }\n        case 683: break;\n        case 303: \n          { return(stem(4,\"belly\",\"s\"));\n          }\n        case 684: break;\n        case 304: \n          { return(stem(2,\"zo\",\"s\"));\n          }\n        case 685: break;\n        case 305: \n          { return(stem(3,\"en\",\"s\"));\n          }\n        case 686: break;\n        case 306: \n          { return(stem(1,\"a\",\"s\"));\n          }\n        case 687: break;\n        case 307: \n          { return(stem(3,\"ly\",\"s\"));\n          }\n        case 688: break;\n        case 308: \n          { return(stem(2,\"lio\",\"s\"));\n          }\n        case 689: break;\n        case 309: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 5;\n          { return(stem(2,\"y\",\"\"));\n          }\n        case 690: break;\n        case 310: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 4;\n          { return(stem(4,\"will\",\"\"));\n          }\n        case 691: break;\n        case 311: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return(stem(3,\"be\",\"ed\"));\n          }\n        case 692: break;\n        case 312: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 3;\n          { return(stem(3,\"be\",\"\"));\n          }\n        case 693: break;\n        case 313: \n          { return(stem(4,\"g\",\"ing\"));\n          }\n        case 694: break;\n        case 314: \n          { return(stem(3,\"d\",\"en\"));\n          }\n        case 695: break;\n        case 315: \n          { return(stem(5,\"eech\",\"ed\"));\n          }\n        case 696: break;\n        case 316: \n          { return(stem(4,\"y\",\"s\"));\n          }\n        case 697: break;\n        case 317: \n          { return(stem(6,\"ivy\",\"ing\"));\n          }\n        case 698: break;\n        case 318: \n          { return(stem(4,\"y\",\"ed\"));\n          }\n        case 699: break;\n        case 319: \n          { return(stem(5,\"ify\",\"ed\"));\n          }\n        case 700: break;\n        case 320: \n          { return(stem(5,\"ify\",\"s\"));\n          }\n        case 701: break;\n        case 321: \n          { return(semi_reg_stem(0,\"ue\"));\n          }\n        case 702: break;\n        case 322: \n          { return(stem(5,\"k\",\"ing\"));\n          }\n        case 703: break;\n        case 323: \n          { return(stem(3,\"ship\",\"ed\"));\n          }\n        case 704: break;\n        case 324: \n          { return(stem(2,\"ion\",\"s\"));\n          }\n        case 705: break;\n        case 325: \n          { return(stem(2,\"ne\",\"s\"));\n          }\n        case 706: break;\n        case 326: \n          { return(stem(2,\"cio\",\"s\"));\n          }\n        case 707: break;\n        case 327: \n          { return(stem(3,\"esis\",\"s\"));\n          }\n        case 708: break;\n        case 328: \n          { return(stem(4,\"eps\",\"s\"));\n          }\n        case 709: break;\n        case 329: \n          { return(stem(2,\"eum\",\"s\"));\n          }\n        case 710: break;\n        case 330: \n          { return(stem(2,\"g\",\"s\"));\n          }\n        case 711: break;\n        case 331: \n          { return(stem(4,\"isee\",\"s\"));\n          }\n        case 712: break;\n        case 332: \n          { return(stem(2,\"oan\",\"s\"));\n          }\n        case 713: break;\n        case 333: \n          { return(stem(2,\"ton\",\"s\"));\n          }\n        case 714: break;\n        case 334: \n          { return(stem(4,\"s\",\"s\"));\n          }\n        case 715: break;\n        case 335: \n          \/\/ lookahead expression with fixed base length\n          zzMarkedPos = zzStartRead + 4;\n          { return(stem(4,\"be\",\"ed\"));\n          }\n        case 716: break;\n        case 336: \n          { return(stem(4,\"l\",\"ing\"));\n          }\n        case 717: break;\n        case 337: \n          { return(stem(6,\"-down\",\"s\"));\n          }\n        case 718: break;\n        case 338: \n          { return(stem(5,\"y\",\"ing\"));\n          }\n        case 719: break;\n        case 339: \n          { return(stem(6,\"-up\",\"ed\"));\n          }\n        case 720: break;\n        case 340: \n          { return(stem(6,\"ify\",\"ing\"));\n          }\n        case 721: break;\n        case 341: \n          { return(stem(4,\"y\",\"ing\"));\n          }\n        case 722: break;\n        case 342: \n          { return(stem(3,\"ix\",\"ed\"));\n          }\n        case 723: break;\n        case 343: \n          { return(stem(2,\"do\",\"s\"));\n          }\n        case 724: break;\n        case 344: \n          { return(stem(1,\"de\",\"s\"));\n          }\n        case 725: break;\n        case 345: \n          { return(stem(4,\"-in\",\"s\"));\n          }\n        case 726: break;\n        case 346: \n          { return(stem(8,\"onsieur\",\"s\"));\n          }\n        case 727: break;\n        case 347: \n          { return(stem(2,\"non\",\"s\"));\n          }\n        case 728: break;\n        case 348: \n          { return(stem(4,\"ese\",\"s\"));\n          }\n        case 729: break;\n        case 349: \n          { return(stem(2,\"le\",\"s\"));\n          }\n        case 730: break;\n        case 350: \n          { return(stem(2,\"r\",\"s\"));\n          }\n        case 731: break;\n        case 351: \n          { return(stem(4,\"us\",\"s\"));\n          }\n        case 732: break;\n        case 352: \n          { return(stem(7,\"-up\",\"ing\"));\n          }\n        case 733: break;\n        case 353: \n          { return(stem(2,\"te\",\"s\"));\n          }\n        case 734: break;\n        case 354: \n          { return(stem(3,\"ff\",\"s\"));\n          }\n        case 735: break;\n        case 355: \n          { return(stem(4,\"-on\",\"s\"));\n          }\n        case 736: break;\n        case 356: \n          { return(stem(9,\"an-of-war\",\"s\"));\n          }\n        case 737: break;\n        case 357: \n          { return(stem(4,\"-by\",\"s\"));\n          }\n        case 738: break;\n        case 358: \n          { return(stem(4,\"o\",\"s\"));\n          }\n        case 739: break;\n        case 359: \n          { return(stem(8,\"-down\",\"ed\"));\n          }\n        case 740: break;\n        case 360: \n          { return(stem(2,\"l\",\"s\"));\n          }\n        case 741: break;\n        case 361: \n          { return(stem(8,\"-de-sac\",\"s\"));\n          }\n        case 742: break;\n        case 362: \n          { return(stem(6,\"-over\",\"s\"));\n          }\n        case 743: break;\n        case 363: \n          { return(stem(10,\"anservant\",\"s\"));\n          }\n        case 744: break;\n        case 364: \n          { return(stem(10,\"an-at-arms\",\"s\"));\n          }\n        case 745: break;\n        case 365: \n          { return(stem(3,\"is\",\"s\"));\n          }\n        case 746: break;\n        case 366: \n          { return(stem(8,\"-in-law\",\"s\"));\n          }\n        case 747: break;\n        case 367: \n          { return(stem(6,\"-lit\",\"s\"));\n          }\n        case 748: break;\n        case 368: \n          { return(stem(2,\"t\",\"s\"));\n          }\n        case 749: break;\n        case 369: \n          { return(stem(9,\"-down\",\"ing\"));\n          }\n        case 750: break;\n        case 370: \n          { return(stem(6,\"-doux\",\"s\"));\n          }\n        case 751: break;\n        case 371: \n          { return(stem(8,\"-de-lys\",\"s\"));\n          }\n        case 752: break;\n        case 372: \n          { return(stem(8,\"-de-lis\",\"s\"));\n          }\n        case 753: break;\n        case 373: \n          { return(stem(9,\"-a-terre\",\"s\"));\n          }\n        case 754: break;\n        case 374: \n          { return(stem(9,\"-mutuel\",\"s\"));\n          }\n        case 755: break;\n        case 375: \n          { return(stem(9,\"-de-camp\",\"s\"));\n          }\n        case 756: break;\n        case 376: \n          { return(stem(13,\"ademoiselle\",\"s\"));\n          }\n        case 757: break;\n        case 377: \n          { return(stem(11,\"erfamilias\",\"s\"));\n          }\n        case 758: break;\n        case 378: \n          { return(stem(9,\"-at-arms\",\"s\"));\n          }\n        case 759: break;\n        case 379: \n          { return(stem(12,\"-in-the-box\",\"s\"));\n          }\n        case 760: break;\n        case 380: \n          { return(stem(14,\"y-in-waiting\",\"s\"));\n          }\n        case 761: break;\n        case 381: \n          { return(stem(11,\"y-general\",\"s\"));\n          }\n        case 762: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":17,"line_counts":1682,"new_code_token_num":10726},{"new_code_raw":"@ApiModelProperty(value = STR) public String getType() { return type; }","old_code_raw":"@ApiModelProperty(value = STR)\npublic TypeEnum getType() {\n    return type;\n}","new_comment_raw":"@return String type","old_comment_raw":"@return TypeEnum type","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"private ComponentAdapter prepRES_lifecycleManagerHonorsInstantiationSequence(MutablePicoContainer picoContainer) { picoContainer.addComponent(RecordingLifecycle.One.class); PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class)); return picoContainer.addAdapter(poolingComponentAdapter).lastCA(); }","old_code_raw":"private ComponentAdapter prepRES_lifecycleManagerHonorsInstantiationSequence(MutablePicoContainer picoContainer) {\n    picoContainer.component(RecordingLifecycle.One.class);\n    PoolingComponentAdapter poolingComponentAdapter = new PoolingComponentAdapter(new ConstructorInjectionComponentAdapter(RecordingLifecycle.Recorder.class, RecordingLifecycle.Two.class));\n    return picoContainer.adapter(poolingComponentAdapter).lastCA();\n}","new_comment_raw":"@return the addAdapter to test","old_comment_raw":"@return the adapter to test","label":1,"pre_label":0,"AST_level":8,"line_counts":5,"new_code_token_num":45},{"new_code_raw":"public Frame readFrame() throws IOException { byte[] header = new byte[HEADER_SIZE]; int actualHeaderSize = 0; do { int headerCount = inputStream.read(header, actualHeaderSize, HEADER_SIZE - actualHeaderSize); if (headerCount == -1) { return null; } actualHeaderSize += headerCount; } while (actualHeaderSize < HEADER_SIZE); int payloadSize = ((header[4] & 0xff) << 24) + ((header[5] & 0xff) << 16) + ((header[6] & 0xff) << 8) + (header[7] & 0xff); byte[] payload = new byte[payloadSize]; int actualPayloadSize = 0; do { int count = inputStream.read(payload, actualPayloadSize, payloadSize - actualPayloadSize); if (count == -1) { if (actualPayloadSize != payloadSize) { throw new IOException(String.format(\"payload must be %d bytes long, but was %d\", payloadSize, actualPayloadSize)); } break; } actualPayloadSize += count; } while (actualPayloadSize < payloadSize); return new Frame(streamType(header[0]), payload); }","old_code_raw":"    public Frame readFrame() throws IOException {\n\n        if (rawStreamDetected) {\n\n\n            int read = inputStream.read(rawBuffer);\n\n            return new Frame(StreamType.RAW, Arrays.copyOf(rawBuffer, read));\n\n        } else {\n\n            byte[] header = new byte[HEADER_SIZE];\n\n            int actualHeaderSize = 0;\n\n            do {\n                int headerCount = inputStream.read(header, actualHeaderSize, HEADER_SIZE - actualHeaderSize);\n\n                if (headerCount == -1) {\n                    return null;\n                }\n                actualHeaderSize += headerCount;\n            } while (actualHeaderSize < HEADER_SIZE);\n\n            StreamType streamType = streamType(header[0]);\n\n            if(streamType.equals(StreamType.RAW)) {\n                rawStreamDetected = true;\n                return new Frame(StreamType.RAW, Arrays.copyOf(header, HEADER_SIZE));\n            }\n\n            int payloadSize = ((header[4] & 0xff) << 24) + ((header[5] & 0xff) << 16) + ((header[6] & 0xff) << 8)\n                    + (header[7] & 0xff);\n\n            byte[] payload = new byte[payloadSize];\n            int actualPayloadSize = 0;\n\n            do {\n                int count = inputStream.read(payload, actualPayloadSize, payloadSize - actualPayloadSize);\n\n                if (count == -1) {\n                    if (actualPayloadSize != payloadSize) {\n                        throw new IOException(String.format(\"payload must be %d bytes long, but was %d\", payloadSize,\n                                actualPayloadSize));\n                    }\n                    break;\n                }\n                actualPayloadSize += count;\n            } while (actualPayloadSize < payloadSize);\n\n            return new Frame(streamType, payload);\n        }\n    }\n","new_comment_raw":"@return A frame, or null if no more frames.","old_comment_raw":"@return A frame, or null if no more frames.","label":0,"pre_label":1,"AST_level":12,"line_counts":36,"new_code_token_num":210},{"new_code_raw":"@Processor public String login(String username, String password) { return config.getClient().login(username, password); }","old_code_raw":"@Processor\n@InvalidateConnectionOn(exception = JiraConnectorException.class)\npublic String login(String username, String password) {\n    return client.login(username, password);\n}","new_comment_raw":"@return the authentication config.getToken()","old_comment_raw":"@return the authentication token","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":26},{"new_code_raw":"@Override public Map<String, DatatypeValidator> getBuiltInTypes() { return new HashMap<>(fBuiltInTypes); }","old_code_raw":"public Hashtable getBuiltInTypes() {\n    return (Hashtable) fBuiltInTypes.clone();\n}","new_comment_raw":"@return a Map which contains all datatypes","old_comment_raw":"@return a hashtable which contains all datatypes","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public boolean isThisMyUrl(String url) { final String myUrlConfigured = serverConfig.getMyUrl(); if (myUrlConfigured != null) { return myUrlConfigured.equals(url); } return isInstanceURL(url, applicationInfoManager.getInfo()); }","old_code_raw":"    public boolean isThisMyUrl(String url) {\n        return isInstanceURL(url, applicationInfoManager.getInfo());\n    }\n","new_comment_raw":"@return true, if the url represents the current node which is trying to replicate, false otherwise.","old_comment_raw":"@return true, if the url represents the current node which is trying to replicate, false otherwise.","label":0,"pre_label":1,"AST_level":7,"line_counts":8,"new_code_token_num":43},{"new_code_raw":"public static Platform fromString(String name) { try { return Platform.valueOf(name); } catch (IllegalArgumentException ex) { for (Platform os : Platform.values()) { for (String matcher : os.partOfOsName) { if (name.toLowerCase().equals(matcher.toLowerCase())) { return os; } } } throw new WebDriverException(\"Unrecognized platform: \" + name); } }","old_code_raw":"  public static Platform fromString(String name) {\n    for (Platform os : Platform.values()) {\n      for (String matcher : os.partOfOsName) {\n        if (name.toLowerCase().equals(matcher.toLowerCase())) {\n          return os;\n        }\n      }\n    }\n    throw new WebDriverException(\"Unknown platform: \" + name);\n  }\n","new_comment_raw":"@return the Platform enum value matching the parameter","old_comment_raw":"@return the Platform enum value matching the parameter","label":0,"pre_label":1,"AST_level":12,"line_counts":15,"new_code_token_num":81},{"new_code_raw":"public static SecureConnectionMode parse(String value, String defaultValue) { SecureConnectionMode mode = parse(value); if (mode == null && defaultValue != null) { mode = parse(defaultValue); } return mode; }","old_code_raw":"        public static TopicSelectionStrategy parse(String value) {\n            if (value == null) {\n                return null;\n            }\n            value = value.trim();\n            for (TopicSelectionStrategy option : TopicSelectionStrategy.values()) {\n                if (option.getValue().equalsIgnoreCase(value)) {\n                    return option;\n                }\n            }\n            return null;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","old_comment_raw":"@return the matching option, or null if no match is found","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":41},{"new_code_raw":"private int processPartition(final int currentRow) throws DrillException { logger.trace(\"{} rows remaining to process, currentRow: {}, outputCount: {}\", remainingRows, currentRow, outputCount); setupWriteFirstValue(internal, container); if (popConfig.isFrameUnitsRows()) { return processROWS(currentRow); } else { return processRANGE(currentRow); } }","old_code_raw":"  private int processPartition(final int currentRow) throws DrillException {\n    logger.trace(\"process partition {}, currentRow: {}, outputCount: {}\", partition, currentRow, outputCount);\n\n    setupWriteFirstValue(internal, container);\n\n    int row = currentRow;\n\n    \/\/ process all rows except the last one of the batch\/partition\n    while (row < outputCount && !partition.isDone()) {\n      processRow(row);\n\n      row++;\n    }\n\n    return row;\n  }\n","new_comment_raw":"@return index of next unprocessed row","old_comment_raw":"@return index of next unprocessed row","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":72},{"new_code_raw":"private IAnnotationModel createExternalSearchAnnotationModel(ExternalEditorInput externalInput) { IStorage storage = externalInput.getStorage(); IResource markerResource = externalInput.getMarkerResource(); return createExternalSearchAnnotationModel(storage, markerResource); }","old_code_raw":"private IAnnotationModel createExternalSearchAnnotationModel(ExternalEditorInput externalInput) {\n    IStorage storage = externalInput.getStorage();\n    IResource resourceToUseForMarker = null;\n    IFile resourceFile = CUIPlugin.getWorkspace().getRoot().getFileForLocation(storage.getFullPath());\n    if (resourceFile == null) {\n        resourceToUseForMarker = externalInput.getMarkerResource();\n        if (null == resourceToUseForMarker) {\n            IProject[] proj = CUIPlugin.getWorkspace().getRoot().getProjects();\n            for (int i = NUM; i < proj.length; i++) {\n                if (proj[i].isOpen()) {\n                    resourceToUseForMarker = proj[i];\n                    break;\n                }\n            }\n        }\n    } else {\n        resourceToUseForMarker = resourceFile.getProject();\n    }\n    if (resourceToUseForMarker != null) {\n        ExternalSearchAnnotationModel model = new ExternalSearchAnnotationModel(resourceToUseForMarker, storage);\n        return model;\n    }\n    return null;\n}","new_comment_raw":"@return a new annotation model for the external editor input","old_comment_raw":"@return a new annotation model for the editor input","label":1,"pre_label":0,"AST_level":5,"line_counts":5,"new_code_token_num":31},{"new_code_raw":"public ResourceRepo removeResource(Resource resource) { if ((this.resourceRepos == null) || (resource == null)) { return null; } ResourceRepo doomed = null; for (ResourceRepo rc : this.resourceRepos) { if (resource.equals(rc.getResourceRepoPK().getResource())) { doomed = rc; break; } } if (doomed != null) { this.resourceRepos.remove(doomed); } return doomed; }","old_code_raw":"public ResourceChannel removeResource(Resource resource) {\n    if ((this.resourceChannels == null) || (resource == null)) {\n        return null;\n    }\n    ResourceChannel doomed = null;\n    for (ResourceChannel rc : this.resourceChannels) {\n        if (resource.equals(rc.getResourceChannelPK().getResource())) {\n            doomed = rc;\n            break;\n        }\n    }\n    if (doomed != null) {\n        this.resourceChannels.remove(doomed);\n    }\n    return doomed;\n}","new_comment_raw":"@return the mapping that was removed or <code>null<\/code> if the resource was not subscribed to this repo","old_comment_raw":"@return the mapping that was removed or <code>null<\/code> if the resource was not subscribed to this channel","label":1,"pre_label":0,"AST_level":9,"line_counts":16,"new_code_token_num":81},{"new_code_raw":"public CacheManager getCacheFactory() { return jbcFactory; }","old_code_raw":"\tpublic JBossCacheFactory getCacheFactory() {\n        return jbcFactory;\n    }\n","new_comment_raw":"@return Value for property 'cacheFactory'.","old_comment_raw":"@return Value for property 'cacheFactory'.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public AppUser getRejectedByUser() { return this.rejectedByUser; }","old_code_raw":"\tpublic AppUser getRejectedByUser() {\n\t\treturn this.approvedByUser;\n\t}\n","new_comment_raw":"@return the user that rejected the request","old_comment_raw":"@return the user that rejected the request","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public User getUserByName(String username) throws ApiException { ApiResponse<User> localVarResp = getUserByNameWithHttpInfo(username); return localVarResp.getData(); }","old_code_raw":"    public User getUserByName(String username) throws ApiException {\n        ApiResponse<User> resp = getUserByNameWithHttpInfo(username);\n        return resp.getData();\n    }\n","new_comment_raw":"@return User","old_comment_raw":"@return User","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public final boolean transform(Canvas canvas, View child) { final RevealValues revealData = targets.get(child); if (revealData == null) { return false; } else if (revealData.target != child) { throw new IllegalStateException(STR); } else if (!revealData.clipping) { return false; } return viewTransformation.transform(canvas, child, revealData); }","old_code_raw":"public boolean transform(Canvas canvas, View child) {\n    final RevealValues revealData = targets.get(child);\n    return revealData != null && revealData.applyTransformation(canvas, child);\n}","new_comment_raw":"@return True if viewTransformation was successfully applied on referenced child, otherwise child be not the target and therefore animation was skipped","old_comment_raw":"@return True if transformation was successfully applied on referenced child, otherwise child be not the target and therefore animation was skipped","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":72},{"new_code_raw":"public ChromeDriverService build() { return (ChromeDriverService) super.build(); }","old_code_raw":"    public ChromeDriverService build() {\n      if (port == 0) {\n        port = PortProber.findFreePort();\n      }\n\n      checkState(exe != null, \"Path to the chromedriver executable not specified\");\n\n      try {\n        return new ChromeDriverService(exe, port, environment, logFile);\n      } catch (IOException e) {\n        throw new WebDriverException(e);\n      }\n    }\n","new_comment_raw":"@return The new binary.","old_comment_raw":"@return The new binary.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"@Deprecated public String getBodyContents() { return getStringPayload(); }","old_code_raw":"public String getBodyContents() {\n    try {\n        return new String(getByteBodyContents(), getCharset());\n    } catch (UnsupportedEncodingException uee) {\n        throw new OAuthException(STR + charset, uee);\n    }\n}","new_comment_raw":"@return value set in {@link #setPayload(java.lang.String)}","old_comment_raw":"@return form encoded string","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"private static boolean containsItem(Collection<String> itemCollection, String item) { return itemCollection.contains(item.toLowerCase()); }","old_code_raw":"private static boolean containsItem(Collection itemCollection, String key) {\n    return itemCollection.contains(key.toLowerCase());\n}","new_comment_raw":"@return true if itemCollection contains the item, false otherwise.","old_comment_raw":"@return true if itemCollection contains the key, false otherwise.","label":1,"pre_label":0,"AST_level":6,"line_counts":3,"new_code_token_num":24},{"new_code_raw":"public static int getKeyLength(AsymmetricKeyParameter keyParams) { if (keyParams instanceof RSAKeyParameters) { return ((RSAKeyParameters) keyParams).getModulus().bitLength(); } else if (keyParams instanceof DSAKeyParameters) { return ((DSAKeyParameters) keyParams).getParameters().getP().bitLength(); } else if (keyParams instanceof DHKeyParameters) { return ((DHKeyParameters) keyParams).getParameters().getP().bitLength(); } else if (keyParams instanceof ECKeyParameters) { return UNKNOWN_KEY_SIZE; } LOG.warning(STR + keyParams); return UNKNOWN_KEY_SIZE; }","old_code_raw":"public static int getKeyLength(AsymmetricKeyParameter keyParams) throws CryptoException {\n    if (keyParams instanceof RSAKeyParameters) {\n        return ((RSAKeyParameters) keyParams).getModulus().bitLength();\n    } else if (keyParams instanceof DSAKeyParameters) {\n        return ((DSAKeyParameters) keyParams).getParameters().getP().bitLength();\n    } else if (keyParams instanceof DHKeyParameters) {\n        return ((DHKeyParameters) keyParams).getParameters().getP().bitLength();\n    } else {\n        throw new CryptoException(RB.getString(STR));\n    }\n}","new_comment_raw":"@return The key size, {@link #UNKNOWN_KEY_SIZE} if not known","old_comment_raw":"@return The key size","label":1,"pre_label":0,"AST_level":9,"line_counts":13,"new_code_token_num":107},{"new_code_raw":"private MessageBatcher getBatcher(final String serviceUrl, String pBatcherName) { String batcherName = null; try { batcherName = new URL(serviceUrl).getHost(); } catch (MalformedURLException e1) { batcherName = serviceUrl; } String absoluteBatcherName = batcherName + \"-\" + pBatcherName; ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".queue.maxMessages\", config.getMaxElementsInPeerReplicationPool()); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".batch.maxMessages\", 250); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".keepAliveTime\", config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60); ConfigurationManager.getConfigInstance().setProperty( \"batcher.\" + absoluteBatcherName + \".maxThreads\", config.getMaxThreadsForPeerReplication()); return BatcherFactory.createBatcher(absoluteBatcherName, new MessageProcessor<ReplicationTask>() { private String BATCH_URL_PATH = \"peerreplication\/batch\/\";; @Override public void process(List<ReplicationTask> tasks) { if (!tasks.get(0).isBatchingSupported()) { executeSingle(tasks); } else if (!executeBatch(tasks)) { executeSingle(tasks); } } private boolean executeBatch(List<ReplicationTask> tasks) { boolean success = true; boolean done = true; PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList(); for (ReplicationTask task : tasks) { if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; logger.warn( \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\", args); continue; } PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance(); instance.setAppName(task.getAppName()); instance.setId(task.getId()); InstanceInfo instanceInfo = task.getInstanceInfo(); if (instanceInfo != null) { String overriddenStatus = (task .getOverriddenStatus() == null ? null : task.getOverriddenStatus().name()); instance.setOverriddenStatus(overriddenStatus); instance.setLastDirtyTimestamp(instanceInfo .getLastDirtyTimestamp()); if (task.shouldReplicateInstanceInfo()) { instance.setInstanceInfo(instanceInfo); } String instanceStatus = instanceInfo .getStatus() == null ? null : instanceInfo.getStatus().name(); instance.setStatus(instanceStatus); } instance.setAction(task.getAction()); list.addReplicationInstance(instance); } if (list.getList().size() == 0) { return true; } Action action = list.getList().get(0).action; DynamicCounter.increment(\"Batch_\" + action + \"_tries\"); do { done = true; ClientResponse response = null; try { response = jerseyApacheClient .resource(serviceUrl) .path(BATCH_URL_PATH) .accept(MediaType.APPLICATION_JSON_TYPE) .type(MediaType.APPLICATION_JSON_TYPE) .post(ClientResponse.class, list); if (!isSuccess(response)) { return false; } DynamicCounter.increment(\"Batch_\" + action + \"_success\"); PeerEurekaNode.ReplicationListResponse batchResponse = response .getEntity(PeerEurekaNode.ReplicationListResponse.class); int ctr = 0; for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse .getResponseList()) { int statusCode = singleResponse .getStatusCode(); if ((!isSuccess(response)) || (singleResponse .getResponseEntity() != null)) { if (singleResponse.getResponseEntity() != null) { tasks.get(ctr) .setPeerInstanceInfo( singleResponse .getResponseEntity()); } tasks.get(ctr) .handleFailure(statusCode); } ++ctr; } done = true; } catch (Throwable e) { if ((isNetworkConnectException(e))) { DynamicCounter.increment(\"Batch_\" + action + \"_retries\"); done = false; } else { success = false; logger.info( \"Not re-trying this exception because it does not seem to be a network exception\", e); } } finally { if (response != null) { response.close(); } } } while (!done); return success; } private boolean isSuccess(ClientResponse response) { return response.getStatus() < 200 || response.getStatus() >= 300; } private void executeSingle(List<ReplicationTask> tasks) { for (ReplicationTask task : tasks) { boolean done = true; do { done = true; try { if (System.currentTimeMillis() - config.getMaxTimeForReplication() > task .getSubmitTime()) { Object[] args = { task.getAppName(), task.getId(), task.getAction(), new Date(System.currentTimeMillis()), new Date(task.getSubmitTime()) }; logger.warn( \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\", args); continue; } DynamicCounter.increment(\"Single_\" + task.getAction().name() + \"_tries\"); int statusCode = task.execute(); if (statusCode < 200 && statusCode > 299) { task.handleFailure(statusCode); } DynamicCounter.increment(\"Single_\" + task.getAction().name() + \"_success\"); } catch (Throwable e) { logger.error( name + task.getAppName() + \"\/\" + task.getId() + \":\" + task.getAction(), e); try { Thread.sleep(RETRY_SLEEP_TIME_MS); } catch (InterruptedException e1) { } if ((isNetworkConnectException(e))) { DynamicCounter.increment(task .getAction().name() + \"_retries\"); done = false; } else { logger.info( \"Not re-trying this exception because it does not seem to be a network exception\", e); } } } while (!done); } } }); }","old_code_raw":"    private MessageBatcher getBatcher(final String serviceUrl, String pBatcherName) {\n        String batcherName = null;\n        try {\n            batcherName = new URL(serviceUrl).getHost();\n        } catch (MalformedURLException e1) {\n            batcherName = serviceUrl;\n        }\n        String absoluteBatcherName = batcherName + \"-\" + pBatcherName;\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".queue.maxMessages\",\n                config.getMaxElementsInPeerReplicationPool());\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".batch.maxMessages\",\n                 250);\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".keepAliveTime\",\n                config.getMaxIdleThreadAgeInMinutesForPeerReplication() * 60);\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"batcher.\" + absoluteBatcherName + \".maxThreads\",\n                config.getMaxThreadsForPeerReplication());\n\n        return BatcherFactory.createBatcher(absoluteBatcherName,\n                new MessageProcessor<ReplicationTask>() {\n\n            private String BATCH_URL_PATH = \"apps\/batch\/\";;\n\n            @Override\n            public void process(List<ReplicationTask> tasks) {\n                if (!tasks.get(0).isBatchingSupported()) {\n                    executeSingle(tasks);\n                } else if (!executeBatch(tasks)) {\n                    executeSingle(tasks);\n                }\n            }\n\n            private boolean executeBatch(List<ReplicationTask> tasks) {\n                boolean success = true;\n                boolean done = true;\n                PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList();\n                for (ReplicationTask task : tasks) {\n                   if (System.currentTimeMillis()\n                            - config.getMaxTimeForReplication() > task\n                            .getSubmitTime()) {\n                       Object[] args = { task.getAppName(), task.getId(),\n                               task.getAction(),\n                               new Date(System.currentTimeMillis()),\n                               new Date(task.getSubmitTime()) };\n                    \n                        logger.warn(\n                                \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\",\n                                args);\n\n                        continue;\n                    }\n                    PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance();\n                    instance.setAppName(task.getAppName());\n                    instance.setId(task.getId());\n                    InstanceInfo instanceInfo = task.getInstanceInfo();\n                    if (instanceInfo != null) {\n                        String overriddenStatus = (task\n                                .getOverriddenStatus() == null ? null\n                                        : task.getOverriddenStatus().name());\n                        instance.setOverriddenStatus(overriddenStatus);\n                        instance.setLastDirtyTimestamp(instanceInfo\n                                .getLastDirtyTimestamp());\n                        if (task.shouldReplicateInstanceInfo()) {\n                            instance.setInstanceInfo(instanceInfo);\n                        }\n                        String instanceStatus = instanceInfo\n                        .getStatus() == null ? null\n                                : instanceInfo.getStatus().name();\n                        instance.setStatus(instanceStatus);\n                    }\n                    instance.setAction(task.getAction());\n                    list.addReplicationInstance(instance);\n                }\n                if (list.getList().size() == 0) {\n                    return true;\n                }\n                Action action = list.getList().get(0).action;\n                DynamicCounter.increment(\"Batch_\"\n                        + action\n\n                        + \"_tries\");\n\n                do {\n                    done = true;\n                    ClientResponse response = null;\n                    try {\n                        response = jerseyApacheClient\n                        .resource(serviceUrl)\n                        .path(BATCH_URL_PATH)\n                        .accept(MediaType.APPLICATION_JSON_TYPE)\n                        .type(MediaType.APPLICATION_JSON_TYPE)\n                        .post(ClientResponse.class, list);\n                        if (!isSuccess(response)) {\n                            return false;\n                        }\n                        DynamicCounter.increment(\"Batch_\"\n                                + action\n\n                                + \"_success\");\n\n                        PeerEurekaNode.ReplicationListResponse batchResponse = response\n                        .getEntity(PeerEurekaNode.ReplicationListResponse.class);\n                        int ctr = 0;\n                        for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse\n                                .getResponseList()) {\n                            int statusCode = singleResponse\n                            .getStatusCode();\n                            if ((!isSuccess(response))\n                                    || (singleResponse\n                                    .getResponseEntity() != null)) {\n                                if (singleResponse.getResponseEntity() != null) {\n                                    tasks.get(ctr)\n                                    .setPeerInstanceInfo(\n                                            singleResponse\n                                            .getResponseEntity());\n                                }\n                                tasks.get(ctr)\n                                .handleFailure(statusCode);\n                            }\n\n                            ++ctr;\n                        }\n                        done = true;\n\n                    } catch (Throwable e) {\n\n                        if ((isNetworkConnectException(e))) {\n                            DynamicCounter.increment(\"Batch_\"\n                                    + action\n                              + \"_retries\");\n                            done = false;\n                        } else {\n                            success = false;\n                            logger.info(\n                                    \"Not re-trying this exception because it does not seem to be a network exception\",\n                                    e);\n                        }\n                    } finally {\n                        if (response != null) {\n                            response.close();\n                        }\n                    }\n                } while (!done);\n                return success;\n            }\n\n            private boolean isSuccess(ClientResponse response) {\n                return response.getStatus() < 200\n                        || response.getStatus() >= 300;\n            }\n\n            private void executeSingle(List<ReplicationTask> tasks) {\n                for (ReplicationTask task : tasks) {\n                    boolean done = true;\n                    do {\n                        done = true;\n                        try {\n                              if (System.currentTimeMillis()\n                                    - config.getMaxTimeForReplication() > task\n                                    .getSubmitTime()) {\n                                  Object[] args = {\n                                          task.getAppName(),\n                                          task.getId(),\n                                          task.getAction(),\n                                          new Date(System.currentTimeMillis()),\n                                          new Date(task.getSubmitTime()) };\n       \n                                logger.warn(\n                                        \"Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}\",\n                                        args);\n\n                                continue;\n                            }\n                            DynamicCounter.increment(\"Single_\"\n                                    + task.getAction().name()\n\n                                    + \"_tries\");\n\n                            int statusCode = task.execute();\n                            if (statusCode < 200 && statusCode > 299) {\n                                task.handleFailure(statusCode);\n                            }\n                            DynamicCounter.increment(\"Single_\"\n                                    + task.getAction().name()\n\n                                    + \"_success\");\n\n                        } catch (Throwable e) {\n                            logger.error(\n                                    name + task.getAppName() + \"\/\"\n                                    + task.getId() + \":\"\n                                    + task.getAction(), e);\n                            try {\n                                Thread.sleep(RETRY_SLEEP_TIME_MS);\n                            } catch (InterruptedException e1) {\n\n                            }\n                            if ((isNetworkConnectException(e))) {\n                                DynamicCounter.increment(task\n                                        .getAction().name()\n                                        + \"_retries\");\n                                done = false;\n                            } else {\n                                logger.info(\n                                        \"Not re-trying this exception because it does not seem to be a network exception\",\n                                        e);\n                            }\n                        }\n                    } while (!done);\n                }\n            }\n        });\n    }\n","new_comment_raw":"@return The batcher instance","old_comment_raw":"@return The batcher instance","label":0,"pre_label":1,"AST_level":20,"line_counts":217,"new_code_token_num":1115},{"new_code_raw":"public TreeGraphNode headWordNode() { return safeCast(label.get(TreeCoreAnnotations.HeadWordAnnotation.class)); }","old_code_raw":"  public TreeGraphNode headWordNode() {\n    TreeGraphNode hwn = safeCast(label.get(TreeCoreAnnotations.HeadWordAnnotation.class));\n    if (hwn == null || (hwn.treeGraph() != null && !(hwn.treeGraph().equals(this.treeGraph())))) {\n      return null;\n    }\n    return hwn;\n  }\n","new_comment_raw":"@return the node containing the head word for this node","old_comment_raw":"@return the node containing the head word for this node","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public boolean isStarting() { return status.get() == STARTING; }","old_code_raw":"    public boolean isStarting() {\n        return starting.get();\n    }\n","new_comment_raw":"@return true if the Connection is starting","old_comment_raw":"@return true if the Connection is starting","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":14},{"new_code_raw":"public static Context getContext() { testInitialize(); return sContext; }","old_code_raw":"public static Application getContext() {\n    if (sApplication == null)\n        throw new ExceptionInInitializerError(STR);\n    return sApplication;\n}","new_comment_raw":"@return {@link Context}.","old_comment_raw":"@return {@link Application}.","label":1,"pre_label":0,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public ChuckInterceptor maxContentLength(long max) { this.maxContentLength = max; return this; }","old_code_raw":"    public ChuckInterceptor maxContentLength(long max) {\n        this.maxContentLength = max;\n    }\n","new_comment_raw":"@return The  ChuckInterceptor instance.","old_comment_raw":"@return The ChuckInterceptor instance.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":16},{"new_code_raw":"protected boolean hasCustomerRevealAnimator() { return true; }","old_code_raw":"  protected boolean hasCustomerRevealAnimator() {\n    return false;\n  }\n","new_comment_raw":"@return True if you don't want use Android native reveal animator in order to use your own custom one","old_comment_raw":"@return True if you don't want use Android native reveal animator in order to use your own custom one","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public final Location doGeoLookup(final String ip) { Location location = null; Integer ipAddressType = determineIpAddressType(ip); switch(ipAddressType) { case NUM: location = ip4Lookup.getLocation(ip); break; case NUM: location = ip6Lookup.getLocationV6(ip); break; default: break; } return location; }","old_code_raw":"private Tuple doGeoLookup(final String ip) throws ExecException {\n    Location location = null;\n    Integer ipAddressType = determineIpAddressType(ip);\n    Tuple output = tupleFactory.newTuple(this.neededGeoFieldNames.size());\n    switch(ipAddressType) {\n        case NUM:\n            location = ip4Lookup.getLocation(ip);\n            break;\n        case NUM:\n            location = ip6Lookup.getLocationV6(ip);\n            break;\n        case NUM:\n            warn(STR, PigWarning.UDF_WARNING_1);\n            return null;\n        default:\n            warn(STR, PigWarning.UDF_WARNING_1);\n            return null;\n    }\n    if (location != null) {\n        int i = NUM;\n        String value = null;\n        for (GeoIpLookupField field : this.neededGeoFieldNames) {\n            switch(field) {\n                case COUNTRYCODE:\n                    value = location.countryCode;\n                    break;\n                case CONTINENTCODE:\n                    value = getContinentCode(location.countryCode);\n                    break;\n                case CONTINENTNAME:\n                    value = getContinentName(location.countryCode);\n                    break;\n                case REGION:\n                    value = location.region;\n                    break;\n                case CITY:\n                    value = location.city;\n                    break;\n                case POSTALCODE:\n                    value = location.postalCode;\n                    break;\n                case LATITUDE:\n                    value = Float.toString(location.latitude);\n                    break;\n                case LONGITUDE:\n                    value = Float.toString(location.longitude);\n                    break;\n                case DMACODE:\n                    value = Integer.toString(location.dma_code);\n                    break;\n                case AREACODE:\n                    value = Integer.toString(location.area_code);\n                    break;\n                case METROCODE:\n                    value = Integer.toString(location.metro_code);\n                    break;\n                default:\n                    break;\n            }\n            output.set(i, value);\n            i++;\n        }\n    } else {\n        warn(STR, PigWarning.UDF_WARNING_3);\n        return null;\n    }\n    return output;\n}","new_comment_raw":"@return location object","old_comment_raw":"@return Tuple containing the requested the geocoded field","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":59},{"new_code_raw":"@Override public AbstractContainerRequestValueFactory<?> createValueFactory(Parameter parameter) { if (!principalClass.equals(parameter.getRawType())) { return null; } return new AbstractContainerRequestValueFactory<Principal>() { public Principal provide() { final Principal principal = getContainerRequest().getSecurityContext().getUserPrincipal(); if (principal == null) { throw new IllegalStateException(STR); } return principal; } }; }","old_code_raw":"@Override\npublic AbstractContainerRequestValueFactory<?> createValueFactory(Parameter parameter) {\n    Class<?> classType = parameter.getRawType();\n    if (classType == null || (!classType.equals(clazz))) {\n        return null;\n    }\n    return new AuthValueFactory<T>();\n}","new_comment_raw":"@return the factory if parameter matched type","old_comment_raw":"@return {@link AuthValueFactory} if parameter matched type","label":1,"pre_label":0,"AST_level":10,"line_counts":16,"new_code_token_num":75},{"new_code_raw":"protected Object convertBigInt(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; } if (data instanceof Long) return data; if (data instanceof Number) { Number value = (Number) data; return new Long(value.longValue()); } if (data instanceof Boolean) { return NumberConversions.getLong((Boolean) data); } return handleUnknownData(column, fieldDefn, data); }","old_code_raw":"    protected Object convertBigInt(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L;\n        }\n        if (data instanceof Long) return data;\n        if (data instanceof Number) {\n            Number value = (Number) data;\n            return new Long(value.longValue());\n        }\n        if (data instanceof Boolean) {\n            return ((Boolean) data).booleanValue() ? LONG_TRUE : LONG_FALSE;\n        }\n        return handleUnknownData(column, fieldDefn, data);\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":8,"line_counts":19,"new_code_token_num":113},{"new_code_raw":"public int removeAll(Predicate<K> predicate) { ArrayList<Entry<K, V>> oldEntries; synchronized (this) { mExclusiveEntries.removeAll(predicate); oldEntries = mCachedEntries.removeAll(predicate); makeOrphans(oldEntries); } maybeClose(oldEntries); maybeUpdateCacheParams(); maybeEvictEntries(); return oldEntries.size(); }","old_code_raw":"public long removeAll(Predicate<K> match) {\n    long numEvictedEntries = NUM;\n    List<CacheEntry<K, V>> matchingEntriesFromEvictionQueue;\n    synchronized (this) {\n        matchingEntriesFromEvictionQueue = getMatchingEntriesFromEvictionQueue(match);\n        numEvictedEntries += matchingEntriesFromEvictionQueue.size();\n        for (CacheEntry<K, V> cacheEntry : matchingEntriesFromEvictionQueue) {\n            removeFromEvictionQueue(cacheEntry);\n            removeFromCachedEntries(cacheEntry);\n            mMemoryCacheIndex.removeEntry(cacheEntry.key, cacheEntry.value);\n        }\n        List<CacheEntry<K, V>> matchingCachedEntries = getMatchingCachedEntries(match);\n        numEvictedEntries += matchingCachedEntries.size();\n        for (CacheEntry<K, V> cacheEntry : matchingCachedEntries) {\n            moveFromCachedEntriesToOrphans(cacheEntry);\n            mMemoryCacheIndex.removeEntry(cacheEntry.key, cacheEntry.value);\n        }\n    }\n    for (CacheEntry<K, V> cacheEntry : matchingEntriesFromEvictionQueue) {\n        cacheEntry.value.close();\n    }\n    return numEvictedEntries;\n}","new_comment_raw":"@return number of the items removed from the cache","old_comment_raw":"@return number of entries that were evicted from the cache","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":60},{"new_code_raw":"private ColumnState buildMap(ContainerState parent, ColumnReadProjection colProj) { ColumnMetadata columnSchema = colProj.providedSchema(); \/\/ When dynamically adding columns, must add the (empty) \/\/ map by itself, then add columns to the map via separate \/\/ calls. assert columnSchema.isMap(); assert columnSchema.mapSchema().size() == 0; \/\/ Create the vector, vector state and writer. if (columnSchema.isArray()) { return buildMapArray(parent, colProj); } else { return buildSingleMap(parent, colProj); } }","old_code_raw":"  private ColumnState buildMap(ContainerState parent, ColumnTransform outputCol) {\n    ColumnMetadata columnSchema = outputCol.outputSchema();\n\n    \/\/ When dynamically adding columns, must add the (empty)\n    \/\/ map by itself, then add columns to the map via separate\n    \/\/ calls.\n\n    assert columnSchema.isMap();\n    assert columnSchema.mapSchema().size() == 0;\n\n    \/\/ Create the vector, vector state and writer.\n\n    if (columnSchema.isArray()) {\n      return buildMapArray(parent, outputCol);\n    } else {\n      return buildSingleMap(parent, outputCol);\n    }\n  }\n","new_comment_raw":"@return column state for the map column","old_comment_raw":"@return column state for the map column","label":0,"pre_label":1,"AST_level":7,"line_counts":19,"new_code_token_num":103},{"new_code_raw":"public EString append(String str) { return append(EStringConst.create(str)); }","old_code_raw":"    public EString append(String str) {\n        return append(EString.__create(str));\n    }\n","new_comment_raw":"@return this + str","old_comment_raw":"@return this + str","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public String getName() { String name = path.getFileName().toString(); if (name.toLowerCase().endsWith(Aes256Cryptor.FOLDER_EXTENSION.toLowerCase())) { name = name.substring(0, name.length() - Aes256Cryptor.FOLDER_EXTENSION.length()); } return name; }","old_code_raw":"\tpublic String getName() {\n\t\treturn path.getFileName().toString();\n\t}\n","new_comment_raw":"@return Directory name without preceeding path components","old_comment_raw":"@return Directory name without preceeding path components","label":0,"pre_label":1,"AST_level":9,"line_counts":8,"new_code_token_num":55},{"new_code_raw":"public static int getIEVersion(WebDriver driver) { String userAgent = getUserAgent(driver); \/\/ extract browser string Pattern browserPattern = Pattern.compile(\"MSIE\\\\s+\\\\d+\\\\.\"); Matcher browserMatcher = browserPattern.matcher(userAgent); \/\/ IE dropped the \"MSIE\" token from its user agent string starting with IE11. Pattern tridentPattern = Pattern.compile(\"Trident\/\\\\d+\\\\.\"); Matcher tridentMatcher = tridentPattern.matcher(userAgent); Matcher versionMatcher; if (browserMatcher.find()) { versionMatcher = Pattern.compile(\"(\\\\d+)\").matcher(browserMatcher.group()); } else if (tridentMatcher.find()) { versionMatcher = Pattern.compile(\"rv:(\\\\d+)\").matcher(userAgent); } else { return 0; } \/\/ extract version string if (!versionMatcher.find()) { return 0; } return Integer.parseInt(versionMatcher.group(1)); }","old_code_raw":"  public static int getIEVersion(WebDriver driver) {\n    \/\/ extract browser string\n    Pattern browserPattern = Pattern.compile(\"MSIE\\\\s+\\\\d+\\\\.\");\n    Matcher browserMatcher = browserPattern.matcher(getUserAgent(driver));\n    if (!browserMatcher.find()) {\n      return 0;\n    }\n    String browserStr = browserMatcher.group();\n\n    \/\/ extract version string\n    Pattern versionPattern = Pattern.compile(\"\\\\d+\");\n    Matcher versionMatcher = versionPattern.matcher(browserStr);\n    if (!versionMatcher.find()) {\n      return 0;\n    }\n    return Integer.parseInt(versionMatcher.group());\n  }\n","new_comment_raw":"@return The found version, or 0 if no version could be found.","old_comment_raw":"@return The found version, or 0 if no version could be found.","label":0,"pre_label":1,"AST_level":10,"line_counts":25,"new_code_token_num":190},{"new_code_raw":"public DateTimeField halfdayOfDay() { return UnsupportedDateTimeField.getInstance (DateTimeFieldType.halfdayOfDay(), UnsupportedDurationField.getInstance(\"halfdays\")); }","old_code_raw":"    public DateTimeField halfdayOfDay() {\n        return UnsupportedDateTimeField.getInstance\n            (\"halfdayOfDay\", UnsupportedDurationField.getInstance(\"halfdays\"));\n    }\n","new_comment_raw":"@return DateTimeField or UnsupportedDateTimeField if unsupported","old_comment_raw":"@return DateTimeField or UnsupportedDateTimeField if unsupported","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":25},{"new_code_raw":"public Integer getIndexForColumnName(String columnName, ResultSet rs) throws SQLException { final Integer cached = columnNameToIndexCache.get( columnName ); if ( cached != null ) { return cached; } else { final Integer index = Integer.valueOf( rs.findColumn( columnName ) ); columnNameToIndexCache.put( columnName, index); return index; } }","old_code_raw":"\tpublic int getIndexForColumnName(String columnName, ResultSet rs) throws SQLException {\n\t\tfinal Integer cached = columnNameToIndexCache.get( columnName );\n\t\tif ( cached != null ) {\n\t\t\treturn cached;\n\t\t}\n\t\telse {\n\t\t\tfinal int index = rs.findColumn( columnName );\n\t\t\tcolumnNameToIndexCache.put( columnName, index);\n\t\t\treturn index;\n\t\t}\n\t}\n","new_comment_raw":"@return The index","old_comment_raw":"@return The index","label":0,"pre_label":1,"AST_level":9,"line_counts":12,"new_code_token_num":61},{"new_code_raw":"public static AdditionalFieldPlacement parse(String value) { if (value == null) { return null; } value = value.trim(); for (AdditionalFieldPlacement option : AdditionalFieldPlacement.values()) { if (option.getValue().equalsIgnoreCase(value)) { return option; } } return null; }","old_code_raw":"        public static AdditionalFieldPlacement parse(String value, String defaultValue) {\n            AdditionalFieldPlacement mode = parse(value);\n            if (mode == null && defaultValue != null) mode = parse(defaultValue);\n            return mode;\n        }\n","new_comment_raw":"@return the matching option, or null if no match is found","old_comment_raw":"@return the matching option, or null if no match is found and the non-null default is invalid","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":57},{"new_code_raw":"Action action(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException { if (!Utils.properProtocol(req)) { logger.debug(\"Invalid request state.\"); res.setStatus(501); res.addHeader(X_ATMOSPHERE_ERROR, \"Websocket protocol not supported\"); res.flushBuffer(); return new Action(); } if (Utils.webSocketEnabled(req) && !supportWebSocket()) { logger.warn(\"Websocket protocol not supported\"); res.setStatus(501); res.addHeader(X_ATMOSPHERE_ERROR, \"Websocket protocol not supported\"); res.flushBuffer(); return new Action(); } if (config.handlers().isEmpty()) { logger.error(\"No AtmosphereHandler found. Make sure you define it inside WEB-INF\/atmosphere.xml or annotate using @___Service\"); throw new AtmosphereMappingException(\"No AtmosphereHandler found. Make sure you define it inside WEB-INF\/atmosphere.xml or annotate using @___Service\"); } if (res.request() == null) { res.request(req); } if (supportSession()) { \/\/ Create the session needed to support the Resume \/\/ operation from disparate requests. HttpSession s = req.getSession(config.getInitParameter(PROPERTY_SESSION_CREATE, true)); if (s != null && s.isNew()) { s.setAttribute(FrameworkConfig.BROADCASTER_FACTORY, config.getBroadcasterFactory()); } } req.setAttribute(FrameworkConfig.SUPPORT_SESSION, supportSession()); int tracing = 0; AtmosphereHandlerWrapper handlerWrapper = map(req); if (config.getBroadcasterFactory() == null) { logger.error(\"Atmosphere is misconfigured and will not work. BroadcasterFactory is null\"); return Action.CANCELLED; } AtmosphereResourceImpl resource = configureWorkflow(null, handlerWrapper, req, res); String v = req.getHeader(HeaderConfig.X_ATMO_BINARY); if (v != null) { resource.forceBinaryWrite(Boolean.valueOf(v)); } \/\/ handler interceptor lists Action a = invokeInterceptors(handlerWrapper.interceptors, resource, tracing); if (a.type() != Action.TYPE.CONTINUE && a.type() != Action.TYPE.SKIP_ATMOSPHEREHANDLER) { return a; } \/\/ Remap occured. if (req.getAttribute(FrameworkConfig.NEW_MAPPING) != null) { req.removeAttribute(FrameworkConfig.NEW_MAPPING); handlerWrapper = map(req); if (handlerWrapper == null) { logger.debug(\"Remap {}\", resource.uuid()); throw new AtmosphereMappingException(\"Invalid state. No AtmosphereHandler maps request for \" + req.getRequestURI()); } resource = configureWorkflow(resource, handlerWrapper, req, res); resource.setBroadcaster(handlerWrapper.broadcaster); } \/\/Unit test mock the request and will throw NPE. boolean skipAtmosphereHandler = req.getAttribute(SKIP_ATMOSPHEREHANDLER.name()) != null ? (Boolean) req.getAttribute(SKIP_ATMOSPHEREHANDLER.name()) : Boolean.FALSE; if (!skipAtmosphereHandler) { try { logger.trace(\"\\t Last: {}\", handlerWrapper.atmosphereHandler.getClass().getName()); handlerWrapper.atmosphereHandler.onRequest(resource); } catch (IOException t) { resource.onThrowable(t); throw t; } } postInterceptors(handlerWrapper.interceptors, resource); Action action = resource.action(); if (supportSession() && allowSessionTimeoutRemoval() && action.type().equals(Action.TYPE.SUSPEND)) { \/\/ Do not allow times out. SessionTimeoutSupport.setupTimeout(config, req.getSession(config.getInitParameter(ApplicationConfig.PROPERTY_SESSION_CREATE, true))); } logger.trace(\"Action for {} was {} with transport \" + req.getHeader(X_ATMOSPHERE_TRANSPORT), req.resource() != null ? req.resource().uuid() : \"null\", action); return action; }","old_code_raw":"    Action action(AtmosphereRequest req, AtmosphereResponse res) throws IOException, ServletException {\n\n        if (!Utils.properProtocol(req)) {\n            logger.debug(\"Invalid request state.\");\n            res.setStatus(501);\n            res.addHeader(X_ATMOSPHERE_ERROR, \"Websocket protocol not supported\");\n            res.flushBuffer();\n            return new Action();\n        }\n\n        if (Utils.webSocketEnabled(req) && !supportWebSocket()) {\n            logger.warn(\"Websocket protocol not supported\");\n            res.setStatus(501);\n            res.addHeader(X_ATMOSPHERE_ERROR, \"Websocket protocol not supported\");\n            res.flushBuffer();\n            return new Action();\n        }\n\n        \/\/ https:\/\/github.com\/Atmosphere\/atmosphere\/issues\/1637\n        if (isServlet30 && (!req.isAsyncSupported() && !Utils.closeMessage(req))) {\n            logger.error(\"Invalid request state. <async-supported>true<\/async-supported> must be defined for ALL Servlets and Filters  declarations in web.xml {}\", req.getRequestURL().toString());\n            res.setStatus(501);\n            res.addHeader(X_ATMOSPHERE_ERROR, \"<async-supported>true<\/async-supported> must be defined for ALL Servlets and Filters  declarations in web.xml.\");\n            res.flushBuffer();\n            return new Action();\n        }\n\n        if (config.handlers().isEmpty()) {\n            logger.error(\"No AtmosphereHandler found. Make sure you define it inside WEB-INF\/atmosphere.xml or annotate using @___Service\");\n            throw new AtmosphereMappingException(\"No AtmosphereHandler found. Make sure you define it inside WEB-INF\/atmosphere.xml or annotate using @___Service\");\n        }\n\n        if (res.request() == null) {\n            res.request(req);\n        }\n\n        if (supportSession()) {\n            \/\/ Create the session needed to support the Resume\n            \/\/ operation from disparate requests.\n            HttpSession s = req.getSession(config.getInitParameter(PROPERTY_SESSION_CREATE, true));\n            if (s != null && s.isNew()) {\n                s.setAttribute(FrameworkConfig.BROADCASTER_FACTORY, config.getBroadcasterFactory());\n            }\n\n        }\n\n        req.setAttribute(FrameworkConfig.SUPPORT_SESSION, supportSession());\n\n        int tracing = 0;\n\n        AtmosphereHandlerWrapper handlerWrapper = map(req);\n        if (config.getBroadcasterFactory() == null) {\n            logger.error(\"Atmosphere is misconfigured and will not work. BroadcasterFactory is null\");\n            return Action.CANCELLED;\n        }\n        AtmosphereResourceImpl resource = configureWorkflow(null, handlerWrapper, req, res);\n\n        String v = req.getHeader(HeaderConfig.X_ATMO_BINARY);\n        if (v != null) {\n            resource.forceBinaryWrite(Boolean.valueOf(v));\n        }\n\n        \/\/ handler interceptor lists\n        Action a = invokeInterceptors(handlerWrapper.interceptors, resource, tracing);\n        if (a.type() != Action.TYPE.CONTINUE && a.type() != Action.TYPE.SKIP_ATMOSPHEREHANDLER) {\n            return a;\n        }\n\n        \/\/ Remap occured.\n        if (req.getAttribute(FrameworkConfig.NEW_MAPPING) != null) {\n            req.removeAttribute(FrameworkConfig.NEW_MAPPING);\n            handlerWrapper = map(req);\n            if (handlerWrapper == null) {\n                logger.debug(\"Remap {}\", resource.uuid());\n                throw new AtmosphereMappingException(\"Invalid state. No AtmosphereHandler maps request for \" + req.getRequestURI());\n            }\n            resource = configureWorkflow(resource, handlerWrapper, req, res);\n            resource.setBroadcaster(handlerWrapper.broadcaster);\n        }\n\n        \/\/Unit test mock the request and will throw NPE.\n        boolean skipAtmosphereHandler = req.getAttribute(SKIP_ATMOSPHEREHANDLER.name()) != null\n                ? (Boolean) req.getAttribute(SKIP_ATMOSPHEREHANDLER.name()) : Boolean.FALSE;\n        if (!skipAtmosphereHandler) {\n            try {\n                logger.trace(\"\\t Last: {}\", handlerWrapper.atmosphereHandler.getClass().getName());\n                handlerWrapper.atmosphereHandler.onRequest(resource);\n            } catch (IOException t) {\n                resource.onThrowable(t);\n                throw t;\n            }\n        }\n\n        postInterceptors(handlerWrapper.interceptors, resource);\n\n        Action action = resource.action();\n        if (supportSession() && allowSessionTimeoutRemoval() && action.type().equals(Action.TYPE.SUSPEND)) {\n            \/\/ Do not allow times out.\n            SessionTimeoutSupport.setupTimeout(config, req.getSession(config.getInitParameter(ApplicationConfig.PROPERTY_SESSION_CREATE, true)));\n        }\n        logger.trace(\"Action for {} was {} with transport \" + req.getHeader(X_ATMOSPHERE_TRANSPORT), req.resource() != null ? req.resource().uuid() : \"null\", action);\n        return action;\n    }\n","new_comment_raw":"@return action the Action operation.","old_comment_raw":"@return action the Action operation.","label":0,"pre_label":1,"AST_level":10,"line_counts":95,"new_code_token_num":703},{"new_code_raw":"public Float getRightValue() { return rightValue; }","old_code_raw":"public float getRightValue() {\n    return rightValue == null ? NUM : rightValue.floatValue();\n}","new_comment_raw":"@return The value of the 'right' attribute, null if not set","old_comment_raw":"@return The value of the 'right' CSS-attribute","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public static SchemaPath parseFromString(String expr) { if (expr == null || expr.isEmpty()) { return null; } if (SchemaPath.DYNAMIC_STAR.equals(expr)) { return SchemaPath.getSimplePath(expr); } LogicalExpression logicalExpression = LogicalExpressionParser.parse(expr); if (logicalExpression instanceof SchemaPath) { return (SchemaPath) logicalExpression; } else { throw new IllegalStateException(String.format(\"Schema path is not a valid format: %s.\", logicalExpression)); } }","old_code_raw":"  public static SchemaPath parseFromString(String expr) {\n    if (expr == null || expr.isEmpty()) {\n      return null;\n    }\n    try {\n      if (SchemaPath.DYNAMIC_STAR.equals(expr)) {\n        return SchemaPath.getSimplePath(expr);\n      }\n      ExprLexer lexer = new ExprLexer(new ANTLRStringStream(expr));\n      CommonTokenStream tokens = new CommonTokenStream(lexer);\n      ExprParser parser = new ExprParser(tokens);\n\n      parse_return ret = parser.parse();\n\n      if (ret.e instanceof SchemaPath) {\n        return (SchemaPath) ret.e;\n      } else {\n        throw new IllegalStateException(\"Schema path is not a valid format.\");\n      }\n    } catch (RecognitionException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","new_comment_raw":"@return  SchemaPath instance","old_comment_raw":"@return SchemaPath instance","label":0,"pre_label":1,"AST_level":8,"line_counts":17,"new_code_token_num":93},{"new_code_raw":"public RequestBody serialize(Object obj, String contentType) throws ApiException { if (obj instanceof byte[]) { \/\/ Binary (byte array) body parameter support. return RequestBody.create(MediaType.parse(contentType), (byte[]) obj); } else if (obj instanceof File) { \/\/ File body parameter support. return RequestBody.create(MediaType.parse(contentType), (File) obj); } else if (isJsonMime(contentType)) { String content; if (obj != null) { content = json.serialize(obj); } else { content = null; } return RequestBody.create(MediaType.parse(contentType), content); } else { throw new ApiException(\"Content type \\\"\" + contentType + \"\\\" is not supported\"); } }","old_code_raw":"  public String serialize(Object obj, String contentType) throws ApiException {\n    if (isJsonMime(contentType)) {\n      if (obj != null)\n        return json.serialize(obj);\n      else\n        return null;\n    } else {\n      throw new ApiException(\"Content type \\\"\" + contentType + \"\\\" is not supported\");\n    }\n  }\n","new_comment_raw":"@return The serialized request body","old_comment_raw":"@return The serialized string","label":1,"pre_label":0,"AST_level":12,"line_counts":20,"new_code_token_num":155},{"new_code_raw":"public String[] getAttributeFromAllWindows(String attributeName) { String current = driver.getWindowHandle(); List<String> attributes = new ArrayList<String>(); for (String handle : driver.getWindowHandles()) { driver.switchTo().window(handle); String value = (String) ((JavascriptExecutor) driver).executeScript( \"return '' + window[arguments[0]];\", attributeName); attributes.add(value); } driver.switchTo().window(current); return attributes.toArray(new String[attributes.size()]); }","old_code_raw":"  public String[] getAttributeFromAllWindows(String attributeName) {\n    throw new UnsupportedOperationException(\"getAttributeFromAllWindows\");\n  }\n","new_comment_raw":"@return the set of values of this attribute from all known windows.","old_comment_raw":"@return the set of values of this attribute from all known windows.","label":0,"pre_label":1,"AST_level":9,"line_counts":16,"new_code_token_num":108},{"new_code_raw":"public PingResult performCheck(PingConfiguration configuration) { PingResult info = client.ping(configuration); setPingInfo(info, configuration, client); return info; }","old_code_raw":"public PingInfo performCheck(PingConfiguration configuration) {\n    PingInfo info = client.ping(configuration);\n    setPingInfo(info, configuration, client);\n    return info;\n}","new_comment_raw":"@return {@link PingResult}","old_comment_raw":"@return {@link PingInfo}","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":29},{"new_code_raw":"CloseableReference<Bitmap> decodeFromEncodedImage(EncodedImage encodedImage) { return doDecodeStaticImage(encodedImage.getInputStream(), encodedImage.getSampleSize()); }","old_code_raw":"  CloseableReference<Bitmap> decodeFromEncodedImage(EncodedImage encodedImage) {\n    return doDecodeStaticImage(encodedImage.getInputStream());\n  }\n","new_comment_raw":"@return the bitmap","old_comment_raw":"@return the bitmap","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public boolean searchEditText(String search) { Pattern p = Pattern.compile(search); Matcher matcher; ArrayList<EditText> editTextList = getCurrentEditTexts(); Iterator<EditText> iterator = editTextList.iterator(); while (iterator.hasNext()) { EditText editText = (EditText) iterator.next(); matcher = p.matcher(editText.getText().toString()); if (matcher.matches()) { return true; } } if (scrollDownList()) return searchEditText(search); else return false; }","old_code_raw":"public EditText searchEditText(String search) {\n    ArrayList<EditText> editTextList = getCurrentEditTexts();\n    Iterator<EditText> iterator = editTextList.iterator();\n    while (iterator.hasNext()) {\n        EditText editText = (EditText) iterator.next();\n        if (editText.getText().toString().equals(search)) {\n            return editText;\n        }\n    }\n    return null;\n}","new_comment_raw":"@return true if an edit text with the given text is found or false if it is not found","old_comment_raw":"@return the EditText found or null if nothing is found","label":1,"pre_label":0,"AST_level":9,"line_counts":17,"new_code_token_num":95},{"new_code_raw":"public static List<CoreMap> findAndMergeNumbers(CoreMap annotationRaw){ \/\/copy annotation to preserve its integrity CoreMap annotation = new ArrayCoreMap(annotationRaw); \/\/ Find and label numbers List<CoreMap> numbers = NumberNormalizer.findNumbers(annotation); CoreMapAggregator numberAggregator = CoreMapAggregator.getAggregator(CoreMapAttributeAggregator.DEFAULT_NUMERIC_AGGREGATORS, CoreAnnotations.TokensAnnotation.class); \/\/ We are going to mark the token begin and token end for each token so we can more easily deal with \/\/ ensuring correct token offsets for merging \/\/get sentence offset Integer startTokenOffset = annotation.get(CoreAnnotations.TokenBeginAnnotation.class); if (startTokenOffset == null) { startTokenOffset = 0; } \/\/set token offsets int i = 0; List<Integer> savedTokenBegins = new LinkedList<Integer>(); List<Integer> savedTokenEnds = new LinkedList<Integer>(); for (CoreMap c:annotation.get(CoreAnnotations.TokensAnnotation.class)) { \/\/set token begin if( (i==0 && c.get(CoreAnnotations.TokenBeginAnnotation.class) != null) || (i > 0 && !savedTokenBegins.isEmpty()) ){ savedTokenBegins.add(c.get(CoreAnnotations.TokenBeginAnnotation.class)); } c.set(CoreAnnotations.TokenBeginAnnotation.class, i+startTokenOffset); i++; \/\/set token end if( (i==1 && c.get(CoreAnnotations.TokenEndAnnotation.class) != null) || (i > 1 && !savedTokenEnds.isEmpty()) ){ savedTokenEnds.add(c.get(CoreAnnotations.TokenEndAnnotation.class)); } c.set(CoreAnnotations.TokenEndAnnotation.class, i+startTokenOffset); } \/\/merge numbers final Integer startTokenOffsetFinal = startTokenOffset; List<CoreMap> mergedNumbers = numberAggregator.merge(annotation.get(CoreAnnotations.TokensAnnotation.class), numbers, in -> Interval.toInterval( in.get(CoreAnnotations.TokenBeginAnnotation.class) - startTokenOffsetFinal, in.get(CoreAnnotations.TokenEndAnnotation.class) - startTokenOffsetFinal) ); \/\/restore token offsets if (!savedTokenBegins.isEmpty() && !savedTokenEnds.isEmpty()) { for (CoreMap c : mergedNumbers) { \/\/ get new indices int newBegin = c.get(CoreAnnotations.TokenBeginAnnotation.class) - startTokenOffset; int newEnd = c.get(CoreAnnotations.TokenEndAnnotation.class) - startTokenOffset; \/\/ get token offsets for those indices c.set(CoreAnnotations.TokenBeginAnnotation.class, savedTokenBegins.get(newBegin)); c.set(CoreAnnotations.TokenEndAnnotation.class, savedTokenEnds.get(newEnd-1)); } } \/\/return return mergedNumbers; }","old_code_raw":"  public static List<CoreMap> findAndMergeNumbers(CoreMap annotationRaw){\n    \/\/copy annotation to preserve its integrity\n    CoreMap annotation = new ArrayCoreMap(annotationRaw);\n    \/\/ Find and label numbers\n    List<CoreMap> numbers = NumberNormalizer.findNumbers(annotation);\n    CoreMapAggregator numberAggregator = CoreMapAggregator.getAggregator(CoreMapAttributeAggregator.DEFAULT_NUMERIC_AGGREGATORS, CoreAnnotations.TokensAnnotation.class);\n\n    \/\/ We are going to mark the token begin and token end for each token so we can more easily deal with\n    \/\/ ensuring correct token offsets for merging\n    \/\/get sentence offset\n    Integer startTokenOffset = annotation.get(CoreAnnotations.TokenBeginAnnotation.class);\n    if (startTokenOffset == null) {\n      startTokenOffset = 0;\n    }\n    \/\/set token offsets\n    int i = 0;\n    List<Integer> savedTokenBegins = new LinkedList<Integer>();\n    List<Integer> savedTokenEnds = new LinkedList<Integer>();\n    for (CoreMap c:annotation.get(CoreAnnotations.TokensAnnotation.class)) {\n      \/\/set token begin\n      if( (i==0 && c.get(CoreAnnotations.TokenBeginAnnotation.class) != null) || (i > 0 && !savedTokenBegins.isEmpty()) ){\n        savedTokenBegins.add(c.get(CoreAnnotations.TokenBeginAnnotation.class));\n      }\n      c.set(CoreAnnotations.TokenBeginAnnotation.class, i+startTokenOffset);\n      i++;\n      \/\/set token end\n      if( (i==1 && c.get(CoreAnnotations.TokenEndAnnotation.class) != null) || (i > 1 && !savedTokenEnds.isEmpty()) ){\n        savedTokenEnds.add(c.get(CoreAnnotations.TokenEndAnnotation.class));\n      }\n      c.set(CoreAnnotations.TokenEndAnnotation.class, i+startTokenOffset);\n    }\n    \/\/merge numbers\n    final Integer startTokenOffsetFinal = startTokenOffset;\n    List<CoreMap> mergedNumbers = numberAggregator.merge(annotation.get(CoreAnnotations.TokensAnnotation.class), numbers,\n          new Function<CoreMap, Interval<Integer>>() {\n            @Override\n            public Interval<Integer> apply(CoreMap in) {\n              return Interval.toInterval(\n                    in.get(CoreAnnotations.TokenBeginAnnotation.class) - startTokenOffsetFinal,\n                    in.get(CoreAnnotations.TokenEndAnnotation.class) - startTokenOffsetFinal);\n            }\n          });\n    \/\/restore token offsets\n    if (!savedTokenBegins.isEmpty() && !savedTokenEnds.isEmpty()) {\n      for (CoreMap c : mergedNumbers) {\n        \/\/ get new indices\n        int newBegin = c.get(CoreAnnotations.TokenBeginAnnotation.class) - startTokenOffset;\n        int newEnd = c.get(CoreAnnotations.TokenEndAnnotation.class) - startTokenOffset;\n        \/\/ get token offsets for those indices\n        c.set(CoreAnnotations.TokenBeginAnnotation.class, savedTokenBegins.get(newBegin));\n        c.set(CoreAnnotations.TokenEndAnnotation.class, savedTokenEnds.get(newEnd-1));\n      }\n    }\n    \/\/return\n    return mergedNumbers;\n  }\n","new_comment_raw":"@return list of CoreMap representing the identified numbers","old_comment_raw":"@return list of CoreMap representing the identified numbers","label":0,"pre_label":1,"AST_level":12,"line_counts":53,"new_code_token_num":437},{"new_code_raw":"public Task<EncodedImage> get(CacheKey key, AtomicBoolean isCancelled) { final EncodedImage pinnedImage = mStagingArea.get(key); if (pinnedImage != null) { return foundPinnedImage(key, pinnedImage); } return getAsync(key, isCancelled); }","old_code_raw":"public Task<EncodedImage> get(final CacheKey key, final AtomicBoolean isCancelled) {\n    Preconditions.checkNotNull(key);\n    Preconditions.checkNotNull(isCancelled);\n    final EncodedImage pinnedImage = mStagingArea.get(key);\n    if (pinnedImage != null) {\n        FLog.v(TAG, STR, key.toString());\n        mImageCacheStatsTracker.onStagingAreaHit();\n        return Task.forResult(pinnedImage);\n    }\n    try {\n        return Task.call(new Callable<EncodedImage>() {\n\n            @Override\n            public EncodedImage call() throws Exception {\n                if (isCancelled.get()) {\n                    throw new CancellationException();\n                }\n                EncodedImage result = mStagingArea.get(key);\n                if (result != null) {\n                    FLog.v(TAG, STR, key.toString());\n                    mImageCacheStatsTracker.onStagingAreaHit();\n                } else {\n                    FLog.v(TAG, STR, key.toString());\n                    mImageCacheStatsTracker.onStagingAreaMiss();\n                    try {\n                        final PooledByteBuffer buffer = readFromDiskCache(key);\n                        CloseableReference<PooledByteBuffer> ref = CloseableReference.of(buffer);\n                        try {\n                            result = new EncodedImage(ref);\n                        } finally {\n                            CloseableReference.closeSafely(ref);\n                        }\n                    } catch (Exception exception) {\n                        return null;\n                    }\n                }\n                if (Thread.interrupted()) {\n                    FLog.v(TAG, STR);\n                    if (result != null) {\n                        result.close();\n                    }\n                    throw new InterruptedException();\n                } else {\n                    return result;\n                }\n            }\n        }, mReadExecutor);\n    } catch (Exception exception) {\n        FLog.w(TAG, exception, STR, key.toString());\n        return Task.forError(exception);\n    }\n}","new_comment_raw":"@return Task that resolves to cached element or null if one cannot be retrieved; returned task never rethrows any exception","old_comment_raw":"@return ListenableFuture that resolves to cached element or null if one cannot be retrieved; returned future never rethrows any exception","label":1,"pre_label":0,"AST_level":7,"line_counts":7,"new_code_token_num":46},{"new_code_raw":"public static String asString(final InputStream is, Charset charset) throws IOException { final BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset)); try { final String firstLine = reader.readLine(); if (firstLine == null) { return STR; } final StringBuilder builder = new StringBuilder(firstLine); for (String line = reader.readLine(); line != null; line = reader.readLine()) { builder.append(EOL); builder.append(line); } return builder.toString(); } finally { reader.close(); } }","old_code_raw":"public static String asString(final InputStream is) throws IOException {\n    final BufferedReader reader = new BufferedReader(new InputStreamReader(is, STR));\n    try {\n        return reader.readLine();\n    } finally {\n        reader.close();\n    }\n}","new_comment_raw":"@return the content of the stream.","old_comment_raw":"@return the UTF-8 content of the stream.","label":1,"pre_label":0,"AST_level":8,"line_counts":17,"new_code_token_num":108},{"new_code_raw":"public JSONObject getJSONObject(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONObject) { return (JSONObject) object; } throw new RuntimeException(STR + quote(key) + STR); }","old_code_raw":"public JSONObject getJSONObject(String key) {\n    Object object = this.get(key);\n    if (object instanceof JSONObject) {\n        return (JSONObject) object;\n    }\n    throw new RuntimeException(STR + quote(key) + STR);\n}","new_comment_raw":"@return A JSONObject which is the value or null if not available.","old_comment_raw":"@return A JSONObject which is the value.","label":1,"pre_label":0,"AST_level":8,"line_counts":10,"new_code_token_num":55},{"new_code_raw":"public static String jenkinsJobName(BuildConfig bc) { String namespace = bc.getMetadata().getNamespace(); String name = bc.getMetadata().getName(); return jenkinsJobName(namespace, name); }","old_code_raw":"public static String jenkinsJobName(BuildConfig bc, String defaultNamespace) {\n    String namespace = bc.getMetadata().getNamespace();\n    String name = bc.getMetadata().getName();\n    return jenkinsJobName(namespace, name, defaultNamespace);\n}","new_comment_raw":"@return the jenkins job name for the given BuildConfig","old_comment_raw":"@return the jenkins job name for the given BuildConfig and default namespace","label":1,"pre_label":0,"AST_level":6,"line_counts":5,"new_code_token_num":38},{"new_code_raw":"private ZapTextField getTxtHeadline() { if (txtHeadline == null) { txtHeadline = new ZapTextField(); txtHeadline.setBorder(javax.swing.BorderFactory.createEtchedBorder(javax.swing.border.EtchedBorder.RAISED)); txtHeadline.setEditable(false); txtHeadline.setEnabled(false); txtHeadline.setBackground(java.awt.Color.white); txtHeadline.setFont(new java.awt.Font(\"Default\", java.awt.Font.BOLD, 12)); } return txtHeadline; }","old_code_raw":"\tprivate JTextField getTxtHeadline() {\n\t\tif (txtHeadline == null) {\n\t\t\ttxtHeadline = new JTextField();\n\t\t\ttxtHeadline.setBorder(javax.swing.BorderFactory.createEtchedBorder(javax.swing.border.EtchedBorder.RAISED));\n\t\t\ttxtHeadline.setEditable(false);\n\t\t\ttxtHeadline.setEnabled(false);\n\t\t\ttxtHeadline.setBackground(java.awt.Color.white);\n\t\t\ttxtHeadline.setFont(new java.awt.Font(\"Default\", java.awt.Font.BOLD, 12));\n\t\t}\n\t\treturn txtHeadline;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":10,"line_counts":12,"new_code_token_num":81},{"new_code_raw":"public static int getIntParam(JSONObject params, String paramName) throws ApiException { if (!params.containsKey(paramName)) { throw new ApiException(ApiException.Type.MISSING_PARAMETER, paramName); } try { return params.getInt(paramName); } catch (JSONException e) { throw new ApiException(ApiException.Type.ILLEGAL_PARAMETER, paramName, e); } }","old_code_raw":"\tpublic static int getIntParam(JSONObject params, String paramName) throws ApiException {\n\t\tint value;\n\t\ttry {\n\t\t\tvalue = params.getInt(paramName);\n\t\t} catch (Exception ex) {\n\t\t\tthrow new ApiException(Type.MISSING_PARAMETER, paramName + \": \" + ex.getLocalizedMessage());\n\t\t}\n\t\treturn value;\n\t}\n","new_comment_raw":"@return the int param","old_comment_raw":"@return the int param","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":67},{"new_code_raw":"protected boolean isOutOfRange(int year, int month, int day) { if (mController.getSelectableDays() != null) { return !isSelectable(year, month, day); } if (isBeforeMin(year, month, day)) { return true; } else if (isAfterMax(year, month, day)) { return true; } return false; }","old_code_raw":"protected boolean isOutOfRange(int year, int month, int day) {\n    if (isBeforeMin(year, month, day)) {\n        return true;\n    } else if (isAfterMax(year, month, day)) {\n        return true;\n    }\n    return false;\n}","new_comment_raw":"@return true if the specified year\/month\/day are within the selectable days or the range set by minDate and maxDate. If one or either have not been set, they are considered as Integer.MIN_VALUE and Integer.MAX_VALUE.","old_comment_raw":"@return true if the specified year\/month\/day are within the range set by minDate and maxDate. If one or either have not been set, they are considered as Integer.MIN_VALUE and Integer.MAX_VALUE.","label":1,"pre_label":0,"AST_level":7,"line_counts":11,"new_code_token_num":73},{"new_code_raw":"public Chat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException { return dccHandler.sendChatRequest(sender); }","old_code_raw":"public DccChat dccSendChatRequest(User sender, int timeout) throws IOException, SocketTimeoutException {\n    if (sender == null)\n        throw new IllegalArgumentException(STR);\n    ServerSocket ss = null;\n    ss.setSoTimeout(timeout);\n    int serverPort = ss.getLocalPort();\n    InetAddress ourAddress = getDccInetAddress();\n    if (ourAddress == null)\n        ourAddress = getInetAddress();\n    String ipNum = DccManager.addressToInteger(ourAddress);\n    sendCTCPCommand(sender, STR + ipNum + STR + serverPort);\n    Socket userSocket = ss.accept();\n    ss.close();\n    return new DccChat(this, sender, userSocket);\n}","new_comment_raw":"@return An open {@link Chat}","old_comment_raw":"@return a DccChat object that can be used to send and recieve lines of text. Returns <b>null<\/b> if the connection could not be made.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":23},{"new_code_raw":"private HiscoreLookup getCorrectLookupFor(final ChatMessage chatMessage) { Player localPlayer = client.getLocalPlayer(); final String player = sanitize(chatMessage.getName()); \/\/ If we are sending the message then just use the local hiscore endpoint for the world if (chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT) || player.equals(localPlayer.getName())) { return new HiscoreLookup(localPlayer.getName(), hiscoreEndpoint); } \/\/ Public chat on a leagues world is always league hiscores, regardless of icon if (chatMessage.getType() == ChatMessageType.PUBLICCHAT || chatMessage.getType() == ChatMessageType.MODCHAT) { if (client.getWorldType().contains(WorldType.LEAGUE)) { return new HiscoreLookup(player, HiscoreEndpoint.LEAGUE); } } \/\/ Get ironman status from their icon in chat HiscoreEndpoint endpoint = getHiscoreEndpointByName(chatMessage.getName()); return new HiscoreLookup(player, endpoint); }","old_code_raw":"\tprivate HiscoreLookup getCorrectLookupFor(final ChatMessage chatMessage)\n\t{\n\t\tfinal String player;\n\t\tfinal HiscoreEndpoint ironmanStatus;\n\n\t\tif (chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT))\n\t\t{\n\t\t\tplayer = client.getLocalPlayer().getName();\n\t\t\tironmanStatus = hiscoreEndpoint;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tplayer = sanitize(chatMessage.getName());\n\n\t\t\tif (player.equals(client.getLocalPlayer().getName()))\n\t\t\t{\n\t\t\t\t\/\/ Get ironman status from for the local player\n\t\t\t\tironmanStatus = hiscoreEndpoint;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\/\/ Get ironman status from their icon in chat\n\t\t\t\tironmanStatus = getHiscoreEndpointByName(chatMessage.getName());\n\t\t\t}\n\t\t}\n\n\t\treturn new HiscoreLookup(player, ironmanStatus);\n\t}\n","new_comment_raw":"@return hiscore lookup data","old_comment_raw":"@return hiscore lookup data","label":0,"pre_label":1,"AST_level":9,"line_counts":26,"new_code_token_num":170},{"new_code_raw":"public String getterAndSetterCapitalize(String name) { if (name == null || name.length() == 0) { return name; } return org.openapitools.codegen.utils.StringUtils.camelize(toVarName(name)); }","old_code_raw":"    public String getterAndSetterCapitalize(String name) {\n        if (name == null || name.length() == 0) {\n            return name;\n        }\n        return camelize(toVarName(name));\n    }\n","new_comment_raw":"@return Camelized string","old_comment_raw":"@return Camelized string","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":40},{"new_code_raw":"public String toString() { StringBuffer msg = new StringBuffer(getMessage()); String[] params = getParameters(); for (int i = NUM; i < params.length; i++) { msg.append(STR + params[i]); } return msg.toString(); }","old_code_raw":"public String toString() {\n    return message;\n}","new_comment_raw":"@return A string representation, the parameters are included as a comma-separated list.","old_comment_raw":"@return a string representation disregarding any parameters","label":1,"pre_label":0,"AST_level":10,"line_counts":8,"new_code_token_num":58},{"new_code_raw":"public List<TaggedWord> tagSentence(List<? extends HasWord> sentence) { TestSentence testSentence = new TestSentence(this); return testSentence.tagSentence(sentence, false); }","old_code_raw":"  public ArrayList<TaggedWord> tagSentence(List<? extends HasWord> sentence) {\n    TestSentence testSentence = new TestSentence(this);\n    return testSentence.tagSentence(sentence, false);\n  }\n","new_comment_raw":"@return tagged sentence","old_comment_raw":"@return tagged sentence","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":30},{"new_code_raw":"public Object getValue() { if (isPresenceType()) return null; if (multiValued) return ((Object[]) value)[NUM]; return value; }","old_code_raw":"public Object getValue() {\n    if (isPresenceType())\n        return null;\n    if (valueIsArray)\n        return ((Object[]) value)[NUM];\n    return value;\n}","new_comment_raw":"@return the value of this <code>Value<\/code> object (in case it is single valued), or the first value of this entry (in case it is multivalued).","old_comment_raw":"@return the value of this entry (in case it is single valued), or the first value of this entry (in case it is multivalued).","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":36},{"new_code_raw":"public BooleanExpression equalsIgnoreCase(String str) { return equalsIgnoreCase(new StringConstant(str)); }","old_code_raw":"    public BooleanExpression equalsIgnoreCase(String str) {\n        return equalsIgnoreCase(StringConstant.create(str));\n    }\n","new_comment_raw":"@return this.equalsIgnoreCase(str)","old_comment_raw":"@return this.equalsIgnoreCase(str)","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":19},{"new_code_raw":"public PlaceType getPlaceType(String placeTypeName) throws InvalidPlaceType { PlaceType type = placeTypeNameCache.get(placeTypeName); if (type == null) throw new InvalidPlaceType(placeTypeName); return type; }","old_code_raw":"public PlaceType getPlaceType(String placeType) {\n    return placeTypesCache.get(placeType);\n}","new_comment_raw":"@return the PlaceType corresponding to the provided name.","old_comment_raw":"@return the PlaceType corresponding to the provided name, or null.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":34},{"new_code_raw":"public HttpSession getSelectedSession() { final int selectedRow = this.sessionsTable.getSelectedRow(); if (selectedRow == -1) { \/\/ No row selected return null; } final int rowIndex = sessionsTable.convertRowIndexToModel(this.sessionsTable.getSelectedRow()); return this.sessionsModel.getHttpSessionAt(rowIndex); }","old_code_raw":"\tpublic HttpSession getSelectedSession() {\n\t\tfinal int rowIndex = sessionsTable.convertRowIndexToModel(this.sessionsTable.getSelectedRow());\n\t\treturn this.sessionsModel.getHttpSessionAt(rowIndex);\n\t}\n","new_comment_raw":"@return the selected session, or null if nothing is selected","old_comment_raw":"@return the selected session, or null if nothing is selected","label":0,"pre_label":1,"AST_level":7,"line_counts":10,"new_code_token_num":53},{"new_code_raw":"public ScalewayCloud getCloud() { Jenkins instance = Jenkins.getInstance(); if (instance != null) { return (ScalewayCloud) instance.getCloud(cloudName); } return null; }","old_code_raw":"public Cloud getCloud() {\n    return (Cloud) Jenkins.getInstance().getCloud(cloudName);\n}","new_comment_raw":"@return the ScalewayCloud associated with the specified cloudName","old_comment_raw":"@return the Cloud associated with the specified cloudName","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":35},{"new_code_raw":"public Action doCometSupport(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException { req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory); req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments); req.setAttribute(BROADCASTER_CLASS, broadcasterClassName); req.setAttribute(SUPPORT_TRACKABLE, config.getInitParameter(SUPPORT_TRACKABLE)); try { if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null && isIECandidate(req) && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) { Map<String, String> headers = configureQueryStringAsRequest(req); String body = headers.remove(ATMOSPHERE_POST_BODY); return cometSupport.service(new AtmosphereRequest.Builder() .headers(headers) .method(body != null ? req.getMethod() : \"GET\") .body(body) .request(req).build(), res); } else { return cometSupport.service(req, res); } } catch (IllegalStateException ex) { if (ex.getMessage() != null && ex.getMessage().startsWith(\"Tomcat failed\")) { if (!isFilter) { logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(), ex.getMessage()); logger.warn(\"Using BlockingIOCometSupport.\"); } logger.trace(ex.getMessage(), ex); cometSupport = new BlockingIOCometSupport(config); service(req, res); } else { logger.error(\"AtmosphereServlet exception\", ex); throw ex; } } return null; }","old_code_raw":"    public Action doCometSupport(HttpServletRequest req, HttpServletResponse res)\n            throws IOException, ServletException {\n        req.setAttribute(BROADCASTER_FACTORY, broadcasterFactory);\n        req.setAttribute(PROPERTY_USE_STREAM, useStreamForFlushingComments);\n        req.setAttribute(BROADCASTER_CLASS, broadcasterClassName);\n        req.setAttribute(SUPPORT_TRACKABLE, config.getInitParameter(SUPPORT_TRACKABLE));\n\n        try {\n            if (config.getInitParameter(ALLOW_QUERYSTRING_AS_REQUEST) != null\n                    && isIECandidate(req)\n                    && req.getAttribute(WebSocket.WEBSOCKET_SUSPEND) == null) {\n\n                Map<String, String> headers = configureQueryStringAsRequest(req);\n                String body = headers.remove(ATMOSPHERE_POST_BODY);\n                return cometSupport.service(new AtmosphereRequest.Builder()\n                        .headers(headers)\n                        .method(req.getMethod())\n                        .body(body)\n                        .request(req).build(), res);\n            } else {\n                return cometSupport.service(req, res);\n            }\n        } catch (IllegalStateException ex) {\n            if (ex.getMessage() != null && ex.getMessage().startsWith(\"Tomcat failed\")) {\n                if (!isFilter) {\n                    logger.warn(\"Failed using comet support: {}, error: {} Is the Nio or Apr Connector enabled?\", cometSupport.getClass().getName(),\n                            ex.getMessage());\n                    logger.warn(\"Using BlockingIOCometSupport.\");\n                }\n                logger.trace(ex.getMessage(), ex);\n\n                cometSupport = new BlockingIOCometSupport(config);\n                service(req, res);\n            } else {\n                logger.error(\"AtmosphereServlet exception\", ex);\n                throw ex;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@return an  Action","old_comment_raw":"@return an Action","label":0,"pre_label":1,"AST_level":12,"line_counts":41,"new_code_token_num":287},{"new_code_raw":"@Override public ActivityOptions getActivityLaunchOptions(Launcher launcher, View v) { if (hasControlRemoteAppTransitionPermission()) { try { RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mHandler) { @Override public AnimatorSet getAnimator(RemoteAnimationTargetCompat[] targetCompats) { AnimatorSet anim = new AnimatorSet(); if (!composeRecentsLaunchAnimator(v, targetCompats, anim)) { mLauncher.getStateManager().setCurrentAnimation(anim); anim.play(getIconAnimator(v)); if (launcherIsATargetWithMode(targetCompats, MODE_CLOSING)) { anim.play(getLauncherContentAnimator(false)); } anim.play(getWindowAnimators(v, targetCompats)); } return anim; } }; int duration = findTaskViewToLaunch(launcher, v, null) != null ? RECENTS_LAUNCH_DURATION : APP_LAUNCH_DURATION; int statusBarTransitionDelay = duration - STATUS_BAR_TRANSITION_DURATION; return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(runner, duration, statusBarTransitionDelay)); } catch (NoClassDefFoundError e) { } } return getDefaultActivityLaunchOptions(launcher, v); }","old_code_raw":"@Override\npublic Bundle getActivityLaunchOptions(Launcher launcher, View v) {\n    if (hasControlRemoteAppTransitionPermission()) {\n        try {\n            RemoteAnimationRunnerCompat runner = new LauncherAnimationRunner(mLauncher) {\n\n                @Override\n                public void onAnimationStart(RemoteAnimationTargetCompat[] targets, Runnable finishedCallback) {\n                    postAtFrontOfQueueAsynchronously(v.getHandler(), () -> {\n                        mAnimator = new AnimatorSet();\n                        setCurrentAnimator(mAnimator);\n                        mAnimator.play(getLauncherAnimators(v));\n                        mAnimator.play(getWindowAnimators(v, targets));\n                        mAnimator.addListener(new AnimatorListenerAdapter() {\n\n                            @Override\n                            public void onAnimationEnd(Animator animation) {\n                                v.setVisibility(View.VISIBLE);\n                                ((ViewGroup) mDragLayer.getParent()).removeView(mFloatingView);\n                                mDragLayer.setAlpha(NUM);\n                                mDragLayer.setTranslationY(NUM);\n                                View appsView = mLauncher.getAppsView();\n                                appsView.setAlpha(NUM);\n                                appsView.setTranslationY(NUM);\n                                finishedCallback.run();\n                            }\n                        });\n                        mAnimator.start();\n                        mAnimator.setCurrentPlayTime(REFRESH_RATE_MS);\n                    });\n                }\n            };\n            return ActivityOptionsCompat.makeRemoteAnimation(new RemoteAnimationAdapterCompat(runner, NUM, NUM)).toBundle();\n        } catch (NoClassDefFoundError e) {\n        }\n    }\n    return getDefaultActivityLaunchOptions(launcher, v);\n}","new_comment_raw":"@return ActivityOptions with remote animations that controls how the window of the opening targets are displayed.","old_comment_raw":"@return A Bundle with remote animations that controls how the window of the opening targets are displayed.","label":1,"pre_label":0,"AST_level":17,"line_counts":28,"new_code_token_num":174},{"new_code_raw":"private Uri getResizedImage (final String realPath, final int initialWidth, final int initialHeight) { final BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 8; Bitmap photo = BitmapFactory.decodeFile(realPath, options); Bitmap scaledphoto = null; if (maxWidth == 0) { maxWidth = initialWidth; } if (maxHeight == 0) { maxHeight = initialHeight; } double widthRatio = (double)maxWidth \/ initialWidth; double heightRatio = (double)maxHeight \/ initialHeight; double ratio = (widthRatio < heightRatio) ? widthRatio : heightRatio; int newWidth = (int)(initialWidth * ratio); int newHeight = (int)(initialHeight * ratio); scaledphoto = Bitmap.createScaledBitmap(photo, newWidth, newHeight, true); ByteArrayOutputStream bytes = new ByteArrayOutputStream(); scaledphoto.compress(Bitmap.CompressFormat.JPEG, quality, bytes); String filname = UUID.randomUUID().toString(); File path = Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES); File f = new File(path, filname +\".jpg\"); try { \/\/ Make sure the Pictures directory exists. path.mkdirs(); f.createNewFile(); } catch (IOException e) { e.printStackTrace(); } FileOutputStream fo; try { fo = new FileOutputStream(f); try { fo.write(bytes.toByteArray()); } catch (IOException e) { e.printStackTrace(); } } catch (FileNotFoundException e) { e.printStackTrace(); } \/\/ recycle to avoid java.lang.OutOfMemoryError if (photo != null) { photo.recycle(); photo = null; } return Uri.fromFile(f); }","old_code_raw":"  private String getResizedImage (final String realPath, final int initialWidth, final int initialHeight) {\n        Bitmap photo = BitmapFactory.decodeFile(realPath);\n\n        Bitmap scaledphoto = null;\n        if (maxWidth == 0) {\n            maxWidth  = initialWidth;\n        }\n        if (maxHeight == 0) {\n            maxHeight = initialHeight;\n        }\n        double widthRatio = (double)maxWidth \/ initialWidth;\n        double heightRatio = (double)maxHeight \/ initialHeight;\n\n        double ratio = (widthRatio < heightRatio)\n                ? widthRatio\n                : heightRatio;\n\n        int newWidth = (int)(initialWidth * ratio);\n        int newHeight = (int)(initialHeight * ratio);\n\n        scaledphoto = Bitmap.createScaledBitmap(photo, newWidth, newHeight, true);\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        scaledphoto.compress(Bitmap.CompressFormat.JPEG, quality, bytes);\n        String filname = UUID.randomUUID().toString();\n        File path = Environment.getExternalStoragePublicDirectory(\n            Environment.DIRECTORY_PICTURES);\n        File f = new File(path, filname +\".jpg\");\n        try {\n            \/\/ Make sure the Pictures directory exists.\n            path.mkdirs();\n\n            f.createNewFile();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        FileOutputStream fo;\n        try {\n            fo = new FileOutputStream(f);\n            try {\n                fo.write(bytes.toByteArray());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        return f.getAbsolutePath();\n  }\n","new_comment_raw":"@return uri of resized file","old_comment_raw":"@return absolute path of resized file","label":1,"pre_label":0,"AST_level":7,"line_counts":57,"new_code_token_num":295},{"new_code_raw":"public static ReferenceResult findReferencedMembers(FieldInfo fieldInfo) { Set<String> members = new HashSet<String>(); ClassMemberVisitor visitor = new ClassMemberVisitor(members); Set<Integer> ids = findPoolReferences(fieldInfo); visitor.visitField(fieldInfo); visitPoolReferences(fieldInfo.getClassInfo(), visitor, ids); return new ReferenceResult(members, new ArrayList<InvokeSite>(NUM)); }","old_code_raw":"public static Set<String> findReferencedMembers(FieldInfo fieldInfo) {\n    Set<String> members = new HashSet<String>();\n    ClassMemberVisitor visitor = new ClassMemberVisitor(members);\n    Set<Integer> ids = findPoolReferences(fieldInfo);\n    visitor.visitField(fieldInfo);\n    visitPoolReferences(fieldInfo.getClassInfo(), visitor, ids);\n    return members;\n}","new_comment_raw":"@return a set of class names and class member signatures found in the field.","old_comment_raw":"@return a set of class names and class member signatures found in the class.","label":1,"pre_label":0,"AST_level":8,"line_counts":8,"new_code_token_num":67},{"new_code_raw":"public String toModelName(final String name) { return initialCaps(modelNamePrefix + name + modelNameSuffix); }","old_code_raw":"    public String toModelName(String name) {\n        return initialCaps(name);\n    }\n","new_comment_raw":"@return capitalized model name","old_comment_raw":"@return capitalized model name","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"public RollCycle getRollCycle() { return queue.rollCycle(); }","old_code_raw":"public RollCycle getRollCycle() {\n    return rollCycle;\n}","new_comment_raw":"@return the queue file roll cycle","old_comment_raw":"@return the rollCycle","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public static Action resolve(Schema writer, Schema reader, GenericData data) { return resolve(writer, reader, data, new HashMap<>()); }","old_code_raw":"  public static Action resolve(Schema writer, Schema reader) {\n    return resolve(writer, reader, new HashMap<>());\n  }\n","new_comment_raw":"@return Nested actions for resolving the two","old_comment_raw":"@return Nested actions for resolving the two","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"private static CoreMap fromProto(CoreNLPProtos.Sentence proto) { CoreMap sentence = new ArrayCoreMap(); \/\/ Required fields sentence.set(TokenBeginAnnotation.class, proto.getTokenOffsetBegin()); sentence.set(TokenEndAnnotation.class, proto.getTokenOffsetEnd()); \/\/ Optional fields if (proto.hasSentenceIndex()) { sentence.set(SentenceIndexAnnotation.class, proto.getSentenceIndex()); } if (proto.hasCharacterOffsetBegin()) { sentence.set(CharacterOffsetBeginAnnotation.class, proto.getCharacterOffsetBegin()); } if (proto.hasCharacterOffsetEnd()) { sentence.set(CharacterOffsetEndAnnotation.class, proto.getCharacterOffsetEnd()); } if (proto.hasParseTree()) { sentence.set(TreeAnnotation.class, fromProto(proto.getParseTree())); } \/\/ Non-default fields if (proto.hasHasRelationAnnotations() && proto.getHasRelationAnnotations()) { \/\/ set entities List<EntityMention> entities = new ArrayList<EntityMention>(); for (CoreNLPProtos.Entity entity : proto.getEntityList()) { entities.add(fromProto(entity, sentence)); } sentence.set(EntityMentionsAnnotation.class, entities); \/\/ set relations List<RelationMention> relations = new ArrayList<RelationMention>(); for (CoreNLPProtos.Relation relation : proto.getRelationList()) { relations.add(fromProto(relation, sentence)); } sentence.set(RelationMentionsAnnotation.class, relations); } \/\/ Return return sentence; }","old_code_raw":"  public CoreLabel fromProto(CoreNLPProtos.Token proto) {\n    CoreLabel word = new CoreLabel();\n    \/\/ Required fields\n    word.setWord(proto.getWord());\n    \/\/ Optional fields\n    if (proto.hasPos()) { word.setTag(proto.getPos()); }\n    if (proto.hasValue()) { word.setValue(proto.getValue()); }\n    if (proto.hasCategory()) { word.setCategory(proto.getCategory()); }\n    if (proto.hasBefore()) { word.setBefore(proto.getBefore()); }\n    if (proto.hasAfter()) { word.setAfter(proto.getAfter()); }\n    if (proto.hasOriginalText()) { word.setOriginalText(proto.getOriginalText()); }\n    if (proto.hasNer()) { word.setNER(proto.getNer()); }\n    if (proto.hasLemma()) { word.setLemma(proto.getLemma()); }\n    if (proto.hasBeginChar()) { word.setBeginPosition(proto.getBeginChar()); }\n    if (proto.hasEndChar()) { word.setEndPosition(proto.getEndChar()); }\n    if (proto.hasSpeaker()) { word.set(SpeakerAnnotation.class, proto.getSpeaker()); }\n    if (proto.hasUtterance()) { word.set(UtteranceAnnotation.class, proto.getUtterance()); }\n    if (proto.hasBeginIndex()) { word.set(BeginIndexAnnotation.class, proto.getBeginIndex()); }\n    if (proto.hasEndIndex()) { word.set(EndIndexAnnotation.class, proto.getEndIndex()); }\n    if (proto.hasTokenBeginIndex()) { word.set(TokenBeginAnnotation.class, proto.getTokenBeginIndex()); }\n    if (proto.hasTokenEndIndex()) { word.set(TokenEndAnnotation.class, proto.getTokenEndIndex()); }\n    if (proto.hasNormalizedNER()) { word.set(NormalizedNamedEntityTagAnnotation.class, proto.getNormalizedNER()); }\n    if (proto.hasTimexValue()) { word.set(TimexAnnotation.class, fromProto(proto.getTimexValue())); }\n    if (proto.hasHasXmlContext() && proto.getHasXmlContext()) { word.set(XmlContextAnnotation.class, proto.getXmlContextList()); }\n    if (proto.hasCorefClusterID()) { word.set(CorefClusterIdAnnotation.class, proto.getCorefClusterID()); }\n    if (proto.hasAnswer()) { word.set(AnswerAnnotation.class, proto.getAnswer()); }\n    if (proto.hasOperator()) { word.set(NaturalLogicAnnotations.OperatorAnnotation.class, fromProto(proto.getOperator())); }\n    if (proto.hasPolarity()) { word.set(NaturalLogicAnnotations.PolarityAnnotation.class, fromProto(proto.getPolarity())); }\n    \/\/ Non-default annotators\n    if (proto.hasGender()) { word.set(GenderAnnotation.class, proto.getGender()); }\n    if (proto.hasTrueCase()) { word.set(TrueCaseAnnotation.class, proto.getTrueCase()); }\n    if (proto.hasTrueCaseText()) { word.set(TrueCaseTextAnnotation.class, proto.getTrueCaseText()); }\n    \/\/ Return\n    return word;\n  }\n","new_comment_raw":"@return A CoreMap, representing a sentence as stored in the protocol buffer (and therefore missing some fields)","old_comment_raw":"@return A CoreLabel, missing the fields that are not stored in the CoreLabel protobuf.","label":1,"pre_label":0,"AST_level":10,"line_counts":25,"new_code_token_num":256},{"new_code_raw":"public boolean searchForText(String search, int matches, boolean scroll) { inst.waitForIdleSync(); RobotiumUtils.sleep(PAUS); Pattern p = Pattern.compile(search); Matcher matcher; ArrayList<TextView> textViewList = soloView.getCurrentTextViews(null); Iterator<TextView> iterator = textViewList.iterator(); TextView textView = null; if(matches == 0) matches = 1; while (iterator.hasNext()) { textView = (TextView) iterator.next(); matcher = p.matcher(textView.getText().toString()); if(matcher.find()){ countMatches++; } if (countMatches == matches) { countMatches=0; return true; } } if (scroll && soloScroll.scrollDown()) { return searchForText(search, matches, scroll); } else { if (countMatches > 0) Log.d(LOG_TAG, \" There are only \" + countMatches + \" matches of \" + search); return false; } }","old_code_raw":"\tpublic boolean searchForText(String search, int matches) {\n\t\tinst.waitForIdleSync();\n\t\tRobotiumUtils.sleep(PAUS);\n\t\tPattern p = Pattern.compile(search);\n\t\tMatcher matcher;\n\t\tint countMatches = 0;\n\t\tArrayList<TextView> textViewList = soloView.getCurrentTextViews(null);\n\t\tIterator<TextView> iterator = textViewList.iterator();\n\t\tTextView textView = null;\n\t\twhile (iterator.hasNext()) {\n\t\t\ttextView = (TextView) iterator.next();\n\t\t\tmatcher = p.matcher(textView.getText().toString());\n\t\t\tif(matcher.find()){\t\n\t\t\t\tcountMatches++;\n\t\t\t}\n\t\t}\n\t\tif (countMatches == matches && matches != 0) {\n\t\t\treturn true;\n\t\t} else if (matches == 0 && countMatches > 0) {\n\t\t\treturn true;\n\t\t} else if (soloScroll.scrollDown()) \n\t\t{\n\t\t\treturn searchForText(search, matches);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t}\n","new_comment_raw":"@return true if search string is found a given number of times and false if the search string is not found","old_comment_raw":"@return true if search string is found a given number of times and false if the search string is not found","label":0,"pre_label":1,"AST_level":11,"line_counts":31,"new_code_token_num":177},{"new_code_raw":"MutableCapabilities toCapabilities() { return this; }","old_code_raw":"  DesiredCapabilities toCapabilities() {\n    DesiredCapabilities capabilities = DesiredCapabilities.chrome().merge(this.capabilities);\n    capabilities.setCapability(CAPABILITY, this);\n    return capabilities;\n  }\n","new_comment_raw":"@return DesiredCapabilities for Chrome with these options.","old_comment_raw":"@return DesiredCapabilities for Chrome with these options.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":9},{"new_code_raw":"public static IntList toList(final BitSet bitSet) { final IntList list = new IntList(); for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1)) { list.add(i); } return list; }","old_code_raw":"    public static List<Integer> toList(final BitSet bitSet)\n    {\n        final List<Integer> list = new ArrayList<Integer>();\n        for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1))\n        {\n            list.add(i);\n        }\n        return list;\n    }\n","new_comment_raw":"@return List of set bits","old_comment_raw":"@return List of set bits","label":0,"pre_label":1,"AST_level":8,"line_counts":10,"new_code_token_num":52},{"new_code_raw":"public String getConsoleOutput() throws IOException { if (process == null || stream == null) { return null; } return stream instanceof CircularOutputStream ? stream.toString() : null; }","old_code_raw":"  public String getConsoleOutput() throws IOException {\n    if (process == null) {\n      return null;\n    }\n\n    return Streams.drainStream(stream);\n  }\n","new_comment_raw":"@return the console output of the executed binary.","old_comment_raw":"@return the console output of the executed binary.","label":0,"pre_label":1,"AST_level":6,"line_counts":8,"new_code_token_num":35},{"new_code_raw":"protected long[] executeBatchInternal() throws SQLException { for (int i = 0; i < connection.maxRetriesPerExecute; i++) { try { return connection.prepareAndUpdateBatch(this, batchedSql).updateCounts; } catch (NoSuchStatementException e) { resetStatement(); } } throw new RuntimeException(\"Failed to successfully execute batch update after \" + connection.maxRetriesPerExecute + \" attempts\"); }","old_code_raw":"  protected int[] executeBatchInternal() throws SQLException {\n    for (int i = 0; i < connection.maxRetriesPerExecute; i++) {\n      try {\n        Meta.ExecuteBatchResult result = connection.prepareAndUpdateBatch(this, batchedSql);\n        return result.updateCounts;\n      } catch (NoSuchStatementException e) {\n        resetStatement();\n      }\n    }\n\n    throw new RuntimeException(\"Failed to successfully execute batch update after \"\n        +  connection.maxRetriesPerExecute + \" attempts\");\n  }\n","new_comment_raw":"@return an array of long mapping to the update count per SQL command.","old_comment_raw":"@return an array of integers mapping to the update count per SQL command.","label":1,"pre_label":0,"AST_level":8,"line_counts":13,"new_code_token_num":73},{"new_code_raw":"public int getBufferSizeBytes() { if (DEFAULT == mBufferSizeBytes) { return getConfiguration().getInt(IO_FILE_BUFFER_SIZE_KEY, IO_FILE_BUFFER_SIZE_DEFAULT); } return mBufferSizeBytes; }","old_code_raw":"      public int getBufferSizeBytes() {\n        if (DEFAULT == mBufferSizeBytes) {\n          return getConfiguration().getInt(\"io.file.buffer.size\", DEFAULT_BUFFER_SIZE_BYTES);\n        }\n        return mBufferSizeBytes;\n      }\n","new_comment_raw":"@return The buffer size in bytes.","old_comment_raw":"@return The buffer size in bytes.","label":0,"pre_label":1,"AST_level":8,"line_counts":8,"new_code_token_num":28},{"new_code_raw":"private JsonNode catIndices(Collection<String> indices, String... fields) { final String fieldNames = String.join(STR, fields); final Cat request = new Cat.IndicesBuilder().addIndex(indices).setParameter(STR, fieldNames).build(); final CatResult response = JestUtils.execute(jestClient, request, () -> STR + indices); return response.getJsonObject().path(STR); }","old_code_raw":"private JsonArray catIndices(Collection<String> indices, String... fields) {\n    final String fieldNames = String.join(STR, fields);\n    final Cat request = new Cat.IndicesBuilder().addIndex(indices).setParameter(STR, fieldNames).build();\n    final CatResult response = JestUtils.execute(jestClient, request, () -> STR + indices);\n    return Optional.of(response.getJsonObject()).map(json -> GsonUtils.asJsonArray(json.get(STR))).orElse(new JsonArray());\n}","new_comment_raw":"@return A {@link JsonNode} with the result of the cat indices request.","old_comment_raw":"@return A {@link JsonArray} with the result of the cat indices request.","label":1,"pre_label":0,"AST_level":8,"line_counts":6,"new_code_token_num":74},{"new_code_raw":"public static int hashCode(boolean v) { return Boolean.hashCode(v); }","old_code_raw":"  public static int hashCode(boolean v) {\n    return v ? 1231 : 1237;\n  }\n","new_comment_raw":"@return Hash code","old_comment_raw":"@return Hash code","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":17},{"new_code_raw":"public Element[] getElements(String name) { Element[] elems = (Element[]) m_elements.get(name.toLowerCase()); return elems; }","old_code_raw":"public Element[] getElements(String name) {\n    Element[] elems = (Element[]) m_elements.get(name.toLowerCase());\n    if (elems == null) {\n        return new Element[NUM];\n    } else {\n        return elems;\n    }\n}","new_comment_raw":"@return the resulting element array (null if the search failed)","old_comment_raw":"@return the resulting element array (empty if the search failed)","label":1,"pre_label":0,"AST_level":7,"line_counts":4,"new_code_token_num":32},{"new_code_raw":"public Options useAstDefinitions(boolean flag) { return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, flag, this.descriptionsAsHashComments, this.comparatorRegistry); }","old_code_raw":"        public Options useAstDefinitions(boolean flag) {\n            return new Options(this.includeIntrospectionTypes, this.includeScalars, this.includeExtendedScalars, this.includeSchemaDefinition, this.includeDirectives, flag, this.comparatorRegistry);\n        }\n","new_comment_raw":"@return new instance of options","old_comment_raw":"@return new instance of options","label":0,"pre_label":1,"AST_level":6,"line_counts":4,"new_code_token_num":37},{"new_code_raw":"@Deprecated public int getTileSize() { return Math.max(tileHeight, tileWidth); }","old_code_raw":"public int getTileSize() {\n    return tileSize;\n}","new_comment_raw":"@return tile height or width, whichever is larger","old_comment_raw":"@return the size of tiles in pixels","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public ArrayList<Word> segmentWords(MatchHeuristic h) throws UnsupportedOperationException { if(lattice==null || len < 0) throw new UnsupportedOperationException(\"segmentWords must be run first\"); List<Word> segmentedWords = new ArrayList<>(); \/\/ Init dynamic programming: double[] costs = new double[len+1]; List<DFSATransition<Word, Integer>> bptrs = new ArrayList<>(); for (int i = 0; i < len + 1; ++i) { bptrs.add(null); } costs[0]=0.0; for (int i=1; i<=len; ++i) costs[i] = Double.MAX_VALUE; \/\/ DP: for (int start=0; start<len; ++start) { DFSAState<Word, Integer> fromState = states.get(start); Collection<DFSATransition<Word, Integer>> trs = fromState.transitions(); for (DFSATransition<Word, Integer> tr : trs) { DFSAState<Word, Integer> toState = tr.getTarget(); double lcost = tr.score(); int end = toState.stateID(); \/\/System.err.println(\"start=\"+start+\" end=\"+end+\" word=\"+tr.getInput()); if (h == MatchHeuristic.MINWORDS) { \/\/ Minimize number of words: if (costs[start]+1 < costs[end]) { costs[end] = costs[start]+lcost; bptrs.set(end, tr); \/\/System.err.println(\"start=\"+start+\" end=\"+end+\" word=\"+tr.getInput()); } } else if (h == MatchHeuristic.MAXWORDS) { \/\/ Maximze number of words: if (costs[start]+1 < costs[end]) { costs[end] = costs[start]-lcost; bptrs.set(end, tr); } } else { throw new UnsupportedOperationException(\"unimplemented heuristic\"); } } } \/\/ Extract min-cost path: int i=len; while (i>0) { DFSATransition<Word, Integer> tr = bptrs.get(i); DFSAState<Word, Integer> fromState = tr.getSource(); Word word = tr.getInput(); if (!word.word().equals(\" \")) segmentedWords.add(0, word); i = fromState.stateID(); } if(DEBUG) { \/\/ Print lattice density ([1,+inf[) : if equal to 1, it means \/\/ there is only one segmentation using words of the lexicon. double density = edgesNb*1.0\/segmentedWords.size(); System.err.println(\"latticeDensity: \"+density+\" cost: \"+costs[len]); } return new ArrayList<>(segmentedWords); }","old_code_raw":"  public ArrayList<Word> segmentWords(MatchHeuristic h) throws UnsupportedOperationException {\n    if(lattice==null || len < 0)\n      throw new UnsupportedOperationException(\"segmentWords must be run first\");\n    List<Word> segmentedWords = new ArrayList<Word>();\n    \/\/ Init dynamic programming:\n    double costs[] = new double[len+1];\n    List<DFSATransition<Word, Integer>> bptrs = new ArrayList<DFSATransition<Word, Integer>>();\n    for (int i = 0; i < len + 1; ++i) {\n      bptrs.add(null);\n    }\n    costs[0]=0.0;\n    for (int i=1; i<=len; ++i)\n       costs[i] = Double.MAX_VALUE;\n    \/\/ DP:\n    for (int start=0; start<len; ++start) {\n      DFSAState<Word, Integer> fromState = states.get(start);\n      Collection<DFSATransition<Word, Integer>> trs = fromState.transitions();\n      for (DFSATransition<Word, Integer> tr : trs) {\n        DFSAState<Word, Integer> toState = tr.getTarget();\n        double lcost = tr.score();\n        int end = toState.stateID();\n        \/\/System.err.println(\"start=\"+start+\" end=\"+end+\" word=\"+tr.getInput());\n        if (h == MatchHeuristic.MINWORDS) {\n          \/\/ Minimize number of words:\n          if (costs[start]+1 < costs[end]) {\n            costs[end] = costs[start]+lcost;\n            bptrs.set(end, tr);\n            \/\/System.err.println(\"start=\"+start+\" end=\"+end+\" word=\"+tr.getInput());\n          }\n        } else if (h == MatchHeuristic.MAXWORDS) {\n          \/\/ Maximze number of words:\n          if (costs[start]+1 < costs[end]) {\n            costs[end] = costs[start]-lcost;\n            bptrs.set(end, tr);\n          }\n        } else {\n          throw new UnsupportedOperationException(\"unimplemented heuristic\");\n        }\n      }\n    }\n    \/\/ Extract min-cost path:\n    int i=len;\n    while (i>0) {\n      DFSATransition<Word, Integer> tr = bptrs.get(i);\n      DFSAState<Word, Integer> fromState = tr.getSource();\n      Word word = tr.getInput();\n      if (!word.word().equals(\" \"))\n        segmentedWords.add(0, word);\n      i = fromState.stateID();\n    }\n    if(DEBUG) {\n      \/\/ Print lattice density ([1,+inf[) : if equal to 1, it means\n      \/\/ there is only one segmentation using words of the lexicon.\n      double density = edgesNb*1.0\/segmentedWords.size();\n      System.err.println(\"latticeDensity: \"+density+\" cost: \"+costs[len]);\n    }\n    return new ArrayList<Word>(segmentedWords);\n  }\n","new_comment_raw":"@return Segmented sentence.","old_comment_raw":"@return Segmented sentence.","label":0,"pre_label":1,"AST_level":17,"line_counts":59,"new_code_token_num":520},{"new_code_raw":"public static RelNode copyRelHints(RelNode originalRel, RelNode newRel, boolean filterHints) { if (originalRel instanceof Hintable && newRel instanceof Hintable && ((Hintable) originalRel).getHints().size() > 0) { final List<RelHint> hints = ((Hintable) originalRel).getHints(); if (filterHints) { HintStrategyTable hintStrategies = originalRel.getCluster().getHintStrategies(); return ((Hintable) newRel).attachHints(hintStrategies.apply(hints, newRel)); } else { \/\/ Keep all the hints if filterHints is false for 2 reasons: \/\/ 1. Keep sync with the hints propagation logic, \/\/ see RelHintPropagateShuttle for details. \/\/ 2. We may re-propagate these hints when decorrelating a query. return ((Hintable) newRel).attachHints(hints); } } return newRel; }","old_code_raw":"  public static RelNode copyRelHints(RelNode originalRel, RelNode newRel) {\n    if (originalRel instanceof Hintable\n        && newRel instanceof Hintable\n        && ((Hintable) originalRel).getHints().size() > 0) {\n      HintStrategyTable hintStrategies = originalRel.getCluster().getHintStrategies();\n      final List<RelHint> hints = ((Hintable) originalRel).getHints();\n      \/\/ Keep all the hints of project node for 2 reasons:\n      \/\/ 1. Keep sync with the hints propagation logic,\n      \/\/ see RelHintPropagateShuttle for details.\n      \/\/ 2. We may re-propagate these hints when decorrelating a query.\n      if (originalRel instanceof Project\n          && newRel instanceof Project) {\n        return ((Hintable) newRel).attachHints(hints);\n      } else {\n        return ((Hintable) newRel)\n            .attachHints(hintStrategies.apply(hints, newRel));\n      }\n    }\n    return newRel;\n  }\n","new_comment_raw":"@return A copy of  newRel with attached hints from  originalRel, or  newRel directly if one of them are not  Hintable","old_comment_raw":"@return A copy of newRel with hints of originalRel, or newRel directly if one of them are not Hintable","label":1,"pre_label":0,"AST_level":10,"line_counts":19,"new_code_token_num":155},{"new_code_raw":"public static SchemaGenAction interpret(Object value) { if ( value == null ) { return NONE; } if ( SchemaGenAction.class.isInstance( value ) ) { return (SchemaGenAction) value; } final String name = value.toString(); if ( StringHelper.isEmpty( name ) || NONE.externalName.equals( name ) ) { \/\/ default is NONE return NONE; } if ( CREATE.externalName.equals( name ) ) { return CREATE; } else if ( DROP.externalName.equals( name ) ) { return DROP; } else if ( BOTH.externalName.equals( name ) ) { return BOTH; } throw new IllegalArgumentException( String.format( \"Unrecognized '%s' or '%s' value : %s\", AvailableSettings.SCHEMA_GEN_DATABASE_ACTION, AvailableSettings.SCHEMA_GEN_SCRIPTS_ACTION, value ) ); }","old_code_raw":"\tpublic static SchemaGenAction interpret(String value) {\n\t\tif ( StringHelper.isEmpty( value ) || NONE.externalName.equals( value ) ) {\n\t\t\t\/\/ default is NONE\n\t\t\treturn NONE;\n\t\t}\n\n\t\tif ( CREATE.externalName.equals( value ) ) {\n\t\t\treturn CREATE;\n\t\t}\n\t\telse if ( DROP.externalName.equals( value ) ) {\n\t\t\treturn DROP;\n\t\t}\n\t\telse if ( BOTH.externalName.equals( value ) ) {\n\t\t\treturn BOTH;\n\t\t}\n\n\t\tthrow new IllegalArgumentException(\n\t\t\t\tString.format(\n\t\t\t\t\t\t\"Unrecognized '%s' or '%s' value : %s\",\n\t\t\t\t\t\tAvailableSettings.SCHEMA_GEN_DATABASE_ACTION,\n\t\t\t\t\t\tAvailableSettings.SCHEMA_GEN_SCRIPTS_ACTION,\n\t\t\t\t\t\tvalue\n\t\t\t\t)\n\t\t);\n\t}\n","new_comment_raw":"@return The matching enum value. An empty value will return  #NONE.","old_comment_raw":"@return The matching enum value. An empty value will return #NONE.","label":0,"pre_label":1,"AST_level":8,"line_counts":35,"new_code_token_num":149},{"new_code_raw":"public SubProjectData getProjectInfo(AbstractProject context) { SubProjectData subProjectData = new SubProjectData(); iterateBuilds(context, projects, subProjectData); subProjectData.getTriggered().removeAll(subProjectData.getDynamic()); subProjectData.getTriggered().removeAll(subProjectData.getFixed()); return subProjectData; }","old_code_raw":"public List<Set<?>> getProjectInfo(AbstractProject context) {\n    Comparator customComparator = new Comparator<AbstractProject>() {\n\n        public int compare(AbstractProject abstractProject1, AbstractProject abstractProject2) {\n            return abstractProject1.getFullName().compareTo(abstractProject2.getFullName());\n        }\n    };\n    Set<AbstractProject> dynamicProject = new TreeSet<AbstractProject>(customComparator);\n    Set<AbstractProject> staticProject = new TreeSet<AbstractProject>(customComparator);\n    Set<AbstractProject> triggeredProject = new TreeSet<AbstractProject>(customComparator);\n    Set<String> unresolvedProject = new TreeSet<String>();\n    iterateBuilds(context, projects, dynamicProject, staticProject, triggeredProject, unresolvedProject);\n    triggeredProject.removeAll(dynamicProject);\n    triggeredProject.removeAll(staticProject);\n    return Arrays.asList(staticProject, dynamicProject, triggeredProject, unresolvedProject);\n}","new_comment_raw":"@return A data object containing sets with projects","old_comment_raw":"@return A list containing sets with Projects","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":52},{"new_code_raw":"private JsonNode catNodes(String... fields) { final String fieldNames = String.join(STR, fields); final Cat request = new Cat.NodesBuilder().setParameter(STR, fieldNames).setParameter(STR, true).build(); final CatResult response = JestUtils.execute(jestClient, request, () -> STR); return response.getJsonObject().path(STR); }","old_code_raw":"private JsonArray catNodes(String... fields) {\n    final String fieldNames = String.join(STR, fields);\n    final Cat request = new Cat.NodesBuilder().setParameter(STR, fieldNames).setParameter(STR, true).build();\n    final CatResult response = JestUtils.execute(jestClient, request, () -> STR);\n    return GsonUtils.asJsonArray(response.getJsonObject().get(STR));\n}","new_comment_raw":"@return A {@link JsonNode} with the result of the cat nodes request.","old_comment_raw":"@return A {@link JsonArray} with the result of the cat nodes request.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":70},{"new_code_raw":"public static String deprocess(String str, STextProcessor processor) { if ((str == null) || (str.length() <= NUM)) return str; STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN); if (!env.isProcessingNeeded()) return str; return STextEngine.fullToLeanText(processor, env, str, null); }","old_code_raw":"public static String deprocess(String str, STextProcessor processor) {\n    if ((str == null) || (str.length() <= NUM) || !isProcessingNeeded())\n        return str;\n    STextEnvironment env = new STextEnvironment(null, false, STextEnvironment.ORIENT_UNKNOWN);\n    return STextEngine.fullToLeanText(processor, env, str, null);\n}","new_comment_raw":"@return string without directional formatting characters","old_comment_raw":"@return string with no directional formatting characters.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":69},{"new_code_raw":"private List<InputSplit> generateInputSplits(GiraphInputFormat inputFormat, int numWorkers, String inputSplitType) { String logPrefix = STR + inputSplitType + STR; List<InputSplit> splits; try { splits = inputFormat.getSplits(getContext(), numWorkers); } catch (IOException e) { throw new IllegalStateException(logPrefix + STR, e); } catch (InterruptedException e) { throw new IllegalStateException(logPrefix + STR, e); } float samplePercent = getConfiguration().getFloat(GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT, GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT_DEFAULT); if (samplePercent != GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT_DEFAULT) { int lastIndex = (int) (samplePercent * splits.size() \/ NUM); List<InputSplit> sampleSplits = splits.subList(NUM, lastIndex); LOG.warn(logPrefix + STR + sampleSplits.size() + STR + splits.size() + STR); return sampleSplits; } else { if (LOG.isInfoEnabled()) { LOG.info(logPrefix + STR + splits.size() + STR + numWorkers + STR); } return splits; } }","old_code_raw":"private List<InputSplit> generateInputSplits(int numWorkers) {\n    VertexInputFormat<I, V, E, M> vertexInputFormat = getConfiguration().createVertexInputFormat();\n    List<InputSplit> splits;\n    try {\n        splits = vertexInputFormat.getSplits(getContext(), numWorkers);\n        float samplePercent = getConfiguration().getFloat(GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT, GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT_DEFAULT);\n        if (samplePercent != GiraphConfiguration.INPUT_SPLIT_SAMPLE_PERCENT_DEFAULT) {\n            int lastIndex = (int) (samplePercent * splits.size() \/ NUM);\n            List<InputSplit> sampleSplits = splits.subList(NUM, lastIndex);\n            LOG.warn(STR + STR + sampleSplits.size() + STR + splits.size() + STR);\n            return sampleSplits;\n        } else {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(STR + splits.size() + STR + numWorkers + STR);\n            }\n            return splits;\n        }\n    } catch (IOException e) {\n        throw new IllegalStateException(STR, e);\n    } catch (InterruptedException e) {\n        throw new IllegalStateException(STR, e);\n    }\n}","new_comment_raw":"@return List of input splits for the given format","old_comment_raw":"@return List of input splits","label":1,"pre_label":0,"AST_level":14,"line_counts":23,"new_code_token_num":187},{"new_code_raw":"public String getTableName(FileSelection selection) { List<Path> files = selection.getFiles(); assert (files.size() == 1); return files.get(0).toUri().getPath(); }","old_code_raw":"  public String getTableName(FileSelection selection) {\n    List<String> files = selection.getFiles();\n    assert (files.size() == 1);\n    return files.get(0);\n  }\n","new_comment_raw":"@return string table name","old_comment_raw":"@return string table name","label":0,"pre_label":1,"AST_level":6,"line_counts":6,"new_code_token_num":39},{"new_code_raw":"public static Heap createHeap(File heapDump, int segment) throws FileNotFoundException, IOException { return new HprofHeap(createBuffer(heapDump, DEFAULT_BUFFER), segment); }","old_code_raw":"    public static Heap createHeap(File heapDump, int segment)\n                           throws FileNotFoundException, IOException {\n        return new HprofHeap(createBuffer(heapDump), segment);\n    }\n","new_comment_raw":"@return implementation of  Heap corresponding to the memory dump passed in heapDump parameter","old_comment_raw":"@return implementation of Heap corresponding to the memory dump passed in heapDump parameter","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":31},{"new_code_raw":"public static WebClient getWebClient(HttpServletRequest request) { HttpSession session = request.getSession(true); WebClient client = getWebClient(session); if (client == null || client.isClosed()) { client = WebClient.createWebClient(request); session.setAttribute(webClientAttribute, client); } return client; }","old_code_raw":"public static WebClient getWebClient(HttpSession session) {\n    return (WebClient) session.getAttribute(webClientAttribute);\n}","new_comment_raw":"@return the current client or a newly creates","old_comment_raw":"@return the web client for the current HTTP session or null if there is not a web client created yet","label":1,"pre_label":0,"AST_level":8,"line_counts":9,"new_code_token_num":56},{"new_code_raw":"public Struct struct(String databaseName) { this.databaseName = databaseName; return struct((TableId) null); }","old_code_raw":"    public Struct struct() {\n        return struct(null);\n    }\n","new_comment_raw":"@return the source partition and offset  Struct; never null","old_comment_raw":"@return the source partition and offset Struct; never null","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":22},{"new_code_raw":"public BackupResultStatus backupSession(final Session session) { if (_log.isInfoEnabled()) { _log.debug(STR + session.getId()); } final MemcachedBackupSession backupSession = (MemcachedBackupSession) session; final BackupSessionTask task = getOrCreateBackupSessionTask(backupSession); final Map<String, Object> attributes = backupSession.getAttributesInternal(); final byte[] attributesData = _transcoderService.serializeAttributes(backupSession, attributes); final int hashCode = Arrays.hashCode(attributesData); if (backupSession.getDataHashCode() != hashCode || task.sessionCookieWasRelocated()) { final byte[] data = _transcoderService.serialize(backupSession, attributesData); final BackupResult result = task.backupSession(data, attributesData); if (result.getAttributesData() != null) { backupSession.setDataHashCode(Arrays.hashCode(result.getAttributesData())); } return result.getStatus(); } else { return BackupResultStatus.SKIPPED; } }","old_code_raw":"public BackupResult backupSession(final Session session) {\n    if (_log.isInfoEnabled()) {\n        _log.debug(STR + session.getId());\n    }\n    final BackupSessionTask task = getOrCreateBackupSessionTask((MemcachedBackupSession) session);\n    return task.backupSession();\n}","new_comment_raw":"@return the {@link SessionTrackerValve.SessionBackupService.BackupResultStatus}","old_comment_raw":"@return the {@link SessionTrackerValve.SessionBackupService.BackupResult}","label":1,"pre_label":0,"AST_level":10,"line_counts":20,"new_code_token_num":157},{"new_code_raw":"protected Object suspendAndGet(Object key, FlagAdapter opt, boolean suppressTimeout) throws CacheException { Transaction tx = suspend(); try { if (suppressTimeout) return cacheAdapter.getAllowingTimeout(key); else return cacheAdapter.get(key); } finally { resume(tx); } }","old_code_raw":"   protected Object suspendAndGet(Object key, Flag opt, boolean suppressTimeout) throws CacheException {\n       Transaction tx = suspend();\n       try {\n           if (suppressTimeout)\n               return CacheHelper.getAllowingTimeout(cache, key);\n           else\n               return CacheHelper.get(cache, key);\n       } finally {\n           resume(tx);\n       }\n   }\n","new_comment_raw":"@return The retrieved object","old_comment_raw":"@return The retrieved object","label":0,"pre_label":1,"AST_level":7,"line_counts":12,"new_code_token_num":53},{"new_code_raw":"public JSONObject getJSONObject(String key) { Object object = this.get(key); if (object == null) { return null; } if (object instanceof JSONObject) { return (JSONObject)object; } throw new RuntimeException(\"JSONObject[\" + quote(key) + \"] is not a JSONObject.\"); }","old_code_raw":"  public JSONObject getJSONObject(String key) {\n    Object object = this.get(key);\n    if (object instanceof JSONObject) {\n      return (JSONObject)object;\n    }\n    throw new RuntimeException(\"JSONObject[\" + quote(key) + \"] is not a JSONObject.\");\n  }\n","new_comment_raw":"@return A JSONObject which is the value or null if not available.","old_comment_raw":"@return A JSONObject which is the value.","label":1,"pre_label":0,"AST_level":8,"line_counts":11,"new_code_token_num":64},{"new_code_raw":"public static int getResIcon(IFile file, final IFileProvider.FilterMode filterMode) { if (file == null || !file.exists()) return R.drawable.afc_file; if (file.isFile()) { String filename = file.getName(); for (String r : _MapFileIcons.keySet()) if (filename.matches(r)) return _MapFileIcons.get(r); return R.drawable.afc_file; } else if (file.isDirectory()) { if (filterMode != IFileProvider.FilterMode.AnyDirectories) { if (file instanceof File && !((File)file).canWrite()) { if (file instanceof ParentFile) { return R.drawable.afc_folder; } else if (accessDenied(file)) { return R.drawable.afc_folder; } else { return R.drawable.afc_folder_locked; } } else { return R.drawable.afc_folder; } } else { return R.drawable.afc_folder; } } return R.drawable.afc_file; }\/\/ getResIcon()","old_code_raw":"    public static int getResIcon(IFile file, final IFileProvider.FilterMode filterMode) {\n        if (file == null || !file.exists())\n            return 0;\/\/android.R.drawable.ic_delete;\n\n        if (file.isFile()) {\n            String filename = file.getName();\n            for (String r : _MapFileIcons.keySet())\n                if (filename.matches(r))\n                    return _MapFileIcons.get(r);\n\n            return R.drawable.afc_file;\n        } else if (file.isDirectory()) {\n            if (filterMode != IFileProvider.FilterMode.AnyDirectories) {\n                if (file instanceof File && !((File)file).canWrite()) {\n                    if (file instanceof ParentFile) {\n                        return R.drawable.afc_folder;\n                    } else if (accessDenied(file)) {\n                        return R.drawable.afc_folder_no_access;\n                    } else {\n                        return R.drawable.afc_folder_locked;\n                    }\n                } else {\n                    return R.drawable.afc_folder;\n                }\n            } else {\n                if (accessDenied(file)) {\n                    return R.drawable.afc_folder_no_access;\n                } else {\n                    return R.drawable.afc_folder;\n                }\n            }\n        }\n\n        return 0;\/\/android.R.drawable.ic_delete;\n    }\/\/ getResIcon()\n","new_comment_raw":"@return the resource icon ID","old_comment_raw":"@return the resource icon ID","label":0,"pre_label":1,"AST_level":14,"line_counts":32,"new_code_token_num":180},{"new_code_raw":"public static Path relativize(Path baseDir, Path childPath) { Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(childPath); Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(baseDir); \/\/ Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri() .relativize(fullPathWithoutSchemeAndAuthority.toUri())); if (relativeFilePath.isAbsolute()) { throw new IllegalStateException(String.format(\"Path %s is not a subpath of %s.\", basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath())); } return relativeFilePath; }","old_code_raw":"  public static String relativize(String baseDir, String childPath) {\n    Path fullPathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(new Path(childPath));\n    Path basePathWithoutSchemeAndAuthority = Path.getPathWithoutSchemeAndAuthority(new Path(baseDir));\n\n    \/\/ Since hadoop Path hasn't relativize() we use uri.relativize() to get relative path\n    Path relativeFilePath = new Path(basePathWithoutSchemeAndAuthority.toUri()\n        .relativize(fullPathWithoutSchemeAndAuthority.toUri()));\n    if (relativeFilePath.isAbsolute()) {\n      throw new IllegalStateException(String.format(\"Path %s is not a subpath of %s.\",\n          basePathWithoutSchemeAndAuthority.toUri().getPath(), fullPathWithoutSchemeAndAuthority.toUri().getPath()));\n    }\n    return relativeFilePath.toUri().getPath();\n  }\n","new_comment_raw":"@return relative path","old_comment_raw":"@return relative path","label":0,"pre_label":1,"AST_level":9,"line_counts":14,"new_code_token_num":118},{"new_code_raw":"private ZapTextField getTxtSessionName() { if (txtSessionName == null) { txtSessionName = new ZapTextField(); } return txtSessionName; }","old_code_raw":"\tprivate JTextField getTxtSessionName() {\n\t\tif (txtSessionName == null) {\n\t\t\ttxtSessionName = new JTextField();\n\t\t}\n\t\treturn txtSessionName;\n\t}\n","new_comment_raw":"@return javax.swing.ZapTextField","old_comment_raw":"@return javax.swing.JTextField","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"public Applications getApplications(String serviceUrl) { if (shouldUseExperimentalTransport()) { try { EurekaHttpResponse<Applications> response = clientConfig.getRegistryRefreshSingleVipAddress() == null ? eurekaHttpClient.getApplications() : eurekaHttpClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress()); if (response.getStatusCode() == 200) { logger.debug(PREFIX + appPathIdentifier + \" - refresh status: \" + response.getStatusCode()); return response.getEntity(); } logger.error(PREFIX + appPathIdentifier + \" - was unable to refresh its cache! status = \" + response.getStatusCode()); } catch (Throwable th) { logger.error(PREFIX + appPathIdentifier + \" - was unable to refresh its cache! status = \" + th.getMessage(), th); } } else { ClientResponse response = null; try { response = makeRemoteCall(Action.Refresh); Applications apps = response.getEntity(Applications.class); logger.debug(PREFIX + appPathIdentifier + \" - refresh status: \" + response.getStatus()); return apps; } catch (Throwable th) { logger.error(PREFIX + appPathIdentifier + \" - was unable to refresh its cache! status = \" + th.getMessage(), th); } finally { closeResponse(response); } } return null; }","old_code_raw":"    public Applications getApplications(String serviceUrl) {\n        ClientResponse response = null;\n        Applications apps = null;\n        try {\n            response = makeRemoteCall(Action.Refresh);\n            apps = response.getEntity(Applications.class);\n            logger.debug(PREFIX + appPathIdentifier + \" -  refresh status: \"\n                    + response.getStatus());\n            return apps;\n        } catch (Throwable th) {\n            logger.error(\n                    PREFIX + appPathIdentifier\n                            + \" - was unable to refresh its cache! status = \"\n                            + th.getMessage(), th);\n\n        } finally {\n            if (response != null) {\n                response.close();\n            }\n        }\n        return apps;\n    }\n","new_comment_raw":"@return - The registry information containing all applications.","old_comment_raw":"@return - The registry information containing all applications.","label":0,"pre_label":1,"AST_level":13,"line_counts":30,"new_code_token_num":232},{"new_code_raw":"protected boolean verifyJmsMessageReceivedOnOutputChannel(Object obj, SubscribableChannel expectedOutputChannel, CountDownHandler handler) throws JMSException, InterruptedException{ return verifyJmsMessageOnOutputChannel(obj, expectedOutputChannel, handler, 7000); }","old_code_raw":"\tprotected boolean verifyJmsMessageReceivedOnOutputChannel(Object obj, SubscribableChannel expectedOutputChannel, CountDownHandler handler) throws JMSException, InterruptedException{\n\t\treturn verifyJmsMessageOnOutputChannel(obj, expectedOutputChannel, handler, 5000);\n\t}\n","new_comment_raw":"@return true if the message was received on the expected channel","old_comment_raw":"@return true if the message was received on the expected channel","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":31},{"new_code_raw":"public static DateTimeFormatter ordinalDate() { return Constants.od; }","old_code_raw":"    public static DateTimeFormatter ordinalDate() {\n        if (od == null) {\n            od = new DateTimeFormatterBuilder()\n                .append(yearElement())\n                .append(dayOfYearElement())\n                .toFormatter();\n        }\n        return od;\n    }\n","new_comment_raw":"@return a formatter for yyyy-DDD","old_comment_raw":"@return a formatter for yyyy-DDD","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"protected DimensionValueLoadTask buildDruidDimensionsLoader(DruidWebService webService, PhysicalTableDictionary physicalTableDictionary, DimensionDictionary dimensionDictionary) { DruidDimensionValueLoader druidDimensionRowProvider = new DruidDimensionValueLoader(physicalTableDictionary, dimensionDictionary, webService); return new DimensionValueLoadTask(Collections.singletonList(druidDimensionRowProvider)); }","old_code_raw":"protected DruidDimensionsLoader buildDruidDimensionsLoader(DruidWebService webService, PhysicalTableDictionary physicalTableDictionary, DimensionDictionary dimensionDictionary) {\n    return new DruidDimensionsLoader(physicalTableDictionary, dimensionDictionary, webService);\n}","new_comment_raw":"@return A DimensionValueLoadTask","old_comment_raw":"@return A DruidDimensionsLoader","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":38},{"new_code_raw":"public static List<Pattern> listOfRegex(String input, int regexFlags) { return listOf(input, RegExSplitter::split, (str) -> Pattern.compile(str, regexFlags)); }","old_code_raw":"    public static Set<Pattern> listOfRegex(String input, int regexFlags) {\n        return listOf(input, RegExSplitter::split, (str) -> Pattern.compile(str, regexFlags));\n    }\n","new_comment_raw":"@return the list of regular expression  Patterns included in the list; never null","old_comment_raw":"@return the list of regular expression Patterns included in the list; never null","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":37},{"new_code_raw":"public boolean submit(E e) { final int segmentIndex = segmentIndex(); final AtomicLong readCounter = readCount[segmentIndex]; final AtomicLong writeCounter = writeCount[segmentIndex]; long head = readCounter.get(); long tail = writeCounter.get(); long size = (tail - head); if (size >= RING_BUFFER_SIZE) { return false; } if (writeCounter.compareAndSet(tail, tail + NUM)) { int index = (int) (tail & RING_BUFFER_MASK); table[segmentIndex][index].lazySet(e); } return true; }","old_code_raw":"public boolean submit(E e) {\n    final int segmentIndex = segmentIndex();\n    final AtomicLong counter = writeCount[segmentIndex];\n    final long writes = counter.get();\n    final int index = (int) (writes & RING_BUFFER_MASK);\n    final AtomicReference<Object> slot = table[segmentIndex][index];\n    final Object value = slot.get();\n    if (!(value instanceof Long)) {\n        return true;\n    } else if (((Long) value).longValue() != writes) {\n        return false;\n    } else if (slot.compareAndSet(value, e)) {\n        counter.lazySet(new Long(writes + NUM));\n    }\n    return false;\n}","new_comment_raw":"@return {@code true} if the element was or could have been added to; {@code false} if full","old_comment_raw":"@return {@code true} if the element could not be added because the buffer needs to be drained","label":1,"pre_label":0,"AST_level":9,"line_counts":16,"new_code_token_num":104},{"new_code_raw":"public static String versionName() { return \"1.0.6\"; }","old_code_raw":"    public static String versionName() {\n        return \"1.0.5\";\n    }\n","new_comment_raw":"@return  String.","old_comment_raw":"@return String.","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"public Element writeSchema(Class javaType, Types types) throws Exception { if (!SimpleType.class.isAssignableFrom(javaType)) return null; Element complexType = types.createElement(STR); types.writeSchemaElement(xmlType, complexType); complexType.setAttribute(STR, xmlType.getLocalPart()); Element simpleContent = types.createElement(STR); complexType.appendChild(simpleContent); Element extension = types.createElement(STR); simpleContent.appendChild(extension); String base = STR; for (int i = NUM; i < propertyDescriptor.length; i++) { String propName = propertyDescriptor[i].getName(); if (!propName.equals(STR)) { if (typeDesc != null) { FieldDesc field = typeDesc.getFieldByName(propName); if (field != null) { if (field.isElement()) { } QName qname = field.getXmlName(); if (qname == null) { qname = new QName(STR, propName); } Class fieldType = propertyDescriptor[i].getType(); if (!types.isAcceptableAsAttribute(fieldType)) { throw new AxisFault(Messages.getMessage(STR, propName, fieldType.getName())); } Element elem = types.createAttributeElement(propName, fieldType, field.getXmlType(), false, extension.getOwnerDocument()); extension.appendChild(elem); } } continue; } BeanPropertyDescriptor bpd = propertyDescriptor[i]; Class type = bpd.getType(); if (!types.isAcceptableAsAttribute(type)) { throw new AxisFault(Messages.getMessage(STR, type.getName())); } base = types.writeType(type); extension.setAttribute(STR, base); } return complexType; }","old_code_raw":"public boolean writeSchema(Types types) throws Exception {\n    if (!SimpleType.class.isAssignableFrom(javaType))\n        return false;\n    Element complexType = types.createElement(STR);\n    types.writeSchemaElement(xmlType, complexType);\n    complexType.setAttribute(STR, xmlType.getLocalPart());\n    Element simpleContent = types.createElement(STR);\n    complexType.appendChild(simpleContent);\n    Element extension = types.createElement(STR);\n    simpleContent.appendChild(extension);\n    String base = STR;\n    for (int i = NUM; i < propertyDescriptor.length; i++) {\n        String propName = propertyDescriptor[i].getName();\n        if (!propName.equals(STR)) {\n            if (typeDesc != null) {\n                FieldDesc field = typeDesc.getFieldByName(propName);\n                if (field != null) {\n                    if (field.isElement()) {\n                    }\n                    QName qname = field.getXmlName();\n                    if (qname == null) {\n                        propName = propName;\n                        qname = new QName(STR, propName);\n                    }\n                    Class fieldType = propertyDescriptor[i].getType();\n                    if (!types.isAcceptableAsAttribute(fieldType)) {\n                        throw new AxisFault(Messages.getMessage(STR, propName, fieldType.getName()));\n                    }\n                    String elementType = types.writeType(fieldType);\n                    Element elem = types.createAttributeElement(propName, elementType, false, extension.getOwnerDocument());\n                    extension.appendChild(elem);\n                }\n            }\n            continue;\n        }\n        BeanPropertyDescriptor bpd = propertyDescriptor[i];\n        Class type = bpd.getType();\n        if (!types.isAcceptableAsAttribute(type)) {\n            throw new AxisFault(Messages.getMessage(STR, type.getName()));\n        }\n        base = types.writeType(type);\n        extension.setAttribute(STR, base);\n    }\n    return true;\n}","new_comment_raw":"@return a type element containing a schema simpleType\/complexType","old_comment_raw":"@return true if we wrote a schema, false if we didn't.","label":1,"pre_label":0,"AST_level":16,"line_counts":43,"new_code_token_num":307},{"new_code_raw":"public final FacebookRequestError getError() { return error; }","old_code_raw":"public final FacebookException getError() {\n    return error;\n}","new_comment_raw":"@return the error from the server, or null if there was no server error","old_comment_raw":"@return the error encountered, or null if the request succeeded","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public PrototypeFactoryDeprecated getQuestionElementsFactory() { if (questionFactory == null) { questionFactory = new PrototypeFactoryDeprecated(); addAnswerDataPrototype(new DateData()); addAnswerDataPrototype(new IntegerData()); addAnswerDataPrototype(new SelectMultiData()); addAnswerDataPrototype(new SelectOneData()); addAnswerDataPrototype(new StringData()); addAnswerDataPrototype(new TimeData()); } return questionFactory; }","old_code_raw":"public PrototypeFactory getQuestionElementsFactory() {\n    if (questionFactory == null) {\n        questionFactory = new PrototypeFactory();\n        addAnswerDataPrototype(new DateData());\n        addAnswerDataPrototype(new IntegerData());\n        addAnswerDataPrototype(new SelectMultiData());\n        addAnswerDataPrototype(new SelectOneData());\n        addAnswerDataPrototype(new StringData());\n        addAnswerDataPrototype(new TimeData());\n    }\n    return questionFactory;\n}","new_comment_raw":"@return a PrototypeFactoryDeprecated containing prototypes for IAnswerData's, IDataReferences, and QuestionDataGroups. If a factory doesn't yet exist, one is created, and default IAnswerData implementing classes are pre-populated.","old_comment_raw":"@return a PrototypeFactory containing prototypes for IAnswerData's, IDataReferences, and QuestionDataGroups. If a factory doesn't yet exist, one is created, and default IAnswerData implementing classes are pre-populated.","label":1,"pre_label":0,"AST_level":8,"line_counts":12,"new_code_token_num":71},{"new_code_raw":"public static ActiveMQConnectionFactory createConnectionFactoryWithoutHA(final DiscoveryGroupConfiguration groupConfiguration, JMSFactoryType jmsFactoryType) { ActiveMQConnectionFactory factory = null; if (jmsFactoryType.equals(JMSFactoryType.CF)) { factory = new ActiveMQJMSConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) { factory = new ActiveMQQueueConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) { factory = new ActiveMQTopicConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) { factory = new ActiveMQXAConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) { factory = new ActiveMQXAQueueConnectionFactory(false, groupConfiguration); } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) { factory = new ActiveMQXATopicConnectionFactory(false, groupConfiguration); } return factory; }","old_code_raw":"public static HornetQConnectionFactory createConnectionFactoryWithoutHA(final DiscoveryGroupConfiguration groupConfiguration, JMSFactoryType jmsFactoryType) {\n    HornetQConnectionFactory factory = null;\n    if (jmsFactoryType.equals(JMSFactoryType.CF)) {\n        factory = new HornetQJMSConnectionFactory(false, groupConfiguration);\n    } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_CF)) {\n        factory = new HornetQQueueConnectionFactory(false, groupConfiguration);\n    } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_CF)) {\n        factory = new HornetQTopicConnectionFactory(false, groupConfiguration);\n    } else if (jmsFactoryType.equals(JMSFactoryType.XA_CF)) {\n        factory = new HornetQXAConnectionFactory(false, groupConfiguration);\n    } else if (jmsFactoryType.equals(JMSFactoryType.QUEUE_XA_CF)) {\n        factory = new HornetQXAQueueConnectionFactory(false, groupConfiguration);\n    } else if (jmsFactoryType.equals(JMSFactoryType.TOPIC_XA_CF)) {\n        factory = new HornetQXATopicConnectionFactory(false, groupConfiguration);\n    }\n    return factory;\n}","new_comment_raw":"@return the ActiveMQConnectionFactory","old_comment_raw":"@return the HornetQConnectionFactory","label":1,"pre_label":0,"AST_level":13,"line_counts":17,"new_code_token_num":146},{"new_code_raw":"public int getMaxConnections() { return getConnectionsPool().getMaxIdlePerKey(); }","old_code_raw":"    public int getMaxConnections() {\n        return getConnectionsPool().getMaxIdle();\n    }\n","new_comment_raw":"@return the maxConnections that will be created for this pool.","old_comment_raw":"@return the maxConnections that will be created for this pool.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":15},{"new_code_raw":"boolean storeRelations(KeyRegistry keyRegistry) { if (relationStoreInfos.isEmpty()) { return false; } ObjectProvider op = getObjectProvider(); ExecutionContext ec = op.getExecutionContext(); DatastoreTable table = getDatastoreTable(); if (datastoreEntity.getKey() != null) { Key key = datastoreEntity.getKey(); AbstractClassMetaData acmd = op.getClassMetaData(); int[] relationFieldNums = acmd.getRelationMemberPositions(ec.getClassLoaderResolver(), ec.getMetaDataManager()); if (relationFieldNums != null) { for (int i = NUM; i < relationFieldNums.length; i++) { AbstractMemberMetaData mmd = acmd.getMetaDataForManagedMemberAtAbsolutePosition(relationFieldNums[i]); boolean owned = MetaDataUtils.isOwnedRelation(mmd); if (owned) { Object childValue = op.provideField(mmd.getAbsoluteFieldNumber()); if (childValue != null) { if (childValue instanceof Object[]) { childValue = Arrays.asList((Object[]) childValue); } String expectedType = getExpectedChildType(mmd); if (childValue instanceof Iterable) { for (Object element : (Iterable) childValue) { addToParentKeyMap(keyRegistry, element, key, op.getExecutionContext(), expectedType, true); } } else { addToParentKeyMap(keyRegistry, childValue, key, op.getExecutionContext(), expectedType, !table.isParentKeyProvider(mmd)); } } } } } } boolean modifiedEntity = false; for (RelationStoreInformation relInfo : relationStoreInfos) { AbstractMemberMetaData mmd = relInfo.mmd; try { JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd); if (mapping instanceof EmbeddedPCMapping || mapping instanceof SerialisedPCMapping || mapping instanceof SerialisedReferenceMapping || mapping instanceof PersistableMapping || mapping instanceof InterfaceMapping) { if (!table.isParentKeyProvider(mmd)) { EntityUtils.checkParentage(relInfo.value, op); mapping.setObject(getExecutionContext(), datastoreEntity, IS_FK_VALUE_ARR, relInfo.value, op, mmd.getAbsoluteFieldNumber()); } } } catch (NotYetFlushedException e) { } } for (RelationStoreInformation relInfo : relationStoreInfos) { try { JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd); if (mapping instanceof MappingCallbacks) { if (operation == StoreFieldManager.Operation.INSERT) { ((MappingCallbacks) mapping).postInsert(op); } else { ((MappingCallbacks) mapping).postUpdate(op); } } } catch (NotYetFlushedException e) { } } for (RelationStoreInformation relInfo : relationStoreInfos) { AbstractMemberMetaData mmd = relInfo.mmd; int relationType = mmd.getRelationType(ec.getClassLoaderResolver()); boolean owned = MetaDataUtils.isOwnedRelation(mmd); if (owned) { if (!getStoreManager().storageVersionAtLeast(StorageVersion.WRITE_OWNED_CHILD_KEYS_TO_PARENTS)) { continue; } if (relationType == Relation.MANY_TO_ONE_BI) { continue; } else if (relationType == Relation.ONE_TO_ONE_BI && mmd.getMappedBy() != null) { continue; } } Object value = relInfo.value; String propName = EntityUtils.getPropertyName(getStoreManager().getIdentifierFactory(), mmd); if (value == null) { checkSettingToNullValue(mmd, value); if (!datastoreEntity.hasProperty(propName)) { modifiedEntity = true; EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value); } } else if (Relation.isRelationSingleValued(relationType)) { if (ec.getApiAdapter().isDeleted(value)) { value = null; } else { Key key = EntityUtils.extractChildKey(value, ec, datastoreEntity); if (key == null) { Object childPC = processPersistable(mmd, value); if (childPC != value) { op.replaceField(mmd.getAbsoluteFieldNumber(), childPC); } key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity); } value = key; if (!datastoreEntity.hasProperty(propName) || !value.equals(datastoreEntity.getProperty(propName))) { modifiedEntity = true; EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value); } } } else if (Relation.isRelationMultiValued(relationType)) { if (mmd.hasCollection()) { Collection coll = (Collection) value; List<Key> keys = Utils.newArrayList(); for (Object obj : coll) { if (!ec.getApiAdapter().isDeleted(obj)) { Key key = EntityUtils.extractChildKey(obj, ec, datastoreEntity); if (key != null) { keys.add(key); } else { Object childPC = processPersistable(mmd, obj); key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity); keys.add(key); } } } value = keys; if (!datastoreEntity.hasProperty(propName) || !value.equals(datastoreEntity.getProperty(propName))) { modifiedEntity = true; EntityUtils.setEntityProperty(datastoreEntity, mmd, propName, value); } } } } relationStoreInfos.clear(); return modifiedEntity; }","old_code_raw":"boolean storeRelations(KeyRegistry keyRegistry) {\n    NucleusLogger.GENERAL.debug(STR + getObjectProvider() + STR + relationStoreInfos.size());\n    if (relationStoreInfos.isEmpty()) {\n        return false;\n    }\n    ObjectProvider op = getObjectProvider();\n    ExecutionContext ec = op.getExecutionContext();\n    DatastoreTable table = getDatastoreTable();\n    if (datastoreEntity.getKey() != null) {\n        Key key = datastoreEntity.getKey();\n        AbstractClassMetaData acmd = op.getClassMetaData();\n        int[] relationFieldNums = acmd.getRelationMemberPositions(ec.getClassLoaderResolver(), ec.getMetaDataManager());\n        if (relationFieldNums != null) {\n            for (int i = NUM; i < relationFieldNums.length; i++) {\n                AbstractMemberMetaData mmd = acmd.getMetaDataForManagedMemberAtAbsolutePosition(relationFieldNums[i]);\n                boolean owned = MetaDataUtils.isOwnedRelation(mmd);\n                if (owned) {\n                    Object childValue = op.provideField(mmd.getAbsoluteFieldNumber());\n                    if (childValue != null) {\n                        if (childValue instanceof Object[]) {\n                            childValue = Arrays.asList((Object[]) childValue);\n                        }\n                        String expectedType = getExpectedChildType(mmd);\n                        if (childValue instanceof Iterable) {\n                            for (Object element : (Iterable) childValue) {\n                                addToParentKeyMap(keyRegistry, element, key, op.getExecutionContext(), expectedType, true);\n                            }\n                        } else {\n                            addToParentKeyMap(keyRegistry, childValue, key, op.getExecutionContext(), expectedType, !table.isParentKeyProvider(mmd));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    boolean modifiedEntity = false;\n    for (RelationStoreInformation relInfo : relationStoreInfos) {\n        AbstractMemberMetaData mmd = relInfo.mmd;\n        try {\n            JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd);\n            if (mapping instanceof EmbeddedPCMapping || mapping instanceof SerialisedPCMapping || mapping instanceof SerialisedReferenceMapping || mapping instanceof PersistableMapping || mapping instanceof InterfaceMapping) {\n                if (!table.isParentKeyProvider(mmd)) {\n                    EntityUtils.checkParentage(relInfo.value, op);\n                    mapping.setObject(getExecutionContext(), datastoreEntity, IS_FK_VALUE_ARR, relInfo.value, op, mmd.getAbsoluteFieldNumber());\n                }\n            }\n        } catch (NotYetFlushedException e) {\n        }\n    }\n    for (RelationStoreInformation relInfo : relationStoreInfos) {\n        try {\n            JavaTypeMapping mapping = table.getMemberMappingInDatastoreClass(relInfo.mmd);\n            if (mapping instanceof MappingCallbacks) {\n                if (operation == StoreFieldManager.Operation.INSERT) {\n                    ((MappingCallbacks) mapping).postInsert(op);\n                } else {\n                    ((MappingCallbacks) mapping).postUpdate(op);\n                }\n            }\n        } catch (NotYetFlushedException e) {\n        }\n    }\n    for (RelationStoreInformation relInfo : relationStoreInfos) {\n        AbstractMemberMetaData mmd = relInfo.mmd;\n        int relationType = mmd.getRelationType(ec.getClassLoaderResolver());\n        NucleusLogger.GENERAL.debug(STR + getObjectProvider() + STR + mmd.getFullFieldName());\n        boolean owned = MetaDataUtils.isOwnedRelation(mmd);\n        if (owned) {\n            if (!getStoreManager().storageVersionAtLeast(StorageVersion.WRITE_OWNED_CHILD_KEYS_TO_PARENTS)) {\n                continue;\n            }\n            if (relationType == Relation.MANY_TO_ONE_BI) {\n                continue;\n            } else if (relationType == Relation.ONE_TO_ONE_BI && mmd.getMappedBy() != null) {\n                continue;\n            }\n        }\n        Object value = relInfo.value;\n        if (value == null) {\n            checkSettingToNullValue(mmd, value);\n        } else if (Relation.isRelationSingleValued(relationType)) {\n            if (ec.getApiAdapter().isDeleted(value)) {\n                value = null;\n            } else {\n                Key key = EntityUtils.extractChildKey(value, ec, datastoreEntity);\n                if (key == null) {\n                    Object childPC = processPersistable(mmd, value);\n                    if (childPC != value) {\n                        op.replaceField(mmd.getAbsoluteFieldNumber(), childPC);\n                    }\n                    key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity);\n                }\n                value = key;\n            }\n        } else if (Relation.isRelationMultiValued(relationType)) {\n            if (mmd.hasCollection()) {\n                Collection coll = (Collection) value;\n                List<Key> keys = Utils.newArrayList();\n                for (Object obj : coll) {\n                    if (!ec.getApiAdapter().isDeleted(obj)) {\n                        Key key = EntityUtils.extractChildKey(obj, ec, datastoreEntity);\n                        if (key != null) {\n                            keys.add(key);\n                        } else {\n                            Object childPC = processPersistable(mmd, obj);\n                            key = EntityUtils.extractChildKey(childPC, ec, datastoreEntity);\n                            keys.add(key);\n                        }\n                    }\n                }\n                value = keys;\n            }\n            if (value instanceof SCO) {\n                value = ((SCO) value).getValue();\n            }\n        }\n        modifiedEntity = true;\n        EntityUtils.setEntityProperty(datastoreEntity, mmd, EntityUtils.getPropertyName(getStoreManager().getIdentifierFactory(), mmd), value);\n    }\n    relationStoreInfos.clear();\n    NucleusLogger.GENERAL.debug(STR + getObjectProvider() + STR + modifiedEntity);\n    try {\n        return keyRegistry.parentNeedsUpdate(datastoreEntity.getKey());\n    } finally {\n        keyRegistry.clearModifiedParent(datastoreEntity.getKey());\n    }\n}","new_comment_raw":"@return {@code true} if the entity has had properties updated during this method, {@code false} otherwise.","old_comment_raw":"@return {@code true} if the relations changed in a way that requires an update to the relation owner, {@code false} otherwise.","label":1,"pre_label":0,"AST_level":20,"line_counts":128,"new_code_token_num":855},{"new_code_raw":"protected CompletableFuture<ExecutionResult> completeValue(ExecutionContext executionContext, ExecutionStrategyParameters parameters) throws NonNullableFieldWasNullException { ExecutionTypeInfo typeInfo = parameters.typeInfo(); Object result = unboxPossibleOptional(parameters.source()); GraphQLType fieldType = typeInfo.getType(); if (result == null) { return completeValueForNull(parameters); } else if (fieldType instanceof GraphQLList) { return completeValueForList(executionContext, parameters, result); } else if (fieldType instanceof GraphQLScalarType) { return completeValueForScalar(executionContext, parameters, (GraphQLScalarType) fieldType, result); } else if (fieldType instanceof GraphQLEnumType) { return completeValueForEnum(executionContext, parameters, (GraphQLEnumType) fieldType, result); } \/\/ \/\/ when we are here, we have a complex type: Interface, Union or Object \/\/ and we must go deeper \/\/ GraphQLObjectType resolvedObjectType = resolveType(executionContext, parameters, fieldType); return completeValueForObject(executionContext, parameters, resolvedObjectType, result); }","old_code_raw":"    protected CompletableFuture<ExecutionResult> completeValue(ExecutionContext executionContext, ExecutionStrategyParameters parameters) throws NonNullableFieldWasNullException {\n        ExecutionTypeInfo typeInfo = parameters.typeInfo();\n        Object result = unboxPossibleOptional(parameters.source());\n        GraphQLType fieldType = typeInfo.getType();\n\n        if (result == null) {\n            return completedFuture(new ExecutionResultImpl(parameters.nonNullFieldValidator().validate(parameters.path(), null), null));\n        } else if (fieldType instanceof GraphQLList) {\n            return completeValueForList(executionContext, parameters, result);\n        } else if (fieldType instanceof GraphQLScalarType) {\n            return completeValueForScalar(executionContext, parameters, (GraphQLScalarType) fieldType, result);\n        } else if (fieldType instanceof GraphQLEnumType) {\n            return completeValueForEnum(executionContext, parameters, (GraphQLEnumType) fieldType, result);\n        }\n\n\n        \/\/ when we are here, we have a complex type: Interface, Union or Object\n        \/\/ and we must go deeper\n\n        GraphQLObjectType resolvedType = resolveType(executionContext, parameters, fieldType);\n\n        FieldCollectorParameters collectorParameters = newParameters()\n                .schema(executionContext.getGraphQLSchema())\n                .objectType(resolvedType)\n                .fragments(executionContext.getFragmentsByName())\n                .variables(executionContext.getVariables())\n                .build();\n\n        Map<String, List<Field>> subFields = fieldCollector.collectFields(collectorParameters, parameters.field());\n\n        ExecutionTypeInfo newTypeInfo = typeInfo.treatAs(resolvedType);\n        NonNullableFieldValidator nonNullableFieldValidator = new NonNullableFieldValidator(executionContext, newTypeInfo);\n\n        ExecutionStrategyParameters newParameters = ExecutionStrategyParameters.newParameters()\n                .typeInfo(newTypeInfo)\n                .fields(subFields)\n                .nonNullFieldValidator(nonNullableFieldValidator)\n                .path(parameters.path())\n                .source(result).build();\n\n        \/\/ Calling this from the executionContext to ensure we shift back from mutation strategy to the query strategy.\n\n        return executionContext.getQueryStrategy().execute(executionContext, newParameters);\n    }\n","new_comment_raw":"@return an  ExecutionResult","old_comment_raw":"@return an ExecutionResult","label":0,"pre_label":1,"AST_level":11,"line_counts":23,"new_code_token_num":171},{"new_code_raw":"public static DateTimeFormatter weekyear() { return Constants.we; }","old_code_raw":"    public static DateTimeFormatter weekyear() {\n        return weekyearElement();\n    }\n","new_comment_raw":"@return a formatter for xxxx","old_comment_raw":"@return a formatter for xxxx","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":12},{"new_code_raw":"private IProject getProject() { return (IProject) managedProject.getOwner(); }","old_code_raw":"private IProject getProject() {\n    return managedTarget.getOwner().getProject();\n}","new_comment_raw":"@return the <code>IProject<\/code> associated with the managed project","old_comment_raw":"@return the <code>IProject<\/code> associated with the target","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":16},{"new_code_raw":"@NonNull protected List<Action> retrieveActions(@NonNull SCMHead head, @NonNull SCMHeadEvent event, @NonNull TaskListener listener) throws IOException, InterruptedException { return Collections.emptyList(); }","old_code_raw":"@NonNull\nprotected Map<Class<? extends Action>, Action> retrieveActions(@NonNull SCMHead head, @NonNull TaskListener listener) throws IOException, InterruptedException {\n    return Collections.emptyMap();\n}","new_comment_raw":"@return the list of {@link Action} instances to persist.","old_comment_raw":"@return the map of {@link Action} instances to persist, keyed by the class of action. Keys with {@code null} values indicate actions that should be removed if present.","label":1,"pre_label":0,"AST_level":5,"line_counts":4,"new_code_token_num":34},{"new_code_raw":"public SequenceService createSequenceService() { return createSequenceService(defaultEndpointUrl); }","old_code_raw":"public SequenceService createSequenceService() {\n    return createSequenceService(defaultServerUrl);\n}","new_comment_raw":"@return a new sequence service with the default endpoint URL","old_comment_raw":"@return a new sequence service with the default server URL","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) { return appendDecimal(DateTimeFieldType.yearOfEra(), minDigits, maxDigits); }","old_code_raw":"    public DateTimeFormatterBuilder appendYearOfEra(final int minDigits, final int maxDigits) {\n        return appendDecimal(iChronoUTC.yearOfEra(), minDigits, maxDigits);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":25},{"new_code_raw":"public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) { return appendDecimal(iChronoUTC.hourOfHalfday(), minDigits, 2); }","old_code_raw":"    public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) {\n        return appendNumeric(iChronoUTC.hourOfHalfday(), minDigits, 2);\n    }\n","new_comment_raw":"@return this DateTimeFormatterBuilder","old_comment_raw":"@return this DateTimeFormatterBuilder","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":23},{"new_code_raw":"public static String addPropertiesToURIFromBean(String uri, Object bean) throws Exception { Map<String, String> properties = PropertyUtil.getProperties(bean); return PropertyUtil.addPropertiesToURI(uri, properties); }","old_code_raw":"public static String addPropertiesToURIFromBean(String uri, Object bean) throws Exception {\n    Map<String, String> props = PropertyUtil.getProperties(bean);\n    return PropertyUtil.addPropertiesToURI(uri, props);\n}","new_comment_raw":"@return a new String value that is the original URI with the added bean properties.","old_comment_raw":"@return <Code>Map<\/Code> of properties","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":35},{"new_code_raw":"@Nullable public synchronized Habit getHabitByPosition(int position) { if (position < NUM || position >= data.habits.size()) return null; return data.habits.get(position); }","old_code_raw":"@NonNull\npublic Habit getHabitByPosition(int position) {\n    return data.habits.get(position);\n}","new_comment_raw":"@return the habit at given position or null if position is invalid","old_comment_raw":"@return the habit at given position","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":36},{"new_code_raw":"long addLocation(String locationSetting, String cityName, double lat, double lon) { long locationId; \/\/ First, check if the location with this city name exists in the db Cursor locationCursor = mContext.getContentResolver().query( WeatherContract.LocationEntry.CONTENT_URI, new String[]{WeatherContract.LocationEntry._ID}, WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING + \" = ?\", new String[]{locationSetting}, null); if (locationCursor.moveToFirst()) { int locationIdIndex = locationCursor.getColumnIndex(WeatherContract.LocationEntry._ID); locationId = locationCursor.getLong(locationIdIndex); } else { \/\/ Now that the content provider is set up, inserting rows of data is pretty simple. \/\/ First create a ContentValues object to hold the data you want to insert. ContentValues locationValues = new ContentValues(); \/\/ Then add the data, along with the corresponding name of the data type, \/\/ so the content provider knows what kind of value is being inserted. locationValues.put(WeatherContract.LocationEntry.COLUMN_CITY_NAME, cityName); locationValues.put(WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING, locationSetting); locationValues.put(WeatherContract.LocationEntry.COLUMN_COORD_LAT, lat); locationValues.put(WeatherContract.LocationEntry.COLUMN_COORD_LONG, lon); \/\/ Finally, insert location data into the database. Uri insertedUri = mContext.getContentResolver().insert( WeatherContract.LocationEntry.CONTENT_URI, locationValues ); \/\/ The resulting URI contains the ID for the row. Extract the locationId from the Uri. locationId = ContentUris.parseId(insertedUri); } locationCursor.close(); \/\/ Wait, that worked? Yes! return locationId; }","old_code_raw":"    long addLocation(String locationSetting, String cityName, double lat, double lon) {\n        \/\/ Students: First, check if the location with this city name exists in the db\n        \/\/ If it exists, return the current ID\n        \/\/ Otherwise, insert it using the content resolver and the base URI\n        return -1;\n    }\n","new_comment_raw":"@return the row ID of the added location.","old_comment_raw":"@return the row ID of the added location.","label":0,"pre_label":1,"AST_level":9,"line_counts":41,"new_code_token_num":283},{"new_code_raw":"public TreeMap<String, List<String>> getFontFamilies(Collection<String> filenames) { LinkedList<String[]> familyAndFont = new LinkedList<String[]>(); String[] family; BaseFont bf = null; int i = NUM; Collection<String> files = checkNotNull(filenames); for (String filename : files) { family = extractFamilyNames(filename, bf); System.out.println(STR + family[NUM] + STR + filename); String[] x = { family[NUM], filename }; familyAndFont.add(x); i++; } gdd.diag(STR + i + STR); try { for (String[] kv : familyAndFont) { if (familyTree.containsKey(kv[NUM])) { List v = familyTree.get(kv[NUM]); v.add(kv[NUM]); } else { List l = new LinkedList<String>(); l.add(kv[NUM]); familyTree.put(kv[NUM], l); } } } catch (Exception e) { System.err.println(STR); } return (familyTree); }","old_code_raw":"public List<String[]> getFontFamilies(Collection<String> filenames) {\n    LinkedList<String[]> familyAndFont = new LinkedList<String[]>();\n    String[] family = null;\n    BaseFont bf = null;\n    Collection<String> files = checkNotNull(filenames);\n    for (String filename : files) {\n        family = extractFamilyNames(filename, bf);\n        System.out.println(STR + family[NUM] + STR + filename);\n        String[] x = { family[NUM], filename };\n        familyAndFont.add(x);\n    }\n    return (familyAndFont);\n}","new_comment_raw":"@return a tree with entries consisting the family (key) and a linked list of font files in that family (value)","old_comment_raw":"@return a sorted list of arrays of two strings consisting of the family and a font file in that family","label":1,"pre_label":0,"AST_level":13,"line_counts":30,"new_code_token_num":211},{"new_code_raw":"public AuditEvent convertToAuditEvent(PersistentAuditEvent persistentAuditEvent) { return new AuditEvent(Date.from(persistentAuditEvent.getAuditEventDate()), persistentAuditEvent.getPrincipal(), persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData())); }","old_code_raw":"    public AuditEvent convertToAuditEvent(PersistentAuditEvent persistentAuditEvent) {\n        Instant instant = persistentAuditEvent.getAuditEventDate().atZone(ZoneId.systemDefault()).toInstant();\n        return new AuditEvent(Date.from(instant), persistentAuditEvent.getPrincipal(),\n            persistentAuditEvent.getAuditEventType(), convertDataToObjects(persistentAuditEvent.getData()));\n    }\n","new_comment_raw":"@return the converted list.","old_comment_raw":"@return the converted list.","label":0,"pre_label":1,"AST_level":6,"line_counts":5,"new_code_token_num":41},{"new_code_raw":"UserInformationResponse processUserInfoResponse(HTTPRequest request) throws UserInfoException { UserInformationResponse userInformationResponse = new UserInformationResponse(); UserInfoResponse response; try { response = com.nimbusds.openid.connect.sdk.UserInfoResponse.parse(request.send()); } catch (ParseException | IOException e) { throw new UserInfoException(STR, e); } if (response instanceof UserInfoErrorResponse) { return userInformationResponse; } UserInfoSuccessResponse userInfoSuccessResponse = (UserInfoSuccessResponse) response; userInformationResponse.setUserInfo(userInfoSuccessResponse.getUserInfo().toJSONObject().toJSONString()); return userInformationResponse; }","old_code_raw":"UserInfoResponse processUserInfoResponse(HTTPRequest request) throws UserInfoException {\n    UserInfoResponse userInfoResponse = new UserInfoResponse();\n    com.nimbusds.openid.connect.sdk.UserInfoResponse response;\n    try {\n        response = com.nimbusds.openid.connect.sdk.UserInfoResponse.parse(request.send());\n    } catch (ParseException | IOException e) {\n        throw new UserInfoException(STR, e);\n    }\n    if (response instanceof UserInfoErrorResponse) {\n        return userInfoResponse;\n    }\n    UserInfoSuccessResponse userInfoSuccessResponse = (UserInfoSuccessResponse) response;\n    userInfoResponse.setUserInfo(userInfoSuccessResponse.getUserInfo().toJSONObject().toJSONString());\n    return userInfoResponse;\n}","new_comment_raw":"@return {@link UserInformationResponse} Object with received values.","old_comment_raw":"@return UserInfoResponse object","label":1,"pre_label":0,"AST_level":7,"line_counts":15,"new_code_token_num":92},{"new_code_raw":"@Override public String toString() { if (stringRep == null) { stringRep = toString(true); } return stringRep; }","old_code_raw":"public String toString(boolean altMemberSep) {\n    StringBuffer s = new StringBuffer();\n    if (className != null) {\n        s.append(className);\n    }\n    if (memberName != null) {\n        if (className != null) {\n            s.append(altMemberSep ? ALT_MEMBER_SEPARATOR : STR);\n        }\n        s.append(memberName);\n    }\n    if (descriptor != null && (className == null || memberName != null)) {\n        s.append(descriptor);\n    }\n    return s.toString();\n}","new_comment_raw":"@return a unique representation of this member ID.","old_comment_raw":"@return the signature string","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":25},{"new_code_raw":"protected RuntimeException handleAccessDeniedException(AccessDeniedException originalException) { ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(originalException); this.beanManager.fireEvent(exceptionToCatchEvent); if (!exceptionToCatchEvent.isHandled()) { throw originalException; } return null; }","old_code_raw":"private boolean handleAccessDeniedException(AccessDeniedException ade) throws AccessDeniedException {\n    ExceptionToCatchEvent exceptionToCatchEvent = new ExceptionToCatchEvent(ade);\n    exceptionToCatchEvent.setOptional(true);\n    beanManager.fireEvent(exceptionToCatchEvent);\n    if (!exceptionToCatchEvent.isHandled()) {\n        throw ade;\n    }\n    return false;\n}","new_comment_raw":"@return the original exception if the default behavior was changed and the exception is unhandled","old_comment_raw":"@return False if the processing should be aborted.","label":1,"pre_label":0,"AST_level":6,"line_counts":8,"new_code_token_num":40},{"new_code_raw":"private static List<Column> resolveColumnsFromStreamTupleData(ByteBuffer buffer, TypeRegistry typeRegistry, Table table) { \/\/ Read number of the columns short numberOfColumns = buffer.getShort(); List<Column> columns = new ArrayList<>(numberOfColumns); for (short i = 0; i < numberOfColumns; ++i) { final io.debezium.relational.Column column = table.columns().get(i); final String columnName = column.name(); final String typeName = column.typeName(); final PostgresType columnType = typeRegistry.get(typeName); final String typeExpression = column.typeExpression(); final boolean optional = column.isOptional(); \/\/ Read the sub-message type \/\/ 't' : Value is represented as text \/\/ 'u' : An unchanged TOAST-ed value, actual value is not sent. \/\/ 'n' : Value is null. char type = (char) buffer.get(); if (type == 't') { final String valueStr = readColumnValueAsString(buffer); columns.add( new AbstractReplicationMessageColumn(columnName, columnType, typeExpression, optional, true) { @Override public Object getValue(PgConnectionSupplier connection, boolean includeUnknownDatatypes) { return PgOutputReplicationMessage.getValue(columnName, columnType, typeExpression, valueStr, connection, includeUnknownDatatypes, typeRegistry); } @Override public String toString() { return columnName + \"(\" + typeExpression + \")=\" + valueStr; } }); } else if (type == 'u') { columns.add( new UnchangedToastedReplicationMessageColumn(columnName, columnType, typeExpression, optional, true) { @Override public String toString() { return columnName + \"(\" + typeExpression + \") - Unchanged toasted column\"; } }); } else if (type == 'n') { columns.add( new AbstractReplicationMessageColumn(columnName, columnType, typeExpression, true, true) { @Override public Object getValue(PgConnectionSupplier connection, boolean includeUnknownDatatypes) { return null; } }); } } columns.forEach(c -> LOGGER.trace(\"Column: {}\", c)); return columns; }","old_code_raw":"    private static List<Column> resolveColumnsFromStreamTupleData(ByteBuffer buffer, TypeRegistry typeRegistry, Table table) {\n        \/\/ Read number of the columns\n        short numberOfColumns = buffer.getShort();\n\n        List<Column> columns = new ArrayList<>(numberOfColumns);\n        for (short i = 0; i < numberOfColumns; ++i) {\n\n            final io.debezium.relational.Column column = table.columns().get(i);\n            final String columnName = column.name();\n            final String typeName = column.typeName();\n            final PostgresType columnType = typeRegistry.get(typeName);\n            final String typeExpression = column.typeExpression();\n            final boolean optional = column.isOptional();\n\n            \/\/ Read the sub-message type\n            \/\/ 't' : Value is represented as text\n            \/\/ 'u' : An unchanged TOAST-ed value, actual value is not sent.\n            \/\/ 'n' : Value is null.\n            char type = (char) buffer.get();\n            if (type == 't') {\n                final String valueStr = readColumnValueAsString(buffer);\n                columns.add(\n                        new AbstractReplicationMessageColumn(columnName, columnType, typeExpression, optional, true) {\n                            @Override\n                            public Object getValue(PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n                                return PgOutputReplicationMessage.getValue(columnName, columnType, typeExpression, valueStr, connection, includeUnknownDatatypes);\n                            }\n\n                            @Override\n                            public String toString() {\n                                return columnName + \"(\" + typeExpression + \")=\" + valueStr;\n                            }\n                        });\n            }\n            else if (type == 'u') {\n                columns.add(\n                        new UnchangedToastedReplicationMessageColumn(columnName, columnType, typeExpression, optional, true) {\n                            @Override\n                            public String toString() {\n                                return columnName + \"(\" + typeExpression + \") - Unchanged toasted column\";\n                            }\n                        });\n            }\n            else if (type == 'n') {\n                columns.add(\n                        new AbstractReplicationMessageColumn(columnName, columnType, typeExpression, true, true) {\n                            @Override\n                            public Object getValue(PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n                                return null;\n                            }\n                        });\n            }\n        }\n\n        columns.forEach(c -> LOGGER.trace(\"Column: {}\", c));\n        return columns;\n    }\n","new_comment_raw":"@return list of replication message columns","old_comment_raw":"@return list of replication message columns","label":0,"pre_label":1,"AST_level":16,"line_counts":59,"new_code_token_num":386},{"new_code_raw":"public static Project createThermalProject(File file) { return createProject(file, THERMAL); }","old_code_raw":"public static Project createThermalProject(File file) {\n    return createProject(file, Type.THERMAL);\n}","new_comment_raw":"@return the created project, or null if file was not writable or it already existed.","old_comment_raw":"@return the created project, or null if file was not writable.","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":18},{"new_code_raw":"private boolean nonValueAnno(AnnotatedTypeMirror mirror) { AnnotationMirror valueAnno = getValueAnnotation(mirror); return AnnotationUtils.areSameIgnoringValues(valueAnno, UNKNOWNVAL) || AnnotationUtils.areSameByClass(valueAnno, BottomVal.class) || AnnotationUtils.areSameIgnoringValues(mirror.getAnnotationInHierarchy(ARRAYLEN), ARRAYLEN); }","old_code_raw":"private boolean nonValueAnno(AnnotatedTypeMirror mirror) {\n    return AnnotationUtils.areSameIgnoringValues(getValueAnnotation(mirror), UNKNOWNVAL) || AnnotationUtils.areSameIgnoringValues(mirror.getAnnotationInHierarchy(ARRAYLEN), ARRAYLEN);\n}","new_comment_raw":"@return true if the AnnotatedTypeMirror contains the UnknownVal, ArrayLen, to BottomVal, false otherwise","old_comment_raw":"@return true if the AnnotatedTypeMirror contains the UnknownVal or ArrayLen AnnotationMirror, false otherwise","label":1,"pre_label":0,"AST_level":8,"line_counts":4,"new_code_token_num":48},{"new_code_raw":"public static String getHostFromUrl(String url) { String authority = getAuthorityFromUrl(url); \/\/ no port int idx = authority.indexOf(\":\"); if (idx == -1) return authority; \/\/ port, return only the portion preceding the port return authority.substring(0, idx); }","old_code_raw":"   public static String getHostFromUrl(String url)\n   {\n      \/\/ no work to do\n      if (url.indexOf('\/') == -1)\n         return url;\n      \n      \/\/ presume no protocol; if present, skip those slashes\n      int slashes = 0;\n      if (url.contains(\":\/\/\"))\n         slashes += 2;\n      \n      \/\/ split on slashes and return first component\n      String[] parts = url.split(\"\/\");\n      if (parts.length < slashes)\n         return url;\n      return parts[slashes];\n   }\n","new_comment_raw":"@return The host, as a string.","old_comment_raw":"@return Host name and port, as a string.","label":1,"pre_label":0,"AST_level":6,"line_counts":13,"new_code_token_num":60},{"new_code_raw":"private Response handleResponse() throws IOException { Socket socket = getOldestSocket(); StringBuilder resultBuilder = new StringBuilder(); BufferedReader reader = new BufferedReader( new InputStreamReader(socket.getInputStream())); String line; boolean hasSeenDoubleCRLF = false; \/\/Whether we are out of headers yet while ((line = reader.readLine()) != null && !line.equals(\"EOResponse\")) { if (hasSeenDoubleCRLF) { if (resultBuilder.length() > 0) { \/\/Out of headers, and not the first line, so append a newline resultBuilder.append(\"\\n\"); } resultBuilder.append(line); } if (line.equals(\"\")) { hasSeenDoubleCRLF = true; } } try { return new JsonToBeanConverter().convert(Response.class, resultBuilder.toString()); } catch (WebDriverException e) { throw e; } catch (Exception e) { throw new WebDriverException(e); } }","old_code_raw":"  private ChromeResponse handleResponse(Command command) throws IOException {\n    Socket socket = getOldestSocket();\n    StringBuilder resultBuilder = new StringBuilder();\n    BufferedReader reader = new BufferedReader(\n        new InputStreamReader(socket.getInputStream()));\n    String line;\n    boolean hasSeenDoubleCRLF = false; \/\/Whether we are out of headers yet\n    while ((line = reader.readLine()) != null && !line.equals(\"EOResponse\")) {\n      if (hasSeenDoubleCRLF) {\n        if (resultBuilder.length() > 0) {\n          \/\/Out of headers, and not the first line, so append a newline\n          resultBuilder.append(\"\\n\");\n        }\n        resultBuilder.append(line);\n      }\n      if (line.equals(\"\")) {\n        hasSeenDoubleCRLF = true;\n      }\n    }\n    return parseResponse(resultBuilder.toString());\n  }\n","new_comment_raw":"@return response to the command.","old_comment_raw":"@return response to the command.","label":0,"pre_label":1,"AST_level":11,"line_counts":29,"new_code_token_num":181},{"new_code_raw":"public Order getOrderById (String orderId) throws ApiException { Object postBody = null; byte[] postBinaryBody = null; \/\/ verify the required parameter 'orderId' is set if (orderId == null) { throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\"); } \/\/ create path and map variables String path = \"\/store\/order\/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\") .replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiClient.escapeString(orderId.toString())); \/\/ query params List<Pair> queryParams = new ArrayList<Pair>(); Map<String, String> headerParams = new HashMap<String, String>(); Map<String, Object> formParams = new HashMap<String, Object>(); final String[] accepts = { \"application\/json\", \"application\/xml\" }; final String accept = apiClient.selectHeaderAccept(accepts); final String[] contentTypes = { }; final String contentType = apiClient.selectHeaderContentType(contentTypes); String[] authNames = new String[] { }; TypeRef returnType = new TypeRef<Order>() {}; return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, postBinaryBody, headerParams, formParams, accept, contentType, authNames, returnType); }","old_code_raw":"  public Order getOrderById (String orderId) throws ApiException {\n    Object postBody = null;\n    \n    \/\/ verify the required parameter 'orderId' is set\n    if (orderId == null) {\n       throw new ApiException(400, \"Missing the required parameter 'orderId' when calling getOrderById\");\n    }\n    \n\n    \/\/ create path and map variables\n    String path = \"\/store\/order\/{orderId}\".replaceAll(\"\\\\{format\\\\}\",\"json\")\n      .replaceAll(\"\\\\{\" + \"orderId\" + \"\\\\}\", apiClient.escapeString(orderId.toString()));\n\n    \/\/ query params\n    List<Pair> queryParams = new ArrayList<Pair>();\n    Map<String, String> headerParams = new HashMap<String, String>();\n    Map<String, Object> formParams = new HashMap<String, Object>();\n\n    \n\n    \n\n    \n\n    final String[] accepts = {\n      \"application\/json\", \"application\/xml\"\n    };\n    final String accept = apiClient.selectHeaderAccept(accepts);\n\n    final String[] contentTypes = {\n      \n    };\n    final String contentType = apiClient.selectHeaderContentType(contentTypes);\n\n    String[] authNames = new String[] {  };\n    \n    TypeRef returnType = new TypeRef<Order>() {};\n    return apiClient.invokeAPI(path, \"GET\", queryParams, postBody, headerParams, formParams, accept, contentType, authNames, returnType);\n    \n  }\n","new_comment_raw":"@return Order","old_comment_raw":"@return Order","label":0,"pre_label":1,"AST_level":9,"line_counts":48,"new_code_token_num":256},{"new_code_raw":"public static HashMap getXmlRpcWorkflowCondition(WorkflowCondition c) { HashMap condition = new HashMap(); condition.put(STR, c.getConditionInstanceClassName()); condition.put(STR, c.getConditionId()); condition.put(STR, c.getConditionName()); condition.put(STR, String.valueOf(c.getOrder())); condition.put(STR, String.valueOf(c.getTimeoutSeconds())); condition.put(STR, String.valueOf(c.isOptional())); condition.put(STR, getXmlRpcWorkflowConditionConfig(c.getCondConfig())); return condition; }","old_code_raw":"public static Hashtable getXmlRpcWorkflowCondition(WorkflowCondition c) {\n    Hashtable condition = new Hashtable();\n    condition.put(STR, c.getConditionInstanceClassName());\n    condition.put(STR, c.getConditionId());\n    condition.put(STR, c.getConditionName());\n    condition.put(STR, String.valueOf(c.getOrder()));\n    condition.put(STR, String.valueOf(c.getTimeoutSeconds()));\n    condition.put(STR, String.valueOf(c.isOptional()));\n    condition.put(STR, getXmlRpcWorkflowConditionConfig(c.getCondConfig()));\n    return condition;\n}","new_comment_raw":"@return an XML-RPC {@link HashMap} representation of the {@link WorkflowCondition} to send over the wire.","old_comment_raw":"@return an XML-RPC {@link Hashtable} representation of the {@link WorkflowCondition} to send over the wire.","label":1,"pre_label":0,"AST_level":6,"line_counts":11,"new_code_token_num":112},{"new_code_raw":"public static String formatObjectKey(String key) { int index = key == null ? -NUM : key.indexOf(STR); if (index >= NUM) { return key.substring(index + NUM); } return formatKey(key, false, true, false, true); }","old_code_raw":"public static String formatObjectKey(String key) {\n    int index = key == null ? -NUM : key.indexOf(STR);\n    if (index >= NUM) {\n        return key.substring(index + NUM);\n    }\n    return formatKey(key, false, false, false, true);\n}","new_comment_raw":"@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = true, formatHyphen = false, firstCase = true","old_comment_raw":"@return {@link #formatKey(String, boolean, boolean, boolean)} formatColon = false, formatAt = false, formatHyphen = false, firstCase = true","label":1,"pre_label":0,"AST_level":8,"line_counts":7,"new_code_token_num":54},{"new_code_raw":"static public String proxy(final String href) { final int hash = href.indexOf(STR); return -NUM == hash ? href : href.substring(NUM, hash); }","old_code_raw":"static public String proxy(final String uri) {\n    final int fragmentStart = uri.indexOf(STR);\n    return -NUM == fragmentStart ? uri : uri.substring(NUM, fragmentStart);\n}","new_comment_raw":"@return <code>href<\/code>, stripped of any <code>fragment<\/code>","old_comment_raw":"@return <code>uri<\/code>, stripped of any <code>fragment<\/code>","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":35},{"new_code_raw":"public SystemUsage getUsageManager() { return this.usageManager; }","old_code_raw":"    public UsageManager getUsageManager() {\n        return this.usageManager;\n    }\n","new_comment_raw":"@return the usageManager","old_comment_raw":"@return the usageManager","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":11},{"new_code_raw":"public Class getASTNodeType(int tokenType) { switch ( tokenType ) { case SELECT: case QUERY: return QueryNode.class; case UPDATE: return UpdateStatement.class; case DELETE: return DeleteStatement.class; case INSERT: return InsertStatement.class; case INTO: return IntoClause.class; case FROM: return FromClause.class; case FROM_FRAGMENT: return FromElement.class; case IMPLIED_FROM: return ImpliedFromElement.class; case DOT: return DotNode.class; case INDEX_OP: return IndexNode.class; \/\/ Alias references and identifiers use the same node class. case ALIAS_REF: case IDENT: return IdentNode.class; case SQL_TOKEN: return SqlFragment.class; case METHOD_CALL: return MethodNode.class; case ELEMENTS: case INDICES: return CollectionFunction.class; case SELECT_CLAUSE: return SelectClause.class; case SELECT_EXPR: return SelectExpressionImpl.class; case AGGREGATE: return AggregateNode.class; case COUNT: return CountNode.class; case CONSTRUCTOR: return ConstructorNode.class; case NUM_INT: case NUM_FLOAT: case NUM_LONG: case NUM_DOUBLE: case QUOTED_STRING: return LiteralNode.class; case TRUE: case FALSE: return BooleanLiteralNode.class; case JAVA_CONSTANT: return JavaConstantNode.class; case ORDER: return OrderByClause.class; case PLUS: case MINUS: case STAR: case DIV: return BinaryArithmeticOperatorNode.class; case UNARY_MINUS: case UNARY_PLUS: return UnaryArithmeticNode.class; case CASE2: return Case2Node.class; case CASE: return CaseNode.class; case PARAM: case NAMED_PARAM: return ParameterNode.class; case EQ: case NE: case LT: case GT: case LE: case GE: case LIKE: case NOT_LIKE: return BinaryLogicOperatorNode.class; case IN: case NOT_IN: return InLogicOperatorNode.class; case BETWEEN: case NOT_BETWEEN: return BetweenOperatorNode.class; case IS_NULL: return IsNullLogicOperatorNode.class; case IS_NOT_NULL: return IsNotNullLogicOperatorNode.class; case EXISTS: return UnaryLogicOperatorNode.class; case KEY: { return MapKeyNode.class; } case VALUE: { return MapValueNode.class; } case ENTRY: { return MapEntryNode.class; } default: return SqlNode.class; } \/\/ switch }","old_code_raw":"\tpublic Class getASTNodeType(int tokenType) {\n\t\tswitch ( tokenType ) {\n\t\t\tcase SELECT:\n\t\t\tcase QUERY:\n\t\t\t\treturn QueryNode.class;\n\t\t\tcase UPDATE:\n\t\t\t\treturn UpdateStatement.class;\n\t\t\tcase DELETE:\n\t\t\t\treturn DeleteStatement.class;\n\t\t\tcase INSERT:\n\t\t\t\treturn InsertStatement.class;\n\t\t\tcase INTO:\n\t\t\t\treturn IntoClause.class;\n\t\t\tcase FROM:\n\t\t\t\treturn FromClause.class;\n\t\t\tcase FROM_FRAGMENT:\n\t\t\t\treturn FromElement.class;\n\t\t\tcase IMPLIED_FROM:\n\t\t\t\treturn ImpliedFromElement.class;\n\t\t\tcase DOT:\n\t\t\t\treturn DotNode.class;\n\t\t\tcase INDEX_OP:\n\t\t\t\treturn IndexNode.class;\n\t\t\t\t\/\/ Alias references and identifiers use the same node class.\n\t\t\tcase ALIAS_REF:\n\t\t\tcase IDENT:\n\t\t\t\treturn IdentNode.class;\n\t\t\tcase SQL_TOKEN:\n\t\t\t\treturn SqlFragment.class;\n\t\t\tcase METHOD_CALL:\n\t\t\t\treturn MethodNode.class;\n\t\t\tcase ELEMENTS:\n\t\t\tcase INDICES:\n\t\t\t\treturn CollectionFunction.class;\n\t\t\tcase SELECT_CLAUSE:\n\t\t\t\treturn SelectClause.class;\n\t\t\tcase SELECT_EXPR:\n\t\t\t\treturn SelectExpressionImpl.class;\n\t\t\tcase AGGREGATE:\n\t\t\t\treturn AggregateNode.class;\n\t\t\tcase COUNT:\n\t\t\t\treturn CountNode.class;\n\t\t\tcase CONSTRUCTOR:\n\t\t\t\treturn ConstructorNode.class;\n\t\t\tcase NUM_INT:\n\t\t\tcase NUM_FLOAT:\n\t\t\tcase NUM_LONG:\n\t\t\tcase NUM_DOUBLE:\n\t\t\tcase QUOTED_STRING:\n\t\t\t\treturn LiteralNode.class;\n\t\t\tcase TRUE:\n\t\t\tcase FALSE:\n\t\t\t\treturn BooleanLiteralNode.class;\n\t\t\tcase JAVA_CONSTANT:\n\t\t\t\treturn JavaConstantNode.class;\n\t\t\tcase ORDER:\n\t\t\t\treturn OrderByClause.class;\n\t\t\tcase PLUS:\n\t\t\tcase MINUS:\n\t\t\tcase STAR:\n\t\t\tcase DIV:\n\t\t\t\treturn BinaryArithmeticOperatorNode.class;\n\t\t\tcase UNARY_MINUS:\n\t\t\tcase UNARY_PLUS:\n\t\t\t\treturn UnaryArithmeticNode.class;\n\t\t\tcase CASE2:\n\t\t\t\treturn Case2Node.class;\n\t\t\tcase CASE:\n\t\t\t\treturn CaseNode.class;\n\t\t\tcase PARAM:\n\t\t\tcase NAMED_PARAM:\n\t\t\t\treturn ParameterNode.class;\n\t\t\tcase EQ:\n\t\t\tcase NE:\n\t\t\tcase LT:\n\t\t\tcase GT:\n\t\t\tcase LE:\n\t\t\tcase GE:\n\t\t\tcase LIKE:\n\t\t\tcase NOT_LIKE:\n\t\t\t\treturn BinaryLogicOperatorNode.class;\n\t\t\tcase IN:\n\t\t\tcase NOT_IN:\n\t\t\t\treturn InLogicOperatorNode.class;\n\t\t\tcase BETWEEN:\n\t\t\tcase NOT_BETWEEN:\n\t\t\t\treturn BetweenOperatorNode.class;\n\t\t\tcase IS_NULL:\n\t\t\t\treturn IsNullLogicOperatorNode.class;\n\t\t\tcase IS_NOT_NULL:\n\t\t\t\treturn IsNotNullLogicOperatorNode.class;\n\t\t\tcase EXISTS:\n\t\t\t\treturn UnaryLogicOperatorNode.class;\n\t\t\tdefault:\n\t\t\t\treturn SqlNode.class;\n\t\t} \/\/ switch\n\t}\n","new_comment_raw":"@return Class - The AST node class to instantiate.","old_comment_raw":"@return Class - The AST node class to instantiate.","label":0,"pre_label":1,"AST_level":8,"line_counts":107,"new_code_token_num":366},{"new_code_raw":"protected Object convertTimestampToEpochMicros(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return MicroTimestamp.toEpochMicros(data, adjuster); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimestampToEpochMicros(Column column, Field fieldDefn, Object data) {\n        if (data == null) {\n            data = fieldDefn.schema().defaultValue();\n        }\n        if (data == null) {\n            if (column.isOptional()) return null;\n            return 0L; \/\/ return epoch\n        }\n        try {\n            return MicroTimestamp.toEpochMicros(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","label":0,"pre_label":1,"AST_level":8,"line_counts":15,"new_code_token_num":84},{"new_code_raw":"public Map<String, Set<String>> getAllGraylogDeflectorIndices() { final Map<String, Set<String>> indexNamesAndAliases = indices.getIndexNamesAndAliases(getDeflectorWildcard()); return indexNamesAndAliases.entrySet().stream().filter(e -> isGraylogDeflectorIndex(e.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)); }","old_code_raw":"public Map<String, IndexStats> getAllGraylogDeflectorIndices() {\n    final ImmutableMap.Builder<String, IndexStats> result = ImmutableMap.builder();\n    for (Map.Entry<String, IndexStats> e : indices.getAll().entrySet()) {\n        final String name = e.getKey();\n        if (isGraylogDeflectorIndex(name)) {\n            result.put(name, e.getValue());\n        }\n    }\n    return result.build();\n}","new_comment_raw":"@return index name and aliases of that index","old_comment_raw":"@return index name and index stats","label":1,"pre_label":0,"AST_level":8,"line_counts":4,"new_code_token_num":65},{"new_code_raw":"public int compareTo(IndexedWord w) { if (this.equals(IndexedWord.NO_WORD)) { if (w.equals(IndexedWord.NO_WORD)) { return 0; } else { return -1; } } if (w.equals(IndexedWord.NO_WORD)) { return 1; } \/\/ Override the default comparator if pseudo-positions are set. \/\/ This is needed for splicing trees together awkwardly in OpenIE. if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) { double val = this.pseudoPosition() - w.pseudoPosition(); if (val < 0) { return -1; } if (val > 0) { return 1; } else { return 0; } } \/\/ Otherwise, compare using the normal doc\/sentence\/token index hierarchy String docID = this.getString(CoreAnnotations.DocIDAnnotation.class); int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class)); if (docComp != 0) return docComp; int sentComp = Integer.compare(sentIndex(), w.sentIndex()); if (sentComp != 0) return sentComp; int indexComp = Integer.compare(index(), w.index()); if (indexComp != 0) return indexComp; return Integer.compare(copyCount(), w.copyCount()); }","old_code_raw":"  public int compareTo(IndexedWord w) {\n    if (this.equals(IndexedWord.NO_WORD)) {\n      if (w.equals(IndexedWord.NO_WORD)) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n    if (w.equals(IndexedWord.NO_WORD)) {\n      return 1;\n    }\n\n    \/\/ Override the default comparator if pseudo-positions are set.\n    \/\/ This is needed for splicing trees together awkwardly in OpenIE.\n    if (!Double.isNaN(w.pseudoPosition) || !Double.isNaN(this.pseudoPosition)) {\n      double val = this.pseudoPosition() - w.pseudoPosition();\n      if (val < 0) { return -1; }\n      if (val > 0) { return 1; }\n      else { return 0; }\n    }\n\n    \/\/ Otherwise, compare using the normal doc\/sentence\/token index hierarchy\n    String docID = this.getString(CoreAnnotations.DocIDAnnotation.class);\n    int docComp = docID.compareTo(w.getString(CoreAnnotations.DocIDAnnotation.class));\n    if (docComp != 0) return docComp;\n\n    int sentComp = sentIndex() - w.sentIndex();\n    if (sentComp != 0) return sentComp;\n\n    int indexComp = index() - w.index();\n    if (indexComp != 0) return indexComp;\n\n    return copyCount() - w.copyCount();\n  }\n","new_comment_raw":"@return Whether this is less than w or not in the ordering","old_comment_raw":"@return Whether this is less than w or not in the ordering","label":0,"pre_label":1,"AST_level":9,"line_counts":35,"new_code_token_num":249},{"new_code_raw":"public String getMergePolicy() { return mergePolicyConfig.getPolicy(); }","old_code_raw":"public String getMergePolicy() {\n    return mergePolicy;\n}","new_comment_raw":"@return the merge policy classname","old_comment_raw":"@return the updated map configuration","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public NumberExpression<T> negate(){ if (negation == null){ negation = multiply(-1); } return negation; }","old_code_raw":"    public NumberExpression<D> negate(){\n        if (negation == null){\n            negation = multiply(-1);\n        }\n        return negation;\n    }\n","new_comment_raw":"@return this -1","old_comment_raw":"@return this -1","label":0,"pre_label":1,"AST_level":8,"line_counts":7,"new_code_token_num":25},{"new_code_raw":"public SubselectFetch getSubselect(EntityKey key) { return subselectsByEntityKey.get( key ); }","old_code_raw":"\tpublic SubselectFetch getSubselect(EntityKey key) {\n\t\treturn (SubselectFetch) subselectsByEntityKey.get(key);\n\t}\n","new_comment_raw":"@return The fetch descriptor; may return null if no subselect fetch queued for this entity key.","old_comment_raw":"@return The fetch descriptor; may return null if no subselect fetch queued for this entity key.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":16},{"new_code_raw":"public int getMonth() { return date.getMonthValue(); }","old_code_raw":"public int getMonth() {\n    return month;\n}","new_comment_raw":"@return the month of the year as defined by {@linkplain LocalDate}","old_comment_raw":"@return the month of the year as defined by {@linkplain Calendar}","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public String getStatus() { if (status == null) { return null; } return status.value(); }","old_code_raw":"  public StatusEnum getStatus() {\n    return status;\n  }\n","new_comment_raw":"@return status","old_comment_raw":"@return status","label":0,"pre_label":1,"AST_level":6,"line_counts":7,"new_code_token_num":23},{"new_code_raw":"protected Object convertDecimal(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return new BigDecimal(0); } BigDecimal decimal = null; if (data instanceof BigDecimal) decimal = (BigDecimal) data; else if (data instanceof Boolean) decimal = new BigDecimal(((Boolean) data).booleanValue() ? 1 : 0); else if (data instanceof Short) decimal = new BigDecimal(((Short) data).intValue()); else if (data instanceof Integer) decimal = new BigDecimal(((Integer) data).intValue()); else if (data instanceof Long) decimal = BigDecimal.valueOf(((Long) data).longValue()); else if (data instanceof Float) decimal = BigDecimal.valueOf(((Float) data).doubleValue()); else if (data instanceof Double) decimal = BigDecimal.valueOf(((Double) data).doubleValue()); else { return handleUnknownData(column, fieldDefn, data); } return decimal; }","old_code_raw":"    protected Object convertDecimal(Column column, Field fieldDefn, Object data) {\n        if (data == null) return null;\n        BigDecimal decimal = null;\n        if (data instanceof BigDecimal)\n            decimal = (BigDecimal) data;\n        else if (data instanceof Boolean)\n            decimal = new BigDecimal(((Boolean) data).booleanValue() ? 1 : 0);\n        else if (data instanceof Short)\n            decimal = new BigDecimal(((Short) data).intValue());\n        else if (data instanceof Integer)\n            decimal = new BigDecimal(((Integer) data).intValue());\n        else if (data instanceof Long)\n            decimal = BigDecimal.valueOf(((Long) data).longValue());\n        else if (data instanceof Float)\n            decimal = BigDecimal.valueOf(((Float) data).doubleValue());\n        else if (data instanceof Double)\n            decimal = BigDecimal.valueOf(((Double) data).doubleValue());\n        else {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n        return decimal;\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":14,"line_counts":29,"new_code_token_num":223},{"new_code_raw":"public Map<String, InternalPortletPreference> getStoredPreferences(PortletWindow portletWindow, PortletRequest request) throws PortletContainerException { String key = getFormattedKey(portletWindow, request); Map<String, InternalPortletPreference> preferences = storage.get(key); if (preferences == null) { if (LOG.isDebugEnabled()) { LOG.debug(STR + key); } return Collections.emptyMap(); } else { if (LOG.isDebugEnabled()) { LOG.debug(STR + preferences.size() + STR); } return clonePreferences(preferences); } }","old_code_raw":"public InternalPortletPreference[] getStoredPreferences(PortletWindow portletWindow, PortletRequest request) throws PortletContainerException {\n    String key = getFormattedKey(portletWindow, request);\n    InternalPortletPreference[] preferences = storage.get(key);\n    if (preferences == null) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(STR + key);\n        }\n        return new InternalPortletPreference[NUM];\n    } else {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(STR + preferences.length + STR);\n        }\n        return clonePreferences(preferences);\n    }\n}","new_comment_raw":"@return a copy of the stored portlet preferences map.","old_comment_raw":"@return a copy of the stored portlet preferences array.","label":1,"pre_label":0,"AST_level":11,"line_counts":15,"new_code_token_num":98},{"new_code_raw":"private long now() { return SystemClock.uptimeMillis(); }","old_code_raw":"private long now() {\n    return mMonotonicClock == null ? SystemClock.uptimeMillis() : mMonotonicClock.now();\n}","new_comment_raw":"@return the current uptime in ms","old_comment_raw":"@return the current time in ms","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public static SocketInputWrapper getInputStream(Socket socket, long timeout) throws IOException { InputStream stm = (socket.getChannel() == null) ? socket.getInputStream() : new SocketInputStream(socket); SocketInputWrapper w = new SocketInputWrapper(socket, stm); w.setTimeout(timeout); return w; }","old_code_raw":"public static InputStream getInputStream(Socket socket, long timeout) throws IOException {\n    return (socket.getChannel() == null) ? socket.getInputStream() : new SocketInputStream(socket, timeout);\n}","new_comment_raw":"@return SocketInputWrapper for reading from the socket.","old_comment_raw":"@return InputStream for reading from the socket.","label":1,"pre_label":0,"AST_level":7,"line_counts":6,"new_code_token_num":55},{"new_code_raw":"protected Class<T> getConfigurationClass() { return (Class<T>) Generics.getTypeParameter(getClass(), Configuration.class); }","old_code_raw":"    protected Class<T> getConfigurationClass() {\n        return (Class<T>) Generics.getTypeParameter(getClass());\n    }\n","new_comment_raw":"@return the  Class of the configuration type","old_comment_raw":"@return the Class of the configuration type","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public Report findOneThrowExceptionIfNotFound(final Long id) { return this.reportRepository.findById(id) .orElseThrow(() -> new ReportNotFoundException(id)); }","old_code_raw":"    public Report findOneThrowExceptionIfNotFound(final Long id) {\n        final Report report = this.reportRepository.findOne(id);\n        \n        if (report == null) {\n            throw new ReportNotFoundException(id);\n        }\n        \n        return report;\n    }\n","new_comment_raw":"@return  Report object","old_comment_raw":"@return Report object","label":0,"pre_label":1,"AST_level":8,"line_counts":5,"new_code_token_num":29},{"new_code_raw":"public boolean isEmpty() { return pendingCount <= NUM; }","old_code_raw":"public boolean isEmpty() {\n    return empty;\n}","new_comment_raw":"@return true if there are no pendingCount messages","old_comment_raw":"@return true if there are no pending messages","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":11},{"new_code_raw":"public OfflinePlayer asOfflinePlayer() { return Bukkit.getOfflinePlayer(raw); }","old_code_raw":"public OfflinePlayer asOfflinePlayer() {\n    return Bukkit.getOfflinePlayer(arg);\n}","new_comment_raw":"@return The offline player by the name of the raw raw","old_comment_raw":"@return The offline player by the name of the raw arg","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":14},{"new_code_raw":"private static Class getVMPrimitiveType(final String name) { return VM_PRIMITIVES.get(name); }","old_code_raw":"    private static Class getVMPrimitiveType(final String name) {\n        return (Class) VM_PRIMITIVES.get(name);\n    }\n","new_comment_raw":"@return Primitive type or null.","old_comment_raw":"@return Primitive type or null.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":18},{"new_code_raw":"public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) { int columnType = (int) datumMessage.getColumnType(); switch (columnType) { case PgOid.BOOL: return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null; case PgOid.INT2: case PgOid.INT4: return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null; case PgOid.INT8: case PgOid.OID: case PgOid.MONEY: return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null; case PgOid.FLOAT4: return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null; case PgOid.FLOAT8: return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; case PgOid.NUMERIC: if (datumMessage.hasDatumDouble()) { return datumMessage.getDatumDouble(); } else if (datumMessage.hasDatumString()) { final String s = datumMessage.getDatumString(); final SpecialValue v = PostgresValueConverter.toSpecialValue(s); return v != null ? v : new BigDecimal(s); } return null; case PgOid.CHAR: case PgOid.VARCHAR: case PgOid.BPCHAR: case PgOid.TEXT: case PgOid.JSON: case PgOid.JSONB_OID: case PgOid.XML: case PgOid.UUID: case PgOid.BIT: case PgOid.VARBIT: return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null; case PgOid.DATE: return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null; case PgOid.TIMESTAMP: case PgOid.TIMESTAMPTZ: case PgOid.TIME: if (!datumMessage.hasDatumInt64()) { return null; } \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch \/\/ but we'll convert them to nanos which is the smallest unit return TimeUnit.NANOSECONDS.convert(datumMessage.getDatumInt64(), TimeUnit.MICROSECONDS); case PgOid.TIMETZ: if (!datumMessage.hasDatumDouble()) { return null; } \/\/ the value is sent as a double microseconds, convert to nano return BigDecimal.valueOf(datumMessage.getDatumDouble() * 1000).longValue(); case PgOid.INTERVAL: \/\/ these are sent as doubles by the plugin since their storage is larger than 8 bytes return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null; \/\/ the plugin will send back a TZ formatted string case PgOid.BYTEA: return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null; case PgOid.POINT: { PgProto.Point datumPoint = datumMessage.getDatumPoint(); return new PGpoint(datumPoint.getX(), datumPoint.getY()); } case PgOid.TSTZRANGE_OID: return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(\"UTF-8\")) : null; case PgOid.INT2_ARRAY: case PgOid.INT4_ARRAY: case PgOid.INT8_ARRAY: case PgOid.TEXT_ARRAY: case PgOid.NUMERIC_ARRAY: case PgOid.FLOAT4_ARRAY: case PgOid.FLOAT8_ARRAY: case PgOid.BOOL_ARRAY: case PgOid.DATE_ARRAY: case PgOid.TIME_ARRAY: case PgOid.TIMETZ_ARRAY: case PgOid.TIMESTAMP_ARRAY: case PgOid.TIMESTAMPTZ_ARRAY: case PgOid.BYTEA_ARRAY: case PgOid.VARCHAR_ARRAY: case PgOid.OID_ARRAY: case PgOid.BPCHAR_ARRAY: case PgOid.MONEY_ARRAY: case PgOid.NAME_ARRAY: case PgOid.INTERVAL_ARRAY: case PgOid.CHAR_ARRAY: case PgOid.VARBIT_ARRAY: case PgOid.UUID_ARRAY: case PgOid.XML_ARRAY: case PgOid.POINT_ARRAY: case PgOid.JSONB_ARRAY: case PgOid.JSON_ARRAY: case PgOid.REF_CURSOR_ARRAY: return getArray(datumMessage, connection, columnType); case PgOid.UNSPECIFIED: return null; default: PostgresType type = typeRegistry.get(columnType); if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() ) { return datumMessage.getDatumBytes().toByteArray(); } if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() ) { return getArray(datumMessage, connection, columnType); } \/\/ unknown datatype is sent by decoder as binary value if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) { return datumMessage.getDatumBytes().toByteArray(); } return null; } }","old_code_raw":"    public Object getValue(PgProto.DatumMessage datumMessage, PgConnectionSupplier connection, boolean includeUnknownDatatypes) {\n        int columnType = (int) datumMessage.getColumnType();\n        switch (columnType) {\n            case PgOid.BOOL:\n                return datumMessage.hasDatumBool() ? datumMessage.getDatumBool() : null;\n            case PgOid.INT2:\n            case PgOid.INT4:\n                return datumMessage.hasDatumInt32() ? datumMessage.getDatumInt32() : null;\n            case PgOid.INT8:\n            case PgOid.OID:\n            case PgOid.MONEY:\n                return datumMessage.hasDatumInt64() ? datumMessage.getDatumInt64() : null;\n            case PgOid.FLOAT4:\n                return datumMessage.hasDatumFloat()? datumMessage.getDatumFloat() : null;\n            case PgOid.FLOAT8:\n            case PgOid.NUMERIC:\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            case PgOid.CHAR:\n            case PgOid.VARCHAR:\n            case PgOid.BPCHAR:\n            case PgOid.TEXT:\n            case PgOid.JSON:\n            case PgOid.JSONB_OID:\n            case PgOid.XML:\n            case PgOid.UUID:\n            case PgOid.BIT:\n            case PgOid.VARBIT:\n                return datumMessage.hasDatumString() ? datumMessage.getDatumString() : null;\n            case PgOid.DATE:\n                return datumMessage.hasDatumInt32() ? (long) datumMessage.getDatumInt32() : null;\n            case PgOid.TIMESTAMP:\n            case PgOid.TIMESTAMPTZ:\n            case PgOid.TIME:\n                if (!datumMessage.hasDatumInt64()) {\n                    return null;\n                }\n                \/\/ these types are sent by the plugin as LONG - microseconds since Unix Epoch\n                \/\/ but we'll convert them to nanos which is the smallest unit\n                return TimeUnit.NANOSECONDS.convert(datumMessage.getDatumInt64(), TimeUnit.MICROSECONDS);\n            case PgOid.TIMETZ:\n                if (!datumMessage.hasDatumDouble()) {\n                    return null;\n                }\n                \/\/ the value is sent as a double microseconds, convert to nano\n                return BigDecimal.valueOf(datumMessage.getDatumDouble() * 1000).longValue();\n            case PgOid.INTERVAL:\n                \/\/ these are sent as doubles by the plugin since their storage is larger than 8 bytes\n                return datumMessage.hasDatumDouble() ? datumMessage.getDatumDouble() : null;\n            \/\/ the plugin will send back a TZ formatted string\n            case PgOid.BYTEA:\n                return datumMessage.hasDatumBytes() ? datumMessage.getDatumBytes().toByteArray() : null;\n            case PgOid.POINT: {\n                PgProto.Point datumPoint = datumMessage.getDatumPoint();\n                return new PGpoint(datumPoint.getX(), datumPoint.getY());\n            }\n            case PgOid.TSTZRANGE_OID:\n                return datumMessage.hasDatumBytes() ? new String(datumMessage.getDatumBytes().toByteArray(), Charset.forName(\"UTF-8\")) : null;\n            case PgOid.INT2_ARRAY:\n            case PgOid.INT4_ARRAY:\n            case PgOid.INT8_ARRAY:\n            case PgOid.TEXT_ARRAY:\n            case PgOid.NUMERIC_ARRAY:\n            case PgOid.FLOAT4_ARRAY:\n            case PgOid.FLOAT8_ARRAY:\n            case PgOid.BOOL_ARRAY:\n            case PgOid.DATE_ARRAY:\n            case PgOid.TIME_ARRAY:\n            case PgOid.TIMETZ_ARRAY:\n            case PgOid.TIMESTAMP_ARRAY:\n            case PgOid.TIMESTAMPTZ_ARRAY:\n            case PgOid.BYTEA_ARRAY:\n            case PgOid.VARCHAR_ARRAY:\n            case PgOid.OID_ARRAY:\n            case PgOid.BPCHAR_ARRAY:\n            case PgOid.MONEY_ARRAY:\n            case PgOid.NAME_ARRAY:\n            case PgOid.INTERVAL_ARRAY:\n            case PgOid.CHAR_ARRAY:\n            case PgOid.VARBIT_ARRAY:\n            case PgOid.UUID_ARRAY:\n            case PgOid.XML_ARRAY:\n            case PgOid.POINT_ARRAY:\n            case PgOid.JSONB_ARRAY:\n            case PgOid.JSON_ARRAY:\n            case PgOid.REF_CURSOR_ARRAY:\n                return getArray(datumMessage, connection, columnType);\n\n            case PgOid.UNSPECIFIED:\n                return null;\n\n            default:\n                PostgresType type = typeRegistry.get(columnType);\n                if (type.getOid() == typeRegistry.geometryOid() || type.getOid() == typeRegistry.geographyOid() ) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n                if (type.getOid() == typeRegistry.geometryArrayOid() || type.getOid() == typeRegistry.geographyArrayOid() ) {\n                    return getArray(datumMessage, connection, columnType);\n                }\n\n                \/\/ unknown datatype is sent by decoder as binary value\n                if (includeUnknownDatatypes && datumMessage.hasDatumBytes()) {\n                    return datumMessage.getDatumBytes().toByteArray();\n                }\n\n                return null;\n        }\n    }\n","new_comment_raw":"@return the value; may be null","old_comment_raw":"@return the value; may be null","label":0,"pre_label":1,"AST_level":11,"line_counts":117,"new_code_token_num":748},{"new_code_raw":"private Object getIdFromParameter() { String parameter = FacesUtils.getParameter(ID); if (parameter == null || parameter.isEmpty()) { return null; } try { Class idType = EntityUtils.getIdType(entityClass); if (idType.equals(Long.class)) { return Long.parseLong(StringUtils.getOnlyIntegerNumbers(parameter)); } else if (idType.equals(Integer.class)) { return Integer.parseInt(StringUtils.getOnlyIntegerNumbers(parameter)); } else { logger.log(Level.SEVERE, STR, new Object[] { idType.getName(), entityClass.getName() }); return null; } } catch (NumberFormatException ex) { return null; } }","old_code_raw":"private Long getIdFromParameter() {\n    String parameter = FacesUtils.getParameter(ID);\n    if (parameter == null || parameter.isEmpty()) {\n        return null;\n    }\n    try {\n        return Long.parseLong(StringUtils.getOnlyIntegerNumbers(parameter));\n    } catch (NumberFormatException ex) {\n        return null;\n    }\n}","new_comment_raw":"@return A Number instance of id passed in parameter","old_comment_raw":"@return A Long instance of id passed in parameter","label":1,"pre_label":0,"AST_level":11,"line_counts":19,"new_code_token_num":128},{"new_code_raw":"public EigenbaseException newValidationSignatureError() { return validator.newValidationError(call, RESOURCE.canNotApplyOp2Type(getOperator().getName(), call.getCallSignature(validator, scope), getOperator().getAllowedSignatures())); }","old_code_raw":"  public EigenbaseException newValidationSignatureError() {\n    return validator.newValidationError(\n        call,\n        EigenbaseResource.instance().CanNotApplyOp2Type.ex(\n            getOperator().getName(),\n            call.getCallSignature(validator, scope),\n            getOperator().getAllowedSignatures()));\n  }\n","new_comment_raw":"@return signature exception","old_comment_raw":"@return signature exception","label":0,"pre_label":1,"AST_level":7,"line_counts":7,"new_code_token_num":40},{"new_code_raw":"public boolean isBodyAllowed() { return Arrays.asList(\"PUT\", \"PATCH\", \"POST\").contains(httpMethod.toUpperCase(Locale.ROOT)); }","old_code_raw":"    public boolean isBodyAllowed() {\n        return Arrays.asList(\"PUT\", \"PATCH\", \"POST\").contains(httpMethod.toUpperCase());\n    }\n","new_comment_raw":"@return true request method is PUT, PATCH or POST; false otherwise","old_comment_raw":"@return true request method is PUT, PATCH or POST; false otherwise","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":33},{"new_code_raw":"public Object next() throws java.io.IOException { int zzInput; int zzAction; \/\/ cached fields: int zzCurrentPosL; int zzMarkedPosL; int zzEndReadL = zzEndRead; char [] zzBufferL = zzBuffer; char [] zzCMapL = ZZ_CMAP; int [] zzTransL = ZZ_TRANS; int [] zzRowMapL = ZZ_ROWMAP; int [] zzAttrL = ZZ_ATTRIBUTE; while (true) { zzMarkedPosL = zzMarkedPos; yychar+= zzMarkedPosL-zzStartRead; zzAction = -1; zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL; zzState = ZZ_LEXSTATE[zzLexicalState]; \/\/ set up zzAction for empty match case: int zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; } zzForAction: { while (true) { if (zzCurrentPosL < zzEndReadL) { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } else if (zzAtEOF) { zzInput = YYEOF; break zzForAction; } else { \/\/ store back cached positions zzCurrentPos = zzCurrentPosL; zzMarkedPos = zzMarkedPosL; boolean eof = zzRefill(); \/\/ get translated positions and possibly new buffer zzCurrentPosL = zzCurrentPos; zzMarkedPosL = zzMarkedPos; zzBufferL = zzBuffer; zzEndReadL = zzEndRead; if (eof) { zzInput = YYEOF; break zzForAction; } else { zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL); zzCurrentPosL += Character.charCount(zzInput); } } int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ]; if (zzNext == -1) break zzForAction; zzState = zzNext; zzAttributes = zzAttrL[zzState]; if ( (zzAttributes & 1) == 1 ) { zzAction = zzState; zzMarkedPosL = zzCurrentPosL; if ( (zzAttributes & 8) == 8 ) break zzForAction; } } } \/\/ store back cached position zzMarkedPos = zzMarkedPosL; if (zzInput == YYEOF && zzStartRead == zzCurrentPos) { zzAtEOF = true; { if (invertible) { prevWordAfter.append(yytext()); String str = prevWordAfter.toString(); prevWordAfter.setLength(0); prevWord.set(CoreAnnotations.AfterAnnotation.class, str); } return null; } } else { switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) { case 1: { String str = yytext(); int first = str.codePointAt(0); String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first)); switch (untokenizable) { case NONE_DELETE: if (invertible) { prevWordAfter.append(str); } break; case FIRST_DELETE: if (invertible) { prevWordAfter.append(str); } if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } break; case ALL_DELETE: if (invertible) { prevWordAfter.append(str); } logger.warning(msg); this.seenUntokenizableCharacter = true; break; case NONE_KEEP: return getNext(); case FIRST_KEEP: if ( ! this.seenUntokenizableCharacter) { logger.warning(msg); this.seenUntokenizableCharacter = true; } return getNext(); case ALL_KEEP: logger.warning(msg); this.seenUntokenizableCharacter = true; return getNext(); } } case 67: break; case 2: { return getNext(\"<\", yytext()); } case 68: break; case 3: { return getNext(); } case 69: break; case 4: { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 70: break; case 5: { if (tokenizeNLs) { return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns } else if (invertible) { prevWordAfter.append(yytext()); } } case 71: break; case 6: { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 72: break; case 7: { if (invertible) { prevWordAfter.append(yytext()); } } case 73: break; case 8: { return handleQuotes(yytext(), false); } case 74: break; case 9: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 75: break; case 10: { return getNext(\">\", yytext()); } case 76: break; case 11: { if (ptb3Dashes) { return getNext(ptbmdash, yytext()); } else { return getNext(); } } case 77: break; case 12: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 78: break; case 13: { return handleEllipsis(yytext()); } case 79: break; case 14: { return normalizeFractions(yytext()); } case 80: break; case 15: { if (normalizeCurrency) { return getNext(normalizeCurrency(yytext()), yytext()); } else { return getNext(minimallyNormalizeCurrency(yytext()), yytext()); } } case 81: break; case 16: { if (normalizeOtherBrackets) { return getNext(closebrace, yytext()); } else { return getNext(); } } case 82: break; case 17: { if (normalizeOtherBrackets) { return getNext(\"-RSB-\", yytext()); } else { return getNext(); } } case 83: break; case 18: { if (normalizeParentheses) { return getNext(openparen, yytext()); } else { return getNext(); } } case 84: break; case 19: { if (normalizeParentheses) { return getNext(closeparen, yytext()); } else { return getNext(); } } case 85: break; case 20: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '*'), yytext()); } else { return getNext(); } } case 86: break; case 21: { if (normalizeOtherBrackets) { return getNext(openbrace, yytext()); } else { return getNext(); } } case 87: break; case 22: { if (normalizeOtherBrackets) { return getNext(\"-LSB-\", yytext()); } else { return getNext(); } } case 88: break; case 23: { if (invertible) { prevWordAfter.append(yytext()); } } case 89: break; case 24: { return getNext(\"\\u2022\", yytext()); } case 90: break; case 25: { return getNext(\"\\u2122\", yytext()); } case 91: break; case 26: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 15; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 92: break; case 27: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(); } case 93: break; case 28: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), true); } case 94: break; case 29: { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 95: break; case 30: { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 96: break; case 31: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 3; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 4; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String origTxt = yytext(); String tmp = removeSoftHyphens(origTxt); if (americanize) { tmp = Americanize.americanize(tmp); } return getNext(tmp, origTxt); } case 97: break; case 32: { if (escapeForwardSlashAsterisk) { return getNext(delimit(yytext(), '\/'), yytext()); } else { return getNext(); } } case 98: break; case 33: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNext(removeSoftHyphens(yytext()), yytext()); } case 99: break; case 34: { \/\/ this one should only match if we're basically at the end of file \/\/ since the last one matches two things, even newlines (if not tokenize per line) String s; if (strictTreebank3 && ! \"U.S.\".equals(yytext())) { yypushback(1); \/\/ return a period for next time s = yytext(); } else { s = yytext(); yypushback(1); \/\/ return a period for next time } return getNext(s, yytext()); } case 100: break; case 35: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { String txt = yytext(); String origText = txt; if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, origText); } case 101: break; case 36: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1); { \/* invert quote - often but not always right *\/ return handleQuotes(yytext(), true); } case 102: break; case 37: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return handleQuotes(yytext(), false); } case 103: break; case 38: { return getNext(removeSoftHyphens(yytext()), yytext()); } case 104: break; case 39: { String txt = yytext(); \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space... if (strictTreebank3) { int spaceIndex = indexOfSpace(txt); if (spaceIndex >= 0) { yypushback(txt.length() - spaceIndex); String newText = yytext(); return getNext(newText, newText); } } if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, txt); } case 105: break; case 40: { return getNormalizedAmpNext(); } case 106: break; case 41: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } return getNext(txt, origTxt); } case 107: break; case 42: { final String origTxt = yytext(); String txt = origTxt; if (normalizeSpace) { txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space } return getNext(txt, origTxt); } case 108: break; case 43: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 5; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 6; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { final String txt = yytext(); return getNext(removeSoftHyphens(txt), txt); } case 109: break; case 44: { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 110: break; case 45: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 17; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 16; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 111: break; case 46: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { if (splitAssimilations) { yypushback(2) ; return getNext(); } else { return getNext(); } } case 112: break; case 47: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 113: break; case 48: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 22; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 114: break; case 49: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 18; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 19; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return getNext(); } case 115: break; case 50: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 10; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 11; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev3(); } case 116: break; case 51: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 20; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 21; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 117: break; case 52: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); txt = delimit(txt, '*'); } return getNext(txt, yytext()); } case 118: break; case 53: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { breakByHyphens(yytext()); return getNext(removeSoftHyphens(yytext()), yytext()); } case 119: break; case 54: { if (splitAssimilations) { yypushback(3) ; return getNext(); } else { return getNext(); } } case 120: break; case 55: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1); { return getNormalizedAmpNext(); } case 121: break; case 56: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 9; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 122: break; case 57: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2); { return getNext(); } case 123: break; case 58: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 14; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 124: break; case 59: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 7; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 8; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAcronym(); } case 125: break; case 60: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 12; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 13; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { return processAbbrev1(); } case 126: break; case 61: { String txt = yytext(); if (escapeForwardSlashAsterisk) { txt = delimit(txt, '\/'); } return getNext(txt, yytext()); } case 127: break; case 62: \/\/ lookahead expression with fixed lookahead length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4); { return getNext(); } case 128: break; case 63: \/\/ lookahead expression with fixed base length zzMarkedPos = Character.offsetByCodePoints (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3); { return getNext(); } case 129: break; case 64: { String txt = yytext(); if (normalizeSpace) { txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space } if (normalizeParentheses) { txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen); txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen); } return getNext(txt, yytext()); } case 130: break; case 65: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 25; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 131: break; case 66: \/\/ general lookahead, find correct zzMarkedPos { int zzFState = 23; int zzFPos = zzStartRead; if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; } boolean zzFinL[] = zzFin; while (zzFState != -1 && zzFPos < zzMarkedPos) { zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1); zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos); zzFPos += Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; } if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } while (zzFPos <= zzMarkedPos) { zzFinL[zzFPos++] = false; } zzFState = 24; zzFPos = zzMarkedPos; while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) { zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead); zzFPos -= Character.charCount(zzInput); zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ]; }; zzMarkedPos = zzFPos; } { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/ return handleEllipsis(yytext()); } case 132: break; default: zzScanError(ZZ_NO_MATCH); } } } }","old_code_raw":"  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    \/\/ cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n      \/\/ set up zzAction for empty match case:\n      int zzAttributes = zzAttrL[zzState];\n      if ( (zzAttributes & 1) == 1 ) {\n        zzAction = zzState;\n      }\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL) {\n            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n            zzCurrentPosL += Character.charCount(zzInput);\n          }\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            \/\/ store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            \/\/ get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\n              zzCurrentPosL += Character.charCount(zzInput);\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      \/\/ store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n        zzAtEOF = true;\n              {\n                if (invertible) {\n            prevWordAfter.append(yytext());\n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n      }\n      else {\n        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n          case 1: \n            { String str = yytext();\n          int first = str.codePointAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                logger.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              logger.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n            }\n          case 67: break;\n          case 2: \n            { return getNext(\"<\", yytext());\n            }\n          case 68: break;\n          case 3: \n            { return getNext();\n            }\n          case 69: break;\n          case 4: \n            { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n                    return getNext(ptbmdash, yytext());\n                  } else {\n                    return getNext();\n                  }\n            }\n          case 70: break;\n          case 5: \n            { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); \/\/ js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n            }\n          case 71: break;\n          case 6: \n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 72: break;\n          case 7: \n            { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n            }\n          case 73: break;\n          case 8: \n            { return handleQuotes(yytext(), false);\n            }\n          case 74: break;\n          case 9: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '\/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 75: break;\n          case 10: \n            { return getNext(\">\", yytext());\n            }\n          case 76: break;\n          case 11: \n            { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n            }\n          case 77: break;\n          case 12: \n            { return getNext(removeSoftHyphens(yytext()),\n                                         yytext());\n            }\n          case 78: break;\n          case 13: \n            { return handleEllipsis(yytext());\n            }\n          case 79: break;\n          case 14: \n            { return normalizeFractions(yytext());\n            }\n          case 80: break;\n          case 15: \n            { if (normalizeCurrency) {\n                            return getNext(normalizeCurrency(yytext()), yytext());\n\t\t\t  } else {\n                            return getNext(minimallyNormalizeCurrency(yytext()), yytext());\n                          }\n            }\n          case 81: break;\n          case 16: \n            { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 82: break;\n          case 17: \n            { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 83: break;\n          case 18: \n            { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 84: break;\n          case 19: \n            { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 85: break;\n          case 20: \n            { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 86: break;\n          case 21: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-RSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 87: break;\n          case 22: \n            { if (normalizeOtherBrackets) {\n                    return getNext(\"-LSB-\", yytext()); }\n                  else {\n                    return getNext();\n                  }\n            }\n          case 88: break;\n          case 23: \n            { if (invertible) {\n                            prevWordAfter.append(yytext());\n                        }\n            }\n          case 89: break;\n          case 24: \n            { return getNext(\"\\u2022\", yytext());\n            }\n          case 90: break;\n          case 25: \n            { return getNext(\"\\u2122\", yytext());\n            }\n          case 91: break;\n          case 26: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 15;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 92: break;\n          case 27: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext();\n            }\n          case 93: break;\n          case 28: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), true);\n            }\n          case 94: break;\n          case 29: \n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 95: break;\n          case 30: \n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 96: break;\n          case 31: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 3;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 4;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String origTxt = yytext();\n                          String tmp = removeSoftHyphens(origTxt);\n                          if (americanize) {\n                            tmp = Americanize.americanize(tmp);\n                          }\n                          return getNext(tmp, origTxt);\n            }\n          case 97: break;\n          case 32: \n            { if (escapeForwardSlashAsterisk) {\n                            return getNext(delimit(yytext(), '\/'), yytext());\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 98: break;\n          case 33: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 99: break;\n          case 34: \n            { \/\/ this one should only match if we're basically at the end of file\n                          \/\/ since the last one matches two things, even newlines (if not tokenize per line)\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); \/\/ return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); \/\/ return a period for next time\n                          }\n                          return getNext(s, yytext());\n            }\n          case 100: break;\n          case 35: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { String txt = yytext();\n                  String origText = txt;\n                  if (normalizeParentheses) {\n                    txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                    txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                  }\n                  return getNext(txt, origText);\n            }\n          case 101: break;\n          case 36: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 1);\n            { \/* invert quote - often but not always right *\/\n                  return handleQuotes(yytext(), true);\n            }\n          case 102: break;\n          case 37: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return handleQuotes(yytext(), false);\n            }\n          case 103: break;\n          case 38: \n            { return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 104: break;\n          case 39: \n            { String txt = yytext();\n                  \/\/ if we are in strictTreebank3 mode, we need to reject everything after a space or non-breaking space...\n                  if (strictTreebank3) {\n                    int spaceIndex = indexOfSpace(txt);\n                    if (spaceIndex >= 0) {\n                      yypushback(txt.length() - spaceIndex);\n                      String newText = yytext();\n                      return getNext(newText, newText);\n                    }\n                  }\n                  if (escapeForwardSlashAsterisk) {\n                    txt = delimit(txt, '\/');\n                  }\n                  if (normalizeSpace) {\n                    txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                  }\n                  return getNext(txt, txt);\n            }\n          case 105: break;\n          case 40: \n            { return getNormalizedAmpNext();\n            }\n          case 106: break;\n          case 41: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 107: break;\n          case 42: \n            { final String origTxt = yytext();\n                          String txt = origTxt;\n                          if (normalizeSpace) {\n                            txt = SINGLE_SPACE_PATTERN.matcher(txt).replaceAll(\"\\u00A0\"); \/\/ change to non-breaking space\n                          }\n                          return getNext(txt, origTxt);\n            }\n          case 108: break;\n          case 43: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 5;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 6;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { final String txt = yytext();\n                          return getNext(removeSoftHyphens(txt),\n                                         txt);\n            }\n          case 109: break;\n          case 44: \n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 110: break;\n          case 45: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 17;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 16;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 111: break;\n          case 46: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { if (splitAssimilations) {\n                            yypushback(2) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 112: break;\n          case 47: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 113: break;\n          case 48: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 22;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 114: break;\n          case 49: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 18;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 19;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return getNext();\n            }\n          case 115: break;\n          case 50: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 10;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 11;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev3();\n            }\n          case 116: break;\n          case 51: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 20;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 21;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 117: break;\n          case 52: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 118: break;\n          case 53: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { breakByHyphens(yytext());\n                    return getNext(removeSoftHyphens(yytext()), yytext());\n            }\n          case 119: break;\n          case 54: \n            { if (splitAssimilations) {\n                            yypushback(3) ; return getNext();\n                          } else {\n                            return getNext();\n                          }\n            }\n          case 120: break;\n          case 55: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -1);\n            { return getNormalizedAmpNext();\n            }\n          case 121: break;\n          case 56: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 9;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 122: break;\n          case 57: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -2);\n            { return getNext();\n            }\n          case 123: break;\n          case 58: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 14;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 124: break;\n          case 59: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 7;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 8;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAcronym();\n            }\n          case 125: break;\n          case 60: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 12;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 13;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { return processAbbrev1();\n            }\n          case 126: break;\n          case 61: \n            { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '\/');\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 127: break;\n          case 62: \n            \/\/ lookahead expression with fixed lookahead length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzMarkedPos, -4);\n            { return getNext();\n            }\n          case 128: break;\n          case 63: \n            \/\/ lookahead expression with fixed base length\n            zzMarkedPos = Character.offsetByCodePoints\n                (zzBufferL, zzStartRead, zzEndRead - zzStartRead, zzStartRead, 3);\n            { return getNext();\n            }\n          case 129: break;\n          case 64: \n            { String txt = yytext();\n                          if (normalizeSpace) {\n                            txt = txt.replace(' ', '\\u00A0'); \/\/ change space to non-breaking space\n                          }\n                          if (normalizeParentheses) {\n                            txt = LEFT_PAREN_PATTERN.matcher(txt).replaceAll(openparen);\n                            txt = RIGHT_PAREN_PATTERN.matcher(txt).replaceAll(closeparen);\n                          }\n                          return getNext(txt, yytext());\n            }\n          case 130: break;\n          case 65: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 25;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 131: break;\n          case 66: \n            \/\/ general lookahead, find correct zzMarkedPos\n            { int zzFState = 23;\n              int zzFPos = zzStartRead;\n              if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n              boolean zzFinL[] = zzFin;\n              while (zzFState != -1 && zzFPos < zzMarkedPos) {\n                zzFinL[zzFPos] = ((zzAttrL[zzFState] & 1) == 1);\n                zzInput = Character.codePointAt(zzBufferL, zzFPos, zzMarkedPos);\n                zzFPos += Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              }\n              if (zzFState != -1) { zzFinL[zzFPos++] = ((zzAttrL[zzFState] & 1) == 1); } \n              while (zzFPos <= zzMarkedPos) {\n                zzFinL[zzFPos++] = false;\n              }\n\n              zzFState = 24;\n              zzFPos = zzMarkedPos;\n              while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n                zzInput = Character.codePointBefore(zzBufferL, zzFPos, zzStartRead);\n                zzFPos -= Character.charCount(zzInput);\n                zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n              };\n              zzMarkedPos = zzFPos;\n            }\n            { \/* attempt to treat fourth ellipsis as period if followed by space and letter. *\/\n                                    return handleEllipsis(yytext());\n            }\n          case 132: break;\n          default:\n            zzScanError(ZZ_NO_MATCH);\n        }\n      }\n    }\n  }\n","new_comment_raw":"@return the next token","old_comment_raw":"@return the next token","label":0,"pre_label":1,"AST_level":19,"line_counts":966,"new_code_token_num":6267},{"new_code_raw":"public boolean isCookiePresent(String name) { return (Boolean) seleneseMethods.get(\"isCookiePresent\").apply(driver, name); }","old_code_raw":"  public boolean isCookiePresent(String name) {\n    return getCookieByName(name) != null;\n  }\n","new_comment_raw":"@return true if a cookie with the specified name is present, or false otherwise.","old_comment_raw":"@return true if a cookie with the specified name is present, or false otherwise.","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":27},{"new_code_raw":"protected Object convertTimestampToEpochNanos(Column column, Field fieldDefn, Object data) { if (data == null) { data = fieldDefn.schema().defaultValue(); } if (data == null) { if (column.isOptional()) return null; return 0L; \/\/ return epoch } try { return NanoTimestamp.toEpochNanos(data); } catch (IllegalArgumentException e) { return handleUnknownData(column, fieldDefn, data); } }","old_code_raw":"    protected Object convertTimestampToEpochNanos(Column column, Field fieldDefn, Object data) {\n        if ( data == null ) return null;\n        try {\n            return NanoTimestamp.toEpochNanos(data);\n        } catch (IllegalArgumentException e) {\n            return handleUnknownData(column, fieldDefn, data);\n        }\n    }\n","new_comment_raw":"@return the converted value, or null if the conversion could not be made and the column allows nulls","old_comment_raw":"@return the converted value, or null if the conversion could not be made","label":1,"pre_label":0,"AST_level":8,"line_counts":15,"new_code_token_num":82},{"new_code_raw":"Folder getOpenFolder() { CellLayout currentScreen = (CellLayout) getChildAt(mCurrentScreen); int count = currentScreen.getChildCount(); for (int i = 0; i < count; i++) { View child = currentScreen.getChildAt(i); CellLayout.LayoutParams lp = (CellLayout.LayoutParams) child.getLayoutParams(); if (lp.cellHSpan == 4 && lp.cellVSpan == 4 && child instanceof Folder) { return (Folder) child; } } return null; }","old_code_raw":"    Folder getOpenFolder() {\n        ViewGroup currentPage = ((CellLayout) getChildAt(mCurrentPage)).getChildrenLayout();\n        int count = currentPage.getChildCount();\n        for (int i = 0; i < count; i++) {\n            View child = currentPage.getChildAt(i);\n            if (child instanceof Folder) {\n                Folder folder = (Folder) child;\n                if (folder.getInfo().opened)\n                    return folder;\n            }\n        }\n        return null;\n    }\n","new_comment_raw":"@return The open folder on the current screen, or null if there is none","old_comment_raw":"@return The open folder on the current screen, or null if there is none","label":0,"pre_label":1,"AST_level":9,"line_counts":13,"new_code_token_num":85},{"new_code_raw":"public List<X_AD_ReplicationTable> getReplicationTables() { final String whereClause = I_AD_ReplicationTable.COLUMNNAME_AD_ReplicationStrategy_ID + STR; return new Query(getCtx(), I_AD_ReplicationTable.Table_Name, whereClause, get_TrxName()).setClient_ID().setParameters(getAD_ReplicationStrategy_ID()).setOnlyActiveRecords(true).setApplyAccessFilter(false).list(); }","old_code_raw":"public Collection<X_AD_ReplicationTable> getReplicationTables() {\n    final String whereClause = new StringBuffer(X_AD_ReplicationTable.COLUMNNAME_AD_ReplicationStrategy_ID) + STR;\n    return new Query(getCtx(), X_AD_ReplicationTable.Table_Name, whereClause, get_TrxName()).setClient_ID().setParameters(getAD_ReplicationStrategy_ID()).setOnlyActiveRecords(true).setApplyAccessFilter(false).list();\n}","new_comment_raw":"@return the list the X_AD_ReplicationTable","old_comment_raw":"@return the collection the X_AD_ReplicationTable","label":1,"pre_label":0,"AST_level":6,"line_counts":4,"new_code_token_num":54},{"new_code_raw":"public PeriodPrinter toPrinter() { if (iNotPrinter) { return null; } return toFormatter().getPrinter(); }","old_code_raw":"    public PeriodPrinter toPrinter() {\n        return toFormatter().getPrinter();\n    }\n","new_comment_raw":"@return the newly created printer, null if builder cannot create a printer","old_comment_raw":"@return the newly created printer","label":1,"pre_label":0,"AST_level":6,"line_counts":7,"new_code_token_num":24},{"new_code_raw":"public static SchemaPath parseFromString(String expr) { if (expr == null || expr.isEmpty()) { return null; } try { if (SchemaPath.DYNAMIC_STAR.equals(expr)) { return SchemaPath.getSimplePath(expr); } ExprLexer lexer = new ExprLexer(new ANTLRStringStream(expr)); CommonTokenStream tokens = new CommonTokenStream(lexer); ExprParser parser = new ExprParser(tokens); parse_return ret = parser.parse(); if (ret.e instanceof SchemaPath) { return (SchemaPath) ret.e; } else { throw new IllegalStateException(\"Schema path is not a valid format.\"); } } catch (RecognitionException e) { throw new RuntimeException(e); } }","old_code_raw":"  public static SchemaPath parseFromString(String expr) {\n    if (expr == null || expr.isEmpty()) {\n      return null;\n    }\n    try {\n      ExprLexer lexer = new ExprLexer(new ANTLRStringStream(expr));\n      CommonTokenStream tokens = new CommonTokenStream(lexer);\n      ExprParser parser = new ExprParser(tokens);\n\n      parse_return ret = parser.parse();\n\n      if (ret.e instanceof SchemaPath) {\n        return (SchemaPath) ret.e;\n      } else {\n        throw new IllegalStateException(\"Schema path is not a valid format.\");\n      }\n    } catch (RecognitionException e) {\n      throw new RuntimeException(e);\n    }\n  }\n","new_comment_raw":"@return  SchemaPath instance","old_comment_raw":"@return SchemaPath instance","label":0,"pre_label":1,"AST_level":8,"line_counts":24,"new_code_token_num":130},{"new_code_raw":"public Connect getConnect() { return virConnect; }","old_code_raw":"public VirConnect getConnect() {\n    return virConnect;\n}","new_comment_raw":"@return the Connect object","old_comment_raw":"@return the VirConnect object","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":10},{"new_code_raw":"public Object clone() { throw ExceptionUtils.unsupportedInGwt(); \/\/ try { \/\/ return super.clone(); \/\/ } catch (CloneNotSupportedException ex) { \/\/ throw new InternalError(\"Clone error\"); \/\/ } }","old_code_raw":"    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException ex) {\n            throw new InternalError(\"Clone error\");\n        }\n    }\n","new_comment_raw":"@return a clone of this object.","old_comment_raw":"@return a clone of this object.","label":0,"pre_label":1,"AST_level":4,"line_counts":9,"new_code_token_num":49},{"new_code_raw":"public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) { FileDownloadLog.w(this, \"If you invoked this method, please remove it directly feel free, \" + \"it doesn't need any longer\"); return true; }","old_code_raw":"    public boolean setTaskCompleted(List<FileDownloadTaskAtom> taskAtomList) {\n        return FileDownloadServiceProxy.getImpl().setTaskCompleted(taskAtomList);\n    }\n","new_comment_raw":"@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in FileDownloadMgr#obtainCompletedTaskShelfModel(String, String, long) will receive false, and non of them would be updated to DB.","old_comment_raw":"@return Whether is successful to update all tasks' status to the Filedownloader Engine. If one task atom among them is not match the Rules in com.liulishuo.filedownloader.services.FileDownloadMgr#obtainCompletedTaskShelfModel(String, String, long) will receive false, and non of them would be updated to DB.","label":1,"pre_label":0,"AST_level":6,"line_counts":6,"new_code_token_num":45},{"new_code_raw":"public String[] getHistory(String historyId) { Assert.isNotNull(historyId); List<String> entries = history.get(historyId); if (entries == null) { entries = new ArrayList<String>(); } return entries.toArray(new String[entries.size()]); }","old_code_raw":"public String[] getHistory(String historyId) {\n    Assert.isNotNull(historyId);\n    List<String> ids = history.get(historyId);\n    if (ids == null) {\n        ids = new ArrayList<String>();\n    }\n    return ids.toArray(new String[ids.size()]);\n}","new_comment_raw":"@return The list of entries within the history ids list or an empty list.","old_comment_raw":"@return The list of ids within the history ids list or an empty list.","label":1,"pre_label":0,"AST_level":10,"line_counts":8,"new_code_token_num":54},{"new_code_raw":"public String ceDataschema() { return dataSchemaUrl; }","old_code_raw":"    public String ceDataschema() {\n        return (dataSchemaUrl == null) ? \"\" : dataSchemaUrl;\n    }\n","new_comment_raw":"@return the data schema url of CloudEvents envelope","old_comment_raw":"@return the data schema url of CloudEvents envelope","label":0,"pre_label":1,"AST_level":4,"line_counts":4,"new_code_token_num":10},{"new_code_raw":"public boolean isThisMyUrl(String url) { return isInstanceURL(url, applicationInfoManager.getInfo()); }","old_code_raw":"    public boolean isThisMyUrl(String url) {\n        InstanceInfo myInfo = applicationInfoManager.getInfo();\n        String hostName = hostFromUrl(url);\n        return hostName != null && hostName.equals(myInfo.getHostName());\n    }\n","new_comment_raw":"@return true, if the url represents the current node which is trying to replicate, false otherwise.","old_comment_raw":"@return true, if the url represents the current node which is trying to replicate, false otherwise.","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":20},{"new_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.POST }) @ResponseBody public CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) { CubeDesc desc = deserializeCubeDesc(cubeRequest); if (desc == null) { cubeRequest.setMessage(STR); return cubeRequest; } String name = CubeService.getCubeNameFromDesc(desc.getName()); if (StringUtils.isEmpty(name)) { logger.info(STR); throw new BadRequestException(STR); } CubeInstance cubeInstance; try { desc.setUuid(UUID.randomUUID().toString()); String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject(); cubeInstance = cubeService.createCubeAndDesc(name, projectName, desc); } catch (Exception e) { logger.error(STR, e); throw new InternalErrorException(e.getLocalizedMessage(), e); } boolean createStreamingConfigSuccess = false, createKafkaConfigSuccess = false; StreamingConfig streamingConfig = null; KafkaConfig kafkaConfig = null; boolean isStreamingCube = cubeRequest.getStreamingCube() != null && cubeRequest.getStreamingCube().equals(STR); try { if (isStreamingCube) { streamingConfig = deserializeStreamingDesc(cubeRequest); kafkaConfig = deserializeKafkaDesc(cubeRequest); if (kafkaConfig == null) { cubeRequest.setMessage(STR); return cubeRequest; } if (streamingConfig == null) { cubeRequest.setMessage(STR); return cubeRequest; } try { streamingConfig.setUuid(UUID.randomUUID().toString()); streamingService.createStreamingConfig(streamingConfig); createStreamingConfigSuccess = true; } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } try { kafkaConfig.setUuid(UUID.randomUUID().toString()); kafkaConfigService.createKafkaConfig(kafkaConfig); createKafkaConfigSuccess = true; } catch (IOException e) { logger.error(STR + e.getLocalizedMessage(), e); throw new InternalErrorException(STR + e.getLocalizedMessage()); } } } finally { if (isStreamingCube) { if (createStreamingConfigSuccess == false || createKafkaConfigSuccess == false) { try { cubeService.deleteCube(cubeInstance); } catch (Exception ex) { throw new InternalErrorException(STR + STR + ex.getMessage(), ex); } if (createStreamingConfigSuccess == true) { try { streamingService.dropStreamingConfig(streamingConfig); } catch (IOException e) { throw new InternalErrorException(STR + e.getLocalizedMessage()); } } if (createKafkaConfigSuccess == true) { try { kafkaConfigService.dropKafkaConfig(kafkaConfig); } catch (IOException e) { throw new InternalErrorException(STR + e.getLocalizedMessage()); } } } } } cubeRequest.setUuid(desc.getUuid()); cubeRequest.setSuccessful(true); return cubeRequest; }","old_code_raw":"@RequestMapping(value = STR, method = { RequestMethod.POST })\n@ResponseBody\npublic CubeRequest saveCubeDesc(@RequestBody CubeRequest cubeRequest) {\n    MetadataManager metaManager = MetadataManager.getInstance(cubeService.getConfig());\n    DataModelDesc modelDesc = deserializeDataModelDesc(cubeRequest);\n    if (modelDesc == null) {\n        return errorRequest(cubeRequest, STR);\n    }\n    if (StringUtils.isEmpty(modelDesc.getName())) {\n        return errorRequest(cubeRequest, STR);\n    }\n    try {\n        DataModelDesc existingModel = metaManager.getDataModelDesc(modelDesc.getName());\n        if (existingModel == null) {\n            metaManager.createDataModelDesc(modelDesc);\n        } else {\n            modelDesc.setLastModified(existingModel.getLastModified());\n            metaManager.updateDataModelDesc(modelDesc);\n        }\n    } catch (IOException e) {\n        logger.error(STR + e.getLocalizedMessage(), e);\n        throw new InternalErrorException(STR + e.getLocalizedMessage());\n    }\n    CubeDesc desc = deserializeCubeDesc(cubeRequest);\n    if (desc == null) {\n        return cubeRequest;\n    }\n    if (StringUtils.isEmpty(desc.getName())) {\n        logger.info(STR);\n        return errorRequest(cubeRequest, STR);\n    }\n    try {\n        desc.setUuid(UUID.randomUUID().toString());\n        String projectName = (null == cubeRequest.getProject()) ? ProjectInstance.DEFAULT_PROJECT_NAME : cubeRequest.getProject();\n        CubeInstance createdCube = cubeService.createCubeAndDesc(desc.getName(), projectName, desc);\n        accessService.init(createdCube, AclPermission.ADMINISTRATION);\n        ProjectInstance project = cubeService.getProjectManager().getProject(projectName);\n        accessService.inherit(createdCube, project);\n    } catch (Exception e) {\n        logger.error(STR, e);\n        throw new InternalErrorException(e.getLocalizedMessage(), e);\n    }\n    cubeRequest.setUuid(desc.getUuid());\n    cubeRequest.setSuccessful(true);\n    return cubeRequest;\n}","new_comment_raw":"@return Table metadata array","old_comment_raw":"@return cubeRequest cube change request","label":1,"pre_label":0,"AST_level":15,"line_counts":84,"new_code_token_num":495},{"new_code_raw":"public static Internal hide() { return hide(null); }","old_code_raw":"public static Hidden hide() {\n    return hide(null);\n}","new_comment_raw":"@return Internal source","old_comment_raw":"@return Hidden source","label":1,"pre_label":0,"AST_level":5,"line_counts":3,"new_code_token_num":14},{"new_code_raw":"public TopologyInfo getTopologyInfo(String topologyId) throws NotAliveException, TException { StormClusterState stormClusterState = data.getStormClusterState(); try { \/\/ get topology's StormBase StormBase base = stormClusterState.storm_base(topologyId, null); if (base == null) { throw new NotAliveException(\"No topology of \" + topologyId); } return getTopologyInfo(topologyId, base); } catch (TException e) { LOG.info(\"Failed to get topologyInfo \" + topologyId, e); throw e; } catch (Exception e) { LOG.info(\"Failed to get topologyInfo \" + topologyId, e); throw new TException(\"Failed to get topologyInfo\" + topologyId); } }","old_code_raw":"\tpublic TopologyInfo getTopologyInfo(String topologyId)\n\t\t\tthrows NotAliveException, TException {\n\n\t\tTopologyInfo topologyInfo = new TopologyInfo();\n\n\t\tStormClusterState stormClusterState = data.getStormClusterState();\n\n\t\ttry {\n\n\t\t\t\/\/ get topology's StormBase\n\t\t\tStormBase base = stormClusterState.storm_base(topologyId, null);\n\t\t\tif (base == null) {\n\t\t\t\tthrow new NotAliveException(\"No topology of \" + topologyId);\n\t\t\t}\n\t\t\ttopologyInfo.set_id(topologyId);\n\t\t\ttopologyInfo.set_name(base.getStormName());\n\t\t\ttopologyInfo.set_uptime_secs(TimeUtils.time_delta(base\n\t\t\t\t\t.getLanchTimeSecs()));\n\t\t\ttopologyInfo.set_status(base.getStatusString());\n\n\t\t\t\/\/ get topology's Assignment\n\t\t\tAssignment assignment = stormClusterState.assignment_info(\n\t\t\t\t\ttopologyId, null);\n\t\t\tif (assignment == null) {\n\t\t\t\tthrow new TException(\"Failed to get StormBase from ZK of \"\n\t\t\t\t\t\t+ topologyId);\n\t\t\t}\n\n\t\t\t\/\/ get topology's map<taskId, componentId>\n\t\t\tMap<Integer, String> taskInfo = Cluster.topology_task_info(\n\t\t\t\t\tstormClusterState, topologyId);\n\n\t\t\tMap<Integer, TaskSummary> tasks = NimbusUtils.mkTaskSummary(\n\t\t\t\t\tstormClusterState, assignment, taskInfo, topologyId);\n\t\t\tList<TaskSummary> taskSumms = new ArrayList<TaskSummary>();\n\t\t\tfor (Entry<Integer, TaskSummary> entry : tasks.entrySet()) {\n\t\t\t\ttaskSumms.add(entry.getValue());\n\t\t\t}\n\t\t\ttopologyInfo.set_tasks(taskSumms);\n\t\t\tList<WorkerSummary> workers = NimbusUtils.mkWorkerSummary(\n\t\t\t\t\ttopologyId, assignment, tasks);\n\t\t\ttopologyInfo.set_workers(workers);\n\n\t\t\treturn topologyInfo;\n\t\t} catch (TException e) {\n\t\t\tLOG.info(\"Failed to get topologyInfo \" + topologyId, e);\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tLOG.info(\"Failed to get topologyInfo \" + topologyId, e);\n\t\t\tthrow new TException(\"Failed to get topologyInfo\" + topologyId);\n\t\t}\n\n\t}\n","new_comment_raw":"@return TopologyInfo","old_comment_raw":"@return TopologyInfo","label":0,"pre_label":1,"AST_level":9,"line_counts":23,"new_code_token_num":129},{"new_code_raw":"public static String[] decodeArray(String encoded){ if (encoded.isEmpty()) return EMPTY_STRING_ARRAY; char[] chars = encoded.trim().toCharArray(); \/\/--Parse the String \/\/ (state) char quoteCloseChar = (char) 0; List<StringBuilder> terms = new LinkedList<>(); StringBuilder current = new StringBuilder(); \/\/(start\/stop overhead) int start = 0; int end = chars.length; if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(\"Unclosed paren in encoded array: \" + encoded); } if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); } if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); } \/\/ (finite state automaton) for (int i=start; i<end; i++) { if (chars[i] == '\\r') { \/\/ Ignore funny windows carriage return continue; } else if(chars[i] == '\\\\'){ \/\/(case: escaped character) if(i == chars.length - 1) throw new IllegalArgumentException(\"Last character of encoded array is escape character: \" + encoded); current.append(chars[i+1]); i += 1; } else if (quoteCloseChar != 0) { \/\/(case: in quotes) if(chars[i] == quoteCloseChar){ quoteCloseChar = (char) 0; }else{ current.append(chars[i]); } } else { \/\/(case: normal) if(chars[i] == '\"'){ quoteCloseChar = '\"'; } else if(chars[i] == '\\''){ quoteCloseChar = '\\''; } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\\t' || chars[i] == '\\n'){ \/\/break if (current.length() > 0) { terms.add(current); } current = new StringBuilder(); }else{ current.append(chars[i]); } } } \/\/--Return if(current.length() > 0) terms.add(current); String[] rtn = new String[terms.size()]; int i=0; for(StringBuilder b : terms){ rtn[i] = b.toString().trim(); i += 1; } return rtn; }","old_code_raw":"  public static String[] decodeArray(String encoded) {\n    if (encoded.isEmpty()) return EMPTY_STRING_ARRAY;\n    char[] chars = encoded.trim().toCharArray();\n\n    \/\/--Parse the String\n    \/\/ (state)\n    char quoteCloseChar = (char) 0;\n    List<String> terms = new ArrayList<>();\n    StringBuilder current = new StringBuilder();\n    \/\/(start\/stop overhead)\n    int start = 0; int end = chars.length;\n    if(chars[0] == '('){ start += 1; end -= 1; if(chars[end] != ')') throw new IllegalArgumentException(\"Unclosed paren in encoded array: \" + encoded); }\n    if(chars[0] == '['){ start += 1; end -= 1; if(chars[end] != ']') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); }\n    if(chars[0] == '{'){ start += 1; end -= 1; if(chars[end] != '}') throw new IllegalArgumentException(\"Unclosed bracket in encoded array: \" + encoded); }\n    \/\/ (finite state automaton)\n    for (int i=start; i<end; i++) {\n      if (chars[i] == '\\r') {\n        \/\/ Ignore funny windows carriage return\n        continue;\n      } else if (quoteCloseChar != 0) {\n        \/\/(case: in quotes)\n        if(chars[i] == quoteCloseChar){\n          quoteCloseChar = (char) 0;\n        }else{\n          current.append(chars[i]);\n        }\n      } else if(chars[i] == '\\\\'){\n        \/\/(case: escaped character)\n        if(i == chars.length - 1) throw new IllegalArgumentException(\"Last character of encoded array is escape character: \" + encoded);\n        current.append(chars[i+1]);\n        i += 1;\n      } else {\n        \/\/(case: normal)\n        if (chars[i] == '\"') {\n          quoteCloseChar = '\"';\n        } else if(chars[i] == '\\'') {\n          quoteCloseChar = '\\'';\n        } else if(chars[i] == ',' || chars[i] == ';' || chars[i] == ' ' || chars[i] == '\\t' || chars[i] == '\\n') {\n          \/\/break\n          if (current.length() > 0) {\n            terms.add(current.toString().trim());\n          }\n          current = new StringBuilder();\n        } else {\n          current.append(chars[i]);\n        }\n      }\n    }\n\n    \/\/--Return\n    if (current.length() > 0) {\n      terms.add(current.toString().trim());\n    }\n    return terms.toArray(EMPTY_STRING_ARRAY);\n  }\n","new_comment_raw":"@return A String array corresponding to the encoded array","old_comment_raw":"@return A String array corresponding to the encoded array","label":0,"pre_label":1,"AST_level":19,"line_counts":60,"new_code_token_num":577},{"new_code_raw":"public boolean isBuffered() { return queue.buffered(); }","old_code_raw":"public boolean isBuffered() {\n    return buffered;\n}","new_comment_raw":"@return true if the queue is buffered, false otherwise","old_comment_raw":"@return the buffered","label":1,"pre_label":0,"AST_level":4,"line_counts":3,"new_code_token_num":13},{"new_code_raw":"public boolean isRemove() { return command != null && command.getDataStructureType() == CommandTypes.MESSAGE_ACK && subscriptionName == null; }","old_code_raw":"    public boolean isRemove() {\n        return command != null && command.getDataStructureType() == CommandTypes.MESSAGE_ACK;\n    }\n","new_comment_raw":"@return true if a MessageAck command","old_comment_raw":"@return true if a MessageAck command","label":0,"pre_label":1,"AST_level":7,"line_counts":4,"new_code_token_num":24},{"new_code_raw":"public int delete(Object[] row, long ts, int rowNumber, int numberOfRows) throws InterruptedException { return converter.delete(source, row, rowNumber, numberOfRows, includedColumns, ts, consumer); }","old_code_raw":"        public int delete(Object[] row, long ts, int rowNumber) throws InterruptedException {\n            return converter.delete(source, row, rowNumber, includedColumns, ts, consumer);\n        }\n","new_comment_raw":"@return the number of records produced; will be 0 or more","old_comment_raw":"@return the number of records produced; will be 0 or more","label":0,"pre_label":1,"AST_level":5,"line_counts":4,"new_code_token_num":41}]